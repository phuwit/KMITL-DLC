var studyTable = function() {
  "use strict";var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __reflectGet = Reflect.get;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);

  var _current, _start, _subscribers, _stop, _Readable_instances, subscribe_fn, unsubscribe_fn, _size, _previous, _curr, _id, _ref, _isActive, _isDisabled, _props, _ref2, _disabled, _id2, _root, _itemState, _isDisabled2, _props2, _ref3, _id3, _originalStyles, _isMountAnimationPrevented, _width, _height, _forceMount, _present, _snippetProps, _props3, _id4, _ref4, _level, _item, _props4, _triggerNode, _titleNode, _contentNode, _descriptionNode, _contentId, _titleId, _triggerId, _descriptionId, _cancelNode, _attrs, _sharedProps, _id5, _ref5, _root2, _disabled2, _props5, _id6, _ref6, _root3, _variant, _disabled3, _attr, _props6, _id7, _ref7, _root4, _level2, _props7, _id8, _ref8, _root5, _props8, _id9, _ref9, _snippetProps2, _props9, _id10, _ref10, _snippetProps3, _props10, _interactOutsideProp, _behaviorType, _interceptedEvents, _isResponsibleLayer, _documentObj, _enabled, _isFocusInsideDOMTree, _onFocusOutside, _currNode, _isValidEventProp, _unsubClickListener, _handleFocus, _DismissibleLayerState_instances, addEventListeners_fn, _handleDismiss, _handleInteractOutside, _markInterceptedEvent, _markNonInterceptedEvent, _markResponsibleLayer, _isTargetWithinLayer, _resetState, isAnyEventIntercepted_fn, _onfocuscapture, _onblurcapture, _onEscapeProp, _behaviorType2, _enabled2, _addEventListener, _onkeydown, _id11, _onPointerDownProp, _onPointerUpProp, _enabled3, _unsubSelectionLock, _ref11, _TextSelectionLayerState_instances, addEventListeners_fn2, _pointerdown, _resetSelectionLock, _sources, _version, _size2, _SvelteMap_instances, read_all_fn, _headingValue, _props11, _isDisabled3, _props12, _isDisabled4, _props13, _props14, _props15, _props16, _props17, _props18, _props19, _transformedStyle, _dir, _side, _sideOffset, _align, _alignOffset, _arrowPadding, _avoidCollisions, _collisionBoundary, _collisionPadding, _sticky, _hideWhenDetached, _strategy, _updatePositionStrategy, _arrowSize, _arrowWidth, _arrowHeight, _desiredPlacement, _boundary, _hasExplicitBoundaries, _detectOverflowOptions, _availableWidth, _availableHeight, _anchorWidth, _anchorHeight, _middleware, _placedSide, _placedAlign, _arrowX, _arrowY, _cannotCenterArrow, _contentZIndex, _arrowBaseSide, _wrapperProps, _props20, _arrowStyle, _contentNode2, _contentId2, _triggerNode2, _id12, _ref12, _disabled4, _root6, _PopoverTriggerState_instances, getAriaControls_fn, _props21, _id13, _ref13, _snippetProps4, _props22, _months, _visibleMonths, _focusedValue, _lastPressedDateValue, _RangeCalendarRootState_instances, updateValue_fn, setStartValue_fn, setEndValue_fn, _weekdays, _isStartInvalid, _isEndInvalid, _isInvalid, _isNextButtonDisabled, _isPrevButtonDisabled, _headingValue2, _fullCalendarLabel, _highlightedRange, announceEmpty_fn, announceSelectedDate_fn, announceSelectedRange_fn, _snippetProps5, _props23, _cellDate, _isDisabled5, _isUnavailable, _isDateToday, _isOutsideMonth, _isOutsideVisibleMonths, _isFocusedDate, _isSelectedDate, _isSelectionStart, _isSelectionEnd, _isHighlighted, _labelText, _snippetProps6, _ariaDisabled, _sharedDataAttrs, _props24, _tabindex, _snippetProps7, _props25, _id14, _ref14, _props26, _id15, _ref15, _SwitchRootState_instances, toggle_fn, _sharedProps2, _props27, _root7, _shouldRender, _props28, _id16, _ref16, _props29, _a, _b;
  function defineContentScript(definition2) {
    return definition2;
  }
  const PUBLIC_VERSION = "5";
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
  let legacy_mode_flag = false;
  function enable_legacy_mode_flag() {
    legacy_mode_flag = true;
  }
  enable_legacy_mode_flag();
  const EACH_ITEM_REACTIVE = 1;
  const EACH_INDEX_REACTIVE = 1 << 1;
  const EACH_IS_CONTROLLED = 1 << 2;
  const EACH_IS_ANIMATED = 1 << 3;
  const EACH_ITEM_IMMUTABLE = 1 << 4;
  const PROPS_IS_IMMUTABLE = 1;
  const PROPS_IS_RUNES = 1 << 1;
  const PROPS_IS_UPDATED = 1 << 2;
  const PROPS_IS_BINDABLE = 1 << 3;
  const PROPS_IS_LAZY_INITIAL = 1 << 4;
  const TEMPLATE_FRAGMENT = 1;
  const TEMPLATE_USE_IMPORT_NODE = 1 << 1;
  const UNINITIALIZED = Symbol();
  const FILENAME = Symbol("filename");
  const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
  function is_capture_event(name) {
    return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
  }
  const DELEGATED_EVENTS = [
    "beforeinput",
    "click",
    "change",
    "dblclick",
    "contextmenu",
    "focusin",
    "focusout",
    "input",
    "keydown",
    "keyup",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "pointerdown",
    "pointermove",
    "pointerout",
    "pointerover",
    "pointerup",
    "touchend",
    "touchmove",
    "touchstart"
  ];
  function is_delegated(event_name) {
    return DELEGATED_EVENTS.includes(event_name);
  }
  const ATTRIBUTE_ALIASES = {
    // no `class: 'className'` because we handle that separately
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly",
    defaultvalue: "defaultValue",
    defaultchecked: "defaultChecked",
    srcobject: "srcObject"
  };
  function normalize_attribute(name) {
    name = name.toLowerCase();
    return ATTRIBUTE_ALIASES[name] ?? name;
  }
  const PASSIVE_EVENTS = ["touchstart", "touchmove"];
  function is_passive_event(name) {
    return PASSIVE_EVENTS.includes(name);
  }
  const DEV = true;
  var is_array = Array.isArray;
  var array_from = Array.from;
  var define_property = Object.defineProperty;
  var get_descriptor = Object.getOwnPropertyDescriptor;
  var get_descriptors = Object.getOwnPropertyDescriptors;
  var object_prototype = Object.prototype;
  var array_prototype = Array.prototype;
  var get_prototype_of = Object.getPrototypeOf;
  function is_function(thing) {
    return typeof thing === "function";
  }
  const noop$1 = () => {
  };
  function run(fn) {
    return fn();
  }
  function run_all(arr) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2]();
    }
  }
  const DERIVED = 1 << 1;
  const EFFECT = 1 << 2;
  const RENDER_EFFECT = 1 << 3;
  const BLOCK_EFFECT = 1 << 4;
  const BRANCH_EFFECT = 1 << 5;
  const ROOT_EFFECT = 1 << 6;
  const BOUNDARY_EFFECT = 1 << 7;
  const UNOWNED = 1 << 8;
  const DISCONNECTED = 1 << 9;
  const CLEAN = 1 << 10;
  const DIRTY = 1 << 11;
  const MAYBE_DIRTY = 1 << 12;
  const INERT = 1 << 13;
  const DESTROYED = 1 << 14;
  const EFFECT_RAN = 1 << 15;
  const EFFECT_TRANSPARENT = 1 << 16;
  const LEGACY_DERIVED_PROP = 1 << 17;
  const INSPECT_EFFECT = 1 << 18;
  const HEAD_EFFECT = 1 << 19;
  const EFFECT_HAS_DERIVED = 1 << 20;
  const STATE_SYMBOL = Symbol("$state");
  const STATE_SYMBOL_METADATA = Symbol("$state metadata");
  const LEGACY_PROPS = Symbol("legacy props");
  const LOADING_ATTR_SYMBOL = Symbol("");
  function equals$1(value) {
    return value === this.v;
  }
  function safe_not_equal(a2, b2) {
    return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
  }
  function not_equal(a2, b2) {
    return a2 !== b2;
  }
  function safe_equals(value) {
    return !safe_not_equal(value, this.v);
  }
  function bind_invalid_checkbox_value() {
    {
      const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function bind_invalid_export(component2, key, name) {
    {
      const error = new Error(`bind_invalid_export
Component ${component2} has an export named \`${key}\` that a consumer component is trying to access using \`bind:${key}\`, which is disallowed. Instead, use \`bind:this\` (e.g. \`<${name} bind:this={component} />\`) and then access the property on the bound component instance (e.g. \`component.${key}\`)
https://svelte.dev/e/bind_invalid_export`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function bind_not_bindable(key, component2, name) {
    {
      const error = new Error(`bind_not_bindable
A component is attempting to bind to a non-bindable property \`${key}\` belonging to ${component2} (i.e. \`<${name} bind:${key}={...}>\`). To mark a property as bindable: \`let { ${key} = $bindable() } = $props()\`
https://svelte.dev/e/bind_not_bindable`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function component_api_changed(parent, method, component2) {
    {
      const error = new Error(`component_api_changed
${parent} called \`${method}\` on an instance of ${component2}, which is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function component_api_invalid_new(component2, name) {
    {
      const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function derived_references_self() {
    {
      const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function effect_in_teardown(rune) {
    {
      const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function effect_in_unowned_derived() {
    {
      const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function effect_orphan(rune) {
    {
      const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function effect_update_depth_exceeded() {
    {
      const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
https://svelte.dev/e/effect_update_depth_exceeded`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function invalid_snippet() {
    {
      const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function props_invalid_value(key) {
    {
      const error = new Error(`props_invalid_value
Cannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function props_rest_readonly(property) {
    {
      const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function rune_outside_svelte(rune) {
    {
      const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function state_descriptors_fixed() {
    {
      const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function state_prototype_fixed() {
    {
      const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function state_unsafe_local_read() {
    {
      const error = new Error(`state_unsafe_local_read
Reading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state
https://svelte.dev/e/state_unsafe_local_read`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function state_unsafe_mutation() {
    {
      const error = new Error(`state_unsafe_mutation
Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
      error.name = "Svelte error";
      throw error;
    }
  }
  let inspect_effects = /* @__PURE__ */ new Set();
  function set_inspect_effects(v2) {
    inspect_effects = v2;
  }
  function source(v2, stack2) {
    var signal = {
      f: 0,
      // TODO ideally we could skip this altogether, but it causes type errors
      v: v2,
      reactions: null,
      equals: equals$1,
      version: 0
    };
    return signal;
  }
  function state(v2) {
    return /* @__PURE__ */ push_derived_source(source(v2));
  }
  // @__NO_SIDE_EFFECTS__
  function mutable_source(initial_value, immutable = false) {
    var _a2;
    const s = source(initial_value);
    if (!immutable) {
      s.equals = safe_equals;
    }
    if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
      ((_a2 = component_context.l).s ?? (_a2.s = [])).push(s);
    }
    return s;
  }
  function mutable_state(v2, immutable = false) {
    return /* @__PURE__ */ push_derived_source(/* @__PURE__ */ mutable_source(v2, immutable));
  }
  // @__NO_SIDE_EFFECTS__
  function push_derived_source(source2) {
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
      if (derived_sources === null) {
        set_derived_sources([source2]);
      } else {
        derived_sources.push(source2);
      }
    }
    return source2;
  }
  function set(source2, value) {
    if (active_reaction !== null && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && // If the source was created locally within the current derived, then
    // we allow the mutation.
    (derived_sources === null || !derived_sources.includes(source2))) {
      state_unsafe_mutation();
    }
    return internal_set(source2, value);
  }
  function internal_set(source2, value) {
    if (!source2.equals(value)) {
      source2.v = value;
      source2.version = increment_version();
      mark_reactions(source2, DIRTY);
      if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0) {
        if (new_deps !== null && new_deps.includes(source2)) {
          set_signal_status(active_effect, DIRTY);
          schedule_effect(active_effect);
        } else {
          if (untracked_writes === null) {
            set_untracked_writes([source2]);
          } else {
            untracked_writes.push(source2);
          }
        }
      }
      if (inspect_effects.size > 0) {
        const inspects = Array.from(inspect_effects);
        var previously_flushing_effect = is_flushing_effect;
        set_is_flushing_effect(true);
        try {
          for (const effect2 of inspects) {
            if ((effect2.f & CLEAN) !== 0) {
              set_signal_status(effect2, MAYBE_DIRTY);
            }
            if (check_dirtiness(effect2)) {
              update_effect(effect2);
            }
          }
        } finally {
          set_is_flushing_effect(previously_flushing_effect);
        }
        inspect_effects.clear();
      }
    }
    return value;
  }
  function mark_reactions(signal, status) {
    var reactions = signal.reactions;
    if (reactions === null) return;
    var runes = is_runes();
    var length = reactions.length;
    for (var i2 = 0; i2 < length; i2++) {
      var reaction = reactions[i2];
      var flags = reaction.f;
      if ((flags & DIRTY) !== 0) continue;
      if (!runes && reaction === active_effect) continue;
      if ((flags & INSPECT_EFFECT) !== 0) {
        inspect_effects.add(reaction);
        continue;
      }
      set_signal_status(reaction, status);
      if ((flags & (CLEAN | UNOWNED)) !== 0) {
        if ((flags & DERIVED) !== 0) {
          mark_reactions(
            /** @type {Derived} */
            reaction,
            MAYBE_DIRTY
          );
        } else {
          schedule_effect(
            /** @type {Effect} */
            reaction
          );
        }
      }
    }
  }
  var bold = "font-weight: bold";
  var normal = "font-weight: normal";
  function lifecycle_double_unmount() {
    {
      console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
    }
  }
  function ownership_invalid_binding(parent, child2, owner) {
    {
      console.warn(`%c[svelte] ownership_invalid_binding
%c${parent} passed a value to ${child2} with \`bind:\`, but the value is owned by ${owner}. Consider creating a binding between ${owner} and ${parent}
https://svelte.dev/e/ownership_invalid_binding`, bold, normal);
    }
  }
  function ownership_invalid_mutation(component2, owner) {
    {
      console.warn(`%c[svelte] ownership_invalid_mutation
%c${component2 ? `${component2} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : "Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead"}
https://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
    }
  }
  function state_proxy_equality_mismatch(operator) {
    {
      console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
    }
  }
  let hydrating = false;
  function reset(node) {
    return;
  }
  function next(count = 1) {
  }
  const boundaries = {};
  const chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
  const firefox_pattern = /@(.+):(\d+):(\d+)$/;
  function get_stack() {
    const stack2 = new Error().stack;
    if (!stack2) return null;
    const entries = [];
    for (const line of stack2.split("\n")) {
      let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);
      if (match) {
        entries.push({
          file: match[1],
          line: +match[2],
          column: +match[3]
        });
      }
    }
    return entries;
  }
  function get_component() {
    var _a2;
    const stack2 = (_a2 = get_stack()) == null ? void 0 : _a2.slice(4);
    if (!stack2) return null;
    for (let i2 = 0; i2 < stack2.length; i2++) {
      const entry = stack2[i2];
      const modules = boundaries[entry.file];
      if (!modules) {
        if (i2 === 0) return null;
        continue;
      }
      for (const module of modules) {
        if (module.end == null) {
          return null;
        }
        if (module.start.line < entry.line && module.end.line > entry.line) {
          return module.component;
        }
      }
    }
    return null;
  }
  const ADD_OWNER = Symbol("ADD_OWNER");
  function mark_module_start() {
    var _a2, _b2;
    const start = (_a2 = get_stack()) == null ? void 0 : _a2[2];
    if (start) {
      (boundaries[_b2 = start.file] ?? (boundaries[_b2] = [])).push({
        start,
        // @ts-expect-error
        end: null,
        // @ts-expect-error we add the component at the end, since HMR will overwrite the function
        component: null
      });
    }
  }
  function mark_module_end(component2) {
    var _a2;
    const end = (_a2 = get_stack()) == null ? void 0 : _a2[2];
    if (end) {
      const boundaries_file = boundaries[end.file];
      const boundary = boundaries_file[boundaries_file.length - 1];
      boundary.end = end;
      boundary.component = component2;
    }
  }
  function add_owner(object, owner, global2 = false, skip_warning = false) {
    if (object && !global2) {
      const component2 = dev_current_component_function;
      const metadata = object[STATE_SYMBOL_METADATA];
      if (metadata && !has_owner(metadata, component2)) {
        let original = get_owner(metadata);
        if (owner[FILENAME] !== component2[FILENAME] && !skip_warning) {
          ownership_invalid_binding(component2[FILENAME], owner[FILENAME], original[FILENAME]);
        }
      }
    }
    add_owner_to_object(object, owner, /* @__PURE__ */ new Set());
  }
  function add_owner_effect(get_object, Component, skip_warning = false) {
    user_pre_effect(() => {
      add_owner(get_object(), Component, false, skip_warning);
    });
  }
  function widen_ownership(from, to) {
    if (to.owners === null) {
      return;
    }
    while (from) {
      if (from.owners === null) {
        to.owners = null;
        break;
      }
      for (const owner of from.owners) {
        to.owners.add(owner);
      }
      from = from.parent;
    }
  }
  function add_owner_to_object(object, owner, seen) {
    const metadata = (
      /** @type {ProxyMetadata} */
      object == null ? void 0 : object[STATE_SYMBOL_METADATA]
    );
    if (metadata) {
      if ("owners" in metadata && metadata.owners != null) {
        metadata.owners.add(owner);
      }
    } else if (object && typeof object === "object") {
      if (seen.has(object)) return;
      seen.add(object);
      if (ADD_OWNER in object && object[ADD_OWNER]) {
        render_effect(() => {
          object[ADD_OWNER](owner);
        });
      } else {
        var proto = get_prototype_of(object);
        if (proto === Object.prototype) {
          for (const key in object) {
            add_owner_to_object(object[key], owner, seen);
          }
        } else if (proto === Array.prototype) {
          for (let i2 = 0; i2 < object.length; i2 += 1) {
            add_owner_to_object(object[i2], owner, seen);
          }
        }
      }
    }
  }
  function has_owner(metadata, component2) {
    if (metadata.owners === null) {
      return true;
    }
    return metadata.owners.has(component2) || metadata.parent !== null && has_owner(metadata.parent, component2);
  }
  function get_owner(metadata) {
    var _a2;
    return ((_a2 = metadata == null ? void 0 : metadata.owners) == null ? void 0 : _a2.values().next().value) ?? get_owner(
      /** @type {ProxyMetadata} */
      metadata.parent
    );
  }
  function check_ownership(metadata) {
    const component2 = get_component();
    if (component2 && !has_owner(metadata, component2)) {
      let original = get_owner(metadata);
      if (original[FILENAME] !== component2[FILENAME]) {
        ownership_invalid_mutation(component2[FILENAME], original[FILENAME]);
      } else {
        ownership_invalid_mutation();
      }
    }
  }
  function proxy(value, parent = null, prev) {
    var _a2, _b2;
    if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
      return value;
    }
    const prototype = get_prototype_of(value);
    if (prototype !== object_prototype && prototype !== array_prototype) {
      return value;
    }
    var sources = /* @__PURE__ */ new Map();
    var is_proxied_array = is_array(value);
    var version = source(0);
    if (is_proxied_array) {
      sources.set("length", source(
        /** @type {any[]} */
        value.length
      ));
    }
    var metadata;
    {
      metadata = {
        parent,
        owners: null
      };
      if (prev) {
        const prev_owners = (_b2 = (_a2 = prev.v) == null ? void 0 : _a2[STATE_SYMBOL_METADATA]) == null ? void 0 : _b2.owners;
        metadata.owners = prev_owners ? new Set(prev_owners) : null;
      } else {
        metadata.owners = parent === null ? component_context !== null ? /* @__PURE__ */ new Set([component_context.function]) : null : /* @__PURE__ */ new Set();
      }
    }
    return new Proxy(
      /** @type {any} */
      value,
      {
        defineProperty(_2, prop2, descriptor) {
          if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
            state_descriptors_fixed();
          }
          var s = sources.get(prop2);
          if (s === void 0) {
            s = source(descriptor.value);
            sources.set(prop2, s);
          } else {
            set(s, proxy(descriptor.value, metadata));
          }
          return true;
        },
        deleteProperty(target, prop2) {
          var s = sources.get(prop2);
          if (s === void 0) {
            if (prop2 in target) {
              sources.set(prop2, source(UNINITIALIZED));
            }
          } else {
            if (is_proxied_array && typeof prop2 === "string") {
              var ls = (
                /** @type {Source<number>} */
                sources.get("length")
              );
              var n = Number(prop2);
              if (Number.isInteger(n) && n < ls.v) {
                set(ls, n);
              }
            }
            set(s, UNINITIALIZED);
            update_version(version);
          }
          return true;
        },
        get(target, prop2, receiver) {
          var _a3;
          if (prop2 === STATE_SYMBOL_METADATA) {
            return metadata;
          }
          if (prop2 === STATE_SYMBOL) {
            return value;
          }
          var s = sources.get(prop2);
          var exists = prop2 in target;
          if (s === void 0 && (!exists || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
            s = source(proxy(exists ? target[prop2] : UNINITIALIZED, metadata));
            sources.set(prop2, s);
          }
          if (s !== void 0) {
            var v2 = get$2(s);
            {
              var prop_metadata = v2 == null ? void 0 : v2[STATE_SYMBOL_METADATA];
              if (prop_metadata && (prop_metadata == null ? void 0 : prop_metadata.parent) !== metadata) {
                widen_ownership(metadata, prop_metadata);
              }
            }
            return v2 === UNINITIALIZED ? void 0 : v2;
          }
          return Reflect.get(target, prop2, receiver);
        },
        getOwnPropertyDescriptor(target, prop2) {
          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
          if (descriptor && "value" in descriptor) {
            var s = sources.get(prop2);
            if (s) descriptor.value = get$2(s);
          } else if (descriptor === void 0) {
            var source2 = sources.get(prop2);
            var value2 = source2 == null ? void 0 : source2.v;
            if (source2 !== void 0 && value2 !== UNINITIALIZED) {
              return {
                enumerable: true,
                configurable: true,
                value: value2,
                writable: true
              };
            }
          }
          return descriptor;
        },
        has(target, prop2) {
          var _a3;
          if (prop2 === STATE_SYMBOL_METADATA) {
            return true;
          }
          if (prop2 === STATE_SYMBOL) {
            return true;
          }
          var s = sources.get(prop2);
          var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
          if (s !== void 0 || active_effect !== null && (!has || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable))) {
            if (s === void 0) {
              s = source(has ? proxy(target[prop2], metadata) : UNINITIALIZED);
              sources.set(prop2, s);
            }
            var value2 = get$2(s);
            if (value2 === UNINITIALIZED) {
              return false;
            }
          }
          return has;
        },
        set(target, prop2, value2, receiver) {
          var _a3;
          var s = sources.get(prop2);
          var has = prop2 in target;
          if (is_proxied_array && prop2 === "length") {
            for (var i2 = value2; i2 < /** @type {Source<number>} */
            s.v; i2 += 1) {
              var other_s = sources.get(i2 + "");
              if (other_s !== void 0) {
                set(other_s, UNINITIALIZED);
              } else if (i2 in target) {
                other_s = source(UNINITIALIZED);
                sources.set(i2 + "", other_s);
              }
            }
          }
          if (s === void 0) {
            if (!has || ((_a3 = get_descriptor(target, prop2)) == null ? void 0 : _a3.writable)) {
              s = source(void 0);
              set(s, proxy(value2, metadata));
              sources.set(prop2, s);
            }
          } else {
            has = s.v !== UNINITIALIZED;
            set(s, proxy(value2, metadata));
          }
          {
            var prop_metadata = value2 == null ? void 0 : value2[STATE_SYMBOL_METADATA];
            if (prop_metadata && (prop_metadata == null ? void 0 : prop_metadata.parent) !== metadata) {
              widen_ownership(metadata, prop_metadata);
            }
            check_ownership(metadata);
          }
          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
          if (descriptor == null ? void 0 : descriptor.set) {
            descriptor.set.call(receiver, value2);
          }
          if (!has) {
            if (is_proxied_array && typeof prop2 === "string") {
              var ls = (
                /** @type {Source<number>} */
                sources.get("length")
              );
              var n = Number(prop2);
              if (Number.isInteger(n) && n >= ls.v) {
                set(ls, n + 1);
              }
            }
            update_version(version);
          }
          return true;
        },
        ownKeys(target) {
          get$2(version);
          var own_keys = Reflect.ownKeys(target).filter((key2) => {
            var source3 = sources.get(key2);
            return source3 === void 0 || source3.v !== UNINITIALIZED;
          });
          for (var [key, source2] of sources) {
            if (source2.v !== UNINITIALIZED && !(key in target)) {
              own_keys.push(key);
            }
          }
          return own_keys;
        },
        setPrototypeOf() {
          state_prototype_fixed();
        }
      }
    );
  }
  function update_version(signal, d2 = 1) {
    set(signal, signal.v + d2);
  }
  function get_proxied_value(value) {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
    return value;
  }
  function init_array_prototype_warnings() {
    const array_prototype2 = Array.prototype;
    const cleanup = Array.__svelte_cleanup;
    if (cleanup) {
      cleanup();
    }
    const { indexOf, lastIndexOf, includes } = array_prototype2;
    array_prototype2.indexOf = function(item, from_index) {
      const index2 = indexOf.call(this, item, from_index);
      if (index2 === -1) {
        for (let i2 = from_index ?? 0; i2 < this.length; i2 += 1) {
          if (get_proxied_value(this[i2]) === item) {
            state_proxy_equality_mismatch("array.indexOf(...)");
            break;
          }
        }
      }
      return index2;
    };
    array_prototype2.lastIndexOf = function(item, from_index) {
      const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
      if (index2 === -1) {
        for (let i2 = 0; i2 <= (from_index ?? this.length - 1); i2 += 1) {
          if (get_proxied_value(this[i2]) === item) {
            state_proxy_equality_mismatch("array.lastIndexOf(...)");
            break;
          }
        }
      }
      return index2;
    };
    array_prototype2.includes = function(item, from_index) {
      const has = includes.call(this, item, from_index);
      if (!has) {
        for (let i2 = 0; i2 < this.length; i2 += 1) {
          if (get_proxied_value(this[i2]) === item) {
            state_proxy_equality_mismatch("array.includes(...)");
            break;
          }
        }
      }
      return has;
    };
    Array.__svelte_cleanup = () => {
      array_prototype2.indexOf = indexOf;
      array_prototype2.lastIndexOf = lastIndexOf;
      array_prototype2.includes = includes;
    };
  }
  function strict_equals(a2, b2, equal = true) {
    try {
      if (a2 === b2 !== (get_proxied_value(a2) === get_proxied_value(b2))) {
        state_proxy_equality_mismatch(equal ? "===" : "!==");
      }
    } catch {
    }
    return a2 === b2 === equal;
  }
  function equals(a2, b2, equal = true) {
    if (a2 == b2 !== (get_proxied_value(a2) == get_proxied_value(b2))) {
      state_proxy_equality_mismatch(equal ? "==" : "!=");
    }
    return a2 == b2 === equal;
  }
  var $window;
  var first_child_getter;
  var next_sibling_getter;
  function init_operations() {
    if ($window !== void 0) {
      return;
    }
    $window = window;
    var element_prototype = Element.prototype;
    var node_prototype = Node.prototype;
    first_child_getter = get_descriptor(node_prototype, "firstChild").get;
    next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
    element_prototype.__click = void 0;
    element_prototype.__className = "";
    element_prototype.__attributes = null;
    element_prototype.__styles = null;
    element_prototype.__e = void 0;
    Text.prototype.__t = void 0;
    {
      element_prototype.__svelte_meta = null;
      init_array_prototype_warnings();
    }
  }
  function create_text(value = "") {
    return document.createTextNode(value);
  }
  // @__NO_SIDE_EFFECTS__
  function get_first_child(node) {
    return first_child_getter.call(node);
  }
  // @__NO_SIDE_EFFECTS__
  function get_next_sibling(node) {
    return next_sibling_getter.call(node);
  }
  function child(node, is_text) {
    {
      return /* @__PURE__ */ get_first_child(node);
    }
  }
  function first_child(fragment, is_text) {
    {
      var first = (
        /** @type {DocumentFragment} */
        /* @__PURE__ */ get_first_child(
          /** @type {Node} */
          fragment
        )
      );
      if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
      return first;
    }
  }
  function sibling(node, count = 1, is_text = false) {
    let next_sibling = node;
    while (count--) {
      next_sibling = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(next_sibling);
    }
    {
      return next_sibling;
    }
  }
  function clear_text_content(node) {
    node.textContent = "";
  }
  // @__NO_SIDE_EFFECTS__
  function derived(fn) {
    var flags = DERIVED | DIRTY;
    if (active_effect === null) {
      flags |= UNOWNED;
    } else {
      active_effect.f |= EFFECT_HAS_DERIVED;
    }
    var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
      /** @type {Derived} */
      active_reaction
    ) : null;
    const signal = {
      children: null,
      ctx: component_context,
      deps: null,
      equals: equals$1,
      f: flags,
      fn,
      reactions: null,
      v: (
        /** @type {V} */
        null
      ),
      version: 0,
      parent: parent_derived ?? active_effect
    };
    if (parent_derived !== null) {
      (parent_derived.children ?? (parent_derived.children = [])).push(signal);
    }
    return signal;
  }
  // @__NO_SIDE_EFFECTS__
  function derived_safe_equal(fn) {
    const signal = /* @__PURE__ */ derived(fn);
    signal.equals = safe_equals;
    return signal;
  }
  function destroy_derived_children(derived2) {
    var children = derived2.children;
    if (children !== null) {
      derived2.children = null;
      for (var i2 = 0; i2 < children.length; i2 += 1) {
        var child2 = children[i2];
        if ((child2.f & DERIVED) !== 0) {
          destroy_derived(
            /** @type {Derived} */
            child2
          );
        } else {
          destroy_effect(
            /** @type {Effect} */
            child2
          );
        }
      }
    }
  }
  let stack = [];
  function get_derived_parent_effect(derived2) {
    var parent = derived2.parent;
    while (parent !== null) {
      if ((parent.f & DERIVED) === 0) {
        return (
          /** @type {Effect} */
          parent
        );
      }
      parent = parent.parent;
    }
    return null;
  }
  function execute_derived(derived2) {
    var value;
    var prev_active_effect = active_effect;
    set_active_effect(get_derived_parent_effect(derived2));
    {
      let prev_inspect_effects = inspect_effects;
      set_inspect_effects(/* @__PURE__ */ new Set());
      try {
        if (stack.includes(derived2)) {
          derived_references_self();
        }
        stack.push(derived2);
        destroy_derived_children(derived2);
        value = update_reaction(derived2);
      } finally {
        set_active_effect(prev_active_effect);
        set_inspect_effects(prev_inspect_effects);
        stack.pop();
      }
    }
    return value;
  }
  function update_derived(derived2) {
    var value = execute_derived(derived2);
    var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
    if (!derived2.equals(value)) {
      derived2.v = value;
      derived2.version = increment_version();
    }
  }
  function destroy_derived(derived2) {
    destroy_derived_children(derived2);
    remove_reactions(derived2, 0);
    set_signal_status(derived2, DESTROYED);
    derived2.v = derived2.children = derived2.deps = derived2.ctx = derived2.reactions = null;
  }
  function validate_effect(rune) {
    if (active_effect === null && active_reaction === null) {
      effect_orphan(rune);
    }
    if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {
      effect_in_unowned_derived();
    }
    if (is_destroying_effect) {
      effect_in_teardown(rune);
    }
  }
  function push_effect(effect2, parent_effect) {
    var parent_last = parent_effect.last;
    if (parent_last === null) {
      parent_effect.last = parent_effect.first = effect2;
    } else {
      parent_last.next = effect2;
      effect2.prev = parent_last;
      parent_effect.last = effect2;
    }
  }
  function create_effect(type, fn, sync, push2 = true) {
    var is_root = (type & ROOT_EFFECT) !== 0;
    var parent_effect = active_effect;
    {
      while (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {
        parent_effect = parent_effect.parent;
      }
    }
    var effect2 = {
      ctx: component_context,
      deps: null,
      deriveds: null,
      nodes_start: null,
      nodes_end: null,
      f: type | DIRTY,
      first: null,
      fn,
      last: null,
      next: null,
      parent: is_root ? null : parent_effect,
      prev: null,
      teardown: null,
      transitions: null,
      version: 0
    };
    {
      effect2.component_function = dev_current_component_function;
    }
    if (sync) {
      var previously_flushing_effect = is_flushing_effect;
      try {
        set_is_flushing_effect(true);
        update_effect(effect2);
        effect2.f |= EFFECT_RAN;
      } catch (e) {
        destroy_effect(effect2);
        throw e;
      } finally {
        set_is_flushing_effect(previously_flushing_effect);
      }
    } else if (fn !== null) {
      schedule_effect(effect2);
    }
    var inert = sync && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & EFFECT_HAS_DERIVED) === 0;
    if (!inert && !is_root && push2) {
      if (parent_effect !== null) {
        push_effect(effect2, parent_effect);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
        var derived2 = (
          /** @type {Derived} */
          active_reaction
        );
        (derived2.children ?? (derived2.children = [])).push(effect2);
      }
    }
    return effect2;
  }
  function effect_tracking() {
    if (active_reaction === null) {
      return false;
    }
    return !skip_reaction;
  }
  function teardown(fn) {
    const effect2 = create_effect(RENDER_EFFECT, null, false);
    set_signal_status(effect2, CLEAN);
    effect2.teardown = fn;
    return effect2;
  }
  function user_effect(fn) {
    validate_effect("$effect");
    var defer = active_effect !== null && (active_effect.f & BRANCH_EFFECT) !== 0 && component_context !== null && !component_context.m;
    {
      define_property(fn, "name", {
        value: "$effect"
      });
    }
    if (defer) {
      var context = (
        /** @type {ComponentContext} */
        component_context
      );
      (context.e ?? (context.e = [])).push({
        fn,
        effect: active_effect,
        reaction: active_reaction
      });
    } else {
      var signal = effect(fn);
      return signal;
    }
  }
  function user_pre_effect(fn) {
    validate_effect("$effect.pre");
    {
      define_property(fn, "name", {
        value: "$effect.pre"
      });
    }
    return render_effect(fn);
  }
  function effect_root(fn) {
    const effect2 = create_effect(ROOT_EFFECT, fn, true);
    return () => {
      destroy_effect(effect2);
    };
  }
  function component_root(fn) {
    const effect2 = create_effect(ROOT_EFFECT, fn, true);
    return (options = {}) => {
      return new Promise((fulfil) => {
        if (options.outro) {
          pause_effect(effect2, () => {
            destroy_effect(effect2);
            fulfil(void 0);
          });
        } else {
          destroy_effect(effect2);
          fulfil(void 0);
        }
      });
    };
  }
  function effect(fn) {
    return create_effect(EFFECT, fn, false);
  }
  function render_effect(fn) {
    return create_effect(RENDER_EFFECT, fn, true);
  }
  function template_effect(fn) {
    {
      define_property(fn, "name", {
        value: "{expression}"
      });
    }
    return block(fn);
  }
  function block(fn, flags = 0) {
    return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
  }
  function branch(fn, push2 = true) {
    return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push2);
  }
  function execute_effect_teardown(effect2) {
    var teardown2 = effect2.teardown;
    if (teardown2 !== null) {
      const previously_destroying_effect = is_destroying_effect;
      const previous_reaction = active_reaction;
      set_is_destroying_effect(true);
      set_active_reaction(null);
      try {
        teardown2.call(null);
      } finally {
        set_is_destroying_effect(previously_destroying_effect);
        set_active_reaction(previous_reaction);
      }
    }
  }
  function destroy_effect_deriveds(signal) {
    var deriveds = signal.deriveds;
    if (deriveds !== null) {
      signal.deriveds = null;
      for (var i2 = 0; i2 < deriveds.length; i2 += 1) {
        destroy_derived(deriveds[i2]);
      }
    }
  }
  function destroy_effect_children(signal, remove_dom = false) {
    var effect2 = signal.first;
    signal.first = signal.last = null;
    while (effect2 !== null) {
      var next2 = effect2.next;
      destroy_effect(effect2, remove_dom);
      effect2 = next2;
    }
  }
  function destroy_block_effect_children(signal) {
    var effect2 = signal.first;
    while (effect2 !== null) {
      var next2 = effect2.next;
      if ((effect2.f & BRANCH_EFFECT) === 0) {
        destroy_effect(effect2);
      }
      effect2 = next2;
    }
  }
  function destroy_effect(effect2, remove_dom = true) {
    var removed = false;
    if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null) {
      var node = effect2.nodes_start;
      var end = effect2.nodes_end;
      while (node !== null) {
        var next2 = node === end ? null : (
          /** @type {TemplateNode} */
          /* @__PURE__ */ get_next_sibling(node)
        );
        node.remove();
        node = next2;
      }
      removed = true;
    }
    destroy_effect_children(effect2, remove_dom && !removed);
    destroy_effect_deriveds(effect2);
    remove_reactions(effect2, 0);
    set_signal_status(effect2, DESTROYED);
    var transitions = effect2.transitions;
    if (transitions !== null) {
      for (const transition of transitions) {
        transition.stop();
      }
    }
    execute_effect_teardown(effect2);
    var parent = effect2.parent;
    if (parent !== null && parent.first !== null) {
      unlink_effect(effect2);
    }
    {
      effect2.component_function = null;
    }
    effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = null;
  }
  function unlink_effect(effect2) {
    var parent = effect2.parent;
    var prev = effect2.prev;
    var next2 = effect2.next;
    if (prev !== null) prev.next = next2;
    if (next2 !== null) next2.prev = prev;
    if (parent !== null) {
      if (parent.first === effect2) parent.first = next2;
      if (parent.last === effect2) parent.last = prev;
    }
  }
  function pause_effect(effect2, callback) {
    var transitions = [];
    pause_children(effect2, transitions, true);
    run_out_transitions(transitions, () => {
      destroy_effect(effect2);
      if (callback) callback();
    });
  }
  function run_out_transitions(transitions, fn) {
    var remaining = transitions.length;
    if (remaining > 0) {
      var check = () => --remaining || fn();
      for (var transition of transitions) {
        transition.out(check);
      }
    } else {
      fn();
    }
  }
  function pause_children(effect2, transitions, local) {
    if ((effect2.f & INERT) !== 0) return;
    effect2.f ^= INERT;
    if (effect2.transitions !== null) {
      for (const transition of effect2.transitions) {
        if (transition.is_global || local) {
          transitions.push(transition);
        }
      }
    }
    var child2 = effect2.first;
    while (child2 !== null) {
      var sibling2 = child2.next;
      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
      pause_children(child2, transitions, transparent ? local : false);
      child2 = sibling2;
    }
  }
  function resume_effect(effect2) {
    resume_children(effect2, true);
  }
  function resume_children(effect2, local) {
    if ((effect2.f & INERT) === 0) return;
    if (check_dirtiness(effect2)) {
      update_effect(effect2);
    }
    effect2.f ^= INERT;
    var child2 = effect2.first;
    while (child2 !== null) {
      var sibling2 = child2.next;
      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
      resume_children(child2, transparent ? local : false);
      child2 = sibling2;
    }
    if (effect2.transitions !== null) {
      for (const transition of effect2.transitions) {
        if (transition.is_global || local) {
          transition.in();
        }
      }
    }
  }
  let is_micro_task_queued$1 = false;
  let current_queued_micro_tasks = [];
  function process_micro_tasks() {
    is_micro_task_queued$1 = false;
    const tasks = current_queued_micro_tasks.slice();
    current_queued_micro_tasks = [];
    run_all(tasks);
  }
  function queue_micro_task(fn) {
    if (!is_micro_task_queued$1) {
      is_micro_task_queued$1 = true;
      queueMicrotask(process_micro_tasks);
    }
    current_queued_micro_tasks.push(fn);
  }
  function flush_tasks() {
    if (is_micro_task_queued$1) {
      process_micro_tasks();
    }
  }
  function lifecycle_outside_component(name) {
    {
      const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
      error.name = "Svelte error";
      throw error;
    }
  }
  function svelte_element_invalid_this_value() {
    {
      const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
      error.name = "Svelte error";
      throw error;
    }
  }
  const FLUSH_MICROTASK = 0;
  const FLUSH_SYNC = 1;
  const handled_errors = /* @__PURE__ */ new WeakSet();
  let is_throwing_error = false;
  let scheduler_mode = FLUSH_MICROTASK;
  let is_micro_task_queued = false;
  let last_scheduled_effect = null;
  let is_flushing_effect = false;
  let is_destroying_effect = false;
  function set_is_flushing_effect(value) {
    is_flushing_effect = value;
  }
  function set_is_destroying_effect(value) {
    is_destroying_effect = value;
  }
  let queued_root_effects = [];
  let flush_count = 0;
  let dev_effect_stack = [];
  let active_reaction = null;
  function set_active_reaction(reaction) {
    active_reaction = reaction;
  }
  let active_effect = null;
  function set_active_effect(effect2) {
    active_effect = effect2;
  }
  let derived_sources = null;
  function set_derived_sources(sources) {
    derived_sources = sources;
  }
  let new_deps = null;
  let skipped_deps = 0;
  let untracked_writes = null;
  function set_untracked_writes(value) {
    untracked_writes = value;
  }
  let current_version = 1;
  let skip_reaction = false;
  let captured_signals = null;
  let component_context = null;
  let dev_current_component_function = null;
  function set_dev_current_component_function(fn) {
    dev_current_component_function = fn;
  }
  function increment_version() {
    return ++current_version;
  }
  function is_runes() {
    return !legacy_mode_flag || component_context !== null && component_context.l === null;
  }
  function check_dirtiness(reaction) {
    var _a2, _b2;
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0) {
      return true;
    }
    if ((flags & MAYBE_DIRTY) !== 0) {
      var dependencies = reaction.deps;
      var is_unowned = (flags & UNOWNED) !== 0;
      if (dependencies !== null) {
        var i2;
        if ((flags & DISCONNECTED) !== 0) {
          for (i2 = 0; i2 < dependencies.length; i2++) {
            ((_a2 = dependencies[i2]).reactions ?? (_a2.reactions = [])).push(reaction);
          }
          reaction.f ^= DISCONNECTED;
        }
        for (i2 = 0; i2 < dependencies.length; i2++) {
          var dependency = dependencies[i2];
          if (check_dirtiness(
            /** @type {Derived} */
            dependency
          )) {
            update_derived(
              /** @type {Derived} */
              dependency
            );
          }
          if (is_unowned && active_effect !== null && !skip_reaction && !((_b2 = dependency == null ? void 0 : dependency.reactions) == null ? void 0 : _b2.includes(reaction))) {
            (dependency.reactions ?? (dependency.reactions = [])).push(reaction);
          }
          if (dependency.version > reaction.version) {
            return true;
          }
        }
      }
      if (!is_unowned || active_effect !== null && !skip_reaction) {
        set_signal_status(reaction, CLEAN);
      }
    }
    return false;
  }
  function propagate_error(error, effect2) {
    var current = effect2;
    while (current !== null) {
      if ((current.f & BOUNDARY_EFFECT) !== 0) {
        try {
          current.fn(error);
          return;
        } catch {
          current.f ^= BOUNDARY_EFFECT;
        }
      }
      current = current.parent;
    }
    is_throwing_error = false;
    throw error;
  }
  function should_rethrow_error(effect2) {
    return (effect2.f & DESTROYED) === 0 && (effect2.parent === null || (effect2.parent.f & BOUNDARY_EFFECT) === 0);
  }
  function handle_error(error, effect2, previous_effect, component_context2) {
    var _a2, _b2;
    if (is_throwing_error) {
      if (previous_effect === null) {
        is_throwing_error = false;
      }
      if (should_rethrow_error(effect2)) {
        throw error;
      }
      return;
    }
    if (previous_effect !== null) {
      is_throwing_error = true;
    }
    if (component_context2 === null || !(error instanceof Error) || handled_errors.has(error)) {
      propagate_error(error, effect2);
      return;
    }
    handled_errors.add(error);
    const component_stack = [];
    const effect_name = (_a2 = effect2.fn) == null ? void 0 : _a2.name;
    if (effect_name) {
      component_stack.push(effect_name);
    }
    let current_context = component_context2;
    while (current_context !== null) {
      {
        var filename = (_b2 = current_context.function) == null ? void 0 : _b2[FILENAME];
        if (filename) {
          const file = filename.split("/").pop();
          component_stack.push(file);
        }
      }
      current_context = current_context.p;
    }
    const indent = /Firefox/.test(navigator.userAgent) ? "  " : "	";
    define_property(error, "message", {
      value: error.message + `
${component_stack.map((name) => `
${indent}in ${name}`).join("")}
`
    });
    define_property(error, "component_stack", {
      value: component_stack
    });
    const stack2 = error.stack;
    if (stack2) {
      const lines = stack2.split("\n");
      const new_lines = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        const line = lines[i2];
        if (line.includes("svelte/src/internal")) {
          continue;
        }
        new_lines.push(line);
      }
      define_property(error, "stack", {
        value: new_lines.join("\n")
      });
    }
    propagate_error(error, effect2);
    if (should_rethrow_error(effect2)) {
      throw error;
    }
  }
  function update_reaction(reaction) {
    var _a2;
    var previous_deps = new_deps;
    var previous_skipped_deps = skipped_deps;
    var previous_untracked_writes = untracked_writes;
    var previous_reaction = active_reaction;
    var previous_skip_reaction = skip_reaction;
    var prev_derived_sources = derived_sources;
    var previous_component_context = component_context;
    var flags = reaction.f;
    new_deps = /** @type {null | Value[]} */
    null;
    skipped_deps = 0;
    untracked_writes = null;
    active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
    skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
    derived_sources = null;
    component_context = reaction.ctx;
    try {
      var result2 = (
        /** @type {Function} */
        (0, reaction.fn)()
      );
      var deps = reaction.deps;
      if (new_deps !== null) {
        var i2;
        remove_reactions(reaction, skipped_deps);
        if (deps !== null && skipped_deps > 0) {
          deps.length = skipped_deps + new_deps.length;
          for (i2 = 0; i2 < new_deps.length; i2++) {
            deps[skipped_deps + i2] = new_deps[i2];
          }
        } else {
          reaction.deps = deps = new_deps;
        }
        if (!skip_reaction) {
          for (i2 = skipped_deps; i2 < deps.length; i2++) {
            ((_a2 = deps[i2]).reactions ?? (_a2.reactions = [])).push(reaction);
          }
        }
      } else if (deps !== null && skipped_deps < deps.length) {
        remove_reactions(reaction, skipped_deps);
        deps.length = skipped_deps;
      }
      return result2;
    } finally {
      new_deps = previous_deps;
      skipped_deps = previous_skipped_deps;
      untracked_writes = previous_untracked_writes;
      active_reaction = previous_reaction;
      skip_reaction = previous_skip_reaction;
      derived_sources = prev_derived_sources;
      component_context = previous_component_context;
    }
  }
  function remove_reaction(signal, dependency) {
    let reactions = dependency.reactions;
    if (reactions !== null) {
      var index2 = reactions.indexOf(signal);
      if (index2 !== -1) {
        var new_length = reactions.length - 1;
        if (new_length === 0) {
          reactions = dependency.reactions = null;
        } else {
          reactions[index2] = reactions[new_length];
          reactions.pop();
        }
      }
    }
    if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
    // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
    // allows us to skip the expensive work of disconnecting and immediately reconnecting it
    (new_deps === null || !new_deps.includes(dependency))) {
      set_signal_status(dependency, MAYBE_DIRTY);
      if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
        dependency.f ^= DISCONNECTED;
      }
      remove_reactions(
        /** @type {Derived} **/
        dependency,
        0
      );
    }
  }
  function remove_reactions(signal, start_index) {
    var dependencies = signal.deps;
    if (dependencies === null) return;
    for (var i2 = start_index; i2 < dependencies.length; i2++) {
      remove_reaction(signal, dependencies[i2]);
    }
  }
  function update_effect(effect2) {
    var flags = effect2.f;
    if ((flags & DESTROYED) !== 0) {
      return;
    }
    set_signal_status(effect2, CLEAN);
    var previous_effect = active_effect;
    var previous_component_context = component_context;
    active_effect = effect2;
    {
      var previous_component_fn = dev_current_component_function;
      dev_current_component_function = effect2.component_function;
    }
    try {
      if ((flags & BLOCK_EFFECT) !== 0) {
        destroy_block_effect_children(effect2);
      } else {
        destroy_effect_children(effect2);
      }
      destroy_effect_deriveds(effect2);
      execute_effect_teardown(effect2);
      var teardown2 = update_reaction(effect2);
      effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
      effect2.version = current_version;
      if (DEV) {
        dev_effect_stack.push(effect2);
      }
    } catch (error) {
      handle_error(error, effect2, previous_effect, previous_component_context || effect2.ctx);
    } finally {
      active_effect = previous_effect;
      {
        dev_current_component_function = previous_component_fn;
      }
    }
  }
  function log_effect_stack() {
    console.error(
      "Last ten effects were: ",
      dev_effect_stack.slice(-10).map((d2) => d2.fn)
    );
    dev_effect_stack = [];
  }
  function infinite_loop_guard() {
    if (flush_count > 1e3) {
      flush_count = 0;
      try {
        effect_update_depth_exceeded();
      } catch (error) {
        {
          define_property(error, "stack", {
            value: ""
          });
        }
        if (last_scheduled_effect !== null) {
          {
            try {
              handle_error(error, last_scheduled_effect, null, null);
            } catch (e) {
              log_effect_stack();
              throw e;
            }
          }
        } else {
          {
            log_effect_stack();
          }
          throw error;
        }
      }
    }
    flush_count++;
  }
  function flush_queued_root_effects(root_effects) {
    var length = root_effects.length;
    if (length === 0) {
      return;
    }
    infinite_loop_guard();
    var previously_flushing_effect = is_flushing_effect;
    is_flushing_effect = true;
    try {
      for (var i2 = 0; i2 < length; i2++) {
        var effect2 = root_effects[i2];
        if ((effect2.f & CLEAN) === 0) {
          effect2.f ^= CLEAN;
        }
        var collected_effects = [];
        process_effects(effect2, collected_effects);
        flush_queued_effects(collected_effects);
      }
    } finally {
      is_flushing_effect = previously_flushing_effect;
    }
  }
  function flush_queued_effects(effects) {
    var length = effects.length;
    if (length === 0) return;
    for (var i2 = 0; i2 < length; i2++) {
      var effect2 = effects[i2];
      if ((effect2.f & (DESTROYED | INERT)) === 0) {
        try {
          if (check_dirtiness(effect2)) {
            update_effect(effect2);
            if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
              if (effect2.teardown === null) {
                unlink_effect(effect2);
              } else {
                effect2.fn = null;
              }
            }
          }
        } catch (error) {
          handle_error(error, effect2, null, effect2.ctx);
        }
      }
    }
  }
  function process_deferred() {
    is_micro_task_queued = false;
    if (flush_count > 1001) {
      return;
    }
    const previous_queued_root_effects = queued_root_effects;
    queued_root_effects = [];
    flush_queued_root_effects(previous_queued_root_effects);
    if (!is_micro_task_queued) {
      flush_count = 0;
      last_scheduled_effect = null;
      {
        dev_effect_stack = [];
      }
    }
  }
  function schedule_effect(signal) {
    if (scheduler_mode === FLUSH_MICROTASK) {
      if (!is_micro_task_queued) {
        is_micro_task_queued = true;
        queueMicrotask(process_deferred);
      }
    }
    last_scheduled_effect = signal;
    var effect2 = signal;
    while (effect2.parent !== null) {
      effect2 = effect2.parent;
      var flags = effect2.f;
      if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
        if ((flags & CLEAN) === 0) return;
        effect2.f ^= CLEAN;
      }
    }
    queued_root_effects.push(effect2);
  }
  function process_effects(effect2, collected_effects) {
    var current_effect = effect2.first;
    var effects = [];
    main_loop: while (current_effect !== null) {
      var flags = current_effect.f;
      var is_branch = (flags & BRANCH_EFFECT) !== 0;
      var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
      var sibling2 = current_effect.next;
      if (!is_skippable_branch && (flags & INERT) === 0) {
        if ((flags & RENDER_EFFECT) !== 0) {
          if (is_branch) {
            current_effect.f ^= CLEAN;
          } else {
            try {
              if (check_dirtiness(current_effect)) {
                update_effect(current_effect);
              }
            } catch (error) {
              handle_error(error, current_effect, null, current_effect.ctx);
            }
          }
          var child2 = current_effect.first;
          if (child2 !== null) {
            current_effect = child2;
            continue;
          }
        } else if ((flags & EFFECT) !== 0) {
          effects.push(current_effect);
        }
      }
      if (sibling2 === null) {
        let parent = current_effect.parent;
        while (parent !== null) {
          if (effect2 === parent) {
            break main_loop;
          }
          var parent_sibling = parent.next;
          if (parent_sibling !== null) {
            current_effect = parent_sibling;
            continue main_loop;
          }
          parent = parent.parent;
        }
      }
      current_effect = sibling2;
    }
    for (var i2 = 0; i2 < effects.length; i2++) {
      child2 = effects[i2];
      collected_effects.push(child2);
      process_effects(child2, collected_effects);
    }
  }
  function flush_sync(fn) {
    var previous_scheduler_mode = scheduler_mode;
    var previous_queued_root_effects = queued_root_effects;
    try {
      infinite_loop_guard();
      const root_effects = [];
      scheduler_mode = FLUSH_SYNC;
      queued_root_effects = root_effects;
      is_micro_task_queued = false;
      flush_queued_root_effects(previous_queued_root_effects);
      var result2 = fn == null ? void 0 : fn();
      flush_tasks();
      if (queued_root_effects.length > 0 || root_effects.length > 0) {
        flush_sync();
      }
      flush_count = 0;
      last_scheduled_effect = null;
      if (DEV) {
        dev_effect_stack = [];
      }
      return result2;
    } finally {
      scheduler_mode = previous_scheduler_mode;
      queued_root_effects = previous_queued_root_effects;
    }
  }
  async function tick() {
    await Promise.resolve();
    flush_sync();
  }
  function get$2(signal) {
    var _a2;
    var flags = signal.f;
    var is_derived = (flags & DERIVED) !== 0;
    if (is_derived && (flags & DESTROYED) !== 0) {
      var value = execute_derived(
        /** @type {Derived} */
        signal
      );
      destroy_derived(
        /** @type {Derived} */
        signal
      );
      return value;
    }
    if (captured_signals !== null) {
      captured_signals.add(signal);
    }
    if (active_reaction !== null) {
      if (derived_sources !== null && derived_sources.includes(signal)) {
        state_unsafe_local_read();
      }
      var deps = active_reaction.deps;
      if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
        skipped_deps++;
      } else if (new_deps === null) {
        new_deps = [signal];
      } else {
        new_deps.push(signal);
      }
      if (untracked_writes !== null && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0 && untracked_writes.includes(signal)) {
        set_signal_status(active_effect, DIRTY);
        schedule_effect(active_effect);
      }
    } else if (is_derived && /** @type {Derived} */
    signal.deps === null) {
      var derived2 = (
        /** @type {Derived} */
        signal
      );
      var parent = derived2.parent;
      var target = derived2;
      while (parent !== null) {
        if ((parent.f & DERIVED) !== 0) {
          var parent_derived = (
            /** @type {Derived} */
            parent
          );
          target = parent_derived;
          parent = parent_derived.parent;
        } else {
          var parent_effect = (
            /** @type {Effect} */
            parent
          );
          if (!((_a2 = parent_effect.deriveds) == null ? void 0 : _a2.includes(target))) {
            (parent_effect.deriveds ?? (parent_effect.deriveds = [])).push(target);
          }
          break;
        }
      }
    }
    if (is_derived) {
      derived2 = /** @type {Derived} */
      signal;
      if (check_dirtiness(derived2)) {
        update_derived(derived2);
      }
    }
    return signal.v;
  }
  function capture_signals(fn) {
    var previous_captured_signals = captured_signals;
    captured_signals = /* @__PURE__ */ new Set();
    var captured = captured_signals;
    var signal;
    try {
      untrack(fn);
      if (previous_captured_signals !== null) {
        for (signal of captured_signals) {
          previous_captured_signals.add(signal);
        }
      }
    } finally {
      captured_signals = previous_captured_signals;
    }
    return captured;
  }
  function invalidate_inner_signals(fn) {
    var captured = capture_signals(() => untrack(fn));
    for (var signal of captured) {
      if ((signal.f & LEGACY_DERIVED_PROP) !== 0) {
        for (
          const dep of
          /** @type {Derived} */
          signal.deps || []
        ) {
          if ((dep.f & DERIVED) === 0) {
            internal_set(dep, dep.v);
          }
        }
      } else {
        internal_set(signal, signal.v);
      }
    }
  }
  function untrack(fn) {
    const previous_reaction = active_reaction;
    try {
      active_reaction = null;
      return fn();
    } finally {
      active_reaction = previous_reaction;
    }
  }
  const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  function set_signal_status(signal, status) {
    signal.f = signal.f & STATUS_MASK | status;
  }
  function getContext$1(key) {
    const context_map = get_or_init_context_map("getContext");
    const result2 = (
      /** @type {T} */
      context_map.get(key)
    );
    {
      const fn = (
        /** @type {ComponentContext} */
        component_context.function
      );
      if (fn) {
        add_owner(result2, fn, true);
      }
    }
    return result2;
  }
  function setContext$1(key, context) {
    const context_map = get_or_init_context_map("setContext");
    context_map.set(key, context);
    return context;
  }
  function hasContext(key) {
    const context_map = get_or_init_context_map("hasContext");
    return context_map.has(key);
  }
  function getAllContexts() {
    const context_map = get_or_init_context_map("getAllContexts");
    {
      const fn = component_context == null ? void 0 : component_context.function;
      if (fn) {
        for (const value of context_map.values()) {
          add_owner(value, fn, true);
        }
      }
    }
    return (
      /** @type {T} */
      context_map
    );
  }
  function get_or_init_context_map(name) {
    if (component_context === null) {
      lifecycle_outside_component(name);
    }
    return component_context.c ?? (component_context.c = new Map(get_parent_context(component_context) || void 0));
  }
  function get_parent_context(component_context2) {
    let parent = component_context2.p;
    while (parent !== null) {
      const context_map = parent.c;
      if (context_map !== null) {
        return context_map;
      }
      parent = parent.p;
    }
    return null;
  }
  function update(signal, d2 = 1) {
    var value = get$2(signal);
    var result2 = d2 === 1 ? value++ : value--;
    set(signal, value);
    return result2;
  }
  function push(props, runes = false, fn) {
    component_context = {
      p: component_context,
      c: null,
      e: null,
      m: false,
      s: props,
      x: null,
      l: null
    };
    if (legacy_mode_flag && !runes) {
      component_context.l = {
        s: null,
        u: null,
        r1: [],
        r2: source(false)
      };
    }
    {
      component_context.function = fn;
      dev_current_component_function = fn;
    }
  }
  function pop(component2) {
    var _a2;
    const context_stack_item = component_context;
    if (context_stack_item !== null) {
      if (component2 !== void 0) {
        context_stack_item.x = component2;
      }
      const component_effects = context_stack_item.e;
      if (component_effects !== null) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        context_stack_item.e = null;
        try {
          for (var i2 = 0; i2 < component_effects.length; i2++) {
            var component_effect = component_effects[i2];
            set_active_effect(component_effect.effect);
            set_active_reaction(component_effect.reaction);
            effect(component_effect.fn);
          }
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
        }
      }
      component_context = context_stack_item.p;
      {
        dev_current_component_function = ((_a2 = context_stack_item.p) == null ? void 0 : _a2.function) ?? null;
      }
      context_stack_item.m = true;
    }
    return component2 || /** @type {T} */
    {};
  }
  function deep_read_state(value) {
    if (typeof value !== "object" || !value || value instanceof EventTarget) {
      return;
    }
    if (STATE_SYMBOL in value) {
      deep_read(value);
    } else if (!Array.isArray(value)) {
      for (let key in value) {
        const prop2 = value[key];
        if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
          deep_read(prop2);
        }
      }
    }
  }
  function deep_read(value, visited = /* @__PURE__ */ new Set()) {
    if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
    !(value instanceof EventTarget) && !visited.has(value)) {
      visited.add(value);
      if (value instanceof Date) {
        value.getTime();
      }
      for (let key in value) {
        try {
          deep_read(value[key], visited);
        } catch (e) {
        }
      }
      const proto = get_prototype_of(value);
      if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
        const descriptors = get_descriptors(proto);
        for (let key in descriptors) {
          const get2 = descriptors[key].get;
          if (get2) {
            try {
              get2.call(value);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  {
    let throw_rune_error = function(rune) {
      if (!(rune in globalThis)) {
        let value;
        Object.defineProperty(globalThis, rune, {
          configurable: true,
          // eslint-disable-next-line getter-return
          get: () => {
            if (value !== void 0) {
              return value;
            }
            rune_outside_svelte(rune);
          },
          set: (v2) => {
            value = v2;
          }
        });
      }
    };
    throw_rune_error("$state");
    throw_rune_error("$effect");
    throw_rune_error("$derived");
    throw_rune_error("$inspect");
    throw_rune_error("$props");
    throw_rune_error("$bindable");
  }
  function add_locations(fn, filename, locations) {
    return (...args) => {
      const dom = fn(...args);
      var node = dom.nodeType === 11 ? dom.firstChild : dom;
      assign_locations(node, filename, locations);
      return dom;
    };
  }
  function assign_location(element2, filename, location2) {
    element2.__svelte_meta = {
      loc: { file: filename, line: location2[0], column: location2[1] }
    };
    if (location2[2]) {
      assign_locations(element2.firstChild, filename, location2[2]);
    }
  }
  function assign_locations(node, filename, locations) {
    var i2 = 0;
    while (node && i2 < locations.length) {
      if (node.nodeType === 1) {
        assign_location(
          /** @type {Element} */
          node,
          filename,
          locations[i2++]
        );
      }
      node = node.nextSibling;
    }
  }
  function autofocus(dom, value) {
    if (value) {
      const body = document.body;
      dom.autofocus = true;
      queue_micro_task(() => {
        if (document.activeElement === body) {
          dom.focus();
        }
      });
    }
  }
  let listening_to_form_reset = false;
  function add_form_reset_listener() {
    if (!listening_to_form_reset) {
      listening_to_form_reset = true;
      document.addEventListener(
        "reset",
        (evt) => {
          Promise.resolve().then(() => {
            var _a2;
            if (!evt.defaultPrevented) {
              for (
                const e of
                /**@type {HTMLFormElement} */
                evt.target.elements
              ) {
                (_a2 = e.__on_r) == null ? void 0 : _a2.call(e);
              }
            }
          });
        },
        // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
        { capture: true }
      );
    }
  }
  function without_reactive_context(fn) {
    var previous_reaction = active_reaction;
    var previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      return fn();
    } finally {
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }
  function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
    element2.addEventListener(event2, () => without_reactive_context(handler));
    const prev = element2.__on_r;
    if (prev) {
      element2.__on_r = () => {
        prev();
        on_reset(true);
      };
    } else {
      element2.__on_r = () => on_reset(true);
    }
    add_form_reset_listener();
  }
  const all_registered_events = /* @__PURE__ */ new Set();
  const root_event_handles = /* @__PURE__ */ new Set();
  function create_event(event_name, dom, handler, options) {
    function target_handler(event2) {
      if (!options.capture) {
        handle_event_propagation.call(dom, event2);
      }
      if (!event2.cancelBubble) {
        return without_reactive_context(() => {
          return handler.call(this, event2);
        });
      }
    }
    if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
      queue_micro_task(() => {
        dom.addEventListener(event_name, target_handler, options);
      });
    } else {
      dom.addEventListener(event_name, target_handler, options);
    }
    return target_handler;
  }
  function event(event_name, dom, handler, capture, passive) {
    var options = { capture, passive };
    var target_handler = create_event(event_name, dom, handler, options);
    if (dom === document.body || dom === window || dom === document) {
      teardown(() => {
        dom.removeEventListener(event_name, target_handler, options);
      });
    }
  }
  function delegate(events) {
    for (var i2 = 0; i2 < events.length; i2++) {
      all_registered_events.add(events[i2]);
    }
    for (var fn of root_event_handles) {
      fn(events);
    }
  }
  function handle_event_propagation(event2) {
    var _a2;
    var handler_element = this;
    var owner_document = (
      /** @type {Node} */
      handler_element.ownerDocument
    );
    var event_name = event2.type;
    var path = ((_a2 = event2.composedPath) == null ? void 0 : _a2.call(event2)) || [];
    var current_target = (
      /** @type {null | Element} */
      path[0] || event2.target
    );
    var path_idx = 0;
    var handled_at = event2.__root;
    if (handled_at) {
      var at_idx = path.indexOf(handled_at);
      if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
      window)) {
        event2.__root = handler_element;
        return;
      }
      var handler_idx = path.indexOf(handler_element);
      if (handler_idx === -1) {
        return;
      }
      if (at_idx <= handler_idx) {
        path_idx = at_idx;
      }
    }
    current_target = /** @type {Element} */
    path[path_idx] || event2.target;
    if (current_target === handler_element) return;
    define_property(event2, "currentTarget", {
      configurable: true,
      get() {
        return current_target || owner_document;
      }
    });
    var previous_reaction = active_reaction;
    var previous_effect = active_effect;
    set_active_reaction(null);
    set_active_effect(null);
    try {
      var throw_error;
      var other_errors = [];
      while (current_target !== null) {
        var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
        current_target.host || null;
        try {
          var delegated = current_target["__" + event_name];
          if (delegated !== void 0 && !/** @type {any} */
          current_target.disabled) {
            if (is_array(delegated)) {
              var [fn, ...data] = delegated;
              fn.apply(current_target, [event2, ...data]);
            } else {
              delegated.call(current_target, event2);
            }
          }
        } catch (error) {
          if (throw_error) {
            other_errors.push(error);
          } else {
            throw_error = error;
          }
        }
        if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
          break;
        }
        current_target = parent_element;
      }
      if (throw_error) {
        for (let error of other_errors) {
          queueMicrotask(() => {
            throw error;
          });
        }
        throw throw_error;
      }
    } finally {
      event2.__root = handler_element;
      delete event2.currentTarget;
      set_active_reaction(previous_reaction);
      set_active_effect(previous_effect);
    }
  }
  function create_fragment_from_html(html) {
    var elem = document.createElement("template");
    elem.innerHTML = html;
    return elem.content;
  }
  function assign_nodes(start, end) {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (effect2.nodes_start === null) {
      effect2.nodes_start = start;
      effect2.nodes_end = end;
    }
  }
  // @__NO_SIDE_EFFECTS__
  function template(content, flags) {
    var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
    var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
    var node;
    var has_start = !content.startsWith("<!>");
    return () => {
      if (node === void 0) {
        node = create_fragment_from_html(has_start ? content : "<!>" + content);
        if (!is_fragment) node = /** @type {Node} */
        /* @__PURE__ */ get_first_child(node);
      }
      var clone = (
        /** @type {TemplateNode} */
        use_import_node ? document.importNode(node, true) : node.cloneNode(true)
      );
      if (is_fragment) {
        var start = (
          /** @type {TemplateNode} */
          /* @__PURE__ */ get_first_child(clone)
        );
        var end = (
          /** @type {TemplateNode} */
          clone.lastChild
        );
        assign_nodes(start, end);
      } else {
        assign_nodes(clone, clone);
      }
      return clone;
    };
  }
  // @__NO_SIDE_EFFECTS__
  function ns_template(content, flags, ns = "svg") {
    var has_start = !content.startsWith("<!>");
    var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
    var node;
    return () => {
      if (!node) {
        var fragment = (
          /** @type {DocumentFragment} */
          create_fragment_from_html(wrapped)
        );
        var root2 = (
          /** @type {Element} */
          /* @__PURE__ */ get_first_child(fragment)
        );
        {
          node = /** @type {Element} */
          /* @__PURE__ */ get_first_child(root2);
        }
      }
      var clone = (
        /** @type {TemplateNode} */
        node.cloneNode(true)
      );
      {
        assign_nodes(clone, clone);
      }
      return clone;
    };
  }
  function text(value = "") {
    {
      var t = create_text(value + "");
      assign_nodes(t, t);
      return t;
    }
  }
  function comment() {
    var frag = document.createDocumentFragment();
    var start = document.createComment("");
    var anchor = create_text();
    frag.append(start, anchor);
    assign_nodes(start, anchor);
    return frag;
  }
  function append(anchor, dom) {
    if (anchor === null) {
      return;
    }
    anchor.before(
      /** @type {Node} */
      dom
    );
  }
  function set_text(text2, value) {
    var str = value == null ? "" : typeof value === "object" ? value + "" : value;
    if (str !== (text2.__t ?? (text2.__t = text2.nodeValue))) {
      text2.__t = str;
      text2.nodeValue = str == null ? "" : str + "";
    }
  }
  function mount(component2, options) {
    return _mount(component2, options);
  }
  const document_listeners = /* @__PURE__ */ new Map();
  function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
    init_operations();
    var registered_events = /* @__PURE__ */ new Set();
    var event_handle = (events2) => {
      for (var i2 = 0; i2 < events2.length; i2++) {
        var event_name = events2[i2];
        if (registered_events.has(event_name)) continue;
        registered_events.add(event_name);
        var passive = is_passive_event(event_name);
        target.addEventListener(event_name, handle_event_propagation, { passive });
        var n = document_listeners.get(event_name);
        if (n === void 0) {
          document.addEventListener(event_name, handle_event_propagation, { passive });
          document_listeners.set(event_name, 1);
        } else {
          document_listeners.set(event_name, n + 1);
        }
      }
    };
    event_handle(array_from(all_registered_events));
    root_event_handles.add(event_handle);
    var component2 = void 0;
    var unmount2 = component_root(() => {
      var anchor_node = anchor ?? target.appendChild(create_text());
      branch(() => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        component2 = Component(anchor_node, props) || {};
        if (context) {
          pop();
        }
      });
      return () => {
        var _a2;
        for (var event_name of registered_events) {
          target.removeEventListener(event_name, handle_event_propagation);
          var n = (
            /** @type {number} */
            document_listeners.get(event_name)
          );
          if (--n === 0) {
            document.removeEventListener(event_name, handle_event_propagation);
            document_listeners.delete(event_name);
          } else {
            document_listeners.set(event_name, n);
          }
        }
        root_event_handles.delete(event_handle);
        if (anchor_node !== anchor) {
          (_a2 = anchor_node.parentNode) == null ? void 0 : _a2.removeChild(anchor_node);
        }
      };
    });
    mounted_components.set(component2, unmount2);
    return component2;
  }
  let mounted_components = /* @__PURE__ */ new WeakMap();
  function unmount(component2, options) {
    const fn = mounted_components.get(component2);
    if (fn) {
      mounted_components.delete(component2);
      return fn(options);
    }
    {
      lifecycle_double_unmount();
    }
    return Promise.resolve();
  }
  function check_target(target) {
    if (target) {
      component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
    }
  }
  function legacy_api() {
    const component2 = component_context == null ? void 0 : component_context.function;
    function error(method) {
      var _a2;
      const parent = ((_a2 = get_component()) == null ? void 0 : _a2[FILENAME]) ?? "Something";
      component_api_changed(parent, method, component2[FILENAME]);
    }
    return {
      $destroy: () => error("$destroy()"),
      $on: () => error("$on(...)"),
      $set: () => error("$set(...)")
    };
  }
  function if_block(node, fn, elseif = false) {
    var anchor = node;
    var consequent_effect = null;
    var alternate_effect = null;
    var condition = UNINITIALIZED;
    var flags = elseif ? EFFECT_TRANSPARENT : 0;
    var has_branch = false;
    const set_branch = (fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    };
    const update_branch = (new_condition, fn2) => {
      if (condition === (condition = new_condition)) return;
      if (condition) {
        if (consequent_effect) {
          resume_effect(consequent_effect);
        } else if (fn2) {
          consequent_effect = branch(() => fn2(anchor));
        }
        if (alternate_effect) {
          pause_effect(alternate_effect, () => {
            alternate_effect = null;
          });
        }
      } else {
        if (alternate_effect) {
          resume_effect(alternate_effect);
        } else if (fn2) {
          alternate_effect = branch(() => fn2(anchor));
        }
        if (consequent_effect) {
          pause_effect(consequent_effect, () => {
            consequent_effect = null;
          });
        }
      }
    };
    block(() => {
      has_branch = false;
      fn(set_branch);
      if (!has_branch) {
        update_branch(null, null);
      }
    }, flags);
  }
  function key_block(node, get_key, render_fn) {
    var anchor = node;
    var key = UNINITIALIZED;
    var effect2;
    var changed = is_runes() ? not_equal : safe_not_equal;
    block(() => {
      if (changed(key, key = get_key())) {
        if (effect2) {
          pause_effect(effect2);
        }
        effect2 = branch(() => render_fn(anchor));
      }
    });
  }
  function index(_2, i2) {
    return i2;
  }
  function pause_effects(state2, items, controlled_anchor, items_map) {
    var transitions = [];
    var length = items.length;
    for (var i2 = 0; i2 < length; i2++) {
      pause_children(items[i2].e, transitions, true);
    }
    var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
    if (is_controlled) {
      var parent_node = (
        /** @type {Element} */
        /** @type {Element} */
        controlled_anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(
        /** @type {Element} */
        controlled_anchor
      );
      items_map.clear();
      link(state2, items[0].prev, items[length - 1].next);
    }
    run_out_transitions(transitions, () => {
      for (var i3 = 0; i3 < length; i3++) {
        var item = items[i3];
        if (!is_controlled) {
          items_map.delete(item.k);
          link(state2, item.prev, item.next);
        }
        destroy_effect(item.e, !is_controlled);
      }
    });
  }
  function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
    var anchor = node;
    var state2 = { flags, items: /* @__PURE__ */ new Map(), first: null };
    var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
    if (is_controlled) {
      var parent_node = (
        /** @type {Element} */
        node
      );
      anchor = parent_node.appendChild(create_text());
    }
    var fallback = null;
    var was_empty = false;
    block(() => {
      var collection = get_collection();
      var array = is_array(collection) ? collection : collection == null ? [] : array_from(collection);
      var length = array.length;
      if (was_empty && length === 0) {
        return;
      }
      was_empty = length === 0;
      {
        var effect2 = (
          /** @type {Effect} */
          active_reaction
        );
        reconcile(
          array,
          state2,
          anchor,
          render_fn,
          flags,
          (effect2.f & INERT) !== 0,
          get_key,
          get_collection
        );
      }
      if (fallback_fn !== null) {
        if (length === 0) {
          if (fallback) {
            resume_effect(fallback);
          } else {
            fallback = branch(() => fallback_fn(anchor));
          }
        } else if (fallback !== null) {
          pause_effect(fallback, () => {
            fallback = null;
          });
        }
      }
      get_collection();
    });
  }
  function reconcile(array, state2, anchor, render_fn, flags, is_inert, get_key, get_collection) {
    var _a2, _b2, _c, _d;
    var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
    var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
    var length = array.length;
    var items = state2.items;
    var first = state2.first;
    var current = first;
    var seen;
    var prev = null;
    var to_animate;
    var matched = [];
    var stashed = [];
    var value;
    var key;
    var item;
    var i2;
    if (is_animated) {
      for (i2 = 0; i2 < length; i2 += 1) {
        value = array[i2];
        key = get_key(value, i2);
        item = items.get(key);
        if (item !== void 0) {
          (_a2 = item.a) == null ? void 0 : _a2.measure();
          (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(item);
        }
      }
    }
    for (i2 = 0; i2 < length; i2 += 1) {
      value = array[i2];
      key = get_key(value, i2);
      item = items.get(key);
      if (item === void 0) {
        var child_anchor = current ? (
          /** @type {TemplateNode} */
          current.e.nodes_start
        ) : anchor;
        prev = create_item(
          child_anchor,
          state2,
          prev,
          prev === null ? state2.first : prev.next,
          value,
          key,
          i2,
          render_fn,
          flags,
          get_collection
        );
        items.set(key, prev);
        matched = [];
        stashed = [];
        current = prev.next;
        continue;
      }
      if (should_update) {
        update_item(item, value, i2, flags);
      }
      if ((item.e.f & INERT) !== 0) {
        resume_effect(item.e);
        if (is_animated) {
          (_b2 = item.a) == null ? void 0 : _b2.unfix();
          (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(item);
        }
      }
      if (item !== current) {
        if (seen !== void 0 && seen.has(item)) {
          if (matched.length < stashed.length) {
            var start = stashed[0];
            var j2;
            prev = start.prev;
            var a2 = matched[0];
            var b2 = matched[matched.length - 1];
            for (j2 = 0; j2 < matched.length; j2 += 1) {
              move(matched[j2], start, anchor);
            }
            for (j2 = 0; j2 < stashed.length; j2 += 1) {
              seen.delete(stashed[j2]);
            }
            link(state2, a2.prev, b2.next);
            link(state2, prev, a2);
            link(state2, b2, start);
            current = start;
            prev = b2;
            i2 -= 1;
            matched = [];
            stashed = [];
          } else {
            seen.delete(item);
            move(item, current, anchor);
            link(state2, item.prev, item.next);
            link(state2, item, prev === null ? state2.first : prev.next);
            link(state2, prev, item);
            prev = item;
          }
          continue;
        }
        matched = [];
        stashed = [];
        while (current !== null && current.k !== key) {
          if (is_inert || (current.e.f & INERT) === 0) {
            (seen ?? (seen = /* @__PURE__ */ new Set())).add(current);
          }
          stashed.push(current);
          current = current.next;
        }
        if (current === null) {
          continue;
        }
        item = current;
      }
      matched.push(item);
      prev = item;
      current = item.next;
    }
    if (current !== null || seen !== void 0) {
      var to_destroy = seen === void 0 ? [] : array_from(seen);
      while (current !== null) {
        if (is_inert || (current.e.f & INERT) === 0) {
          to_destroy.push(current);
        }
        current = current.next;
      }
      var destroy_length = to_destroy.length;
      if (destroy_length > 0) {
        var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
        if (is_animated) {
          for (i2 = 0; i2 < destroy_length; i2 += 1) {
            (_c = to_destroy[i2].a) == null ? void 0 : _c.measure();
          }
          for (i2 = 0; i2 < destroy_length; i2 += 1) {
            (_d = to_destroy[i2].a) == null ? void 0 : _d.fix();
          }
        }
        pause_effects(state2, to_destroy, controlled_anchor, items);
      }
    }
    if (is_animated) {
      queue_micro_task(() => {
        var _a3;
        if (to_animate === void 0) return;
        for (item of to_animate) {
          (_a3 = item.a) == null ? void 0 : _a3.apply();
        }
      });
    }
    active_effect.first = state2.first && state2.first.e;
    active_effect.last = prev && prev.e;
  }
  function update_item(item, value, index2, type) {
    if ((type & EACH_ITEM_REACTIVE) !== 0) {
      internal_set(item.v, value);
    }
    if ((type & EACH_INDEX_REACTIVE) !== 0) {
      internal_set(
        /** @type {Value<number>} */
        item.i,
        index2
      );
    } else {
      item.i = index2;
    }
  }
  function create_item(anchor, state2, prev, next2, value, key, index2, render_fn, flags, get_collection) {
    var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
    var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;
    var v2 = reactive ? mutable ? /* @__PURE__ */ mutable_source(value) : source(value) : value;
    var i2 = (flags & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
    if (reactive) {
      v2.debug = () => {
        var collection_index = typeof i2 === "number" ? index2 : i2.v;
        get_collection()[collection_index];
      };
    }
    var item = {
      i: i2,
      v: v2,
      k: key,
      a: null,
      // @ts-expect-error
      e: null,
      prev,
      next: next2
    };
    try {
      item.e = branch(() => render_fn(anchor, v2, i2), hydrating);
      item.e.prev = prev && prev.e;
      item.e.next = next2 && next2.e;
      if (prev === null) {
        state2.first = item;
      } else {
        prev.next = item;
        prev.e.next = item.e;
      }
      if (next2 !== null) {
        next2.prev = item;
        next2.e.prev = item.e;
      }
      return item;
    } finally {
    }
  }
  function move(item, next2, anchor) {
    var end = item.next ? (
      /** @type {TemplateNode} */
      item.next.e.nodes_start
    ) : anchor;
    var dest = next2 ? (
      /** @type {TemplateNode} */
      next2.e.nodes_start
    ) : anchor;
    var node = (
      /** @type {TemplateNode} */
      item.e.nodes_start
    );
    while (node !== end) {
      var next_node = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ get_next_sibling(node)
      );
      dest.before(node);
      node = next_node;
    }
  }
  function link(state2, prev, next2) {
    if (prev === null) {
      state2.first = next2;
    } else {
      prev.next = next2;
      prev.e.next = next2 && next2.e;
    }
    if (next2 !== null) {
      next2.prev = prev;
      next2.e.prev = prev && prev.e;
    }
  }
  function slot(anchor, $$props, name, slot_props, fallback_fn) {
    var _a2;
    var slot_fn = (_a2 = $$props.$$slots) == null ? void 0 : _a2[name];
    var is_interop = false;
    if (slot_fn === true) {
      slot_fn = $$props["children"];
      is_interop = true;
    }
    if (slot_fn === void 0) ;
    else {
      slot_fn(anchor, is_interop ? () => slot_props : slot_props);
    }
  }
  function snippet(node, get_snippet, ...args) {
    var anchor = node;
    var snippet2 = noop$1;
    var snippet_effect;
    block(() => {
      if (snippet2 === (snippet2 = get_snippet())) return;
      if (snippet_effect) {
        destroy_effect(snippet_effect);
        snippet_effect = null;
      }
      if (snippet2 == null) {
        invalid_snippet();
      }
      snippet_effect = branch(() => (
        /** @type {SnippetFn} */
        snippet2(anchor, ...args)
      ));
    }, EFFECT_TRANSPARENT);
  }
  function wrap_snippet(component2, fn) {
    return (node, ...args) => {
      var previous_component_function = dev_current_component_function;
      set_dev_current_component_function(component2);
      try {
        return fn(node, ...args);
      } finally {
        set_dev_current_component_function(previous_component_function);
      }
    };
  }
  function component(node, get_component2, render_fn) {
    var anchor = node;
    var component2;
    var effect2;
    block(() => {
      if (component2 === (component2 = get_component2())) return;
      if (effect2) {
        pause_effect(effect2);
        effect2 = null;
      }
      if (component2) {
        effect2 = branch(() => render_fn(anchor, component2));
      }
    }, EFFECT_TRANSPARENT);
  }
  function element(node, get_tag, is_svg, render_fn, get_namespace, location2) {
    var filename = location2 && (component_context == null ? void 0 : component_context.function[FILENAME]);
    var tag;
    var current_tag;
    var element2 = null;
    var anchor = (
      /** @type {TemplateNode} */
      node
    );
    var effect2;
    block(() => {
      const next_tag = get_tag() || null;
      var ns = NAMESPACE_SVG;
      if (next_tag === tag) return;
      if (effect2) {
        if (next_tag === null) {
          pause_effect(effect2, () => {
            effect2 = null;
            current_tag = null;
          });
        } else if (next_tag === current_tag) {
          resume_effect(effect2);
        } else {
          destroy_effect(effect2);
        }
      }
      if (next_tag && next_tag !== current_tag) {
        effect2 = branch(() => {
          element2 = document.createElementNS(ns, next_tag);
          if (location2) {
            element2.__svelte_meta = {
              loc: {
                file: filename,
                line: location2[0],
                column: location2[1]
              }
            };
          }
          assign_nodes(element2, element2);
          if (render_fn) {
            var child_anchor = (
              /** @type {TemplateNode} */
              element2.appendChild(create_text())
            );
            render_fn(element2, child_anchor);
          }
          active_effect.nodes_end = element2;
          anchor.before(element2);
        });
      }
      tag = next_tag;
      if (tag) current_tag = tag;
    }, EFFECT_TRANSPARENT);
  }
  function r$1(e) {
    var t, f2, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o2 = e.length;
      for (t = 0; t < o2; t++) e[t] && (f2 = r$1(e[t])) && (n && (n += " "), n += f2);
    } else for (f2 in e) e[f2] && (n && (n += " "), n += f2);
    return n;
  }
  function clsx$1() {
    for (var e, t, f2 = 0, n = "", o2 = arguments.length; f2 < o2; f2++) (e = arguments[f2]) && (t = r$1(e)) && (n && (n += " "), n += t);
    return n;
  }
  function clsx(value) {
    if (typeof value === "object") {
      return clsx$1(value);
    } else {
      return value ?? "";
    }
  }
  function set_selected(element2, selected) {
    if (selected) {
      if (!element2.hasAttribute("selected")) {
        element2.setAttribute("selected", "");
      }
    } else {
      element2.removeAttribute("selected");
    }
  }
  function set_attribute(element2, attribute, value, skip_warning) {
    var attributes = element2.__attributes ?? (element2.__attributes = {});
    if (attributes[attribute] === (attributes[attribute] = value)) return;
    if (attribute === "style" && "__styles" in element2) {
      element2.__styles = {};
    }
    if (attribute === "loading") {
      element2[LOADING_ATTR_SYMBOL] = value;
    }
    if (value == null) {
      element2.removeAttribute(attribute);
    } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
      element2[attribute] = value;
    } else {
      element2.setAttribute(attribute, value);
    }
  }
  function set_attributes(element2, prev, next2, css_hash, preserve_attribute_case = false, is_custom_element = false, skip_warning = false) {
    var current = prev || {};
    var is_option_element = element2.tagName === "OPTION";
    for (var key in prev) {
      if (!(key in next2)) {
        next2[key] = null;
      }
    }
    if (next2.class) {
      next2.class = clsx(next2.class);
    }
    var setters = get_setters(element2);
    var attributes = (
      /** @type {Record<string, unknown>} **/
      element2.__attributes ?? (element2.__attributes = {})
    );
    for (const key2 in next2) {
      let value = next2[key2];
      if (is_option_element && key2 === "value" && value == null) {
        element2.value = element2.__value = "";
        current[key2] = value;
        continue;
      }
      var prev_value = current[key2];
      if (value === prev_value) continue;
      current[key2] = value;
      var prefix = key2[0] + key2[1];
      if (prefix === "$$") continue;
      if (prefix === "on") {
        const opts = {};
        const event_handle_key = "$$" + key2;
        let event_name = key2.slice(2);
        var delegated = is_delegated(event_name);
        if (is_capture_event(event_name)) {
          event_name = event_name.slice(0, -7);
          opts.capture = true;
        }
        if (!delegated && prev_value) {
          if (value != null) continue;
          element2.removeEventListener(event_name, current[event_handle_key], opts);
          current[event_handle_key] = null;
        }
        if (value != null) {
          if (!delegated) {
            let handle = function(evt) {
              current[key2].call(this, evt);
            };
            current[event_handle_key] = create_event(event_name, element2, handle, opts);
          } else {
            element2[`__${event_name}`] = value;
            delegate([event_name]);
          }
        } else if (delegated) {
          element2[`__${event_name}`] = void 0;
        }
      } else if (key2 === "style" && value != null) {
        element2.style.cssText = value + "";
      } else if (key2 === "autofocus") {
        autofocus(
          /** @type {HTMLElement} */
          element2,
          Boolean(value)
        );
      } else if (key2 === "__value" || key2 === "value" && value != null) {
        element2.value = element2[key2] = element2.__value = value;
      } else if (key2 === "selected" && is_option_element) {
        set_selected(
          /** @type {HTMLOptionElement} */
          element2,
          value
        );
      } else {
        var name = key2;
        if (!preserve_attribute_case) {
          name = normalize_attribute(name);
        }
        var is_default = name === "defaultValue" || name === "defaultChecked";
        if (value == null && !is_custom_element && !is_default) {
          attributes[key2] = null;
          if (name === "value" || name === "checked") {
            let input = (
              /** @type {HTMLInputElement} */
              element2
            );
            if (name === "value") {
              let prev2 = input.defaultValue;
              input.removeAttribute(name);
              input.defaultValue = prev2;
            } else {
              let prev2 = input.defaultChecked;
              input.removeAttribute(name);
              input.defaultChecked = prev2;
            }
          } else {
            element2.removeAttribute(key2);
          }
        } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
          element2[name] = value;
        } else if (typeof value !== "function") {
          {
            set_attribute(element2, name, value);
          }
        }
      }
      if (key2 === "style" && "__styles" in element2) {
        element2.__styles = {};
      }
    }
    return current;
  }
  var setters_cache = /* @__PURE__ */ new Map();
  function get_setters(element2) {
    var setters = setters_cache.get(element2.nodeName);
    if (setters) return setters;
    setters_cache.set(element2.nodeName, setters = []);
    var descriptors;
    var proto = element2;
    var element_proto = Element.prototype;
    while (element_proto !== proto) {
      descriptors = get_descriptors(proto);
      for (var key in descriptors) {
        if (descriptors[key].set) {
          setters.push(key);
        }
      }
      proto = get_prototype_of(proto);
    }
    return setters;
  }
  function set_class(dom, value, hash) {
    var prev_class_name = dom.__className;
    var next_class_name = to_class(value);
    if (prev_class_name !== next_class_name || hydrating) {
      if (value == null && !hash) {
        dom.removeAttribute("class");
      } else {
        dom.className = next_class_name;
      }
      dom.__className = next_class_name;
    }
  }
  function to_class(value, hash) {
    return (value == null ? "" : value) + "";
  }
  function bind_value(input, get2, set2 = get2) {
    var runes = is_runes();
    listen_to_event_and_reset_event(input, "input", (is_reset) => {
      if (input.type === "checkbox") {
        bind_invalid_checkbox_value();
      }
      var value = is_reset ? input.defaultValue : input.value;
      value = is_numberlike_input(input) ? to_number(value) : value;
      set2(value);
      if (runes && value !== (value = get2())) {
        var start = input.selectionStart;
        var end = input.selectionEnd;
        input.value = value ?? "";
        if (end !== null) {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, input.value.length);
        }
      }
    });
    if (
      // If we are hydrating and the value has since changed,
      // then use the updated value from the input instead.
      // If defaultValue is set, then value == defaultValue
      // TODO Svelte 6: remove input.value check and set to empty string?
      untrack(get2) == null && input.value
    ) {
      set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    }
    render_effect(() => {
      if (input.type === "checkbox") {
        bind_invalid_checkbox_value();
      }
      var value = get2();
      if (is_numberlike_input(input) && value === to_number(input.value)) {
        return;
      }
      if (input.type === "date" && !value && !input.value) {
        return;
      }
      if (value !== input.value) {
        input.value = value ?? "";
      }
    });
  }
  function is_numberlike_input(input) {
    var type = input.type;
    return type === "number" || type === "range";
  }
  function to_number(value) {
    return value === "" ? null : +value;
  }
  function is_bound_this(bound_value, element_or_component) {
    return bound_value === element_or_component || (bound_value == null ? void 0 : bound_value[STATE_SYMBOL]) === element_or_component;
  }
  function bind_this(element_or_component = {}, update2, get_value, get_parts) {
    effect(() => {
      var old_parts;
      var parts;
      render_effect(() => {
        old_parts = parts;
        parts = [];
        untrack(() => {
          if (element_or_component !== get_value(...parts)) {
            update2(element_or_component, ...parts);
            if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
              update2(null, ...old_parts);
            }
          }
        });
      });
      return () => {
        queue_micro_task(() => {
          if (parts && is_bound_this(get_value(...parts), element_or_component)) {
            update2(null, ...parts);
          }
        });
      };
    });
    return element_or_component;
  }
  function init(immutable = false) {
    const context = (
      /** @type {ComponentContextLegacy} */
      component_context
    );
    const callbacks = context.l.u;
    if (!callbacks) return;
    let props = () => deep_read_state(context.s);
    if (immutable) {
      let version = 0;
      let prev = (
        /** @type {Record<string, any>} */
        {}
      );
      const d2 = /* @__PURE__ */ derived(() => {
        let changed = false;
        const props2 = context.s;
        for (const key in props2) {
          if (props2[key] !== prev[key]) {
            prev[key] = props2[key];
            changed = true;
          }
        }
        if (changed) version++;
        return version;
      });
      props = () => get$2(d2);
    }
    if (callbacks.b.length) {
      user_pre_effect(() => {
        observe_all(context, props);
        run_all(callbacks.b);
      });
    }
    user_effect(() => {
      const fns = untrack(() => callbacks.m.map(run));
      return () => {
        for (const fn of fns) {
          if (typeof fn === "function") {
            fn();
          }
        }
      };
    });
    if (callbacks.a.length) {
      user_effect(() => {
        observe_all(context, props);
        run_all(callbacks.a);
      });
    }
  }
  function observe_all(context, props) {
    if (context.l.s) {
      for (const signal of context.l.s) get$2(signal);
    }
    props();
  }
  function onMount(fn) {
    if (component_context === null) {
      lifecycle_outside_component("onMount");
    }
    if (legacy_mode_flag && component_context.l !== null) {
      init_update_callbacks(component_context).m.push(fn);
    } else {
      user_effect(() => {
        const cleanup = untrack(fn);
        if (typeof cleanup === "function") return (
          /** @type {() => void} */
          cleanup
        );
      });
    }
  }
  function init_update_callbacks(context) {
    var l2 = (
      /** @type {ComponentContextLegacy} */
      context.l
    );
    return l2.u ?? (l2.u = { a: [], b: [], m: [] });
  }
  let is_store_binding = false;
  function capture_store_binding(fn) {
    var previous_is_store_binding = is_store_binding;
    try {
      is_store_binding = false;
      return [fn(), is_store_binding];
    } finally {
      is_store_binding = previous_is_store_binding;
    }
  }
  const rest_props_handler = {
    get(target, key) {
      if (target.exclude.includes(key)) return;
      return target.props[key];
    },
    set(target, key) {
      {
        props_rest_readonly(`${target.name}.${String(key)}`);
      }
      return false;
    },
    getOwnPropertyDescriptor(target, key) {
      if (target.exclude.includes(key)) return;
      if (key in target.props) {
        return {
          enumerable: true,
          configurable: true,
          value: target.props[key]
        };
      }
    },
    has(target, key) {
      if (target.exclude.includes(key)) return false;
      return key in target.props;
    },
    ownKeys(target) {
      return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
    }
  };
  // @__NO_SIDE_EFFECTS__
  function rest_props(props, exclude, name) {
    return new Proxy(
      { props, exclude, name, other: {}, to_proxy: [] },
      rest_props_handler
    );
  }
  const legacy_rest_props_handler = {
    get(target, key) {
      if (target.exclude.includes(key)) return;
      get$2(target.version);
      return key in target.special ? target.special[key]() : target.props[key];
    },
    set(target, key, value) {
      if (!(key in target.special)) {
        target.special[key] = prop(
          {
            get [key]() {
              return target.props[key];
            }
          },
          /** @type {string} */
          key,
          PROPS_IS_UPDATED
        );
      }
      target.special[key](value);
      update(target.version);
      return true;
    },
    getOwnPropertyDescriptor(target, key) {
      if (target.exclude.includes(key)) return;
      if (key in target.props) {
        return {
          enumerable: true,
          configurable: true,
          value: target.props[key]
        };
      }
    },
    deleteProperty(target, key) {
      if (target.exclude.includes(key)) return true;
      target.exclude.push(key);
      update(target.version);
      return true;
    },
    has(target, key) {
      if (target.exclude.includes(key)) return false;
      return key in target.props;
    },
    ownKeys(target) {
      return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
    }
  };
  function legacy_rest_props(props, exclude) {
    return new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);
  }
  const spread_props_handler = {
    get(target, key) {
      let i2 = target.props.length;
      while (i2--) {
        let p2 = target.props[i2];
        if (is_function(p2)) p2 = p2();
        if (typeof p2 === "object" && p2 !== null && key in p2) return p2[key];
      }
    },
    set(target, key, value) {
      let i2 = target.props.length;
      while (i2--) {
        let p2 = target.props[i2];
        if (is_function(p2)) p2 = p2();
        const desc = get_descriptor(p2, key);
        if (desc && desc.set) {
          desc.set(value);
          return true;
        }
      }
      return false;
    },
    getOwnPropertyDescriptor(target, key) {
      let i2 = target.props.length;
      while (i2--) {
        let p2 = target.props[i2];
        if (is_function(p2)) p2 = p2();
        if (typeof p2 === "object" && p2 !== null && key in p2) {
          const descriptor = get_descriptor(p2, key);
          if (descriptor && !descriptor.configurable) {
            descriptor.configurable = true;
          }
          return descriptor;
        }
      }
    },
    has(target, key) {
      if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;
      for (let p2 of target.props) {
        if (is_function(p2)) p2 = p2();
        if (p2 != null && key in p2) return true;
      }
      return false;
    },
    ownKeys(target) {
      const keys = [];
      for (let p2 of target.props) {
        if (is_function(p2)) p2 = p2();
        for (const key in p2) {
          if (!keys.includes(key)) keys.push(key);
        }
      }
      return keys;
    }
  };
  function spread_props(...props) {
    return new Proxy({ props }, spread_props_handler);
  }
  function with_parent_branch(fn) {
    var effect2 = active_effect;
    var previous_effect = active_effect;
    while (effect2 !== null && (effect2.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      effect2 = effect2.parent;
    }
    try {
      set_active_effect(effect2);
      return fn();
    } finally {
      set_active_effect(previous_effect);
    }
  }
  function prop(props, key, flags, fallback) {
    var _a2;
    var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
    var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
    var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
    var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
    var is_store_sub = false;
    var prop_value;
    if (bindable) {
      [prop_value, is_store_sub] = capture_store_binding(() => (
        /** @type {V} */
        props[key]
      ));
    } else {
      prop_value = /** @type {V} */
      props[key];
    }
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    var setter = ((_a2 = get_descriptor(props, key)) == null ? void 0 : _a2.set) ?? (is_entry_props && bindable && key in props ? (v2) => props[key] = v2 : void 0);
    var fallback_value = (
      /** @type {V} */
      fallback
    );
    var fallback_dirty = true;
    var fallback_used = false;
    var get_fallback = () => {
      fallback_used = true;
      if (fallback_dirty) {
        fallback_dirty = false;
        if (lazy) {
          fallback_value = untrack(
            /** @type {() => V} */
            fallback
          );
        } else {
          fallback_value = /** @type {V} */
          fallback;
        }
      }
      return fallback_value;
    };
    if (prop_value === void 0 && fallback !== void 0) {
      if (setter && runes) {
        props_invalid_value(key);
      }
      prop_value = get_fallback();
      if (setter) setter(prop_value);
    }
    var getter;
    if (runes) {
      getter = () => {
        var value = (
          /** @type {V} */
          props[key]
        );
        if (value === void 0) return get_fallback();
        fallback_dirty = true;
        fallback_used = false;
        return value;
      };
    } else {
      var derived_getter = with_parent_branch(
        () => (immutable ? derived : derived_safe_equal)(() => (
          /** @type {V} */
          props[key]
        ))
      );
      derived_getter.f |= LEGACY_DERIVED_PROP;
      getter = () => {
        var value = get$2(derived_getter);
        if (value !== void 0) fallback_value = /** @type {V} */
        void 0;
        return value === void 0 ? fallback_value : value;
      };
    }
    if ((flags & PROPS_IS_UPDATED) === 0) {
      return getter;
    }
    if (setter) {
      var legacy_parent = props.$$legacy;
      return function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        } else {
          return getter();
        }
      };
    }
    var from_child = false;
    var was_from_child = false;
    var inner_current_value = /* @__PURE__ */ mutable_source(prop_value);
    var current_value = with_parent_branch(
      () => /* @__PURE__ */ derived(() => {
        var parent_value = getter();
        var child_value = get$2(inner_current_value);
        if (from_child) {
          from_child = false;
          was_from_child = true;
          return child_value;
        }
        was_from_child = false;
        return inner_current_value.v = parent_value;
      })
    );
    if (!immutable) current_value.equals = safe_equals;
    return function(value, mutation) {
      if (captured_signals !== null) {
        from_child = was_from_child;
        getter();
        get$2(inner_current_value);
      }
      if (arguments.length > 0) {
        const new_value = mutation ? get$2(current_value) : runes && bindable ? proxy(value) : value;
        if (!current_value.equals(new_value)) {
          from_child = true;
          set(inner_current_value, new_value);
          if (fallback_used && fallback_value !== void 0) {
            fallback_value = new_value;
          }
          untrack(() => get$2(current_value));
        }
        return value;
      }
      return get$2(current_value);
    };
  }
  function validate_prop_bindings($$props, bindable, exports, component2) {
    var _a2;
    for (const key in $$props) {
      var setter = (_a2 = get_descriptor($$props, key)) == null ? void 0 : _a2.set;
      var name = component2.name;
      if (setter) {
        if (exports.includes(key)) {
          bind_invalid_export(component2[FILENAME], key, name);
        }
        if (!bindable.includes(key)) {
          bind_not_bindable(key, component2[FILENAME], name);
        }
      }
    }
  }
  function validate_dynamic_element_tag(tag_fn) {
    const tag = tag_fn();
    const is_string = typeof tag === "string";
    if (tag && !is_string) {
      svelte_element_invalid_this_value();
    }
  }
  function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
    return amount - numerator * Math.floor(amount / numerator);
  }
  const $3b62074eb05584b2$var$EPOCH = 1721426;
  function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
    year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
    let y1 = year - 1;
    let monthOffset = -2;
    if (month <= 2) monthOffset = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
    return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
  }
  function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
    return era === "BC" ? 1 - year : year;
  }
  function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
    let era = "AD";
    if (year <= 0) {
      era = "BC";
      year = 1 - year;
    }
    return [
      era,
      year
    ];
  }
  const $3b62074eb05584b2$var$daysInMonth = {
    standard: [
      31,
      28,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ],
    leapyear: [
      31,
      29,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ]
  };
  class $3b62074eb05584b2$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
      let jd0 = jd;
      let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
      let quadricent = Math.floor(depoch / 146097);
      let dqc = $2b4dce13dd5a17fa$export$842a2cf37af977e1(depoch, 146097);
      let cent = Math.floor(dqc / 36524);
      let dcent = $2b4dce13dd5a17fa$export$842a2cf37af977e1(dqc, 36524);
      let quad = Math.floor(dcent / 1461);
      let dquad = $2b4dce13dd5a17fa$export$842a2cf37af977e1(dcent, 1461);
      let yindex = Math.floor(dquad / 365);
      let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
      let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
      let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
      let leapAdj = 2;
      if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
      else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
      let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
      let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
      return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(era, year, month, day);
    }
    toJulianDay(date) {
      return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
      return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMonthsInYear(date) {
      return 12;
    }
    getDaysInYear(date) {
      return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getYearsInEra(date) {
      return 9999;
    }
    getEras() {
      return [
        "BC",
        "AD"
      ];
    }
    isInverseEra(date) {
      return date.era === "BC";
    }
    balanceDate(date) {
      if (date.year <= 0) {
        date.era = date.era === "BC" ? "AD" : "BC";
        date.year = 1 - date.year;
      }
    }
    constructor() {
      this.identifier = "gregory";
    }
  }
  const $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BY: 1,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    HR: 1,
    HU: 1,
    IE: 1,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JO: 6,
    KG: 1,
    KW: 6,
    KZ: 1,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MK: 1,
    MN: 1,
    MQ: 1,
    MV: 5,
    MY: 1,
    NL: 1,
    NO: 1,
    NZ: 1,
    OM: 6,
    PL: 1,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SD: 6,
    SE: 1,
    SI: 1,
    SK: 1,
    SM: 1,
    SY: 6,
    TJ: 1,
    TM: 1,
    TR: 1,
    UA: 1,
    UY: 1,
    UZ: 1,
    VA: 1,
    VN: 1,
    XK: 1
  };
  function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a2, b2) {
    b2 = $11d87f3f76e88657$export$b4a036af3fc0b032(b2, a2.calendar);
    return a2.era === b2.era && a2.year === b2.year && a2.month === b2.month && a2.day === b2.day;
  }
  function $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a2, b2) {
    b2 = $11d87f3f76e88657$export$b4a036af3fc0b032(b2, a2.calendar);
    a2 = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a2);
    b2 = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b2);
    return a2.era === b2.era && a2.year === b2.year && a2.month === b2.month;
  }
  function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  }
  function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    let dayOfWeek = Math.ceil(julian + 1 - $14e0f24ef4ac5c92$var$getWeekStart(locale)) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    return dayOfWeek;
  }
  function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
    return $11d87f3f76e88657$export$1b96692a1ba042ac(Date.now(), timeZone);
  }
  function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
    return $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
  }
  function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a2, b2) {
    return a2.calendar.toJulianDay(a2) - b2.calendar.toJulianDay(b2);
  }
  function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a2, b2) {
    return $14e0f24ef4ac5c92$var$timeToMs(a2) - $14e0f24ef4ac5c92$var$timeToMs(b2);
  }
  function $14e0f24ef4ac5c92$var$timeToMs(a2) {
    return a2.hour * 36e5 + a2.minute * 6e4 + a2.second * 1e3 + a2.millisecond;
  }
  let $14e0f24ef4ac5c92$var$localTimeZone = null;
  function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
    if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    return $14e0f24ef4ac5c92$var$localTimeZone;
  }
  function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
    return date.subtract({
      days: date.day - 1
    });
  }
  function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
    return date.add({
      days: date.calendar.getDaysInMonth(date) - date.day
    });
  }
  const $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
  function $14e0f24ef4ac5c92$var$getRegion(locale) {
    if (Intl.Locale) {
      let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
      if (!region) {
        region = new Intl.Locale(locale).maximize().region;
        if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
      }
      return region;
    }
    let part = locale.split("-")[1];
    return part === "u" ? void 0 : part;
  }
  function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
    let region = $14e0f24ef4ac5c92$var$getRegion(locale);
    return region ? $2fe286d2fb449abb$export$7a5acbd77d414bd9[region] || 0 : 0;
  }
  function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
    date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
    let year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(date.era, date.year);
    return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
  }
  function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
    let date = /* @__PURE__ */ new Date();
    date.setUTCHours(hour, minute, second, millisecond);
    date.setUTCFullYear(year, month - 1, day);
    return date.getTime();
  }
  function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
    if (timeZone === "UTC") return 0;
    if (ms > 0 && timeZone === $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) return new Date(ms).getTimezoneOffset() * -6e4;
    let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
    let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
    return utc - Math.floor(ms / 1e3) * 1e3;
  }
  const $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
  function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
    let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat("en-US", {
        timeZone,
        hour12: false,
        era: "short",
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      });
      $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
    }
    let parts = formatter.formatToParts(new Date(ms));
    let namedParts = {};
    for (let part of parts) if (part.type !== "literal") namedParts[part.type] = part.value;
    return {
      // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
      year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
      month: +namedParts.month,
      day: +namedParts.day,
      hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
      minute: +namedParts.minute,
      second: +namedParts.second
    };
  }
  const $11d87f3f76e88657$var$DAYMILLIS = 864e5;
  function $11d87f3f76e88657$export$136f38efe7caf549(date, timeZone) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date);
    let earlier = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let later = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    return $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later);
  }
  function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
    let found = earlier === later ? [
      earlier
    ] : [
      earlier,
      later
    ];
    return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
  }
  function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
    let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
  }
  function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
    let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
    if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
    if (timeZone === $14e0f24ef4ac5c92$export$aa8b41735afcabd2() && disambiguation === "compatible") {
      dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
      let date2 = /* @__PURE__ */ new Date();
      let year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(dateTime.era, dateTime.year);
      date2.setFullYear(year, dateTime.month - 1, dateTime.day);
      date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
      return date2.getTime();
    }
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
    let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
    let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
    if (valid.length === 1) return valid[0];
    if (valid.length > 1) switch (disambiguation) {
      // 'compatible' means 'earlier' for "fall back" transitions
      case "compatible":
      case "earlier":
        return valid[0];
      case "later":
        return valid[valid.length - 1];
      case "reject":
        throw new RangeError("Multiple possible absolute times found");
    }
    switch (disambiguation) {
      case "earlier":
        return Math.min(ms - offsetBefore, ms - offsetAfter);
      // 'compatible' means 'later' for "spring forward" transitions
      case "compatible":
      case "later":
        return Math.max(ms - offsetBefore, ms - offsetAfter);
      case "reject":
        throw new RangeError("No such absolute time found");
    }
  }
  function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
    return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
  }
  function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
    let offset2 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
    let date = new Date(ms + offset2);
    let year = date.getUTCFullYear();
    let month = date.getUTCMonth() + 1;
    let day = date.getUTCDate();
    let hour = date.getUTCHours();
    let minute = date.getUTCMinutes();
    let second = date.getUTCSeconds();
    let millisecond = date.getUTCMilliseconds();
    return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset2, hour, minute, second, millisecond);
  }
  function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
  }
  function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
    let hour = 0, minute = 0, second = 0, millisecond = 0;
    if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
    else if ("hour" in date && !time) return date;
    if (time) ({ hour, minute, second, millisecond } = time);
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
  }
  function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
    if (date.calendar.identifier === calendar.identifier) return date;
    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
    let copy = date.copy();
    copy.calendar = calendar;
    copy.era = calendarDate.era;
    copy.year = calendarDate.year;
    copy.month = calendarDate.month;
    copy.day = calendarDate.day;
    $735220c2d4774dd3$export$c4e2ecac49351ef2(copy);
    return copy;
  }
  function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
    if (date instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
      if (date.timeZone === timeZone) return date;
      return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
    }
    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
  }
  function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
    return new Date(ms);
  }
  function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
    let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
  }
  const $735220c2d4774dd3$var$ONE_HOUR = 36e5;
  function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
    let mutableDate = date.copy();
    let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
    $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
    mutableDate.month += duration.months || 0;
    $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
    $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
    mutableDate.day += (duration.weeks || 0) * 7;
    mutableDate.day += duration.days || 0;
    mutableDate.day += days;
    $735220c2d4774dd3$var$balanceDay(mutableDate);
    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
    if (mutableDate.year < 1) {
      mutableDate.year = 1;
      mutableDate.month = 1;
      mutableDate.day = 1;
    }
    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
    if (mutableDate.year > maxYear) {
      var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
      let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
      mutableDate.year = maxYear;
      mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
      mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    if (mutableDate.month < 1) {
      mutableDate.month = 1;
      mutableDate.day = 1;
    }
    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
    if (mutableDate.month > maxMonth) {
      mutableDate.month = maxMonth;
      mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
    return mutableDate;
  }
  function $735220c2d4774dd3$var$addYears(date, years) {
    var _date_calendar_isInverseEra, _date_calendar;
    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
    date.year += years;
  }
  function $735220c2d4774dd3$var$balanceYearMonth(date) {
    while (date.month < 1) {
      $735220c2d4774dd3$var$addYears(date, -1);
      date.month += date.calendar.getMonthsInYear(date);
    }
    let monthsInYear = 0;
    while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
      date.month -= monthsInYear;
      $735220c2d4774dd3$var$addYears(date, 1);
    }
  }
  function $735220c2d4774dd3$var$balanceDay(date) {
    while (date.day < 1) {
      date.month--;
      $735220c2d4774dd3$var$balanceYearMonth(date);
      date.day += date.calendar.getDaysInMonth(date);
    }
    while (date.day > date.calendar.getDaysInMonth(date)) {
      date.day -= date.calendar.getDaysInMonth(date);
      date.month++;
      $735220c2d4774dd3$var$balanceYearMonth(date);
    }
  }
  function $735220c2d4774dd3$var$constrainMonthDay(date) {
    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
  }
  function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
    if (date.calendar.constrainDate) date.calendar.constrainDate(date);
    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
    $735220c2d4774dd3$var$constrainMonthDay(date);
  }
  function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
    let inverseDuration = {};
    for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
    return inverseDuration;
  }
  function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
    return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
  }
  function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
    let mutableDate = date.copy();
    if (fields.era != null) mutableDate.era = fields.era;
    if (fields.year != null) mutableDate.year = fields.year;
    if (fields.month != null) mutableDate.month = fields.month;
    if (fields.day != null) mutableDate.day = fields.day;
    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
    return mutableDate;
  }
  function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
    let mutableValue = value.copy();
    if (fields.hour != null) mutableValue.hour = fields.hour;
    if (fields.minute != null) mutableValue.minute = fields.minute;
    if (fields.second != null) mutableValue.second = fields.second;
    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
    $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
    return mutableValue;
  }
  function $735220c2d4774dd3$var$balanceTime(time) {
    time.second += Math.floor(time.millisecond / 1e3);
    time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
    time.minute += Math.floor(time.second / 60);
    time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
    time.hour += Math.floor(time.minute / 60);
    time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
    let days = Math.floor(time.hour / 24);
    time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
    return days;
  }
  function $735220c2d4774dd3$export$7555de1e070510cb(time) {
    time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
    time.second = Math.max(0, Math.min(time.second, 59));
    time.minute = Math.max(0, Math.min(time.minute, 59));
    time.hour = Math.max(0, Math.min(time.hour, 23));
  }
  function $735220c2d4774dd3$var$nonNegativeMod(a2, b2) {
    let result2 = a2 % b2;
    if (result2 < 0) result2 += b2;
    return result2;
  }
  function $735220c2d4774dd3$var$addTimeFields(time, duration) {
    time.hour += duration.hours || 0;
    time.minute += duration.minutes || 0;
    time.second += duration.seconds || 0;
    time.millisecond += duration.milliseconds || 0;
    return $735220c2d4774dd3$var$balanceTime(time);
  }
  function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
    let res = time.copy();
    $735220c2d4774dd3$var$addTimeFields(res, duration);
    return res;
  }
  function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
    return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
  }
  function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
    let mutable = value.copy();
    switch (field) {
      case "era": {
        let eras = value.calendar.getEras();
        let eraIndex = eras.indexOf(value.era);
        if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
        eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
        mutable.era = eras[eraIndex];
        $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
        break;
      }
      case "year":
        var _mutable_calendar_isInverseEra, _mutable_calendar;
        if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
        mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
        if (mutable.year === -Infinity) mutable.year = 1;
        if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
        break;
      case "month":
        mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
        break;
      case "day":
        mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
        break;
      default:
        throw new Error("Unsupported field " + field);
    }
    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
    $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
    return mutable;
  }
  function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
    let mutable = value.copy();
    switch (field) {
      case "hour": {
        let hours = value.hour;
        let min2 = 0;
        let max2 = 23;
        if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
          let isPM = hours >= 12;
          min2 = isPM ? 12 : 0;
          max2 = isPM ? 23 : 11;
        }
        mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min2, max2, options === null || options === void 0 ? void 0 : options.round);
        break;
      }
      case "minute":
        mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
        break;
      case "second":
        mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
        break;
      case "millisecond":
        mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
        break;
      default:
        throw new Error("Unsupported field " + field);
    }
    return mutable;
  }
  function $735220c2d4774dd3$var$cycleValue(value, amount, min2, max2, round2 = false) {
    if (round2) {
      value += Math.sign(amount);
      if (value < min2) value = max2;
      let div = Math.abs(amount);
      if (amount > 0) value = Math.ceil(value / div) * div;
      else value = Math.floor(value / div) * div;
      if (value > max2) value = min2;
    } else {
      value += amount;
      if (value < min2) value = max2 - (min2 - value - 1);
      else if (value > max2) value = min2 + (value - max2 - 1);
    }
    return value;
  }
  function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
    let ms;
    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
      let res2 = $735220c2d4774dd3$export$e16d8520af44a096($11d87f3f76e88657$export$b21e0b124e224484(dateTime), {
        years: duration.years,
        months: duration.months,
        weeks: duration.weeks,
        days: duration.days
      });
      ms = $11d87f3f76e88657$export$5107c82f94518f5c(res2, dateTime.timeZone);
    } else
      ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime) - dateTime.offset;
    ms += duration.milliseconds || 0;
    ms += (duration.seconds || 0) * 1e3;
    ms += (duration.minutes || 0) * 6e4;
    ms += (duration.hours || 0) * 36e5;
    let res = $11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone);
    return $11d87f3f76e88657$export$b4a036af3fc0b032(res, dateTime.calendar);
  }
  function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
    return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
  }
  function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
    switch (field) {
      case "hour": {
        let min2 = 0;
        let max2 = 23;
        if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
          let isPM = dateTime.hour >= 12;
          min2 = isPM ? 12 : 0;
          max2 = isPM ? 23 : 11;
        }
        let plainDateTime = $11d87f3f76e88657$export$b21e0b124e224484(dateTime);
        let minDate = $11d87f3f76e88657$export$b4a036af3fc0b032($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
          hour: min2
        }), new $3b62074eb05584b2$export$80ee6245ec4f29ec());
        let minAbsolute = [
          $11d87f3f76e88657$export$5107c82f94518f5c(minDate, dateTime.timeZone, "earlier"),
          $11d87f3f76e88657$export$5107c82f94518f5c(minDate, dateTime.timeZone, "later")
        ].filter((ms2) => $11d87f3f76e88657$export$1b96692a1ba042ac(ms2, dateTime.timeZone).day === minDate.day)[0];
        let maxDate = $11d87f3f76e88657$export$b4a036af3fc0b032($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
          hour: max2
        }), new $3b62074eb05584b2$export$80ee6245ec4f29ec());
        let maxAbsolute = [
          $11d87f3f76e88657$export$5107c82f94518f5c(maxDate, dateTime.timeZone, "earlier"),
          $11d87f3f76e88657$export$5107c82f94518f5c(maxDate, dateTime.timeZone, "later")
        ].filter((ms2) => $11d87f3f76e88657$export$1b96692a1ba042ac(ms2, dateTime.timeZone).day === maxDate.day).pop();
        let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime) - dateTime.offset;
        let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
        let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
        ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
        return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone), dateTime.calendar);
      }
      case "minute":
      case "second":
      case "millisecond":
        return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
      case "era":
      case "year":
      case "month":
      case "day": {
        let res = $735220c2d4774dd3$export$d52ced6badfb9a4c($11d87f3f76e88657$export$b21e0b124e224484(dateTime), field, amount, options);
        let ms = $11d87f3f76e88657$export$5107c82f94518f5c(res, dateTime.timeZone);
        return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone), dateTime.calendar);
      }
      default:
        throw new Error("Unsupported field " + field);
    }
  }
  function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
    let plainDateTime = $11d87f3f76e88657$export$b21e0b124e224484(dateTime);
    let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
    if (res.compare(plainDateTime) === 0) return dateTime;
    let ms = $11d87f3f76e88657$export$5107c82f94518f5c(res, dateTime.timeZone, disambiguation);
    return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, dateTime.timeZone), dateTime.calendar);
  }
  const $fae977aafc393c5c$var$DATE_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})$/;
  const $fae977aafc393c5c$var$DATE_TIME_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
  const $fae977aafc393c5c$var$ZONED_DATE_TIME_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?)?\[(.*?)\]$/;
  function $fae977aafc393c5c$export$6b862160d295c8e(value) {
    let m = value.match($fae977aafc393c5c$var$DATE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date string: " + value);
    let date = new $35ea8db9cb2ccb90$export$99faa760c7908e4f($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
  }
  function $fae977aafc393c5c$export$588937bcd60ade55(value) {
    let m = value.match($fae977aafc393c5c$var$DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let year = $fae977aafc393c5c$var$parseNumber(m[1], -9999, 9999);
    let era = year < 1 ? "BC" : "AD";
    let date = new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(era, year < 1 ? -year + 1 : year, $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1e3 : 0);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
  }
  function $fae977aafc393c5c$export$fd7893f06e92a6a4(value, disambiguation) {
    let m = value.match($fae977aafc393c5c$var$ZONED_DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let year = $fae977aafc393c5c$var$parseNumber(m[1], -9999, 9999);
    let era = year < 1 ? "BC" : "AD";
    let date = new $35ea8db9cb2ccb90$export$d3b7288e7994edea(era, year < 1 ? -year + 1 : year, $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1e3 : 0);
    date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    let plainDateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
    let ms;
    if (m[8]) {
      var _m_;
      date.offset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23) * 36e5 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 6e4;
      ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
      let absolutes = $11d87f3f76e88657$export$136f38efe7caf549(plainDateTime, date.timeZone);
      if (!absolutes.includes(ms)) throw new Error(`Offset ${$fae977aafc393c5c$var$offsetToString(date.offset)} is invalid for ${$fae977aafc393c5c$export$4223de14708adc63(date)} in ${date.timeZone}`);
    } else
      ms = $11d87f3f76e88657$export$5107c82f94518f5c($11d87f3f76e88657$export$b21e0b124e224484(plainDateTime), date.timeZone, disambiguation);
    return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, date.timeZone);
  }
  function $fae977aafc393c5c$var$parseNumber(value, min2, max2) {
    let val = Number(value);
    if (val < min2 || val > max2) throw new RangeError(`Value out of range: ${min2} <= ${val} <= ${max2}`);
    return val;
  }
  function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
    return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
  }
  function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
    let gregorianDate = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
    let year;
    if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
    else year = String(gregorianDate.year).padStart(4, "0");
    return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
  }
  function $fae977aafc393c5c$export$4223de14708adc63(date) {
    return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
  }
  function $fae977aafc393c5c$var$offsetToString(offset2) {
    let sign = Math.sign(offset2) < 0 ? "-" : "+";
    offset2 = Math.abs(offset2);
    let offsetHours = Math.floor(offset2 / 36e5);
    let offsetMinutes = offset2 % 36e5 / 6e4;
    return `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
  }
  function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
    return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
  }
  function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
  function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
  function $35ea8db9cb2ccb90$var$shiftArgs(args) {
    let calendar = typeof args[0] === "object" ? args.shift() : new $3b62074eb05584b2$export$80ee6245ec4f29ec();
    let era;
    if (typeof args[0] === "string") era = args.shift();
    else {
      let eras = calendar.getEras();
      era = eras[eras.length - 1];
    }
    let year = args.shift();
    let month = args.shift();
    let day = args.shift();
    return [
      calendar,
      era,
      year,
      month,
      day
    ];
  }
  var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
  class $35ea8db9cb2ccb90$export$99faa760c7908e4f {
    /** Returns a copy of this date. */
    copy() {
      if (this.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
      else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
    }
    /** Returns a new `CalendarDate` with the given duration added to it. */
    add(duration) {
      return $735220c2d4774dd3$export$e16d8520af44a096(this, duration);
    }
    /** Returns a new `CalendarDate` with the given duration subtracted from it. */
    subtract(duration) {
      return $735220c2d4774dd3$export$4e2d2ead65e5f7e3(this, duration);
    }
    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
    set(fields) {
      return $735220c2d4774dd3$export$adaa4cf7ef1b65be(this, fields);
    }
    /**
    * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
    * When the resulting value reaches the limits of the field, it wraps around.
    */
    cycle(field, amount, options) {
      return $735220c2d4774dd3$export$d52ced6badfb9a4c(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
    toDate(timeZone) {
      return $11d87f3f76e88657$export$e67a095c620b86fe(this, timeZone);
    }
    /** Converts the date to an ISO 8601 formatted string. */
    toString() {
      return $fae977aafc393c5c$export$60dfd74aa96791bd(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
    compare(b2) {
      return $14e0f24ef4ac5c92$export$68781ddf31c0090f(this, b2);
    }
    constructor(...args) {
      _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type, {
        writable: true,
        value: void 0
      });
      let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
      this.calendar = calendar;
      this.era = era;
      this.year = year;
      this.month = month;
      this.day = day;
      $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
    }
  }
  var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
  class $35ea8db9cb2ccb90$export$680ea196effce5f {
    /** Returns a copy of this time. */
    copy() {
      return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `Time` with the given duration added to it. */
    add(duration) {
      return $735220c2d4774dd3$export$7ed87b6bc2506470(this, duration);
    }
    /** Returns a new `Time` with the given duration subtracted from it. */
    subtract(duration) {
      return $735220c2d4774dd3$export$fe34d3a381cd7501(this, duration);
    }
    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
    set(fields) {
      return $735220c2d4774dd3$export$e5d5e1c1822b6e56(this, fields);
    }
    /**
    * Returns a new `Time` with the given field adjusted by a specified amount.
    * When the resulting value reaches the limits of the field, it wraps around.
    */
    cycle(field, amount, options) {
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(this, field, amount, options);
    }
    /** Converts the time to an ISO 8601 formatted string. */
    toString() {
      return $fae977aafc393c5c$export$f59dee82248f5ad4(this);
    }
    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
    compare(b2) {
      return $14e0f24ef4ac5c92$export$c19a80a9721b80f6(this, b2);
    }
    constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
      _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type1, {
        writable: true,
        value: void 0
      });
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond;
      $735220c2d4774dd3$export$7555de1e070510cb(this);
    }
  }
  var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
  class $35ea8db9cb2ccb90$export$ca871e8dbb80966f {
    /** Returns a copy of this date. */
    copy() {
      if (this.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `CalendarDateTime` with the given duration added to it. */
    add(duration) {
      return $735220c2d4774dd3$export$e16d8520af44a096(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
    subtract(duration) {
      return $735220c2d4774dd3$export$4e2d2ead65e5f7e3(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
    set(fields) {
      return $735220c2d4774dd3$export$adaa4cf7ef1b65be($735220c2d4774dd3$export$e5d5e1c1822b6e56(this, fields), fields);
    }
    /**
    * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
    * When the resulting value reaches the limits of the field, it wraps around.
    */
    cycle(field, amount, options) {
      switch (field) {
        case "era":
        case "year":
        case "month":
        case "day":
          return $735220c2d4774dd3$export$d52ced6badfb9a4c(this, field, amount, options);
        default:
          return $735220c2d4774dd3$export$dd02b3e0007dfe28(this, field, amount, options);
      }
    }
    /** Converts the date to a native JavaScript Date object in the given time zone. */
    toDate(timeZone, disambiguation) {
      return $11d87f3f76e88657$export$e67a095c620b86fe(this, timeZone, disambiguation);
    }
    /** Converts the date to an ISO 8601 formatted string. */
    toString() {
      return $fae977aafc393c5c$export$4223de14708adc63(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
    compare(b2) {
      let res = $14e0f24ef4ac5c92$export$68781ddf31c0090f(this, b2);
      if (res === 0) return $14e0f24ef4ac5c92$export$c19a80a9721b80f6(this, $11d87f3f76e88657$export$b21e0b124e224484(b2));
      return res;
    }
    constructor(...args) {
      _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type2, {
        writable: true,
        value: void 0
      });
      let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
      this.calendar = calendar;
      this.era = era;
      this.year = year;
      this.month = month;
      this.day = day;
      this.hour = args.shift() || 0;
      this.minute = args.shift() || 0;
      this.second = args.shift() || 0;
      this.millisecond = args.shift() || 0;
      $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
    }
  }
  var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
  class $35ea8db9cb2ccb90$export$d3b7288e7994edea {
    /** Returns a copy of this date. */
    copy() {
      if (this.era) return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
      else return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `ZonedDateTime` with the given duration added to it. */
    add(duration) {
      return $735220c2d4774dd3$export$96b1d28349274637(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
    subtract(duration) {
      return $735220c2d4774dd3$export$6814caac34ca03c7(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
    set(fields, disambiguation) {
      return $735220c2d4774dd3$export$31b5430eb18be4f8(this, fields, disambiguation);
    }
    /**
    * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
    * When the resulting value reaches the limits of the field, it wraps around.
    */
    cycle(field, amount, options) {
      return $735220c2d4774dd3$export$9a297d111fc86b79(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object. */
    toDate() {
      return $11d87f3f76e88657$export$83aac07b4c37b25(this);
    }
    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
    toString() {
      return $fae977aafc393c5c$export$bf79f1ebf4b18792(this);
    }
    /** Converts the date to an ISO 8601 formatted string in UTC. */
    toAbsoluteString() {
      return this.toDate().toISOString();
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
    compare(b2) {
      return this.toDate().getTime() - $11d87f3f76e88657$export$84c95a83c799e074(b2, this.timeZone).toDate().getTime();
    }
    constructor(...args) {
      _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type3, {
        writable: true,
        value: void 0
      });
      let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
      let timeZone = args.shift();
      let offset2 = args.shift();
      this.calendar = calendar;
      this.era = era;
      this.year = year;
      this.month = month;
      this.day = day;
      this.timeZone = timeZone;
      this.offset = offset2;
      this.hour = args.shift() || 0;
      this.minute = args.shift() || 0;
      this.second = args.shift() || 0;
      this.millisecond = args.shift() || 0;
      $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
    }
  }
  let $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
  class $fb18d541ea1ad717$export$ad991b66133851cf {
    /** Formats a date as a string according to the locale and format options passed to the constructor. */
    format(value) {
      return this.formatter.format(value);
    }
    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
    formatToParts(value) {
      return this.formatter.formatToParts(value);
    }
    /** Formats a date range as a string. */
    formatRange(start, end) {
      if (typeof this.formatter.formatRange === "function")
        return this.formatter.formatRange(start, end);
      if (end < start) throw new RangeError("End date must be >= start date");
      return `${this.formatter.format(start)} – ${this.formatter.format(end)}`;
    }
    /** Formats a date range as an array of parts. */
    formatRangeToParts(start, end) {
      if (typeof this.formatter.formatRangeToParts === "function")
        return this.formatter.formatRangeToParts(start, end);
      if (end < start) throw new RangeError("End date must be >= start date");
      let startParts = this.formatter.formatToParts(start);
      let endParts = this.formatter.formatToParts(end);
      return [
        ...startParts.map((p2) => ({
          ...p2,
          source: "startRange"
        })),
        {
          type: "literal",
          value: " – ",
          source: "shared"
        },
        ...endParts.map((p2) => ({
          ...p2,
          source: "endRange"
        }))
      ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */
    resolvedOptions() {
      let resolvedOptions = this.formatter.resolvedOptions();
      if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
        if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
        resolvedOptions.hourCycle = this.resolvedHourCycle;
        resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
      }
      if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
      return resolvedOptions;
    }
    constructor(locale, options = {}) {
      this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
      this.options = options;
    }
  }
  const $fb18d541ea1ad717$var$hour12Preferences = {
    true: {
      // Only Japanese uses the h11 style for 12 hour time. All others use h12.
      ja: "h11"
    },
    false: {}
  };
  function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
    if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
      options = {
        ...options
      };
      let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
      let defaultHourCycle = options.hour12 ? "h12" : "h23";
      options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
      delete options.hour12;
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
    if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.DateTimeFormat(locale, options);
    $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
  }
  let $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
  function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
    if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
      hour: "numeric",
      hour12: false
    }).format(new Date(2020, 2, 3, 0)) === "24";
    return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
  }
  let $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
  function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
    if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
      hour: "numeric",
      hour12: false
    }).resolvedOptions().hourCycle === "h12";
    return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
  }
  function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
    if (!options.timeStyle && !options.hour) return void 0;
    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
    locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
    let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
      ...options,
      timeZone: void 0
      // use local timezone
    });
    let min2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p2) => p2.type === "hour").value, 10);
    let max2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p2) => p2.type === "hour").value, 10);
    if (min2 === 0 && max2 === 23) return "h23";
    if (min2 === 24 && max2 === 23) return "h24";
    if (min2 === 0 && max2 === 11) return "h11";
    if (min2 === 12 && max2 === 11) return "h12";
    throw new Error("Unexpected hour cycle result");
  }
  var l$1 = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, u = (e) => !e || typeof e != "object" || Object.keys(e).length === 0, x$2 = (e, o2) => JSON.stringify(e) === JSON.stringify(o2);
  function i(e, o2) {
    e.forEach(function(r2) {
      Array.isArray(r2) ? i(r2, o2) : o2.push(r2);
    });
  }
  function y$1(e) {
    let o2 = [];
    return i(e, o2), o2;
  }
  var a = (...e) => y$1(e).filter(Boolean), p$1 = (e, o2) => {
    let r2 = {}, c2 = Object.keys(e), f2 = Object.keys(o2);
    for (let t of c2) if (f2.includes(t)) {
      let s = e[t], n = o2[t];
      Array.isArray(s) || Array.isArray(n) ? r2[t] = a(n, s) : typeof s == "object" && typeof n == "object" ? r2[t] = p$1(s, n) : r2[t] = n + " " + s;
    } else r2[t] = e[t];
    for (let t of f2) c2.includes(t) || (r2[t] = o2[t]);
    return r2;
  }, g$1 = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();
  const CLASS_PART_SEPARATOR = "-";
  const createClassGroupUtils = (config) => {
    const classMap = createClassMap(config);
    const {
      conflictingClassGroups,
      conflictingClassGroupModifiers
    } = config;
    const getClassGroupId = (className) => {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      if (classParts[0] === "" && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
      }
      return conflicts;
    };
    return {
      getClassGroupId,
      getConflictingClassGroupIds
    };
  };
  const getGroupRecursive = (classParts, classPartObject) => {
    var _a2;
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return void 0;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return (_a2 = classPartObject.validators.find(({
      validator
    }) => validator(classRest))) == null ? void 0 : _a2.classGroupId;
  };
  const arbitraryPropertyRegex = /^\[(.+)\]$/;
  const getGroupIdForArbitraryProperty = (className) => {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
      if (property) {
        return "arbitrary.." + property;
      }
    }
  };
  const createClassMap = (config) => {
    const {
      theme,
      prefix
    } = config;
    const classMap = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
      processClassesRecursively(classGroup, classMap, classGroupId, theme);
    });
    return classMap;
  };
  const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === "string") {
        const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === "function") {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key, classGroup2]) => {
        processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
      });
    });
  };
  const getPart = (classPartObject, path) => {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: /* @__PURE__ */ new Map(),
          validators: []
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  };
  const isThemeGetter = (func) => func.isThemeGetter;
  const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
    if (!prefix) {
      return classGroupEntries;
    }
    return classGroupEntries.map(([classGroupId, classGroup]) => {
      const prefixedClassGroup = classGroup.map((classDefinition) => {
        if (typeof classDefinition === "string") {
          return prefix + classDefinition;
        }
        if (typeof classDefinition === "object") {
          return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
        }
        return classDefinition;
      });
      return [classGroupId, prefixedClassGroup];
    });
  };
  const createLruCache = (maxCacheSize) => {
    if (maxCacheSize < 1) {
      return {
        get: () => void 0,
        set: () => {
        }
      };
    }
    let cacheSize = 0;
    let cache2 = /* @__PURE__ */ new Map();
    let previousCache = /* @__PURE__ */ new Map();
    const update2 = (key, value) => {
      cache2.set(key, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache2;
        cache2 = /* @__PURE__ */ new Map();
      }
    };
    return {
      get(key) {
        let value = cache2.get(key);
        if (value !== void 0) {
          return value;
        }
        if ((value = previousCache.get(key)) !== void 0) {
          update2(key, value);
          return value;
        }
      },
      set(key, value) {
        if (cache2.has(key)) {
          cache2.set(key, value);
        } else {
          update2(key, value);
        }
      }
    };
  };
  const IMPORTANT_MODIFIER = "!";
  const createParseClassName = (config) => {
    const {
      separator,
      experimentalParseClassName
    } = config;
    const isSeparatorSingleCharacter = separator.length === 1;
    const firstSeparatorCharacter = separator[0];
    const separatorLength = separator.length;
    const parseClassName = (className) => {
      const modifiers = [];
      let bracketDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index2 = 0; index2 < className.length; index2++) {
        let currentCharacter = className[index2];
        if (bracketDepth === 0) {
          if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
            modifiers.push(className.slice(modifierStart, index2));
            modifierStart = index2 + separatorLength;
            continue;
          }
          if (currentCharacter === "/") {
            postfixModifierPosition = index2;
            continue;
          }
        }
        if (currentCharacter === "[") {
          bracketDepth++;
        } else if (currentCharacter === "]") {
          bracketDepth--;
        }
      }
      const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
      const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
      const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
      return {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      };
    };
    if (experimentalParseClassName) {
      return (className) => experimentalParseClassName({
        className,
        parseClassName
      });
    }
    return parseClassName;
  };
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isArbitraryVariant = modifier[0] === "[";
      if (isArbitraryVariant) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  const createConfigUtils = (config) => ({
    cache: createLruCache(config.cacheSize),
    parseClassName: createParseClassName(config),
    ...createClassGroupUtils(config)
  });
  const SPLIT_CLASSES_REGEX = /\s+/;
  const mergeClassList = (classList, configUtils) => {
    const {
      parseClassName,
      getClassGroupId,
      getConflictingClassGroupIds
    } = configUtils;
    const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result2 = "";
    for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
      const originalClassName = classNames[index2];
      const {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      } = parseClassName(originalClassName);
      let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
      let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
      if (!classGroupId) {
        if (!hasPostfixModifier) {
          result2 = originalClassName + (result2.length > 0 ? " " + result2 : result2);
          continue;
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          result2 = originalClassName + (result2.length > 0 ? " " + result2 : result2);
          continue;
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers).join(":");
      const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.includes(classId)) {
        continue;
      }
      classGroupsInConflict.push(classId);
      const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
      for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
        const group = conflictGroups[i2];
        classGroupsInConflict.push(modifierId + group);
      }
      result2 = originalClassName + (result2.length > 0 ? " " + result2 : result2);
    }
    return result2;
  };
  function twJoin() {
    let index2 = 0;
    let argument;
    let resolvedValue;
    let string = "";
    while (index2 < arguments.length) {
      if (argument = arguments[index2++]) {
        if (resolvedValue = toValue(argument)) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  const toValue = (mix) => {
    if (typeof mix === "string") {
      return mix;
    }
    let resolvedValue;
    let string = "";
    for (let k = 0; k < mix.length; k++) {
      if (mix[k]) {
        if (resolvedValue = toValue(mix[k])) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  };
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
      configUtils = createConfigUtils(config);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult = cacheGet(classList);
      if (cachedResult) {
        return cachedResult;
      }
      const result2 = mergeClassList(classList, configUtils);
      cacheSet(classList, result2);
      return result2;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  const fromTheme = (key) => {
    const themeGetter = (theme) => theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  };
  const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
  const fractionRegex = /^\d+\/\d+$/;
  const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
  const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
  const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  const isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
  const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
  const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
  const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
  const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
  const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
  const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
  const isTshirtSize = (value) => tshirtUnitRegex.test(value);
  const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
  const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
  const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
  const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
  const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
  const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
  const isAny = () => true;
  const getIsArbitraryValue = (value, label, testValue) => {
    const result2 = arbitraryValueRegex.exec(value);
    if (result2) {
      if (result2[1]) {
        return typeof label === "string" ? result2[1] === label : label.has(result2[1]);
      }
      return testValue(result2[2]);
    }
    return false;
  };
  const isLengthOnly = (value) => (
    // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
  );
  const isNever = () => false;
  const isShadow = (value) => shadowRegex.test(value);
  const isImage = (value) => imageRegex.test(value);
  const getDefaultConfig = () => {
    const colors = fromTheme("colors");
    const spacing = fromTheme("spacing");
    const blur = fromTheme("blur");
    const brightness = fromTheme("brightness");
    const borderColor = fromTheme("borderColor");
    const borderRadius = fromTheme("borderRadius");
    const borderSpacing = fromTheme("borderSpacing");
    const borderWidth = fromTheme("borderWidth");
    const contrast = fromTheme("contrast");
    const grayscale = fromTheme("grayscale");
    const hueRotate = fromTheme("hueRotate");
    const invert = fromTheme("invert");
    const gap = fromTheme("gap");
    const gradientColorStops = fromTheme("gradientColorStops");
    const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
    const inset = fromTheme("inset");
    const margin = fromTheme("margin");
    const opacity = fromTheme("opacity");
    const padding = fromTheme("padding");
    const saturate = fromTheme("saturate");
    const scale = fromTheme("scale");
    const sepia = fromTheme("sepia");
    const skew = fromTheme("skew");
    const space = fromTheme("space");
    const translate = fromTheme("translate");
    const getOverscroll = () => ["auto", "contain", "none"];
    const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
    const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
    const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
    const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
    const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
    const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
    const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
    const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
    const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
    const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
    const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
    const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [isAny],
        spacing: [isLength, isArbitraryLength],
        blur: ["none", "", isTshirtSize, isArbitraryValue],
        brightness: getNumberAndArbitrary(),
        borderColor: [colors],
        borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
        borderSpacing: getSpacingWithArbitrary(),
        borderWidth: getLengthWithEmptyAndArbitrary(),
        contrast: getNumberAndArbitrary(),
        grayscale: getZeroAndEmpty(),
        hueRotate: getNumberAndArbitrary(),
        invert: getZeroAndEmpty(),
        gap: getSpacingWithArbitrary(),
        gradientColorStops: [colors],
        gradientColorStopPositions: [isPercent, isArbitraryLength],
        inset: getSpacingWithAutoAndArbitrary(),
        margin: getSpacingWithAutoAndArbitrary(),
        opacity: getNumberAndArbitrary(),
        padding: getSpacingWithArbitrary(),
        saturate: getNumberAndArbitrary(),
        scale: getNumberAndArbitrary(),
        sepia: getZeroAndEmpty(),
        skew: getNumberAndArbitrary(),
        space: getSpacingWithArbitrary(),
        translate: getSpacingWithArbitrary()
      },
      classGroups: {
        // Layout
        /**
         * Aspect Ratio
         * @see https://tailwindcss.com/docs/aspect-ratio
         */
        aspect: [{
          aspect: ["auto", "square", "video", isArbitraryValue]
        }],
        /**
         * Container
         * @see https://tailwindcss.com/docs/container
         */
        container: ["container"],
        /**
         * Columns
         * @see https://tailwindcss.com/docs/columns
         */
        columns: [{
          columns: [isTshirtSize]
        }],
        /**
         * Break After
         * @see https://tailwindcss.com/docs/break-after
         */
        "break-after": [{
          "break-after": getBreaks()
        }],
        /**
         * Break Before
         * @see https://tailwindcss.com/docs/break-before
         */
        "break-before": [{
          "break-before": getBreaks()
        }],
        /**
         * Break Inside
         * @see https://tailwindcss.com/docs/break-inside
         */
        "break-inside": [{
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
        }],
        /**
         * Box Decoration Break
         * @see https://tailwindcss.com/docs/box-decoration-break
         */
        "box-decoration": [{
          "box-decoration": ["slice", "clone"]
        }],
        /**
         * Box Sizing
         * @see https://tailwindcss.com/docs/box-sizing
         */
        box: [{
          box: ["border", "content"]
        }],
        /**
         * Display
         * @see https://tailwindcss.com/docs/display
         */
        display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
        /**
         * Floats
         * @see https://tailwindcss.com/docs/float
         */
        float: [{
          float: ["right", "left", "none", "start", "end"]
        }],
        /**
         * Clear
         * @see https://tailwindcss.com/docs/clear
         */
        clear: [{
          clear: ["left", "right", "both", "none", "start", "end"]
        }],
        /**
         * Isolation
         * @see https://tailwindcss.com/docs/isolation
         */
        isolation: ["isolate", "isolation-auto"],
        /**
         * Object Fit
         * @see https://tailwindcss.com/docs/object-fit
         */
        "object-fit": [{
          object: ["contain", "cover", "fill", "none", "scale-down"]
        }],
        /**
         * Object Position
         * @see https://tailwindcss.com/docs/object-position
         */
        "object-position": [{
          object: [...getPositions(), isArbitraryValue]
        }],
        /**
         * Overflow
         * @see https://tailwindcss.com/docs/overflow
         */
        overflow: [{
          overflow: getOverflow()
        }],
        /**
         * Overflow X
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-x": [{
          "overflow-x": getOverflow()
        }],
        /**
         * Overflow Y
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-y": [{
          "overflow-y": getOverflow()
        }],
        /**
         * Overscroll Behavior
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        overscroll: [{
          overscroll: getOverscroll()
        }],
        /**
         * Overscroll Behavior X
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-x": [{
          "overscroll-x": getOverscroll()
        }],
        /**
         * Overscroll Behavior Y
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-y": [{
          "overscroll-y": getOverscroll()
        }],
        /**
         * Position
         * @see https://tailwindcss.com/docs/position
         */
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        /**
         * Top / Right / Bottom / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        inset: [{
          inset: [inset]
        }],
        /**
         * Right / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-x": [{
          "inset-x": [inset]
        }],
        /**
         * Top / Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-y": [{
          "inset-y": [inset]
        }],
        /**
         * Start
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        start: [{
          start: [inset]
        }],
        /**
         * End
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        end: [{
          end: [inset]
        }],
        /**
         * Top
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        top: [{
          top: [inset]
        }],
        /**
         * Right
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        right: [{
          right: [inset]
        }],
        /**
         * Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        bottom: [{
          bottom: [inset]
        }],
        /**
         * Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        left: [{
          left: [inset]
        }],
        /**
         * Visibility
         * @see https://tailwindcss.com/docs/visibility
         */
        visibility: ["visible", "invisible", "collapse"],
        /**
         * Z-Index
         * @see https://tailwindcss.com/docs/z-index
         */
        z: [{
          z: ["auto", isInteger, isArbitraryValue]
        }],
        // Flexbox and Grid
        /**
         * Flex Basis
         * @see https://tailwindcss.com/docs/flex-basis
         */
        basis: [{
          basis: getSpacingWithAutoAndArbitrary()
        }],
        /**
         * Flex Direction
         * @see https://tailwindcss.com/docs/flex-direction
         */
        "flex-direction": [{
          flex: ["row", "row-reverse", "col", "col-reverse"]
        }],
        /**
         * Flex Wrap
         * @see https://tailwindcss.com/docs/flex-wrap
         */
        "flex-wrap": [{
          flex: ["wrap", "wrap-reverse", "nowrap"]
        }],
        /**
         * Flex
         * @see https://tailwindcss.com/docs/flex
         */
        flex: [{
          flex: ["1", "auto", "initial", "none", isArbitraryValue]
        }],
        /**
         * Flex Grow
         * @see https://tailwindcss.com/docs/flex-grow
         */
        grow: [{
          grow: getZeroAndEmpty()
        }],
        /**
         * Flex Shrink
         * @see https://tailwindcss.com/docs/flex-shrink
         */
        shrink: [{
          shrink: getZeroAndEmpty()
        }],
        /**
         * Order
         * @see https://tailwindcss.com/docs/order
         */
        order: [{
          order: ["first", "last", "none", isInteger, isArbitraryValue]
        }],
        /**
         * Grid Template Columns
         * @see https://tailwindcss.com/docs/grid-template-columns
         */
        "grid-cols": [{
          "grid-cols": [isAny]
        }],
        /**
         * Grid Column Start / End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start-end": [{
          col: ["auto", {
            span: ["full", isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Column Start
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start": [{
          "col-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Column End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-end": [{
          "col-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Template Rows
         * @see https://tailwindcss.com/docs/grid-template-rows
         */
        "grid-rows": [{
          "grid-rows": [isAny]
        }],
        /**
         * Grid Row Start / End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start-end": [{
          row: ["auto", {
            span: [isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Row Start
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start": [{
          "row-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Row End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-end": [{
          "row-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Auto Flow
         * @see https://tailwindcss.com/docs/grid-auto-flow
         */
        "grid-flow": [{
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
        }],
        /**
         * Grid Auto Columns
         * @see https://tailwindcss.com/docs/grid-auto-columns
         */
        "auto-cols": [{
          "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Grid Auto Rows
         * @see https://tailwindcss.com/docs/grid-auto-rows
         */
        "auto-rows": [{
          "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Gap
         * @see https://tailwindcss.com/docs/gap
         */
        gap: [{
          gap: [gap]
        }],
        /**
         * Gap X
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-x": [{
          "gap-x": [gap]
        }],
        /**
         * Gap Y
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-y": [{
          "gap-y": [gap]
        }],
        /**
         * Justify Content
         * @see https://tailwindcss.com/docs/justify-content
         */
        "justify-content": [{
          justify: ["normal", ...getAlign()]
        }],
        /**
         * Justify Items
         * @see https://tailwindcss.com/docs/justify-items
         */
        "justify-items": [{
          "justify-items": ["start", "end", "center", "stretch"]
        }],
        /**
         * Justify Self
         * @see https://tailwindcss.com/docs/justify-self
         */
        "justify-self": [{
          "justify-self": ["auto", "start", "end", "center", "stretch"]
        }],
        /**
         * Align Content
         * @see https://tailwindcss.com/docs/align-content
         */
        "align-content": [{
          content: ["normal", ...getAlign(), "baseline"]
        }],
        /**
         * Align Items
         * @see https://tailwindcss.com/docs/align-items
         */
        "align-items": [{
          items: ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Align Self
         * @see https://tailwindcss.com/docs/align-self
         */
        "align-self": [{
          self: ["auto", "start", "end", "center", "stretch", "baseline"]
        }],
        /**
         * Place Content
         * @see https://tailwindcss.com/docs/place-content
         */
        "place-content": [{
          "place-content": [...getAlign(), "baseline"]
        }],
        /**
         * Place Items
         * @see https://tailwindcss.com/docs/place-items
         */
        "place-items": [{
          "place-items": ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Place Self
         * @see https://tailwindcss.com/docs/place-self
         */
        "place-self": [{
          "place-self": ["auto", "start", "end", "center", "stretch"]
        }],
        // Spacing
        /**
         * Padding
         * @see https://tailwindcss.com/docs/padding
         */
        p: [{
          p: [padding]
        }],
        /**
         * Padding X
         * @see https://tailwindcss.com/docs/padding
         */
        px: [{
          px: [padding]
        }],
        /**
         * Padding Y
         * @see https://tailwindcss.com/docs/padding
         */
        py: [{
          py: [padding]
        }],
        /**
         * Padding Start
         * @see https://tailwindcss.com/docs/padding
         */
        ps: [{
          ps: [padding]
        }],
        /**
         * Padding End
         * @see https://tailwindcss.com/docs/padding
         */
        pe: [{
          pe: [padding]
        }],
        /**
         * Padding Top
         * @see https://tailwindcss.com/docs/padding
         */
        pt: [{
          pt: [padding]
        }],
        /**
         * Padding Right
         * @see https://tailwindcss.com/docs/padding
         */
        pr: [{
          pr: [padding]
        }],
        /**
         * Padding Bottom
         * @see https://tailwindcss.com/docs/padding
         */
        pb: [{
          pb: [padding]
        }],
        /**
         * Padding Left
         * @see https://tailwindcss.com/docs/padding
         */
        pl: [{
          pl: [padding]
        }],
        /**
         * Margin
         * @see https://tailwindcss.com/docs/margin
         */
        m: [{
          m: [margin]
        }],
        /**
         * Margin X
         * @see https://tailwindcss.com/docs/margin
         */
        mx: [{
          mx: [margin]
        }],
        /**
         * Margin Y
         * @see https://tailwindcss.com/docs/margin
         */
        my: [{
          my: [margin]
        }],
        /**
         * Margin Start
         * @see https://tailwindcss.com/docs/margin
         */
        ms: [{
          ms: [margin]
        }],
        /**
         * Margin End
         * @see https://tailwindcss.com/docs/margin
         */
        me: [{
          me: [margin]
        }],
        /**
         * Margin Top
         * @see https://tailwindcss.com/docs/margin
         */
        mt: [{
          mt: [margin]
        }],
        /**
         * Margin Right
         * @see https://tailwindcss.com/docs/margin
         */
        mr: [{
          mr: [margin]
        }],
        /**
         * Margin Bottom
         * @see https://tailwindcss.com/docs/margin
         */
        mb: [{
          mb: [margin]
        }],
        /**
         * Margin Left
         * @see https://tailwindcss.com/docs/margin
         */
        ml: [{
          ml: [margin]
        }],
        /**
         * Space Between X
         * @see https://tailwindcss.com/docs/space
         */
        "space-x": [{
          "space-x": [space]
        }],
        /**
         * Space Between X Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-x-reverse": ["space-x-reverse"],
        /**
         * Space Between Y
         * @see https://tailwindcss.com/docs/space
         */
        "space-y": [{
          "space-y": [space]
        }],
        /**
         * Space Between Y Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-y-reverse": ["space-y-reverse"],
        // Sizing
        /**
         * Width
         * @see https://tailwindcss.com/docs/width
         */
        w: [{
          w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
        }],
        /**
         * Min-Width
         * @see https://tailwindcss.com/docs/min-width
         */
        "min-w": [{
          "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
        }],
        /**
         * Max-Width
         * @see https://tailwindcss.com/docs/max-width
         */
        "max-w": [{
          "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
            screen: [isTshirtSize]
          }, isTshirtSize]
        }],
        /**
         * Height
         * @see https://tailwindcss.com/docs/height
         */
        h: [{
          h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Min-Height
         * @see https://tailwindcss.com/docs/min-height
         */
        "min-h": [{
          "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Max-Height
         * @see https://tailwindcss.com/docs/max-height
         */
        "max-h": [{
          "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Size
         * @see https://tailwindcss.com/docs/size
         */
        size: [{
          size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
        }],
        // Typography
        /**
         * Font Size
         * @see https://tailwindcss.com/docs/font-size
         */
        "font-size": [{
          text: ["base", isTshirtSize, isArbitraryLength]
        }],
        /**
         * Font Smoothing
         * @see https://tailwindcss.com/docs/font-smoothing
         */
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        /**
         * Font Style
         * @see https://tailwindcss.com/docs/font-style
         */
        "font-style": ["italic", "not-italic"],
        /**
         * Font Weight
         * @see https://tailwindcss.com/docs/font-weight
         */
        "font-weight": [{
          font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
        }],
        /**
         * Font Family
         * @see https://tailwindcss.com/docs/font-family
         */
        "font-family": [{
          font: [isAny]
        }],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-normal": ["normal-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-ordinal": ["ordinal"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-slashed-zero": ["slashed-zero"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        /**
         * Letter Spacing
         * @see https://tailwindcss.com/docs/letter-spacing
         */
        tracking: [{
          tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
        }],
        /**
         * Line Clamp
         * @see https://tailwindcss.com/docs/line-clamp
         */
        "line-clamp": [{
          "line-clamp": ["none", isNumber, isArbitraryNumber]
        }],
        /**
         * Line Height
         * @see https://tailwindcss.com/docs/line-height
         */
        leading: [{
          leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
        }],
        /**
         * List Style Image
         * @see https://tailwindcss.com/docs/list-style-image
         */
        "list-image": [{
          "list-image": ["none", isArbitraryValue]
        }],
        /**
         * List Style Type
         * @see https://tailwindcss.com/docs/list-style-type
         */
        "list-style-type": [{
          list: ["none", "disc", "decimal", isArbitraryValue]
        }],
        /**
         * List Style Position
         * @see https://tailwindcss.com/docs/list-style-position
         */
        "list-style-position": [{
          list: ["inside", "outside"]
        }],
        /**
         * Placeholder Color
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/placeholder-color
         */
        "placeholder-color": [{
          placeholder: [colors]
        }],
        /**
         * Placeholder Opacity
         * @see https://tailwindcss.com/docs/placeholder-opacity
         */
        "placeholder-opacity": [{
          "placeholder-opacity": [opacity]
        }],
        /**
         * Text Alignment
         * @see https://tailwindcss.com/docs/text-align
         */
        "text-alignment": [{
          text: ["left", "center", "right", "justify", "start", "end"]
        }],
        /**
         * Text Color
         * @see https://tailwindcss.com/docs/text-color
         */
        "text-color": [{
          text: [colors]
        }],
        /**
         * Text Opacity
         * @see https://tailwindcss.com/docs/text-opacity
         */
        "text-opacity": [{
          "text-opacity": [opacity]
        }],
        /**
         * Text Decoration
         * @see https://tailwindcss.com/docs/text-decoration
         */
        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
        /**
         * Text Decoration Style
         * @see https://tailwindcss.com/docs/text-decoration-style
         */
        "text-decoration-style": [{
          decoration: [...getLineStyles(), "wavy"]
        }],
        /**
         * Text Decoration Thickness
         * @see https://tailwindcss.com/docs/text-decoration-thickness
         */
        "text-decoration-thickness": [{
          decoration: ["auto", "from-font", isLength, isArbitraryLength]
        }],
        /**
         * Text Underline Offset
         * @see https://tailwindcss.com/docs/text-underline-offset
         */
        "underline-offset": [{
          "underline-offset": ["auto", isLength, isArbitraryValue]
        }],
        /**
         * Text Decoration Color
         * @see https://tailwindcss.com/docs/text-decoration-color
         */
        "text-decoration-color": [{
          decoration: [colors]
        }],
        /**
         * Text Transform
         * @see https://tailwindcss.com/docs/text-transform
         */
        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
        /**
         * Text Overflow
         * @see https://tailwindcss.com/docs/text-overflow
         */
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        /**
         * Text Wrap
         * @see https://tailwindcss.com/docs/text-wrap
         */
        "text-wrap": [{
          text: ["wrap", "nowrap", "balance", "pretty"]
        }],
        /**
         * Text Indent
         * @see https://tailwindcss.com/docs/text-indent
         */
        indent: [{
          indent: getSpacingWithArbitrary()
        }],
        /**
         * Vertical Alignment
         * @see https://tailwindcss.com/docs/vertical-align
         */
        "vertical-align": [{
          align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
        }],
        /**
         * Whitespace
         * @see https://tailwindcss.com/docs/whitespace
         */
        whitespace: [{
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
        }],
        /**
         * Word Break
         * @see https://tailwindcss.com/docs/word-break
         */
        break: [{
          break: ["normal", "words", "all", "keep"]
        }],
        /**
         * Hyphens
         * @see https://tailwindcss.com/docs/hyphens
         */
        hyphens: [{
          hyphens: ["none", "manual", "auto"]
        }],
        /**
         * Content
         * @see https://tailwindcss.com/docs/content
         */
        content: [{
          content: ["none", isArbitraryValue]
        }],
        // Backgrounds
        /**
         * Background Attachment
         * @see https://tailwindcss.com/docs/background-attachment
         */
        "bg-attachment": [{
          bg: ["fixed", "local", "scroll"]
        }],
        /**
         * Background Clip
         * @see https://tailwindcss.com/docs/background-clip
         */
        "bg-clip": [{
          "bg-clip": ["border", "padding", "content", "text"]
        }],
        /**
         * Background Opacity
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/background-opacity
         */
        "bg-opacity": [{
          "bg-opacity": [opacity]
        }],
        /**
         * Background Origin
         * @see https://tailwindcss.com/docs/background-origin
         */
        "bg-origin": [{
          "bg-origin": ["border", "padding", "content"]
        }],
        /**
         * Background Position
         * @see https://tailwindcss.com/docs/background-position
         */
        "bg-position": [{
          bg: [...getPositions(), isArbitraryPosition]
        }],
        /**
         * Background Repeat
         * @see https://tailwindcss.com/docs/background-repeat
         */
        "bg-repeat": [{
          bg: ["no-repeat", {
            repeat: ["", "x", "y", "round", "space"]
          }]
        }],
        /**
         * Background Size
         * @see https://tailwindcss.com/docs/background-size
         */
        "bg-size": [{
          bg: ["auto", "cover", "contain", isArbitrarySize]
        }],
        /**
         * Background Image
         * @see https://tailwindcss.com/docs/background-image
         */
        "bg-image": [{
          bg: ["none", {
            "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isArbitraryImage]
        }],
        /**
         * Background Color
         * @see https://tailwindcss.com/docs/background-color
         */
        "bg-color": [{
          bg: [colors]
        }],
        /**
         * Gradient Color Stops From Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from-pos": [{
          from: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops Via Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via-pos": [{
          via: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops To Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to-pos": [{
          to: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops From
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from": [{
          from: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops Via
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via": [{
          via: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops To
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to": [{
          to: [gradientColorStops]
        }],
        // Borders
        /**
         * Border Radius
         * @see https://tailwindcss.com/docs/border-radius
         */
        rounded: [{
          rounded: [borderRadius]
        }],
        /**
         * Border Radius Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-s": [{
          "rounded-s": [borderRadius]
        }],
        /**
         * Border Radius End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-e": [{
          "rounded-e": [borderRadius]
        }],
        /**
         * Border Radius Top
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-t": [{
          "rounded-t": [borderRadius]
        }],
        /**
         * Border Radius Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-r": [{
          "rounded-r": [borderRadius]
        }],
        /**
         * Border Radius Bottom
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-b": [{
          "rounded-b": [borderRadius]
        }],
        /**
         * Border Radius Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-l": [{
          "rounded-l": [borderRadius]
        }],
        /**
         * Border Radius Start Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ss": [{
          "rounded-ss": [borderRadius]
        }],
        /**
         * Border Radius Start End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-se": [{
          "rounded-se": [borderRadius]
        }],
        /**
         * Border Radius End End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ee": [{
          "rounded-ee": [borderRadius]
        }],
        /**
         * Border Radius End Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-es": [{
          "rounded-es": [borderRadius]
        }],
        /**
         * Border Radius Top Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tl": [{
          "rounded-tl": [borderRadius]
        }],
        /**
         * Border Radius Top Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tr": [{
          "rounded-tr": [borderRadius]
        }],
        /**
         * Border Radius Bottom Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-br": [{
          "rounded-br": [borderRadius]
        }],
        /**
         * Border Radius Bottom Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-bl": [{
          "rounded-bl": [borderRadius]
        }],
        /**
         * Border Width
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w": [{
          border: [borderWidth]
        }],
        /**
         * Border Width X
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-x": [{
          "border-x": [borderWidth]
        }],
        /**
         * Border Width Y
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-y": [{
          "border-y": [borderWidth]
        }],
        /**
         * Border Width Start
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-s": [{
          "border-s": [borderWidth]
        }],
        /**
         * Border Width End
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-e": [{
          "border-e": [borderWidth]
        }],
        /**
         * Border Width Top
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-t": [{
          "border-t": [borderWidth]
        }],
        /**
         * Border Width Right
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-r": [{
          "border-r": [borderWidth]
        }],
        /**
         * Border Width Bottom
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-b": [{
          "border-b": [borderWidth]
        }],
        /**
         * Border Width Left
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-l": [{
          "border-l": [borderWidth]
        }],
        /**
         * Border Opacity
         * @see https://tailwindcss.com/docs/border-opacity
         */
        "border-opacity": [{
          "border-opacity": [opacity]
        }],
        /**
         * Border Style
         * @see https://tailwindcss.com/docs/border-style
         */
        "border-style": [{
          border: [...getLineStyles(), "hidden"]
        }],
        /**
         * Divide Width X
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x": [{
          "divide-x": [borderWidth]
        }],
        /**
         * Divide Width X Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x-reverse": ["divide-x-reverse"],
        /**
         * Divide Width Y
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y": [{
          "divide-y": [borderWidth]
        }],
        /**
         * Divide Width Y Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y-reverse": ["divide-y-reverse"],
        /**
         * Divide Opacity
         * @see https://tailwindcss.com/docs/divide-opacity
         */
        "divide-opacity": [{
          "divide-opacity": [opacity]
        }],
        /**
         * Divide Style
         * @see https://tailwindcss.com/docs/divide-style
         */
        "divide-style": [{
          divide: getLineStyles()
        }],
        /**
         * Border Color
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color": [{
          border: [borderColor]
        }],
        /**
         * Border Color X
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-x": [{
          "border-x": [borderColor]
        }],
        /**
         * Border Color Y
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-y": [{
          "border-y": [borderColor]
        }],
        /**
         * Border Color S
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-s": [{
          "border-s": [borderColor]
        }],
        /**
         * Border Color E
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-e": [{
          "border-e": [borderColor]
        }],
        /**
         * Border Color Top
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-t": [{
          "border-t": [borderColor]
        }],
        /**
         * Border Color Right
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-r": [{
          "border-r": [borderColor]
        }],
        /**
         * Border Color Bottom
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-b": [{
          "border-b": [borderColor]
        }],
        /**
         * Border Color Left
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-l": [{
          "border-l": [borderColor]
        }],
        /**
         * Divide Color
         * @see https://tailwindcss.com/docs/divide-color
         */
        "divide-color": [{
          divide: [borderColor]
        }],
        /**
         * Outline Style
         * @see https://tailwindcss.com/docs/outline-style
         */
        "outline-style": [{
          outline: ["", ...getLineStyles()]
        }],
        /**
         * Outline Offset
         * @see https://tailwindcss.com/docs/outline-offset
         */
        "outline-offset": [{
          "outline-offset": [isLength, isArbitraryValue]
        }],
        /**
         * Outline Width
         * @see https://tailwindcss.com/docs/outline-width
         */
        "outline-w": [{
          outline: [isLength, isArbitraryLength]
        }],
        /**
         * Outline Color
         * @see https://tailwindcss.com/docs/outline-color
         */
        "outline-color": [{
          outline: [colors]
        }],
        /**
         * Ring Width
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w": [{
          ring: getLengthWithEmptyAndArbitrary()
        }],
        /**
         * Ring Width Inset
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w-inset": ["ring-inset"],
        /**
         * Ring Color
         * @see https://tailwindcss.com/docs/ring-color
         */
        "ring-color": [{
          ring: [colors]
        }],
        /**
         * Ring Opacity
         * @see https://tailwindcss.com/docs/ring-opacity
         */
        "ring-opacity": [{
          "ring-opacity": [opacity]
        }],
        /**
         * Ring Offset Width
         * @see https://tailwindcss.com/docs/ring-offset-width
         */
        "ring-offset-w": [{
          "ring-offset": [isLength, isArbitraryLength]
        }],
        /**
         * Ring Offset Color
         * @see https://tailwindcss.com/docs/ring-offset-color
         */
        "ring-offset-color": [{
          "ring-offset": [colors]
        }],
        // Effects
        /**
         * Box Shadow
         * @see https://tailwindcss.com/docs/box-shadow
         */
        shadow: [{
          shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
        }],
        /**
         * Box Shadow Color
         * @see https://tailwindcss.com/docs/box-shadow-color
         */
        "shadow-color": [{
          shadow: [isAny]
        }],
        /**
         * Opacity
         * @see https://tailwindcss.com/docs/opacity
         */
        opacity: [{
          opacity: [opacity]
        }],
        /**
         * Mix Blend Mode
         * @see https://tailwindcss.com/docs/mix-blend-mode
         */
        "mix-blend": [{
          "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
        }],
        /**
         * Background Blend Mode
         * @see https://tailwindcss.com/docs/background-blend-mode
         */
        "bg-blend": [{
          "bg-blend": getBlendModes()
        }],
        // Filters
        /**
         * Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/filter
         */
        filter: [{
          filter: ["", "none"]
        }],
        /**
         * Blur
         * @see https://tailwindcss.com/docs/blur
         */
        blur: [{
          blur: [blur]
        }],
        /**
         * Brightness
         * @see https://tailwindcss.com/docs/brightness
         */
        brightness: [{
          brightness: [brightness]
        }],
        /**
         * Contrast
         * @see https://tailwindcss.com/docs/contrast
         */
        contrast: [{
          contrast: [contrast]
        }],
        /**
         * Drop Shadow
         * @see https://tailwindcss.com/docs/drop-shadow
         */
        "drop-shadow": [{
          "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
        }],
        /**
         * Grayscale
         * @see https://tailwindcss.com/docs/grayscale
         */
        grayscale: [{
          grayscale: [grayscale]
        }],
        /**
         * Hue Rotate
         * @see https://tailwindcss.com/docs/hue-rotate
         */
        "hue-rotate": [{
          "hue-rotate": [hueRotate]
        }],
        /**
         * Invert
         * @see https://tailwindcss.com/docs/invert
         */
        invert: [{
          invert: [invert]
        }],
        /**
         * Saturate
         * @see https://tailwindcss.com/docs/saturate
         */
        saturate: [{
          saturate: [saturate]
        }],
        /**
         * Sepia
         * @see https://tailwindcss.com/docs/sepia
         */
        sepia: [{
          sepia: [sepia]
        }],
        /**
         * Backdrop Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/backdrop-filter
         */
        "backdrop-filter": [{
          "backdrop-filter": ["", "none"]
        }],
        /**
         * Backdrop Blur
         * @see https://tailwindcss.com/docs/backdrop-blur
         */
        "backdrop-blur": [{
          "backdrop-blur": [blur]
        }],
        /**
         * Backdrop Brightness
         * @see https://tailwindcss.com/docs/backdrop-brightness
         */
        "backdrop-brightness": [{
          "backdrop-brightness": [brightness]
        }],
        /**
         * Backdrop Contrast
         * @see https://tailwindcss.com/docs/backdrop-contrast
         */
        "backdrop-contrast": [{
          "backdrop-contrast": [contrast]
        }],
        /**
         * Backdrop Grayscale
         * @see https://tailwindcss.com/docs/backdrop-grayscale
         */
        "backdrop-grayscale": [{
          "backdrop-grayscale": [grayscale]
        }],
        /**
         * Backdrop Hue Rotate
         * @see https://tailwindcss.com/docs/backdrop-hue-rotate
         */
        "backdrop-hue-rotate": [{
          "backdrop-hue-rotate": [hueRotate]
        }],
        /**
         * Backdrop Invert
         * @see https://tailwindcss.com/docs/backdrop-invert
         */
        "backdrop-invert": [{
          "backdrop-invert": [invert]
        }],
        /**
         * Backdrop Opacity
         * @see https://tailwindcss.com/docs/backdrop-opacity
         */
        "backdrop-opacity": [{
          "backdrop-opacity": [opacity]
        }],
        /**
         * Backdrop Saturate
         * @see https://tailwindcss.com/docs/backdrop-saturate
         */
        "backdrop-saturate": [{
          "backdrop-saturate": [saturate]
        }],
        /**
         * Backdrop Sepia
         * @see https://tailwindcss.com/docs/backdrop-sepia
         */
        "backdrop-sepia": [{
          "backdrop-sepia": [sepia]
        }],
        // Tables
        /**
         * Border Collapse
         * @see https://tailwindcss.com/docs/border-collapse
         */
        "border-collapse": [{
          border: ["collapse", "separate"]
        }],
        /**
         * Border Spacing
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing": [{
          "border-spacing": [borderSpacing]
        }],
        /**
         * Border Spacing X
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-x": [{
          "border-spacing-x": [borderSpacing]
        }],
        /**
         * Border Spacing Y
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-y": [{
          "border-spacing-y": [borderSpacing]
        }],
        /**
         * Table Layout
         * @see https://tailwindcss.com/docs/table-layout
         */
        "table-layout": [{
          table: ["auto", "fixed"]
        }],
        /**
         * Caption Side
         * @see https://tailwindcss.com/docs/caption-side
         */
        caption: [{
          caption: ["top", "bottom"]
        }],
        // Transitions and Animation
        /**
         * Tranisition Property
         * @see https://tailwindcss.com/docs/transition-property
         */
        transition: [{
          transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
        }],
        /**
         * Transition Duration
         * @see https://tailwindcss.com/docs/transition-duration
         */
        duration: [{
          duration: getNumberAndArbitrary()
        }],
        /**
         * Transition Timing Function
         * @see https://tailwindcss.com/docs/transition-timing-function
         */
        ease: [{
          ease: ["linear", "in", "out", "in-out", isArbitraryValue]
        }],
        /**
         * Transition Delay
         * @see https://tailwindcss.com/docs/transition-delay
         */
        delay: [{
          delay: getNumberAndArbitrary()
        }],
        /**
         * Animation
         * @see https://tailwindcss.com/docs/animation
         */
        animate: [{
          animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
        }],
        // Transforms
        /**
         * Transform
         * @see https://tailwindcss.com/docs/transform
         */
        transform: [{
          transform: ["", "gpu", "none"]
        }],
        /**
         * Scale
         * @see https://tailwindcss.com/docs/scale
         */
        scale: [{
          scale: [scale]
        }],
        /**
         * Scale X
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-x": [{
          "scale-x": [scale]
        }],
        /**
         * Scale Y
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-y": [{
          "scale-y": [scale]
        }],
        /**
         * Rotate
         * @see https://tailwindcss.com/docs/rotate
         */
        rotate: [{
          rotate: [isInteger, isArbitraryValue]
        }],
        /**
         * Translate X
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-x": [{
          "translate-x": [translate]
        }],
        /**
         * Translate Y
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-y": [{
          "translate-y": [translate]
        }],
        /**
         * Skew X
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-x": [{
          "skew-x": [skew]
        }],
        /**
         * Skew Y
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-y": [{
          "skew-y": [skew]
        }],
        /**
         * Transform Origin
         * @see https://tailwindcss.com/docs/transform-origin
         */
        "transform-origin": [{
          origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
        }],
        // Interactivity
        /**
         * Accent Color
         * @see https://tailwindcss.com/docs/accent-color
         */
        accent: [{
          accent: ["auto", colors]
        }],
        /**
         * Appearance
         * @see https://tailwindcss.com/docs/appearance
         */
        appearance: [{
          appearance: ["none", "auto"]
        }],
        /**
         * Cursor
         * @see https://tailwindcss.com/docs/cursor
         */
        cursor: [{
          cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
        }],
        /**
         * Caret Color
         * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
         */
        "caret-color": [{
          caret: [colors]
        }],
        /**
         * Pointer Events
         * @see https://tailwindcss.com/docs/pointer-events
         */
        "pointer-events": [{
          "pointer-events": ["none", "auto"]
        }],
        /**
         * Resize
         * @see https://tailwindcss.com/docs/resize
         */
        resize: [{
          resize: ["none", "y", "x", ""]
        }],
        /**
         * Scroll Behavior
         * @see https://tailwindcss.com/docs/scroll-behavior
         */
        "scroll-behavior": [{
          scroll: ["auto", "smooth"]
        }],
        /**
         * Scroll Margin
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-m": [{
          "scroll-m": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin X
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mx": [{
          "scroll-mx": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Y
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-my": [{
          "scroll-my": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Start
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ms": [{
          "scroll-ms": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin End
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-me": [{
          "scroll-me": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Top
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mt": [{
          "scroll-mt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Right
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mr": [{
          "scroll-mr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Bottom
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mb": [{
          "scroll-mb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Left
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ml": [{
          "scroll-ml": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-p": [{
          "scroll-p": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding X
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-px": [{
          "scroll-px": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Y
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-py": [{
          "scroll-py": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Start
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-ps": [{
          "scroll-ps": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding End
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pe": [{
          "scroll-pe": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Top
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pt": [{
          "scroll-pt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Right
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pr": [{
          "scroll-pr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Bottom
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pb": [{
          "scroll-pb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Left
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pl": [{
          "scroll-pl": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Snap Align
         * @see https://tailwindcss.com/docs/scroll-snap-align
         */
        "snap-align": [{
          snap: ["start", "end", "center", "align-none"]
        }],
        /**
         * Scroll Snap Stop
         * @see https://tailwindcss.com/docs/scroll-snap-stop
         */
        "snap-stop": [{
          snap: ["normal", "always"]
        }],
        /**
         * Scroll Snap Type
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-type": [{
          snap: ["none", "x", "y", "both"]
        }],
        /**
         * Scroll Snap Type Strictness
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-strictness": [{
          snap: ["mandatory", "proximity"]
        }],
        /**
         * Touch Action
         * @see https://tailwindcss.com/docs/touch-action
         */
        touch: [{
          touch: ["auto", "none", "manipulation"]
        }],
        /**
         * Touch Action X
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-x": [{
          "touch-pan": ["x", "left", "right"]
        }],
        /**
         * Touch Action Y
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-y": [{
          "touch-pan": ["y", "up", "down"]
        }],
        /**
         * Touch Action Pinch Zoom
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-pz": ["touch-pinch-zoom"],
        /**
         * User Select
         * @see https://tailwindcss.com/docs/user-select
         */
        select: [{
          select: ["none", "text", "all", "auto"]
        }],
        /**
         * Will Change
         * @see https://tailwindcss.com/docs/will-change
         */
        "will-change": [{
          "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
        }],
        // SVG
        /**
         * Fill
         * @see https://tailwindcss.com/docs/fill
         */
        fill: [{
          fill: [colors, "none"]
        }],
        /**
         * Stroke Width
         * @see https://tailwindcss.com/docs/stroke-width
         */
        "stroke-w": [{
          stroke: [isLength, isArbitraryLength, isArbitraryNumber]
        }],
        /**
         * Stroke
         * @see https://tailwindcss.com/docs/stroke
         */
        stroke: [{
          stroke: [colors, "none"]
        }],
        // Accessibility
        /**
         * Screen Readers
         * @see https://tailwindcss.com/docs/screen-readers
         */
        sr: ["sr-only", "not-sr-only"],
        /**
         * Forced Color Adjust
         * @see https://tailwindcss.com/docs/forced-color-adjust
         */
        "forced-color-adjust": [{
          "forced-color-adjust": ["auto", "none"]
        }]
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"]
      },
      conflictingClassGroupModifiers: {
        "font-size": ["leading"]
      }
    };
  };
  const mergeConfigs = (baseConfig, {
    cacheSize,
    prefix,
    separator,
    experimentalParseClassName,
    extend = {},
    override = {}
  }) => {
    overrideProperty(baseConfig, "cacheSize", cacheSize);
    overrideProperty(baseConfig, "prefix", prefix);
    overrideProperty(baseConfig, "separator", separator);
    overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
    for (const configKey in override) {
      overrideConfigProperties(baseConfig[configKey], override[configKey]);
    }
    for (const key in extend) {
      mergeConfigProperties(baseConfig[key], extend[key]);
    }
    return baseConfig;
  };
  const overrideProperty = (baseObject, overrideKey, overrideValue) => {
    if (overrideValue !== void 0) {
      baseObject[overrideKey] = overrideValue;
    }
  };
  const overrideConfigProperties = (baseObject, overrideObject) => {
    if (overrideObject) {
      for (const key in overrideObject) {
        overrideProperty(baseObject, key, overrideObject[key]);
      }
    }
  };
  const mergeConfigProperties = (baseObject, mergeObject) => {
    if (mergeObject) {
      for (const key in mergeObject) {
        const mergeValue = mergeObject[key];
        if (mergeValue !== void 0) {
          baseObject[key] = (baseObject[key] || []).concat(mergeValue);
        }
      }
    }
  };
  const extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
  const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  var ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false }, x$1 = (s) => s || void 0, N$1 = (...s) => x$1(y$1(s).filter(Boolean).join(" ")), R$1 = null, v$1 = {}, q = false, M$1 = (...s) => (b$1) => b$1.twMerge ? ((!R$1 || q) && (q = false, R$1 = u(v$1) ? twMerge : extendTailwindMerge({ ...v$1, extend: { theme: v$1.theme, classGroups: v$1.classGroups, conflictingClassGroupModifiers: v$1.conflictingClassGroupModifiers, conflictingClassGroups: v$1.conflictingClassGroups, ...v$1.extend } })), x$1(R$1(N$1(s)))) : N$1(s), _ = (s, b2) => {
    for (let e in b2) s.hasOwnProperty(e) ? s[e] = N$1(s[e], b2[e]) : s[e] = b2[e];
    return s;
  }, ce = (s, b$1) => {
    let { extend: e = null, slots: O2 = {}, variants: U2 = {}, compoundVariants: W = [], compoundSlots: C2 = [], defaultVariants: z2 = {} } = s, m = { ...ie, ...b$1 }, k = e != null && e.base ? N$1(e.base, s == null ? void 0 : s.base) : s == null ? void 0 : s.base, g$1$1 = e != null && e.variants && !u(e.variants) ? p$1(U2, e.variants) : U2, w2 = e != null && e.defaultVariants && !u(e.defaultVariants) ? { ...e.defaultVariants, ...z2 } : z2;
    !u(m.twMergeConfig) && !x$2(m.twMergeConfig, v$1) && (q = true, v$1 = m.twMergeConfig);
    let S2 = u(e == null ? void 0 : e.slots), T2 = u(O2) ? {} : { base: N$1(s == null ? void 0 : s.base, S2 && (e == null ? void 0 : e.base)), ...O2 }, j2 = S2 ? T2 : _({ ...e == null ? void 0 : e.slots }, u(T2) ? { base: s == null ? void 0 : s.base } : T2), h$1 = u(e == null ? void 0 : e.compoundVariants) ? W : a(e == null ? void 0 : e.compoundVariants, W), V2 = (l2) => {
      if (u(g$1$1) && u(O2) && S2) return M$1(k, l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m);
      if (h$1 && !Array.isArray(h$1)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
      if (C2 && !Array.isArray(C2)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof C2}`);
      let P2 = (a2, n, t = [], i2) => {
        let r2 = t;
        if (typeof n == "string") r2 = r2.concat(g$1(n).split(" ").map((o2) => `${a2}:${o2}`));
        else if (Array.isArray(n)) r2 = r2.concat(n.reduce((o2, c2) => o2.concat(`${a2}:${c2}`), []));
        else if (typeof n == "object" && typeof i2 == "string") {
          for (let o2 in n) if (n.hasOwnProperty(o2) && o2 === i2) {
            let c2 = n[o2];
            if (c2 && typeof c2 == "string") {
              let u2 = g$1(c2);
              r2[i2] ? r2[i2] = r2[i2].concat(u2.split(" ").map((f2) => `${a2}:${f2}`)) : r2[i2] = u2.split(" ").map((f2) => `${a2}:${f2}`);
            } else Array.isArray(c2) && c2.length > 0 && (r2[i2] = c2.reduce((u2, f2) => u2.concat(`${a2}:${f2}`), []));
          }
        }
        return r2;
      }, D2 = (a$1, n = g$1$1, t = null, i2 = null) => {
        var L2;
        let r2 = n[a$1];
        if (!r2 || u(r2)) return null;
        let o2 = (L2 = i2 == null ? void 0 : i2[a$1]) != null ? L2 : l2 == null ? void 0 : l2[a$1];
        if (o2 === null) return null;
        let c2 = l$1(o2), u$1 = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, f2 = w2 == null ? void 0 : w2[a$1], d2 = [];
        if (typeof c2 == "object" && u$1) for (let [E2, Q] of Object.entries(c2)) {
          let ne = r2[Q];
          if (E2 === "initial") {
            f2 = Q;
            continue;
          }
          Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(E2) || (d2 = P2(E2, ne, d2, t));
        }
        let $ = c2 != null && typeof c2 != "object" ? c2 : l$1(f2), A2 = r2[$ || "false"];
        return typeof d2 == "object" && typeof t == "string" && d2[t] ? _(d2, A2) : d2.length > 0 ? (d2.push(A2), t === "base" ? d2.join(" ") : d2) : A2;
      }, p2 = () => g$1$1 ? Object.keys(g$1$1).map((a2) => D2(a2, g$1$1)) : null, ee = (a2, n) => {
        if (!g$1$1 || typeof g$1$1 != "object") return null;
        let t = new Array();
        for (let i2 in g$1$1) {
          let r2 = D2(i2, g$1$1, a2, n), o2 = a2 === "base" && typeof r2 == "string" ? r2 : r2 && r2[a2];
          o2 && (t[t.length] = o2);
        }
        return t;
      }, H2 = {};
      for (let a2 in l2) l2[a2] !== void 0 && (H2[a2] = l2[a2]);
      let I2 = (a2, n) => {
        var i2;
        let t = typeof (l2 == null ? void 0 : l2[a2]) == "object" ? { [a2]: (i2 = l2[a2]) == null ? void 0 : i2.initial } : {};
        return { ...w2, ...H2, ...t, ...n };
      }, J2 = (a2 = [], n) => {
        let t = [];
        for (let { class: i2, className: r2, ...o2 } of a2) {
          let c2 = true;
          for (let [u2, f2] of Object.entries(o2)) {
            let d2 = I2(u2, n)[u2];
            if (Array.isArray(f2)) {
              if (!f2.includes(d2)) {
                c2 = false;
                break;
              }
            } else {
              let $ = (A2) => A2 == null || A2 === false;
              if ($(f2) && $(d2)) continue;
              if (d2 !== f2) {
                c2 = false;
                break;
              }
            }
          }
          c2 && (i2 && t.push(i2), r2 && t.push(r2));
        }
        return t;
      }, te = (a2) => {
        let n = J2(h$1, a2);
        if (!Array.isArray(n)) return n;
        let t = {};
        for (let i2 of n) if (typeof i2 == "string" && (t.base = M$1(t.base, i2)(m)), typeof i2 == "object") for (let [r2, o2] of Object.entries(i2)) t[r2] = M$1(t[r2], o2)(m);
        return t;
      }, ae = (a2) => {
        if (C2.length < 1) return null;
        let n = {};
        for (let { slots: t = [], class: i2, className: r2, ...o2 } of C2) {
          if (!u(o2)) {
            let c2 = true;
            for (let u2 of Object.keys(o2)) {
              let f2 = I2(u2, a2)[u2];
              if (f2 === void 0 || (Array.isArray(o2[u2]) ? !o2[u2].includes(f2) : o2[u2] !== f2)) {
                c2 = false;
                break;
              }
            }
            if (!c2) continue;
          }
          for (let c2 of t) n[c2] = n[c2] || [], n[c2].push([i2, r2]);
        }
        return n;
      };
      if (!u(O2) || !S2) {
        let a2 = {};
        if (typeof j2 == "object" && !u(j2)) for (let n of Object.keys(j2)) a2[n] = (t) => {
          var i2, r2;
          return M$1(j2[n], ee(n, t), ((i2 = te(t)) != null ? i2 : [])[n], ((r2 = ae(t)) != null ? r2 : [])[n], t == null ? void 0 : t.class, t == null ? void 0 : t.className)(m);
        };
        return a2;
      }
      return M$1(k, p2(), J2(h$1), l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m);
    }, K = () => {
      if (!(!g$1$1 || typeof g$1$1 != "object")) return Object.keys(g$1$1);
    };
    return V2.variantKeys = K(), V2.extend = e, V2.base = k, V2.slots = j2, V2.variants = g$1$1, V2.defaultVariants = w2, V2.compoundSlots = C2, V2.compoundVariants = h$1, V2;
  };
  function cn(...inputs) {
    return twMerge(clsx$1(inputs));
  }
  studyTable;
  mark_module_start();
  Button[FILENAME] = "src/lib/components/shadcn-ui/button/button.svelte";
  const buttonVariants = ce({
    base: "ring-offset-background focus-visible:ring-ring inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border-input bg-background hover:bg-accent hover:text-accent-foreground border",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: { variant: "default", size: "default" }
  });
  var root_1$7 = add_locations(/* @__PURE__ */ template(`<a><!></a>`), Button[FILENAME], [[56, 1]]);
  var root_2$q = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Button[FILENAME], [[60, 1]]);
  function Button($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Button);
    validate_prop_bindings($$props, ["ref"], [], Button);
    let variant = prop($$props, "variant", 3, "default"), size2 = prop($$props, "size", 3, "default"), ref = prop($$props, "ref", 15, null), href = prop($$props, "href", 3, void 0), type = prop($$props, "type", 3, "button"), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "class",
        "variant",
        "size",
        "ref",
        "href",
        "type",
        "children"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var a2 = root_1$7();
        let attributes;
        var node_1 = child(a2);
        snippet(node_1, () => $$props.children ?? noop$1);
        bind_this(a2, ($$value) => ref($$value), () => ref());
        template_effect(() => attributes = set_attributes(a2, attributes, {
          class: cn(buttonVariants({
            variant: variant(),
            size: size2(),
            className: $$props.class
          })),
          href: href(),
          ...restProps
        }));
        append($$anchor2, a2);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$q();
        let attributes_1;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1);
        bind_this(button, ($$value) => ref($$value), () => ref());
        template_effect(() => attributes_1 = set_attributes(button, attributes_1, {
          class: cn(buttonVariants({
            variant: variant(),
            size: size2(),
            className: $$props.class
          })),
          type: type(),
          ...restProps
        }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if (href()) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Button);
  studyTable;
  function isFunction$1(value) {
    return typeof value === "function";
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  const BoxSymbol = Symbol("box");
  const isWritableSymbol = Symbol("is-writable");
  function isBox(value) {
    return isObject(value) && BoxSymbol in value;
  }
  function isWritableBox(value) {
    return box.isBox(value) && isWritableSymbol in value;
  }
  function box(initialValue) {
    let current = state(proxy(initialValue));
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get$2(current);
      },
      set current(v2) {
        set(current, proxy(v2, null, current));
      }
    };
  }
  function boxWith(getter, setter) {
    const derived$1 = /* @__PURE__ */ derived(getter);
    if (setter) {
      return {
        [BoxSymbol]: true,
        [isWritableSymbol]: true,
        get current() {
          return get$2(derived$1);
        },
        set current(v2) {
          setter(v2);
        }
      };
    }
    return {
      [BoxSymbol]: true,
      get current() {
        return getter();
      }
    };
  }
  function boxFrom(value) {
    if (box.isBox(value)) return value;
    if (isFunction$1(value)) return box.with(value);
    return box(value);
  }
  function boxFlatten(boxes) {
    return Object.entries(boxes).reduce(
      (acc, [key, b2]) => {
        if (!box.isBox(b2)) {
          return Object.assign(acc, { [key]: b2 });
        }
        if (box.isWritableBox(b2)) {
          Object.defineProperty(acc, key, {
            get() {
              return b2.current;
            },
            set(v2) {
              b2.current = v2;
            }
          });
        } else {
          Object.defineProperty(acc, key, {
            get() {
              return b2.current;
            }
          });
        }
        return acc;
      },
      {}
    );
  }
  function toReadonlyBox(b2) {
    if (!box.isWritableBox(b2)) return b2;
    return {
      [BoxSymbol]: true,
      get current() {
        return b2.current;
      }
    };
  }
  box.from = boxFrom;
  box.with = boxWith;
  box.flatten = boxFlatten;
  box.readonly = toReadonlyBox;
  box.isBox = isBox;
  box.isWritableBox = isWritableBox;
  function composeHandlers(...handlers) {
    return function(e) {
      var _a2;
      for (const handler of handlers) {
        if (!handler)
          continue;
        if (e.defaultPrevented)
          return;
        if (typeof handler === "function") {
          handler.call(this, e);
        } else {
          (_a2 = handler.current) == null ? void 0 : _a2.call(this, e);
        }
      }
    };
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f2 = n.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d2 = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a2, k, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a2;
  }
  var cjs = {};
  var inlineStyleParser;
  var hasRequiredInlineStyleParser;
  function requireInlineStyleParser() {
    if (hasRequiredInlineStyleParser) return inlineStyleParser;
    hasRequiredInlineStyleParser = 1;
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    inlineStyleParser = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style) return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines) lineno += lines.length;
        var i2 = str.lastIndexOf(NEWLINE);
        column = ~i2 ? str.length - i2 : column + str.length;
      }
      function position() {
        var start = { line: lineno, column };
        return function(node) {
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) ;
        else {
          throw err;
        }
      }
      function match(re) {
        var m = re.exec(style);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c2;
        rules = rules || [];
        while (c2 = comment2()) {
          if (c2 !== false) {
            rules.push(c2);
          }
        }
        return rules;
      }
      function comment2() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
        var i2 = 2;
        while (EMPTY_STRING != style.charAt(i2) && (ASTERISK != style.charAt(i2) || FORWARD_SLASH != style.charAt(i2 + 1))) {
          ++i2;
        }
        i2 += 2;
        if (EMPTY_STRING === style.charAt(i2 - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i2 - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i2);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position();
        var prop2 = match(PROPERTY_REGEX);
        if (!prop2) return;
        comment2();
        if (!match(COLON_REGEX)) return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop2[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
    return inlineStyleParser;
  }
  var hasRequiredCjs;
  function requireCjs() {
    if (hasRequiredCjs) return cjs;
    hasRequiredCjs = 1;
    var __importDefault = cjs.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(cjs, "__esModule", { value: true });
    cjs.default = StyleToObject2;
    var inline_style_parser_1 = __importDefault(requireInlineStyleParser());
    function StyleToObject2(style, iterator) {
      var styleObject = null;
      if (!style || typeof style !== "string") {
        return styleObject;
      }
      var declarations = (0, inline_style_parser_1.default)(style);
      var hasIterator = typeof iterator === "function";
      declarations.forEach(function(declaration) {
        if (declaration.type !== "declaration") {
          return;
        }
        var property = declaration.property, value = declaration.value;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          styleObject = styleObject || {};
          styleObject[property] = value;
        }
      });
      return styleObject;
    }
    return cjs;
  }
  var cjsExports = requireCjs();
  const StyleToObject = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
  const parse = StyleToObject.default || StyleToObject;
  const NUMBER_CHAR_RE = /\d/;
  const STR_SPLITTERS = ["-", "_", "/", "."];
  function isUppercase(char = "") {
    if (NUMBER_CHAR_RE.test(char))
      return void 0;
    return char !== char.toLowerCase();
  }
  function splitByCase(str) {
    const parts = [];
    let buff = "";
    let previousUpper;
    let previousSplitter;
    for (const char of str) {
      const isSplitter = STR_SPLITTERS.includes(char);
      if (isSplitter === true) {
        parts.push(buff);
        buff = "";
        previousUpper = void 0;
        continue;
      }
      const isUpper = isUppercase(char);
      if (previousSplitter === false) {
        if (previousUpper === false && isUpper === true) {
          parts.push(buff);
          buff = char;
          previousUpper = isUpper;
          continue;
        }
        if (previousUpper === true && isUpper === false && buff.length > 1) {
          const lastChar = buff.at(-1);
          parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
          buff = lastChar + char;
          previousUpper = isUpper;
          continue;
        }
      }
      buff += char;
      previousUpper = isUpper;
      previousSplitter = isSplitter;
    }
    parts.push(buff);
    return parts;
  }
  function pascalCase(str) {
    if (!str)
      return "";
    return splitByCase(str).map((p2) => upperFirst(p2)).join("");
  }
  function camelCase(str) {
    return lowerFirst(pascalCase(str || ""));
  }
  function upperFirst(str) {
    return str ? str[0].toUpperCase() + str.slice(1) : "";
  }
  function lowerFirst(str) {
    return str ? str[0].toLowerCase() + str.slice(1) : "";
  }
  function cssToStyleObj(css) {
    if (!css)
      return {};
    const styleObj = {};
    function iterator(name, value) {
      if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
        styleObj[pascalCase(name)] = value;
        return;
      }
      if (name.startsWith("--")) {
        styleObj[name] = value;
        return;
      }
      styleObj[camelCase(name)] = value;
    }
    parse(css, iterator);
    return styleObj;
  }
  function executeCallbacks(...callbacks) {
    return (...args) => {
      for (const callback of callbacks) {
        if (typeof callback === "function") {
          callback(...args);
        }
      }
    };
  }
  function createParser(matcher, replacer) {
    const regex = RegExp(matcher, "g");
    return (str) => {
      if (typeof str !== "string") {
        throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
      }
      if (!str.match(regex))
        return str;
      return str.replace(regex, replacer);
    };
  }
  const camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
  function styleToCSS(styleObj) {
    if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
      throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
    }
    return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
  }
  function styleToString(style = {}) {
    return styleToCSS(style).replace("\n", " ");
  }
  const srOnlyStyles = {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0",
    transform: "translateX(-100%)"
  };
  const srOnlyStylesString = styleToString(srOnlyStyles);
  function isEventHandler(key) {
    var _a2;
    return key.length > 2 && key.startsWith("on") && key[2] === ((_a2 = key[2]) == null ? void 0 : _a2.toLowerCase());
  }
  function mergeProps(...args) {
    const result2 = { ...args[0] };
    for (let i2 = 1; i2 < args.length; i2++) {
      const props = args[i2];
      for (const key in props) {
        const a2 = result2[key];
        const b2 = props[key];
        const aIsFunction = typeof a2 === "function";
        const bIsFunction = typeof b2 === "function";
        if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
          const aHandler = a2;
          const bHandler = b2;
          result2[key] = composeHandlers(aHandler, bHandler);
        } else if (aIsFunction && bIsFunction) {
          result2[key] = executeCallbacks(a2, b2);
        } else if (key === "class" && typeof a2 === "string" && typeof b2 === "string") {
          result2[key] = clsx$1(a2, b2);
        } else if (key === "style") {
          const aIsObject = typeof a2 === "object";
          const bIsObject = typeof b2 === "object";
          const aIsString = typeof a2 === "string";
          const bIsString = typeof b2 === "string";
          if (aIsObject && bIsObject) {
            result2[key] = { ...a2, ...b2 };
          } else if (aIsObject && bIsString) {
            const parsedStyle = cssToStyleObj(b2);
            result2[key] = { ...a2, ...parsedStyle };
          } else if (aIsString && bIsObject) {
            const parsedStyle = cssToStyleObj(a2);
            result2[key] = { ...parsedStyle, ...b2 };
          } else if (aIsString && bIsString) {
            const parsedStyleA = cssToStyleObj(a2);
            const parsedStyleB = cssToStyleObj(b2);
            result2[key] = { ...parsedStyleA, ...parsedStyleB };
          } else if (aIsObject) {
            result2[key] = a2;
          } else if (bIsObject) {
            result2[key] = b2;
          }
        } else {
          result2[key] = b2 !== void 0 ? b2 : a2;
        }
      }
    }
    if (typeof result2.style === "object") {
      result2.style = styleToString(result2.style).replaceAll("\n", " ");
    }
    if (result2.hidden !== true) {
      result2.hidden = void 0;
    }
    if (result2.disabled !== true) {
      result2.disabled = void 0;
    }
    return result2;
  }
  function useRefById({
    id,
    ref,
    deps = () => true,
    onRefChange = () => {
    },
    getRootNode = () => strict_equals(typeof document, "undefined", false) ? document : void 0
  }) {
    const dependencies = /* @__PURE__ */ derived(() => deps());
    const rootNode = /* @__PURE__ */ derived(() => getRootNode());
    user_effect(() => {
      id.current;
      get$2(dependencies);
      get$2(rootNode);
      return untrack(() => {
        var _a2;
        const node = (_a2 = get$2(rootNode)) == null ? void 0 : _a2.getElementById(id.current);
        if (node) {
          ref.current = node;
        } else {
          ref.current = null;
        }
        onRefChange(ref.current);
      });
    });
    user_effect(() => {
      return () => {
        ref.current = null;
        onRefChange(null);
      };
    });
  }
  function onDestroyEffect(fn) {
    user_effect(() => {
      return () => {
        fn();
      };
    });
  }
  function afterSleep(ms, cb) {
    setTimeout(cb, ms);
  }
  function afterTick(fn) {
    tick().then(fn);
  }
  class Readable {
    constructor(initialValue, start) {
      __privateAdd(this, _Readable_instances);
      __privateAdd(this, _current, state());
      __privateAdd(this, _start);
      __privateAdd(this, _subscribers, 0);
      __privateAdd(this, _stop, null);
      __privateGet(this, _current).v = proxy(initialValue, null, __privateGet(this, _current));
      __privateSet(this, _start, start);
    }
    get current() {
      if (effect_tracking()) {
        user_effect(() => {
          __privateWrapper(this, _subscribers)._++;
          if (strict_equals(__privateGet(this, _subscribers), 1)) {
            __privateMethod(this, _Readable_instances, subscribe_fn).call(this, true);
          }
          return () => {
            tick().then(() => {
              __privateWrapper(this, _subscribers)._--;
              if (strict_equals(__privateGet(this, _subscribers), 0)) {
                __privateMethod(this, _Readable_instances, unsubscribe_fn).call(this);
              }
            });
          };
        });
      } else if (strict_equals(__privateGet(this, _subscribers), 0)) {
        __privateMethod(this, _Readable_instances, subscribe_fn).call(this, false);
        __privateMethod(this, _Readable_instances, unsubscribe_fn).call(this);
      }
      return get$2(__privateGet(this, _current));
    }
  }
  _current = new WeakMap();
  _start = new WeakMap();
  _subscribers = new WeakMap();
  _stop = new WeakMap();
  _Readable_instances = new WeakSet();
  subscribe_fn = function(inEffect) {
    __privateSet(this, _stop, __privateGet(this, _start).call(this, (value) => {
      set(__privateGet(this, _current), proxy(value, null, __privateGet(this, _current)));
    }, inEffect) ?? null);
  };
  unsubscribe_fn = function() {
    if (strict_equals(__privateGet(this, _stop), null)) return;
    __privateGet(this, _stop).call(this);
    __privateSet(this, _stop, null);
  };
  new Readable(null, (set2, insideEffect) => {
    function update2() {
      set2(document.activeElement);
    }
    update2();
    if (!insideEffect) return;
    document.addEventListener("focusin", update2);
    document.addEventListener("focusout", update2);
    return () => {
      document.removeEventListener("focusin", update2);
      document.removeEventListener("focusout", update2);
    };
  });
  function isFunction(value) {
    return typeof value === "function";
  }
  function get$1(value) {
    if (isFunction(value)) {
      return value();
    }
    return value;
  }
  class ElementSize {
    constructor(node, options = { box: "border-box" }) {
      __privateAdd(this, _size, state(proxy({ width: 0, height: 0 })));
      var _a2, _b2;
      __privateGet(this, _size).v = proxy(
        {
          width: ((_a2 = options.initialSize) == null ? void 0 : _a2.width) ?? 0,
          height: ((_b2 = options.initialSize) == null ? void 0 : _b2.height) ?? 0
        },
        null,
        __privateGet(this, _size)
      );
      user_effect(() => {
        const node$ = get$1(node);
        if (!node$) return;
        const observer = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const boxSize = strict_equals(options.box, "content-box") ? entry.contentBoxSize : entry.borderBoxSize;
            const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];
            get$2(__privateGet(this, _size)).width = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.inlineSize), 0);
            get$2(__privateGet(this, _size)).height = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.blockSize), 0);
          }
        });
        observer.observe(node$);
        return () => {
          observer.disconnect();
        };
      });
    }
    get width() {
      return get$2(__privateGet(this, _size)).width;
    }
    get height() {
      return get$2(__privateGet(this, _size)).height;
    }
  }
  _size = new WeakMap();
  function runEffect(flush, effect2) {
    switch (flush) {
      case "post":
        user_effect(effect2);
        break;
      case "pre":
        user_pre_effect(effect2);
        break;
    }
  }
  function runWatcher(sources, flush, effect2, options = {}) {
    const { lazy = false } = options;
    let active = !lazy;
    let previousValues = Array.isArray(sources) ? [] : void 0;
    runEffect(flush, () => {
      const values = Array.isArray(sources) ? sources.map((source2) => source2()) : sources();
      if (!active) {
        active = true;
        previousValues = values;
        return;
      }
      const cleanup = untrack(() => effect2(values, previousValues));
      previousValues = values;
      return cleanup;
    });
  }
  function watch(sources, effect2, options) {
    runWatcher(sources, "post", effect2, options);
  }
  function watchPre(sources, effect2, options) {
    runWatcher(sources, "pre", effect2, options);
  }
  watch.pre = watchPre;
  class Previous {
    constructor(getter) {
      __privateAdd(this, _previous, state());
      __privateAdd(this, _curr);
      user_effect(() => {
        set(__privateGet(this, _previous), proxy(__privateGet(this, _curr), null, __privateGet(this, _previous)));
        __privateSet(this, _curr, getter());
      });
    }
    get current() {
      return get$2(__privateGet(this, _previous));
    }
  }
  _previous = new WeakMap();
  _curr = new WeakMap();
  function increment(source2) {
    set(source2, source2.v + 1);
  }
  function getDataOpenClosed(condition) {
    return condition ? "open" : "closed";
  }
  function getDataChecked(condition) {
    return condition ? "checked" : "unchecked";
  }
  function getAriaDisabled(condition) {
    return condition ? "true" : "false";
  }
  function getAriaReadonly(condition) {
    return condition ? "true" : "false";
  }
  function getAriaExpanded(condition) {
    return condition ? "true" : "false";
  }
  function getDataDisabled(condition) {
    return condition ? "" : void 0;
  }
  function getAriaRequired(condition) {
    return condition ? "true" : "false";
  }
  function getAriaSelected(condition) {
    return condition ? "true" : "false";
  }
  function getAriaChecked(checked, indeterminate) {
    return checked ? "true" : "false";
  }
  function getAriaHidden(condition) {
    return condition ? "true" : void 0;
  }
  function getDataOrientation(orientation) {
    return orientation;
  }
  function getDataInvalid(condition) {
    return condition ? "" : void 0;
  }
  function getDataRequired(condition) {
    return condition ? "" : void 0;
  }
  function getDataReadonly(condition) {
    return condition ? "" : void 0;
  }
  function getDataSelected(condition) {
    return condition ? "" : void 0;
  }
  function getDataUnavailable(condition) {
    return condition ? "" : void 0;
  }
  function getDisabled(condition) {
    return condition ? true : void 0;
  }
  const ARROW_DOWN = "ArrowDown";
  const ARROW_LEFT = "ArrowLeft";
  const ARROW_RIGHT = "ArrowRight";
  const ARROW_UP = "ArrowUp";
  const ENTER = "Enter";
  const ESCAPE = "Escape";
  const SPACE = " ";
  const TAB = "Tab";
  const isBrowser = typeof document !== "undefined";
  const isIOS = getIsIOS();
  function getIsIOS() {
    var _a2, _b2;
    return isBrowser && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) && // eslint-disable-next-line regexp/no-unused-capturing-group
    (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
    ((_b2 = window == null ? void 0 : window.navigator) == null ? void 0 : _b2.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function isHTMLElement$1(element2) {
    return element2 instanceof HTMLElement;
  }
  function isElement$1(element2) {
    return element2 instanceof Element;
  }
  function isNotNull(value) {
    return value !== null;
  }
  function isSelectableInput(element2) {
    return element2 instanceof HTMLInputElement && "select" in element2;
  }
  function isElementHidden(node, stopAt) {
    if (getComputedStyle(node).visibility === "hidden")
      return true;
    while (node) {
      if (stopAt !== void 0 && node === stopAt)
        return false;
      if (getComputedStyle(node).display === "none")
        return true;
      node = node.parentElement;
    }
    return false;
  }
  function setContext(key, value) {
    return setContext$1(key, value);
  }
  function getContext(key, fallback) {
    const trueKey = typeof key === "symbol" ? key : key;
    const description = typeof key === "symbol" ? key.description : key;
    if (!hasContext(trueKey)) {
      if (fallback === void 0) {
        throw new Error(`Missing context dependency: ${description} and no fallback was provided.`);
      }
      return fallback;
    }
    return getContext$1(key);
  }
  function getSymbolDescription(providerComponentName, contextName) {
    if (contextName !== void 0)
      return contextName;
    if (typeof providerComponentName === "string" && contextName === void 0) {
      return `${providerComponentName}Context`;
    } else if (Array.isArray(providerComponentName) && contextName === void 0) {
      return `${providerComponentName[0]}Context`;
    } else {
      if (contextName !== void 0)
        return contextName;
      return `${providerComponentName}Context`;
    }
  }
  function createContext(providerComponentName, contextName, useSymbol = true) {
    const symbolDescription = getSymbolDescription(providerComponentName, contextName);
    const symbol = Symbol.for(`bits-ui.${symbolDescription}`);
    const key = symbolDescription;
    function getCtx(fallback) {
      const context = getContext(useSymbol ? symbol : key, fallback);
      if (context === void 0) {
        throw new Error(`Context \`${symbolDescription}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(", ")}` : `\`${providerComponentName}\``}`);
      }
      if (context === null)
        return context;
      return context;
    }
    function setCtx(value) {
      if (useSymbol) {
        return setContext(symbol, value);
      } else {
        return setContext(key, value);
      }
    }
    return [setCtx, getCtx];
  }
  const ACCORDION_TRIGGER_ATTR = "data-accordion-trigger";
  const ACCORDION_CONTENT_ATTR = "data-accordion-content";
  const ACCORDION_ITEM_ATTR = "data-accordion-item";
  const ACCORDION_HEADER_ATTR = "data-accordion-header";
  class AccordionItemState {
    constructor(props) {
      __privateAdd(this, _id);
      __privateAdd(this, _ref);
      __publicField(this, "value");
      __publicField(this, "disabled");
      __publicField(this, "root");
      __privateAdd(this, _isActive, /* @__PURE__ */ derived(() => this.root.includesItem(this.value.current)));
      __privateAdd(this, _isDisabled, /* @__PURE__ */ derived(() => this.disabled.current || this.root.disabled.current));
      __privateAdd(this, _props, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id).current,
        "data-state": getDataOpenClosed(this.isActive),
        "data-disabled": getDataDisabled(this.isDisabled),
        "data-orientation": getDataOrientation(this.root.orientation.current),
        [ACCORDION_ITEM_ATTR]: ""
      })));
      this.value = props.value;
      this.disabled = props.disabled;
      this.root = props.rootState;
      __privateSet(this, _id, props.id);
      __privateSet(this, _ref, props.ref);
      this.updateValue = this.updateValue.bind(this);
      useRefById({
        id: __privateGet(this, _id),
        ref: __privateGet(this, _ref),
        deps: () => this.isActive
      });
    }
    get isActive() {
      return get$2(__privateGet(this, _isActive));
    }
    set isActive(_2) {
      throw new Error("Cannot update a derived property ('isActive')");
    }
    get isDisabled() {
      return get$2(__privateGet(this, _isDisabled));
    }
    set isDisabled(_2) {
      throw new Error("Cannot update a derived property ('isDisabled')");
    }
    updateValue() {
      this.root.toggleItem(this.value.current);
    }
    get props() {
      return get$2(__privateGet(this, _props));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id = new WeakMap();
  _ref = new WeakMap();
  _isActive = new WeakMap();
  _isDisabled = new WeakMap();
  _props = new WeakMap();
  class AccordionTriggerState {
    constructor(props, itemState) {
      __privateAdd(this, _ref2);
      __privateAdd(this, _disabled);
      __privateAdd(this, _id2);
      __privateAdd(this, _root);
      __privateAdd(this, _itemState);
      __privateAdd(this, _isDisabled2, /* @__PURE__ */ derived(() => __privateGet(this, _disabled).current || __privateGet(this, _itemState).disabled.current || __privateGet(this, _root).disabled.current));
      __privateAdd(this, _props2, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id2).current,
        disabled: get$2(__privateGet(this, _isDisabled2)),
        "aria-expanded": getAriaExpanded(__privateGet(this, _itemState).isActive),
        "aria-disabled": getAriaDisabled(get$2(__privateGet(this, _isDisabled2))),
        "data-disabled": getDataDisabled(get$2(__privateGet(this, _isDisabled2))),
        "data-state": getDataOpenClosed(__privateGet(this, _itemState).isActive),
        "data-orientation": getDataOrientation(__privateGet(this, _root).orientation.current),
        [ACCORDION_TRIGGER_ATTR]: "",
        tabindex: 0,
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown
      })));
      __privateSet(this, _disabled, props.disabled);
      __privateSet(this, _itemState, itemState);
      __privateSet(this, _root, itemState.root);
      __privateSet(this, _id2, props.id);
      __privateSet(this, _ref2, props.ref);
      this.onkeydown = this.onkeydown.bind(this);
      this.onclick = this.onclick.bind(this);
      useRefById({ id: props.id, ref: __privateGet(this, _ref2) });
    }
    onclick(e) {
      if (get$2(__privateGet(this, _isDisabled2))) return;
      if (strict_equals(e.button, 0, false)) return e.preventDefault();
      __privateGet(this, _itemState).updateValue();
    }
    onkeydown(e) {
      if (get$2(__privateGet(this, _isDisabled2))) return;
      if (strict_equals(e.key, SPACE) || strict_equals(e.key, ENTER)) {
        e.preventDefault();
        __privateGet(this, _itemState).updateValue();
        return;
      }
      __privateGet(this, _root).rovingFocusGroup.handleKeydown(__privateGet(this, _ref2).current, e);
    }
    get props() {
      return get$2(__privateGet(this, _props2));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _ref2 = new WeakMap();
  _disabled = new WeakMap();
  _id2 = new WeakMap();
  _root = new WeakMap();
  _itemState = new WeakMap();
  _isDisabled2 = new WeakMap();
  _props2 = new WeakMap();
  class AccordionContentState {
    constructor(props, item) {
      __publicField(this, "item");
      __privateAdd(this, _ref3);
      __privateAdd(this, _id3);
      __privateAdd(this, _originalStyles);
      __privateAdd(this, _isMountAnimationPrevented, false);
      __privateAdd(this, _width, state(0));
      __privateAdd(this, _height, state(0));
      __privateAdd(this, _forceMount);
      __privateAdd(this, _present, /* @__PURE__ */ derived(() => __privateGet(this, _forceMount).current || this.item.isActive));
      __privateAdd(this, _snippetProps, /* @__PURE__ */ derived(() => ({ open: this.item.isActive })));
      __privateAdd(this, _props3, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id3).current,
        "data-state": getDataOpenClosed(this.item.isActive),
        "data-disabled": getDataDisabled(this.item.isDisabled),
        "data-orientation": getDataOrientation(this.item.root.orientation.current),
        [ACCORDION_CONTENT_ATTR]: "",
        style: {
          "--bits-accordion-content-height": `${get$2(__privateGet(this, _height))}px`,
          "--bits-accordion-content-width": `${get$2(__privateGet(this, _width))}px`
        }
      })));
      this.item = item;
      __privateSet(this, _forceMount, props.forceMount);
      __privateSet(this, _isMountAnimationPrevented, this.item.isActive);
      __privateSet(this, _id3, props.id);
      __privateSet(this, _ref3, props.ref);
      useRefById({ id: __privateGet(this, _id3), ref: __privateGet(this, _ref3) });
      user_pre_effect(() => {
        const rAF = requestAnimationFrame(() => {
          __privateSet(this, _isMountAnimationPrevented, false);
        });
        return () => {
          cancelAnimationFrame(rAF);
        };
      });
      watch([() => this.present, () => __privateGet(this, _ref3).current], ([_2, node]) => {
        if (!node) return;
        afterTick(() => {
          if (!__privateGet(this, _ref3).current) return;
          __privateSet(this, _originalStyles, __privateGet(this, _originalStyles) || {
            transitionDuration: node.style.transitionDuration,
            animationName: node.style.animationName
          });
          node.style.transitionDuration = "0s";
          node.style.animationName = "none";
          const rect = node.getBoundingClientRect();
          set(__privateGet(this, _height), proxy(rect.height, null, __privateGet(this, _height)));
          set(__privateGet(this, _width), proxy(rect.width, null, __privateGet(this, _width)));
          if (!__privateGet(this, _isMountAnimationPrevented)) {
            const { animationName, transitionDuration } = __privateGet(this, _originalStyles);
            node.style.transitionDuration = transitionDuration;
            node.style.animationName = animationName;
          }
        });
      });
    }
    get present() {
      return get$2(__privateGet(this, _present));
    }
    set present(_2) {
      throw new Error("Cannot update a derived property ('present')");
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props3));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _ref3 = new WeakMap();
  _id3 = new WeakMap();
  _originalStyles = new WeakMap();
  _isMountAnimationPrevented = new WeakMap();
  _width = new WeakMap();
  _height = new WeakMap();
  _forceMount = new WeakMap();
  _present = new WeakMap();
  _snippetProps = new WeakMap();
  _props3 = new WeakMap();
  class AccordionHeaderState {
    constructor(props, item) {
      __privateAdd(this, _id4);
      __privateAdd(this, _ref4);
      __privateAdd(this, _level);
      __privateAdd(this, _item);
      __privateAdd(this, _props4, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id4).current,
        role: "heading",
        "aria-level": __privateGet(this, _level).current,
        "data-heading-level": __privateGet(this, _level).current,
        "data-state": getDataOpenClosed(__privateGet(this, _item).isActive),
        "data-orientation": getDataOrientation(__privateGet(this, _item).root.orientation.current),
        [ACCORDION_HEADER_ATTR]: ""
      })));
      __privateSet(this, _level, props.level);
      __privateSet(this, _id4, props.id);
      __privateSet(this, _ref4, props.ref);
      useRefById({ id: __privateGet(this, _id4), ref: __privateGet(this, _ref4) });
      __privateSet(this, _item, item);
    }
    get props() {
      return get$2(__privateGet(this, _props4));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id4 = new WeakMap();
  _ref4 = new WeakMap();
  _level = new WeakMap();
  _item = new WeakMap();
  _props4 = new WeakMap();
  const [
    setAccordionRootContext,
    getAccordionRootContext
  ] = createContext("Accordion.Root");
  const [
    setAccordionItemContext,
    getAccordionItemContext
  ] = createContext("Accordion.Item");
  function useAccordionItem(props) {
    const rootState = getAccordionRootContext();
    return setAccordionItemContext(new AccordionItemState({ ...props, rootState }));
  }
  function useAccordionTrigger(props) {
    const item = getAccordionItemContext();
    return new AccordionTriggerState(props, item);
  }
  function useAccordionContent(props) {
    const item = getAccordionItemContext();
    return new AccordionContentState(props, item);
  }
  function useAccordionHeader(props) {
    const item = getAccordionItemContext();
    return new AccordionHeaderState(props, item);
  }
  globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = { current: 0 });
  function useId(prefix = "bits") {
    globalThis.bitsIdCounter.current++;
    return `${prefix}-${globalThis.bitsIdCounter.current}`;
  }
  function noop() {
  }
  mark_module_start();
  Accordion_item$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte";
  var root_2$p = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Accordion_item$1[FILENAME], [[33, 1]]);
  function Accordion_item$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_item$1);
    validate_prop_bindings($$props, ["ref"], [], Accordion_item$1);
    let id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "disabled",
        "value",
        "children",
        "child",
        "ref"
      ],
      "restProps"
    );
    const itemState = useAccordionItem({
      value: box.with(() => value()),
      disabled: box.with(() => disabled()),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, itemState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var div = root_2$p();
        let attributes;
        var node_2 = child(div);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_item$1);
  mark_module_start();
  Accordion_header[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte";
  var root_2$o = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Accordion_header[FILENAME], [[31, 1]]);
  function Accordion_header($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_header);
    validate_prop_bindings($$props, ["ref"], [], Accordion_header);
    let id = prop($$props, "id", 19, useId), level = prop($$props, "level", 3, 2), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "level",
        "children",
        "child",
        "ref"
      ],
      "restProps"
    );
    const headerState = useAccordionHeader({
      id: box.with(() => id()),
      level: box.with(() => level()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, headerState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var div = root_2$o();
        let attributes;
        var node_2 = child(div);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_header);
  mark_module_start();
  Accordion_trigger$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte";
  var root_2$n = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Accordion_trigger$1[FILENAME], [[31, 1]]);
  function Accordion_trigger$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_trigger$1);
    validate_prop_bindings($$props, ["ref"], [], Accordion_trigger$1);
    let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "disabled",
        "ref",
        "id",
        "children",
        "child"
      ],
      "restProps"
    );
    const triggerState = useAccordionTrigger({
      disabled: box.with(() => disabled()),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, triggerState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$n();
        let attributes;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(button, attributes, { type: "button", ...get$2(mergedProps) }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_trigger$1);
  function useStateMachine(initialState, machine) {
    const state2 = box(initialState);
    function reducer(event2) {
      const nextState = machine[state2.current][event2];
      return nextState ?? state2.current;
    }
    const dispatch = (event2) => {
      state2.current = reducer(event2);
    };
    return { state: state2, dispatch };
  }
  function usePresence(present, id) {
    let styles = state(proxy({}));
    let prevAnimationNameState = state("none");
    const initialState = present.current ? "mounted" : "unmounted";
    let node = state(null);
    const prevPresent = new Previous(() => present.current);
    user_effect(() => {
      if (!id.current) return;
      if (!present.current) return;
      afterTick(() => {
        set(node, proxy(document.getElementById(id.current), null, node));
      });
    });
    const { state: state$1, dispatch } = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" }
    });
    user_effect(() => {
      const currPresent = present.current;
      untrack(() => {
        if (!get$2(node)) {
          set(node, proxy(document.getElementById(id.current), null, node));
        }
        if (!get$2(node)) return;
        const hasPresentChanged = strict_equals(currPresent, prevPresent.current, false);
        if (!hasPresentChanged) return;
        const prevAnimationName = get$2(prevAnimationNameState);
        const currAnimationName = getAnimationName(get$2(node));
        if (currPresent) {
          dispatch("MOUNT");
        } else if (strict_equals(currAnimationName, "none") || strict_equals(get$2(styles).display, "none")) {
          dispatch("UNMOUNT");
        } else {
          const isAnimating = strict_equals(prevAnimationName, currAnimationName, false);
          if (prevPresent && isAnimating) {
            dispatch("ANIMATION_OUT");
          } else {
            dispatch("UNMOUNT");
          }
        }
      });
    });
    function handleAnimationEnd(event2) {
      if (!get$2(node)) {
        set(node, proxy(document.getElementById(id.current), null, node));
      }
      if (!get$2(node)) return;
      const currAnimationName = getAnimationName(get$2(node));
      const isCurrentAnimation = currAnimationName.includes(event2.animationName) || strict_equals(currAnimationName, "none");
      if (strict_equals(event2.target, get$2(node)) && isCurrentAnimation) {
        dispatch("ANIMATION_END");
      }
    }
    function handleAnimationStart(event2) {
      if (!get$2(node)) {
        set(node, proxy(document.getElementById(id.current), null, node));
      }
      if (!get$2(node)) return;
      if (strict_equals(event2.target, get$2(node))) {
        set(prevAnimationNameState, proxy(getAnimationName(get$2(node)), null, prevAnimationNameState));
      }
    }
    user_effect(() => {
      state$1.current;
      untrack(() => {
        if (!get$2(node)) {
          set(node, proxy(document.getElementById(id.current), null, node));
        }
        if (!get$2(node)) return;
        const currAnimationName = getAnimationName(get$2(node));
        set(prevAnimationNameState, proxy(strict_equals(state$1.current, "mounted") ? currAnimationName : "none", null, prevAnimationNameState));
      });
    });
    user_effect(() => {
      if (!get$2(node)) return;
      set(styles, proxy(getComputedStyle(get$2(node)), null, styles));
      get$2(node).addEventListener("animationstart", handleAnimationStart);
      get$2(node).addEventListener("animationcancel", handleAnimationEnd);
      get$2(node).addEventListener("animationend", handleAnimationEnd);
      return () => {
        var _a2, _b2, _c;
        (_a2 = get$2(node)) == null ? void 0 : _a2.removeEventListener("animationstart", handleAnimationStart);
        (_b2 = get$2(node)) == null ? void 0 : _b2.removeEventListener("animationcancel", handleAnimationEnd);
        (_c = get$2(node)) == null ? void 0 : _c.removeEventListener("animationend", handleAnimationEnd);
      };
    });
    const isPresentDerived = /* @__PURE__ */ derived(() => ["mounted", "unmountSuspended"].includes(state$1.current));
    return {
      get current() {
        return get$2(isPresentDerived);
      }
    };
  }
  function getAnimationName(node) {
    return node ? getComputedStyle(node).animationName || "none" : "none";
  }
  mark_module_start();
  Presence_layer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte";
  function Presence_layer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Presence_layer);
    validate_prop_bindings($$props, [], [], Presence_layer);
    const isPresent = usePresence(box.with(() => $$props.present), box.with(() => $$props.id));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.presence ?? noop$1, () => ({ present: isPresent }));
        append($$anchor2, fragment_1);
      };
      if_block(node, ($$render) => {
        if ($$props.forceMount || $$props.present || isPresent.current) $$render(consequent);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Presence_layer);
  mark_module_start();
  Accordion_content$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte";
  var root_3$4 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Accordion_content$1[FILENAME], [[38, 3]]);
  function Accordion_content$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_content$1);
    validate_prop_bindings($$props, ["ref"], [], Accordion_content$1);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "child",
        "ref",
        "id",
        "forceMount",
        "children"
      ],
      "restProps"
    );
    const contentState = useAccordionContent({
      forceMount: box.with(() => forceMount()),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    {
      const presence = wrap_snippet(Accordion_content$1, ($$anchor2, $$arg0) => {
        let present = () => $$arg0 == null ? void 0 : $$arg0().present;
        present();
        var fragment_1 = comment();
        const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, contentState.props, {
          hidden: forceMount() ? void 0 : !present().current
        }));
        get$2(mergedProps);
        var node = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            snippet(node_1, () => $$props.child, () => ({
              props: get$2(mergedProps),
              ...contentState.snippetProps
            }));
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var div = root_3$4();
            let attributes;
            var node_2 = child(div);
            snippet(node_2, () => $$props.children ?? noop$1);
            reset(div);
            template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
            append($$anchor3, div);
          };
          if_block(node, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      });
      Presence_layer($$anchor, {
        forceMount: true,
        get present() {
          return contentState.present;
        },
        get id() {
          return id();
        },
        presence,
        $$slots: { presence: true }
      });
    }
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_content$1);
  function createAttrs(variant) {
    return {
      content: `data-${variant}-content`,
      trigger: `data-${variant}-trigger`,
      overlay: `data-${variant}-overlay`,
      title: `data-${variant}-title`,
      description: `data-${variant}-description`,
      close: `data-${variant}-close`,
      cancel: `data-${variant}-cancel`,
      action: `data-${variant}-action`
    };
  }
  class DialogRootState {
    constructor(props) {
      __publicField(this, "open");
      __publicField(this, "variant");
      __privateAdd(this, _triggerNode, state(null));
      __privateAdd(this, _titleNode, state(null));
      __privateAdd(this, _contentNode, state(null));
      __privateAdd(this, _descriptionNode, state(null));
      __privateAdd(this, _contentId, state(void 0));
      __privateAdd(this, _titleId, state(void 0));
      __privateAdd(this, _triggerId, state(void 0));
      __privateAdd(this, _descriptionId, state(void 0));
      __privateAdd(this, _cancelNode, state(null));
      __privateAdd(this, _attrs, /* @__PURE__ */ derived(() => createAttrs(this.variant.current)));
      __privateAdd(this, _sharedProps, /* @__PURE__ */ derived(() => ({
        "data-state": getDataOpenClosed(this.open.current)
      })));
      this.open = props.open;
      this.variant = props.variant;
      this.handleOpen = this.handleOpen.bind(this);
      this.handleClose = this.handleClose.bind(this);
    }
    get triggerNode() {
      return get$2(__privateGet(this, _triggerNode));
    }
    set triggerNode(value) {
      set(__privateGet(this, _triggerNode), proxy(value, null, __privateGet(this, _triggerNode)));
    }
    get titleNode() {
      return get$2(__privateGet(this, _titleNode));
    }
    set titleNode(value) {
      set(__privateGet(this, _titleNode), proxy(value, null, __privateGet(this, _titleNode)));
    }
    get contentNode() {
      return get$2(__privateGet(this, _contentNode));
    }
    set contentNode(value) {
      set(__privateGet(this, _contentNode), proxy(value, null, __privateGet(this, _contentNode)));
    }
    get descriptionNode() {
      return get$2(__privateGet(this, _descriptionNode));
    }
    set descriptionNode(value) {
      set(__privateGet(this, _descriptionNode), proxy(value, null, __privateGet(this, _descriptionNode)));
    }
    get contentId() {
      return get$2(__privateGet(this, _contentId));
    }
    set contentId(value) {
      set(__privateGet(this, _contentId), proxy(value, null, __privateGet(this, _contentId)));
    }
    get titleId() {
      return get$2(__privateGet(this, _titleId));
    }
    set titleId(value) {
      set(__privateGet(this, _titleId), proxy(value, null, __privateGet(this, _titleId)));
    }
    get triggerId() {
      return get$2(__privateGet(this, _triggerId));
    }
    set triggerId(value) {
      set(__privateGet(this, _triggerId), proxy(value, null, __privateGet(this, _triggerId)));
    }
    get descriptionId() {
      return get$2(__privateGet(this, _descriptionId));
    }
    set descriptionId(value) {
      set(__privateGet(this, _descriptionId), proxy(value, null, __privateGet(this, _descriptionId)));
    }
    get cancelNode() {
      return get$2(__privateGet(this, _cancelNode));
    }
    set cancelNode(value) {
      set(__privateGet(this, _cancelNode), proxy(value, null, __privateGet(this, _cancelNode)));
    }
    get attrs() {
      return get$2(__privateGet(this, _attrs));
    }
    set attrs(_2) {
      throw new Error("Cannot update a derived property ('attrs')");
    }
    handleOpen() {
      if (this.open.current) return;
      this.open.current = true;
    }
    handleClose() {
      if (!this.open.current) return;
      this.open.current = false;
    }
    get sharedProps() {
      return get$2(__privateGet(this, _sharedProps));
    }
    set sharedProps(_2) {
      throw new Error("Cannot update a derived property ('sharedProps')");
    }
    [ADD_OWNER](owner) {
      add_owner(get$2(__privateGet(this, _triggerNode)), owner, false);
      add_owner(get$2(__privateGet(this, _titleNode)), owner, false);
      add_owner(get$2(__privateGet(this, _contentNode)), owner, false);
      add_owner(get$2(__privateGet(this, _descriptionNode)), owner, false);
      add_owner(get$2(__privateGet(this, _contentId)), owner, false);
      add_owner(get$2(__privateGet(this, _titleId)), owner, false);
      add_owner(get$2(__privateGet(this, _triggerId)), owner, false);
      add_owner(get$2(__privateGet(this, _descriptionId)), owner, false);
      add_owner(get$2(__privateGet(this, _cancelNode)), owner, false);
    }
  }
  _triggerNode = new WeakMap();
  _titleNode = new WeakMap();
  _contentNode = new WeakMap();
  _descriptionNode = new WeakMap();
  _contentId = new WeakMap();
  _titleId = new WeakMap();
  _triggerId = new WeakMap();
  _descriptionId = new WeakMap();
  _cancelNode = new WeakMap();
  _attrs = new WeakMap();
  _sharedProps = new WeakMap();
  class DialogTriggerState {
    constructor(props, root2) {
      __privateAdd(this, _id5);
      __privateAdd(this, _ref5);
      __privateAdd(this, _root2);
      __privateAdd(this, _disabled2);
      __publicField(this, "onclick", (e) => {
        if (__privateGet(this, _disabled2).current) return;
        if (e.button > 0) return;
        __privateGet(this, _root2).handleOpen();
      });
      __publicField(this, "onpointerdown", (e) => {
        if (__privateGet(this, _disabled2).current) return;
        if (e.button > 0) return;
        e.preventDefault();
      });
      __publicField(this, "onkeydown", (e) => {
        if (__privateGet(this, _disabled2).current) return;
        if (strict_equals(e.key, SPACE) || strict_equals(e.key, ENTER)) {
          e.preventDefault();
          __privateGet(this, _root2).handleOpen();
        }
      });
      __privateAdd(this, _props5, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id5).current,
        "aria-haspopup": "dialog",
        "aria-expanded": getAriaExpanded(__privateGet(this, _root2).open.current),
        "aria-controls": __privateGet(this, _root2).contentId,
        [__privateGet(this, _root2).attrs.trigger]: "",
        onpointerdown: this.onpointerdown,
        onkeydown: this.onkeydown,
        onclick: this.onclick,
        ...__privateGet(this, _root2).sharedProps
      })));
      __privateSet(this, _id5, props.id);
      __privateSet(this, _root2, root2);
      __privateSet(this, _ref5, props.ref);
      __privateSet(this, _disabled2, props.disabled);
      this.onclick = this.onclick.bind(this);
      this.onpointerdown = this.onpointerdown.bind(this);
      this.onkeydown = this.onkeydown.bind(this);
      useRefById({
        id: __privateGet(this, _id5),
        ref: __privateGet(this, _ref5),
        onRefChange: (node) => {
          __privateGet(this, _root2).triggerNode = node;
          __privateGet(this, _root2).triggerId = node == null ? void 0 : node.id;
        }
      });
    }
    get props() {
      return get$2(__privateGet(this, _props5));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id5 = new WeakMap();
  _ref5 = new WeakMap();
  _root2 = new WeakMap();
  _disabled2 = new WeakMap();
  _props5 = new WeakMap();
  class DialogCloseState {
    constructor(props, root2) {
      __privateAdd(this, _id6);
      __privateAdd(this, _ref6);
      __privateAdd(this, _root3);
      __privateAdd(this, _variant);
      __privateAdd(this, _disabled3);
      __privateAdd(this, _attr, /* @__PURE__ */ derived(() => __privateGet(this, _root3).attrs[__privateGet(this, _variant).current]));
      __privateAdd(this, _props6, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id6).current,
        [get$2(__privateGet(this, _attr))]: "",
        onpointerdown: this.onpointerdown,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...__privateGet(this, _root3).sharedProps
      })));
      __privateSet(this, _root3, root2);
      __privateSet(this, _ref6, props.ref);
      __privateSet(this, _id6, props.id);
      __privateSet(this, _variant, props.variant);
      __privateSet(this, _disabled3, props.disabled);
      this.onclick = this.onclick.bind(this);
      this.onpointerdown = this.onpointerdown.bind(this);
      this.onkeydown = this.onkeydown.bind(this);
      useRefById({
        id: __privateGet(this, _id6),
        ref: __privateGet(this, _ref6),
        deps: () => __privateGet(this, _root3).open.current
      });
    }
    onclick(e) {
      if (__privateGet(this, _disabled3).current) return;
      if (e.button > 0) return;
      __privateGet(this, _root3).handleClose();
    }
    onpointerdown(e) {
      if (__privateGet(this, _disabled3).current) return;
      if (e.button > 0) return;
      e.preventDefault();
      __privateGet(this, _root3).handleClose();
    }
    onkeydown(e) {
      if (__privateGet(this, _disabled3).current) return;
      if (strict_equals(e.key, SPACE) || strict_equals(e.key, ENTER)) {
        e.preventDefault();
        __privateGet(this, _root3).handleClose();
      }
    }
    get props() {
      return get$2(__privateGet(this, _props6));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id6 = new WeakMap();
  _ref6 = new WeakMap();
  _root3 = new WeakMap();
  _variant = new WeakMap();
  _disabled3 = new WeakMap();
  _attr = new WeakMap();
  _props6 = new WeakMap();
  class DialogTitleState {
    constructor(props, root2) {
      __privateAdd(this, _id7);
      __privateAdd(this, _ref7);
      __privateAdd(this, _root4);
      __privateAdd(this, _level2);
      __privateAdd(this, _props7, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id7).current,
        role: "heading",
        "aria-level": __privateGet(this, _level2).current,
        [__privateGet(this, _root4).attrs.title]: "",
        ...__privateGet(this, _root4).sharedProps
      })));
      __privateSet(this, _id7, props.id);
      __privateSet(this, _root4, root2);
      __privateSet(this, _ref7, props.ref);
      __privateSet(this, _level2, props.level);
      useRefById({
        id: __privateGet(this, _id7),
        ref: __privateGet(this, _ref7),
        onRefChange: (node) => {
          __privateGet(this, _root4).titleNode = node;
          __privateGet(this, _root4).titleId = node == null ? void 0 : node.id;
        },
        deps: () => __privateGet(this, _root4).open.current
      });
    }
    get props() {
      return get$2(__privateGet(this, _props7));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id7 = new WeakMap();
  _ref7 = new WeakMap();
  _root4 = new WeakMap();
  _level2 = new WeakMap();
  _props7 = new WeakMap();
  class DialogDescriptionState {
    constructor(props, root2) {
      __privateAdd(this, _id8);
      __privateAdd(this, _ref8);
      __privateAdd(this, _root5);
      __privateAdd(this, _props8, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id8).current,
        [__privateGet(this, _root5).attrs.description]: "",
        ...__privateGet(this, _root5).sharedProps
      })));
      __privateSet(this, _id8, props.id);
      __privateSet(this, _root5, root2);
      __privateSet(this, _ref8, props.ref);
      useRefById({
        id: __privateGet(this, _id8),
        ref: __privateGet(this, _ref8),
        deps: () => __privateGet(this, _root5).open.current,
        onRefChange: (node) => {
          __privateGet(this, _root5).descriptionNode = node;
          __privateGet(this, _root5).descriptionId = node == null ? void 0 : node.id;
        }
      });
    }
    get props() {
      return get$2(__privateGet(this, _props8));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id8 = new WeakMap();
  _ref8 = new WeakMap();
  _root5 = new WeakMap();
  _props8 = new WeakMap();
  class DialogContentState {
    constructor(props, root2) {
      __privateAdd(this, _id9);
      __privateAdd(this, _ref9);
      __publicField(this, "root");
      __privateAdd(this, _snippetProps2, /* @__PURE__ */ derived(() => ({ open: this.root.open.current })));
      __privateAdd(this, _props9, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id9).current,
        role: strict_equals(this.root.variant.current, "alert-dialog") ? "alertdialog" : "dialog",
        "aria-describedby": this.root.descriptionId,
        "aria-labelledby": this.root.titleId,
        [this.root.attrs.content]: "",
        style: { pointerEvents: "auto" },
        ...this.root.sharedProps
      })));
      __privateSet(this, _id9, props.id);
      this.root = root2;
      __privateSet(this, _ref9, props.ref);
      useRefById({
        id: __privateGet(this, _id9),
        ref: __privateGet(this, _ref9),
        deps: () => this.root.open.current,
        onRefChange: (node) => {
          this.root.contentNode = node;
          this.root.contentId = node == null ? void 0 : node.id;
        }
      });
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps2));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props9));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id9 = new WeakMap();
  _ref9 = new WeakMap();
  _snippetProps2 = new WeakMap();
  _props9 = new WeakMap();
  class DialogOverlayState {
    constructor(props, root2) {
      __privateAdd(this, _id10);
      __privateAdd(this, _ref10);
      __publicField(this, "root");
      __privateAdd(this, _snippetProps3, /* @__PURE__ */ derived(() => ({ open: this.root.open.current })));
      __privateAdd(this, _props10, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id10).current,
        [this.root.attrs.overlay]: "",
        style: { pointerEvents: "auto" },
        ...this.root.sharedProps
      })));
      __privateSet(this, _id10, props.id);
      __privateSet(this, _ref10, props.ref);
      this.root = root2;
      useRefById({
        id: __privateGet(this, _id10),
        ref: __privateGet(this, _ref10),
        deps: () => this.root.open.current
      });
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps3));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props10));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id10 = new WeakMap();
  _ref10 = new WeakMap();
  _snippetProps3 = new WeakMap();
  _props10 = new WeakMap();
  const [setDialogRootContext, getDialogRootContext] = createContext("Dialog.Root");
  function useDialogRoot(props) {
    return setDialogRootContext(new DialogRootState(props));
  }
  function useDialogTrigger(props) {
    const root2 = getDialogRootContext();
    return new DialogTriggerState(props, root2);
  }
  function useDialogTitle(props) {
    return new DialogTitleState(props, getDialogRootContext());
  }
  function useDialogContent(props) {
    return new DialogContentState(props, getDialogRootContext());
  }
  function useDialogOverlay(props) {
    return new DialogOverlayState(props, getDialogRootContext());
  }
  function useDialogDescription(props) {
    return new DialogDescriptionState(props, getDialogRootContext());
  }
  function useDialogClose(props) {
    return new DialogCloseState(props, getDialogRootContext());
  }
  mark_module_start();
  Dialog_title$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte";
  var root_2$m = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Dialog_title$1[FILENAME], [[31, 1]]);
  function Dialog_title$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_title$1);
    validate_prop_bindings($$props, ["ref"], [], Dialog_title$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), level = prop($$props, "level", 3, 2), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "ref",
        "child",
        "children",
        "level"
      ],
      "restProps"
    );
    const titleState = useDialogTitle({
      id: box.with(() => id()),
      level: box.with(() => level()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, titleState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var div = root_2$m();
        let attributes;
        var node_2 = child(div);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_title$1);
  mark_module_start();
  Portal_consumer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte";
  function Portal_consumer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Portal_consumer);
    validate_prop_bindings($$props, [], [], Portal_consumer);
    var fragment = comment();
    var node = first_child(fragment);
    key_block(node, () => $$props.children, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop$1);
      append($$anchor2, fragment_1);
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Portal_consumer);
  mark_module_start();
  Portal$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte";
  function Portal$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Portal$1);
    validate_prop_bindings($$props, [], [], Portal$1);
    let to = prop($$props, "to", 3, "body");
    const context = getAllContexts();
    let target = /* @__PURE__ */ derived(getTarget);
    function getTarget() {
      if (!isBrowser || $$props.disabled) return null;
      let localTarget = null;
      if (strict_equals(typeof to(), "string")) {
        localTarget = document.querySelector(to());
        if (strict_equals(localTarget, null)) {
          {
            throw new Error(`Target element "${to()}" not found.`);
          }
        }
      } else if (to() instanceof HTMLElement || to() instanceof DocumentFragment) {
        localTarget = to();
      } else {
        {
          throw new TypeError(`Unknown portal target type: ${strict_equals(to(), null) ? "null" : typeof to()}. Allowed types: string (query selector), HTMLElement, or DocumentFragment.`);
        }
      }
      return localTarget;
    }
    let instance;
    user_effect(() => {
      if (!get$2(target) || $$props.disabled) {
        if (instance) {
          unmount(instance);
          instance = null;
        }
        return;
      }
      untrack(() => instance = mount(Portal_consumer, {
        target: get$2(target),
        props: { children: $$props.children },
        context
      }));
      return () => {
        if (instance) {
          unmount(instance);
          instance = null;
        }
      };
    });
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop$1);
        append($$anchor2, fragment_1);
      };
      if_block(node, ($$render) => {
        if ($$props.disabled) $$render(consequent);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Portal$1);
  function addEventListener$1(target, event2, handler, options) {
    const events = Array.isArray(event2) ? event2 : [event2];
    events.forEach((_event) => target.addEventListener(_event, handler, options));
    return () => {
      events.forEach((_event) => target.removeEventListener(_event, handler, options));
    };
  }
  function debounce(fn, wait = 500) {
    let timeout = null;
    const debounced = (...args) => {
      if (timeout !== null) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        fn(...args);
      }, wait);
    };
    debounced.destroy = () => {
      if (timeout !== null) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }
  function isOrContainsTarget(node, target) {
    return node === target || node.contains(target);
  }
  function getOwnerDocument(el) {
    return (el == null ? void 0 : el.ownerDocument) ?? document;
  }
  globalThis.bitsDismissableLayers ?? (globalThis.bitsDismissableLayers = /* @__PURE__ */ new Map());
  class DismissibleLayerState {
    constructor(props) {
      __privateAdd(this, _DismissibleLayerState_instances);
      __privateAdd(this, _interactOutsideProp);
      __privateAdd(this, _behaviorType);
      __privateAdd(this, _interceptedEvents, { pointerdown: false });
      __privateAdd(this, _isResponsibleLayer, false);
      __publicField(this, "node", box(null));
      __privateAdd(this, _documentObj);
      __privateAdd(this, _enabled);
      __privateAdd(this, _isFocusInsideDOMTree, state(false));
      __privateAdd(this, _onFocusOutside);
      __privateAdd(this, _currNode, state(null));
      __privateAdd(this, _isValidEventProp);
      __privateAdd(this, _unsubClickListener, noop);
      __privateAdd(this, _handleFocus, (event2) => {
        if (event2.defaultPrevented) return;
        if (!this.currNode) return;
        afterTick(() => {
          var _a2, _b2;
          if (!this.currNode || __privateGet(this, _isTargetWithinLayer).call(this, event2.target)) return;
          if (event2.target && !get$2(__privateGet(this, _isFocusInsideDOMTree))) {
            (_b2 = (_a2 = __privateGet(this, _onFocusOutside)).current) == null ? void 0 : _b2.call(_a2, event2);
          }
        });
      });
      __privateAdd(this, _handleDismiss, (e) => {
        let event2 = e;
        if (event2.defaultPrevented) {
          event2 = createWrappedEvent(e);
        }
        __privateGet(this, _interactOutsideProp).current(e);
      });
      __privateAdd(this, _handleInteractOutside, debounce(
        (e) => {
          if (!this.currNode) {
            __privateGet(this, _unsubClickListener).call(this);
            return;
          }
          const isEventValid = __privateGet(this, _isValidEventProp).current(e, this.currNode) || isValidEvent(e, this.currNode);
          if (!__privateGet(this, _isResponsibleLayer) || __privateMethod(this, _DismissibleLayerState_instances, isAnyEventIntercepted_fn).call(this) || !isEventValid) {
            __privateGet(this, _unsubClickListener).call(this);
            return;
          }
          let event2 = e;
          if (event2.defaultPrevented) {
            event2 = createWrappedEvent(event2);
          }
          if (strict_equals(__privateGet(this, _behaviorType).current, "close", false) && strict_equals(__privateGet(this, _behaviorType).current, "defer-otherwise-close", false)) {
            __privateGet(this, _unsubClickListener).call(this);
            return;
          }
          if (strict_equals(e.pointerType, "touch")) {
            __privateGet(this, _unsubClickListener).call(this);
            __privateSet(this, _unsubClickListener, addEventListener$1(__privateGet(this, _documentObj), "click", __privateGet(this, _handleDismiss), { once: true }));
          } else {
            __privateGet(this, _interactOutsideProp).current(event2);
          }
        },
        10
      ));
      __privateAdd(this, _markInterceptedEvent, (e) => {
        __privateGet(this, _interceptedEvents)[e.type] = true;
      });
      __privateAdd(this, _markNonInterceptedEvent, (e) => {
        __privateGet(this, _interceptedEvents)[e.type] = false;
      });
      __privateAdd(this, _markResponsibleLayer, () => {
        if (!this.node.current) return;
        __privateSet(this, _isResponsibleLayer, isResponsibleLayer(this.node.current));
      });
      __privateAdd(this, _isTargetWithinLayer, (target) => {
        if (!this.node.current) return false;
        return isOrContainsTarget(this.node.current, target);
      });
      __privateAdd(this, _resetState, debounce(
        () => {
          for (const eventType in __privateGet(this, _interceptedEvents)) {
            __privateGet(this, _interceptedEvents)[eventType] = false;
          }
          __privateSet(this, _isResponsibleLayer, false);
        },
        20
      ));
      __privateAdd(this, _onfocuscapture, () => {
        set(__privateGet(this, _isFocusInsideDOMTree), true);
      });
      __privateAdd(this, _onblurcapture, () => {
        set(__privateGet(this, _isFocusInsideDOMTree), false);
      });
      __publicField(this, "props", {
        onfocuscapture: __privateGet(this, _onfocuscapture),
        onblurcapture: __privateGet(this, _onblurcapture)
      });
      __privateSet(this, _enabled, props.enabled);
      __privateSet(this, _isValidEventProp, props.isValidEvent);
      useRefById({
        id: props.id,
        ref: this.node,
        deps: () => __privateGet(this, _enabled).current,
        onRefChange: (node) => {
          this.currNode = node;
        }
      });
      __privateSet(this, _behaviorType, props.interactOutsideBehavior);
      __privateSet(this, _interactOutsideProp, props.onInteractOutside);
      __privateSet(this, _onFocusOutside, props.onFocusOutside);
      user_effect(() => {
        __privateSet(this, _documentObj, getOwnerDocument(this.currNode));
      });
      let unsubEvents = noop;
      const cleanup = () => {
        __privateGet(this, _resetState).call(this);
        globalThis.bitsDismissableLayers.delete(this);
        __privateGet(this, _handleInteractOutside).destroy();
        unsubEvents();
      };
      user_effect(() => {
        if (__privateGet(this, _enabled).current && this.currNode) {
          afterSleep(1, () => {
            if (!this.currNode) return;
            globalThis.bitsDismissableLayers.set(this, untrack(() => __privateGet(this, _behaviorType)));
            unsubEvents();
            unsubEvents = __privateMethod(this, _DismissibleLayerState_instances, addEventListeners_fn).call(this);
          });
        }
        return () => {
          cleanup();
        };
      });
      onDestroyEffect(() => {
        __privateGet(this, _resetState).destroy();
        globalThis.bitsDismissableLayers.delete(this);
        __privateGet(this, _handleInteractOutside).destroy();
        __privateGet(this, _unsubClickListener).call(this);
        unsubEvents();
      });
    }
    get currNode() {
      return get$2(__privateGet(this, _currNode));
    }
    set currNode(value) {
      set(__privateGet(this, _currNode), proxy(value, null, __privateGet(this, _currNode)));
    }
    [ADD_OWNER](owner) {
      add_owner(get$2(__privateGet(this, _currNode)), owner, false);
    }
  }
  _interactOutsideProp = new WeakMap();
  _behaviorType = new WeakMap();
  _interceptedEvents = new WeakMap();
  _isResponsibleLayer = new WeakMap();
  _documentObj = new WeakMap();
  _enabled = new WeakMap();
  _isFocusInsideDOMTree = new WeakMap();
  _onFocusOutside = new WeakMap();
  _currNode = new WeakMap();
  _isValidEventProp = new WeakMap();
  _unsubClickListener = new WeakMap();
  _handleFocus = new WeakMap();
  _DismissibleLayerState_instances = new WeakSet();
  addEventListeners_fn = function() {
    return executeCallbacks(
      /**
      * CAPTURE INTERACTION START
      * mark interaction-start event as intercepted.
      * mark responsible layer during interaction start
      * to avoid checking if is responsible layer during interaction end
      * when a new floating element may have been opened.
      */
      addEventListener$1(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markInterceptedEvent), __privateGet(this, _markResponsibleLayer)), true),
      /**
      * BUBBLE INTERACTION START
      * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
      * to avoid prematurely checking if other events were intercepted.
      */
      addEventListener$1(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markNonInterceptedEvent), __privateGet(this, _handleInteractOutside))),
      /**
      * HANDLE FOCUS OUTSIDE
      */
      addEventListener$1(__privateGet(this, _documentObj), "focusin", __privateGet(this, _handleFocus))
    );
  };
  _handleDismiss = new WeakMap();
  _handleInteractOutside = new WeakMap();
  _markInterceptedEvent = new WeakMap();
  _markNonInterceptedEvent = new WeakMap();
  _markResponsibleLayer = new WeakMap();
  _isTargetWithinLayer = new WeakMap();
  _resetState = new WeakMap();
  isAnyEventIntercepted_fn = function() {
    const i2 = Object.values(__privateGet(this, _interceptedEvents)).some(Boolean);
    return i2;
  };
  _onfocuscapture = new WeakMap();
  _onblurcapture = new WeakMap();
  function useDismissibleLayer(props) {
    return new DismissibleLayerState(props);
  }
  function getTopMostLayer(layersArr) {
    return layersArr.findLast(([_2, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
  }
  function isResponsibleLayer(node) {
    const layersArr = [...globalThis.bitsDismissableLayers];
    const topMostLayer = getTopMostLayer(layersArr);
    if (topMostLayer) return strict_equals(topMostLayer[0].node.current, node);
    const [firstLayerNode] = layersArr[0];
    return strict_equals(firstLayerNode.node.current, node);
  }
  function isValidEvent(e, node) {
    if ("button" in e && e.button > 0) return false;
    const target = e.target;
    if (!isElement$1(target)) return false;
    const ownerDocument = getOwnerDocument(target);
    const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget(node, target);
    return isValid;
  }
  function createWrappedEvent(e) {
    const capturedCurrentTarget = e.currentTarget;
    const capturedTarget = e.target;
    let newEvent;
    if (e instanceof PointerEvent) {
      newEvent = new PointerEvent(e.type, e);
    } else {
      newEvent = new PointerEvent("pointerdown", e);
    }
    let isPrevented = false;
    const wrappedEvent = new Proxy(newEvent, {
      get: (target, prop2) => {
        if (strict_equals(prop2, "currentTarget")) {
          return capturedCurrentTarget;
        }
        if (strict_equals(prop2, "target")) {
          return capturedTarget;
        }
        if (strict_equals(prop2, "preventDefault")) {
          return () => {
            isPrevented = true;
            if (strict_equals(typeof target.preventDefault, "function")) {
              target.preventDefault();
            }
          };
        }
        if (strict_equals(prop2, "defaultPrevented")) {
          return isPrevented;
        }
        if (prop2 in target) {
          return target[prop2];
        }
        return e[prop2];
      }
    });
    return wrappedEvent;
  }
  mark_module_start();
  Dismissible_layer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte";
  function Dismissible_layer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dismissible_layer);
    validate_prop_bindings($$props, [], [], Dismissible_layer);
    let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop), onFocusOutside = prop($$props, "onFocusOutside", 3, noop), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false);
    const dismissibleLayerState = useDismissibleLayer({
      id: box.with(() => $$props.id),
      interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
      onInteractOutside: box.with(() => onInteractOutside()),
      enabled: box.with(() => $$props.enabled),
      onFocusOutside: box.with(() => onFocusOutside()),
      isValidEvent: box.with(() => isValidEvent2())
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.children ?? noop$1, () => ({ props: dismissibleLayerState.props }));
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dismissible_layer);
  globalThis.bitsEscapeLayers ?? (globalThis.bitsEscapeLayers = /* @__PURE__ */ new Map());
  class EscapeLayerState {
    constructor(props) {
      __privateAdd(this, _onEscapeProp);
      __privateAdd(this, _behaviorType2);
      __privateAdd(this, _enabled2);
      __privateAdd(this, _addEventListener, () => {
        return addEventListener$1(document, "keydown", __privateGet(this, _onkeydown), { passive: false });
      });
      __privateAdd(this, _onkeydown, (e) => {
        if (strict_equals(e.key, ESCAPE, false) || !isResponsibleEscapeLayer(this)) return;
        const clonedEvent = new KeyboardEvent(e.type, e);
        e.preventDefault();
        const behaviorType = __privateGet(this, _behaviorType2).current;
        if (strict_equals(behaviorType, "close", false) && strict_equals(behaviorType, "defer-otherwise-close", false)) return;
        __privateGet(this, _onEscapeProp).current(clonedEvent);
      });
      __privateSet(this, _behaviorType2, props.escapeKeydownBehavior);
      __privateSet(this, _onEscapeProp, props.onEscapeKeydown);
      __privateSet(this, _enabled2, props.enabled);
      let unsubEvents = noop;
      user_effect(() => {
        if (__privateGet(this, _enabled2).current) {
          globalThis.bitsEscapeLayers.set(this, untrack(() => __privateGet(this, _behaviorType2)));
          unsubEvents = __privateGet(this, _addEventListener).call(this);
        }
        return () => {
          unsubEvents();
          globalThis.bitsEscapeLayers.delete(this);
        };
      });
    }
  }
  _onEscapeProp = new WeakMap();
  _behaviorType2 = new WeakMap();
  _enabled2 = new WeakMap();
  _addEventListener = new WeakMap();
  _onkeydown = new WeakMap();
  function useEscapeLayer(props) {
    return new EscapeLayerState(props);
  }
  function isResponsibleEscapeLayer(instance) {
    const layersArr = [...globalThis.bitsEscapeLayers];
    const topMostLayer = layersArr.findLast(([_2, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
    if (topMostLayer) return strict_equals(topMostLayer[0], instance);
    const [firstLayerNode] = layersArr[0];
    return strict_equals(firstLayerNode, instance);
  }
  mark_module_start();
  Escape_layer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte";
  function Escape_layer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Escape_layer);
    validate_prop_bindings($$props, [], [], Escape_layer);
    let escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop);
    useEscapeLayer({
      escapeKeydownBehavior: box.with(() => escapeKeydownBehavior()),
      onEscapeKeydown: box.with(() => onEscapeKeydown()),
      enabled: box.with(() => $$props.enabled)
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.children ?? noop$1);
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Escape_layer);
  const focusStack = box([]);
  function createFocusScopeStack() {
    const stack2 = focusStack;
    return {
      add(focusScope) {
        const activeFocusScope = stack2.current[0];
        if (strict_equals(focusScope.id, activeFocusScope == null ? void 0 : activeFocusScope.id, false)) {
          activeFocusScope == null ? void 0 : activeFocusScope.pause();
        }
        stack2.current = removeFromFocusScopeArray(stack2.current, focusScope);
        stack2.current.unshift(focusScope);
      },
      remove(focusScope) {
        var _a2;
        stack2.current = removeFromFocusScopeArray(stack2.current, focusScope);
        (_a2 = stack2.current[0]) == null ? void 0 : _a2.resume();
      }
    };
  }
  function createFocusScopeAPI() {
    let paused = state(false);
    return {
      id: useId(),
      get paused() {
        return get$2(paused);
      },
      pause() {
        set(paused, true);
      },
      resume() {
        set(paused, false);
      }
    };
  }
  function removeFromFocusScopeArray(arr, item) {
    return [...arr].filter((i2) => strict_equals(i2.id, item.id, false));
  }
  function removeLinks(items) {
    return items.filter((item) => strict_equals(item.tagName, "A", false));
  }
  function focus(element2, { select = false } = {}) {
    if (!(element2 && element2.focus))
      return;
    const previouslyFocusedElement = document.activeElement;
    element2.focus({ preventScroll: true });
    if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select) {
      element2.select();
    }
  }
  function focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement) {
        return true;
      }
    }
  }
  function findVisible(elements, container) {
    for (const element2 of elements) {
      if (!isElementHidden(element2, container))
        return element2;
    }
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      // eslint-disable-next-line ts/no-explicit-any
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  const AUTOFOCUS_ON_DESTROY = "focusScope.autoFocusOnDestroy";
  const EVENT_OPTIONS = { bubbles: false, cancelable: true };
  function useFocusScope({
    id,
    loop,
    enabled,
    onOpenAutoFocus,
    onCloseAutoFocus,
    forceMount
  }) {
    const focusScopeStack = createFocusScopeStack();
    const focusScope = createFocusScopeAPI();
    const ref = box(null);
    useRefById({ id, ref, deps: () => enabled.current });
    let lastFocusedElement = state(null);
    user_effect(() => {
      const container = ref.current;
      if (!container) return;
      if (!enabled.current) return;
      function handleFocusIn(event2) {
        if (focusScope.paused || !container) return;
        const target = event2.target;
        if (!isHTMLElement$1(target)) return;
        if (container.contains(target)) {
          set(lastFocusedElement, proxy(target, null, lastFocusedElement));
        } else {
          focus(get$2(lastFocusedElement), { select: true });
        }
      }
      function handleFocusOut(event2) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event2.relatedTarget;
        if (!isHTMLElement$1(relatedTarget)) return;
        if (strict_equals(relatedTarget, null)) return;
        if (!container.contains(relatedTarget)) focus(get$2(lastFocusedElement), { select: true });
      }
      function handleMutations(_2) {
        const lastFocusedElementExists = container == null ? void 0 : container.contains(get$2(lastFocusedElement));
        if (!lastFocusedElementExists) {
          focus(container);
        }
      }
      return untrack(() => {
        const unsubEvents = executeCallbacks(addEventListener$1(document, "focusin", handleFocusIn), addEventListener$1(document, "focusout", handleFocusOut));
        const mutationObserver = new MutationObserver(handleMutations);
        mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          unsubEvents();
          mutationObserver.disconnect();
        };
      });
    });
    user_effect(() => {
      if (forceMount.current) return;
      let container = ref.current;
      const previouslyFocusedElement = document.activeElement;
      untrack(() => {
        handleMount(container, previouslyFocusedElement);
      });
      return () => {
        if (!container) return;
        handleDestroy(previouslyFocusedElement);
      };
    });
    user_effect(() => {
      if (!forceMount.current) return;
      enabled.current;
      const container = ref.current;
      const previouslyFocusedElement = document.activeElement;
      untrack(() => {
        handleMount(container, previouslyFocusedElement);
      });
      return () => {
        if (!container) return;
        handleDestroy(previouslyFocusedElement);
      };
    });
    function handleMount(container, prevFocusedElement) {
      if (!container) container = document.getElementById(id.current);
      if (!container) return;
      focusScopeStack.add(focusScope);
      const hasFocusedCandidate = container.contains(prevFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        onOpenAutoFocus.current(mountEvent);
        if (!mountEvent.defaultPrevented) {
          afterTick(() => {
            if (!container) return;
            focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
            if (strict_equals(document.activeElement, prevFocusedElement)) {
              focus(container);
            }
          });
        }
      }
    }
    function handleDestroy(prevFocusedElement) {
      const destroyEvent = new CustomEvent(AUTOFOCUS_ON_DESTROY, EVENT_OPTIONS);
      onCloseAutoFocus.current(destroyEvent);
      setTimeout(
        () => {
          if (!destroyEvent.defaultPrevented && prevFocusedElement) {
            focus(prevFocusedElement ?? document.body, { select: true });
          }
          focusScopeStack.remove(focusScope);
        },
        0
      );
    }
    function handleKeydown(e) {
      if (!enabled.current) return;
      if (!loop.current && !enabled.current) return;
      if (focusScope.paused) return;
      const isTabKey = strict_equals(e.key, TAB) && !e.ctrlKey && !e.altKey && !e.metaKey;
      const focusedElement = document.activeElement;
      if (!(isTabKey && focusedElement)) return;
      const container = ref.current;
      if (!container) return;
      const [first, last] = getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (strict_equals(focusedElement, container)) {
          e.preventDefault();
        }
      } else {
        if (!e.shiftKey && strict_equals(focusedElement, last)) {
          e.preventDefault();
          if (loop.current) focus(first, { select: true });
        } else if (e.shiftKey && strict_equals(focusedElement, first)) {
          e.preventDefault();
          if (loop.current) focus(last, { select: true });
        }
      }
    }
    const props = /* @__PURE__ */ derived(() => ({
      id: id.current,
      tabindex: -1,
      onkeydown: handleKeydown
    }));
    return {
      get props() {
        return get$2(props);
      }
    };
  }
  mark_module_start();
  Focus_scope[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte";
  function Focus_scope($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Focus_scope);
    validate_prop_bindings($$props, [], [], Focus_scope);
    let trapFocus = prop($$props, "trapFocus", 3, false), loop = prop($$props, "loop", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop), forceMount = prop($$props, "forceMount", 3, false);
    const focusScopeState = useFocusScope({
      enabled: box.with(() => trapFocus()),
      loop: box.with(() => loop()),
      onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
      onOpenAutoFocus: box.with(() => onOpenAutoFocus()),
      id: box.with(() => $$props.id),
      forceMount: box.with(() => forceMount())
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.focusScope ?? noop$1, () => ({ props: focusScopeState.props }));
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Focus_scope);
  globalThis.bitsTextSelectionLayers ?? (globalThis.bitsTextSelectionLayers = /* @__PURE__ */ new Map());
  class TextSelectionLayerState {
    constructor(props) {
      __privateAdd(this, _TextSelectionLayerState_instances);
      __privateAdd(this, _id11);
      __privateAdd(this, _onPointerDownProp);
      __privateAdd(this, _onPointerUpProp);
      __privateAdd(this, _enabled3);
      __privateAdd(this, _unsubSelectionLock, noop);
      __privateAdd(this, _ref11, box(null));
      __privateAdd(this, _pointerdown, (e) => {
        const node = __privateGet(this, _ref11).current;
        const target = e.target;
        if (!isHTMLElement$1(node) || !isHTMLElement$1(target) || !__privateGet(this, _enabled3).current) return;
        if (!isHighestLayer(this) || !isOrContainsTarget(node, target)) return;
        __privateGet(this, _onPointerDownProp).current(e);
        if (e.defaultPrevented) return;
        __privateSet(this, _unsubSelectionLock, preventTextSelectionOverflow(node));
      });
      __privateAdd(this, _resetSelectionLock, () => {
        __privateGet(this, _unsubSelectionLock).call(this);
        __privateSet(this, _unsubSelectionLock, noop);
      });
      __privateSet(this, _id11, props.id);
      __privateSet(this, _enabled3, props.preventOverflowTextSelection);
      __privateSet(this, _onPointerDownProp, props.onPointerDown);
      __privateSet(this, _onPointerUpProp, props.onPointerUp);
      useRefById({
        id: __privateGet(this, _id11),
        ref: __privateGet(this, _ref11),
        deps: () => __privateGet(this, _enabled3).current
      });
      let unsubEvents = noop;
      user_effect(() => {
        if (__privateGet(this, _enabled3).current) {
          globalThis.bitsTextSelectionLayers.set(this, untrack(() => __privateGet(this, _enabled3)));
          unsubEvents = __privateMethod(this, _TextSelectionLayerState_instances, addEventListeners_fn2).call(this);
        }
        return () => {
          unsubEvents();
          __privateGet(this, _resetSelectionLock).call(this);
          globalThis.bitsTextSelectionLayers.delete(this);
        };
      });
    }
  }
  _id11 = new WeakMap();
  _onPointerDownProp = new WeakMap();
  _onPointerUpProp = new WeakMap();
  _enabled3 = new WeakMap();
  _unsubSelectionLock = new WeakMap();
  _ref11 = new WeakMap();
  _TextSelectionLayerState_instances = new WeakSet();
  addEventListeners_fn2 = function() {
    return executeCallbacks(addEventListener$1(document, "pointerdown", __privateGet(this, _pointerdown)), addEventListener$1(document, "pointerup", composeHandlers(__privateGet(this, _resetSelectionLock), __privateGet(this, _onPointerUpProp))));
  };
  _pointerdown = new WeakMap();
  _resetSelectionLock = new WeakMap();
  function useTextSelectionLayer(props) {
    return new TextSelectionLayerState(props);
  }
  const getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;
  function preventTextSelectionOverflow(node) {
    const body = document.body;
    const originalBodyUserSelect = getUserSelect(body);
    const originalNodeUserSelect = getUserSelect(node);
    setUserSelect(body, "none");
    setUserSelect(node, "text");
    return () => {
      setUserSelect(body, originalBodyUserSelect);
      setUserSelect(node, originalNodeUserSelect);
    };
  }
  function setUserSelect(node, value) {
    node.style.userSelect = value;
    node.style.webkitUserSelect = value;
  }
  function isHighestLayer(instance) {
    const layersArr = [...globalThis.bitsTextSelectionLayers];
    if (!layersArr.length) return false;
    const highestLayer = layersArr.at(-1);
    if (!highestLayer) return false;
    return strict_equals(highestLayer[0], instance);
  }
  mark_module_start();
  Text_selection_layer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte";
  function Text_selection_layer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Text_selection_layer);
    validate_prop_bindings($$props, [], [], Text_selection_layer);
    let preventOverflowTextSelection = prop($$props, "preventOverflowTextSelection", 3, true), onPointerDown = prop($$props, "onPointerDown", 3, noop), onPointerUp = prop($$props, "onPointerUp", 3, noop);
    useTextSelectionLayer({
      id: box.with(() => $$props.id),
      preventOverflowTextSelection: box.with(() => preventOverflowTextSelection()),
      onPointerDown: box.with(() => onPointerDown()),
      onPointerUp: box.with(() => onPointerUp()),
      enabled: box.with(() => $$props.enabled)
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.children ?? noop$1);
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Text_selection_layer);
  const _SvelteMap = class _SvelteMap extends Map {
    /**
     * @param {Iterable<readonly [K, V]> | null | undefined} [value]
     */
    constructor(value) {
      super();
      __privateAdd(this, _SvelteMap_instances);
      /** @type {Map<K, Source<number>>} */
      __privateAdd(this, _sources, /* @__PURE__ */ new Map());
      __privateAdd(this, _version, source(0));
      __privateAdd(this, _size2, source(0));
      value = new Map(value);
      if (value) {
        for (var [key, v2] of value) {
          super.set(key, v2);
        }
        __privateGet(this, _size2).v = super.size;
      }
    }
    /** @param {K} key */
    has(key) {
      var sources = __privateGet(this, _sources);
      var s = sources.get(key);
      if (s === void 0) {
        var ret = super.get(key);
        if (ret !== void 0) {
          s = source(0);
          sources.set(key, s);
        } else {
          get$2(__privateGet(this, _version));
          return false;
        }
      }
      get$2(s);
      return true;
    }
    /**
     * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn
     * @param {any} [this_arg]
     */
    forEach(callbackfn, this_arg) {
      __privateMethod(this, _SvelteMap_instances, read_all_fn).call(this);
      super.forEach(callbackfn, this_arg);
    }
    /** @param {K} key */
    get(key) {
      var sources = __privateGet(this, _sources);
      var s = sources.get(key);
      if (s === void 0) {
        var ret = super.get(key);
        if (ret !== void 0) {
          s = source(0);
          sources.set(key, s);
        } else {
          get$2(__privateGet(this, _version));
          return void 0;
        }
      }
      get$2(s);
      return super.get(key);
    }
    /**
     * @param {K} key
     * @param {V} value
     * */
    set(key, value) {
      var _a2;
      var sources = __privateGet(this, _sources);
      var s = sources.get(key);
      var prev_res = super.get(key);
      var res = super.set(key, value);
      var version = __privateGet(this, _version);
      if (s === void 0) {
        sources.set(key, source(0));
        set(__privateGet(this, _size2), super.size);
        increment(version);
      } else if (prev_res !== value) {
        increment(s);
        var v_reactions = version.reactions === null ? null : new Set(version.reactions);
        var needs_version_increase = v_reactions === null || !((_a2 = s.reactions) == null ? void 0 : _a2.every(
          (r2) => (
            /** @type {NonNullable<typeof v_reactions>} */
            v_reactions.has(r2)
          )
        ));
        if (needs_version_increase) {
          increment(version);
        }
      }
      return res;
    }
    /** @param {K} key */
    delete(key) {
      var sources = __privateGet(this, _sources);
      var s = sources.get(key);
      var res = super.delete(key);
      if (s !== void 0) {
        sources.delete(key);
        set(__privateGet(this, _size2), super.size);
        set(s, -1);
        increment(__privateGet(this, _version));
      }
      return res;
    }
    clear() {
      if (super.size === 0) {
        return;
      }
      super.clear();
      var sources = __privateGet(this, _sources);
      set(__privateGet(this, _size2), 0);
      for (var s of sources.values()) {
        set(s, -1);
      }
      increment(__privateGet(this, _version));
      sources.clear();
    }
    keys() {
      get$2(__privateGet(this, _version));
      return super.keys();
    }
    values() {
      __privateMethod(this, _SvelteMap_instances, read_all_fn).call(this);
      return super.values();
    }
    entries() {
      __privateMethod(this, _SvelteMap_instances, read_all_fn).call(this);
      return super.entries();
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    get size() {
      get$2(__privateGet(this, _size2));
      return super.size;
    }
  };
  _sources = new WeakMap();
  _version = new WeakMap();
  _size2 = new WeakMap();
  _SvelteMap_instances = new WeakSet();
  read_all_fn = function() {
    get$2(__privateGet(this, _version));
    var sources = __privateGet(this, _sources);
    if (__privateGet(this, _size2).v !== sources.size) {
      for (var key of __superGet(_SvelteMap.prototype, this, "keys").call(this)) {
        if (!sources.has(key)) {
          sources.set(key, source(0));
        }
      }
    }
    for (var [, s] of __privateGet(this, _sources)) {
      get$2(s);
    }
  };
  let SvelteMap = _SvelteMap;
  function createSharedHook(factory) {
    let subscribers = 0;
    let state$1 = state(void 0);
    let scope;
    function dispose() {
      subscribers -= 1;
      if (scope && subscribers <= 0) {
        scope();
        set(state$1, void 0);
        scope = void 0;
      }
    }
    return (...args) => {
      subscribers += 1;
      if (strict_equals(get$2(state$1), void 0)) {
        scope = effect_root(() => {
          set(state$1, proxy(factory(...args), null, state$1));
        });
      }
      user_effect(() => {
        return () => {
          dispose();
        };
      });
      return get$2(state$1);
    };
  }
  const useBodyLockStackCount = createSharedHook(() => {
    const map = new SvelteMap();
    const locked = /* @__PURE__ */ derived(() => {
      for (const value of map.values()) {
        if (value) {
          return true;
        }
      }
      return false;
    });
    let initialBodyStyle = proxy({});
    let stopTouchMoveListener = null;
    function resetBodyStyle() {
      if (!isBrowser) return;
      document.body.style.paddingRight = initialBodyStyle.paddingRight ?? "";
      document.body.style.marginRight = initialBodyStyle.marginRight ?? "";
      document.body.style.pointerEvents = initialBodyStyle.pointerEvents ?? "";
      document.body.style.removeProperty("--scrollbar-width");
      document.body.style.overflow = initialBodyStyle.overflow ?? "";
      isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    }
    user_effect(() => {
      const curr = get$2(locked);
      return untrack(() => {
        if (!curr) {
          return;
        }
        const bodyStyle = getComputedStyle(document.body);
        initialBodyStyle.overflow = bodyStyle.overflow;
        initialBodyStyle.paddingRight = bodyStyle.paddingRight;
        initialBodyStyle.marginRight = bodyStyle.marginRight;
        initialBodyStyle.pointerEvents = bodyStyle.pointerEvents;
        const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        const paddingRight = Number.parseInt(initialBodyStyle.paddingRight ?? "0", 10);
        const config = {
          padding: paddingRight + verticalScrollbarWidth,
          margin: Number.parseInt(initialBodyStyle.marginRight ?? "0", 10)
        };
        if (verticalScrollbarWidth > 0) {
          document.body.style.paddingRight = `${config.padding}px`;
          document.body.style.marginRight = `${config.margin}px`;
          document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
          document.body.style.overflow = "hidden";
        }
        if (isIOS) {
          stopTouchMoveListener = addEventListener$1(
            document,
            "touchmove",
            (e) => {
              if (strict_equals(e.target, document.documentElement, false)) return;
              if (e.touches.length > 1) return;
              e.preventDefault();
            },
            { passive: false }
          );
        }
        afterTick(() => {
          document.body.style.pointerEvents = "none";
          document.body.style.overflow = "hidden";
        });
      });
    });
    user_effect(() => {
      return () => {
        stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
      };
    });
    return {
      get map() {
        return map;
      },
      resetBodyStyle
    };
  });
  function useBodyScrollLock(initialState, restoreScrollDelay = () => null) {
    const id = useId();
    const countState = useBodyLockStackCount();
    const _restoreScrollDelay = /* @__PURE__ */ derived(restoreScrollDelay);
    countState.map.set(id, initialState ?? false);
    const locked = box.with(() => countState.map.get(id) ?? false, (v2) => countState.map.set(id, v2));
    user_effect(() => {
      return () => {
        countState.map.delete(id);
        if (isAnyLocked(countState.map)) return;
        if (strict_equals(get$2(_restoreScrollDelay), null)) {
          requestAnimationFrame(() => countState.resetBodyStyle());
        } else {
          afterSleep(get$2(_restoreScrollDelay), () => countState.resetBodyStyle());
        }
      };
    });
    return locked;
  }
  function isAnyLocked(map) {
    for (const [_2, value] of map) {
      if (value) return true;
    }
    return false;
  }
  mark_module_start();
  Scroll_lock[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte";
  function Scroll_lock($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Scroll_lock);
    validate_prop_bindings($$props, [], [], Scroll_lock);
    let preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null);
    useBodyScrollLock(preventScroll(), () => restoreScrollDelay());
    return pop({ ...legacy_api() });
  }
  mark_module_end(Scroll_lock);
  function shouldTrapFocus({ forceMount, present, trapFocus, open: open2 }) {
    if (forceMount) {
      return open2 && trapFocus;
    }
    return present && trapFocus && open2;
  }
  mark_module_start();
  Dialog_overlay$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte";
  var root_3$3 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Dialog_overlay$1[FILENAME], [[33, 3]]);
  function Dialog_overlay$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_overlay$1);
    validate_prop_bindings($$props, ["ref"], [], Dialog_overlay$1);
    let id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "forceMount",
        "child",
        "children",
        "ref"
      ],
      "restProps"
    );
    const overlayState = useDialogOverlay({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, overlayState.props));
    var present = /* @__PURE__ */ derived(() => overlayState.root.open.current || forceMount());
    {
      const presence = wrap_snippet(Dialog_overlay$1, ($$anchor2) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            var render_arg = /* @__PURE__ */ derived_safe_equal(() => ({
              props: mergeProps(get$2(mergedProps)),
              ...overlayState.snippetProps
            }));
            snippet(node_1, () => $$props.child, () => get$2(render_arg));
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var div = root_3$3();
            const spread_with_call = /* @__PURE__ */ derived(() => mergeProps(get$2(mergedProps)));
            let attributes;
            var node_2 = child(div);
            snippet(node_2, () => $$props.children ?? noop$1, () => overlayState.snippetProps);
            reset(div);
            template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(spread_with_call) }));
            append($$anchor3, div);
          };
          if_block(node, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      });
      Presence_layer($$anchor, {
        get id() {
          return id();
        },
        get present() {
          return get$2(present);
        },
        presence,
        $$slots: { presence: true }
      });
    }
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_overlay$1);
  mark_module_start();
  Dialog_trigger[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte";
  var root_2$l = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Dialog_trigger[FILENAME], [[31, 1]]);
  function Dialog_trigger($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_trigger);
    validate_prop_bindings($$props, ["ref"], [], Dialog_trigger);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "ref",
        "children",
        "child",
        "disabled"
      ],
      "restProps"
    );
    const triggerState = useDialogTrigger({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2)),
      disabled: box.with(() => Boolean(disabled()))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, triggerState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$l();
        let attributes;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(button, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_trigger);
  mark_module_start();
  Dialog_description$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte";
  var root_2$k = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Dialog_description$1[FILENAME], [[29, 1]]);
  function Dialog_description$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_description$1);
    validate_prop_bindings($$props, ["ref"], [], Dialog_description$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "children",
        "child",
        "ref"
      ],
      "restProps"
    );
    const descriptionState = useDialogDescription({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, descriptionState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var div = root_2$k();
        let attributes;
        var node_2 = child(div);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_description$1);
  function initAnnouncer() {
    if (!isBrowser)
      return null;
    let el = document.querySelector("[data-bits-announcer]");
    if (!isHTMLElement$1(el)) {
      const div = document.createElement("div");
      div.style.cssText = srOnlyStylesString;
      div.setAttribute("data-bits-announcer", "");
      div.appendChild(createLog("assertive"));
      div.appendChild(createLog("polite"));
      el = div;
      document.body.insertBefore(el, document.body.firstChild);
    }
    function createLog(kind) {
      const log = document.createElement("div");
      log.role = "log";
      log.ariaLive = kind;
      log.setAttribute("aria-relevant", "additions");
      return log;
    }
    function getLog(kind) {
      if (!isHTMLElement$1(el))
        return null;
      const log = el.querySelector(`[aria-live="${kind}"]`);
      if (!isHTMLElement$1(log))
        return null;
      return log;
    }
    return {
      getLog
    };
  }
  function getAnnouncer() {
    const announcer = initAnnouncer();
    function announce(value, kind = "assertive", timeout = 7500) {
      if (!announcer || !isBrowser)
        return;
      const log = announcer.getLog(kind);
      const content = document.createElement("div");
      if (typeof value === "number") {
        value = value.toString();
      } else if (value === null) {
        value = "Empty";
      } else {
        value = value.trim();
      }
      content.innerText = value;
      if (kind === "assertive") {
        log == null ? void 0 : log.replaceChildren(content);
      } else {
        log == null ? void 0 : log.appendChild(content);
      }
      return setTimeout(() => {
        content.remove();
      }, timeout);
    }
    return {
      announce
    };
  }
  const defaultDateDefaults = {
    defaultValue: void 0,
    defaultPlaceholder: void 0,
    granularity: "day"
  };
  function getDefaultDate(props) {
    const withDefaults = { ...defaultDateDefaults, ...props };
    const { defaultValue, defaultPlaceholder, granularity } = withDefaults;
    if (Array.isArray(defaultValue) && defaultValue.length) {
      return defaultValue[defaultValue.length - 1];
    }
    if (defaultValue && !Array.isArray(defaultValue)) {
      return defaultValue;
    } else if (defaultPlaceholder) {
      return defaultPlaceholder;
    } else {
      const date = /* @__PURE__ */ new Date();
      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const calendarDateTimeGranularities = ["hour", "minute", "second"];
      if (calendarDateTimeGranularities.includes(granularity ?? "day")) {
        return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0);
      }
      return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day);
    }
  }
  function parseStringToDateValue(dateStr, referenceVal) {
    let dateValue;
    if (referenceVal instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
      dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
    } else if (referenceVal instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f) {
      dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
    } else {
      dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
    }
    return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
  }
  function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
    if (dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
      return dateValue.toDate();
    } else {
      return dateValue.toDate(tz);
    }
  }
  function isCalendarDateTime(dateValue) {
    return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
  }
  function isZonedDateTime(dateValue) {
    return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
  }
  function hasTime(dateValue) {
    return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
  }
  function getDaysInMonth(date) {
    if (date instanceof Date) {
      const year = date.getFullYear();
      const month = date.getMonth() + 1;
      return new Date(year, month, 0).getDate();
    } else {
      return date.set({ day: 100 }).day;
    }
  }
  function isBefore(dateToCompare, referenceDate) {
    return dateToCompare.compare(referenceDate) < 0;
  }
  function isAfter(dateToCompare, referenceDate) {
    return dateToCompare.compare(referenceDate) > 0;
  }
  function isBeforeOrSame(dateToCompare, referenceDate) {
    return dateToCompare.compare(referenceDate) <= 0;
  }
  function isAfterOrSame(dateToCompare, referenceDate) {
    return dateToCompare.compare(referenceDate) >= 0;
  }
  function isBetweenInclusive(date, start, end) {
    return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
  }
  function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
    const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
    if (firstDayOfWeek > day) {
      return date.subtract({ days: day + 7 - firstDayOfWeek });
    }
    if (firstDayOfWeek === day) {
      return date;
    }
    return date.subtract({ days: day - firstDayOfWeek });
  }
  function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
    const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
    const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
    if (day === lastDayOfWeek) {
      return date;
    }
    if (day > lastDayOfWeek) {
      return date.add({ days: 7 - day + lastDayOfWeek });
    }
    return date.add({ days: lastDayOfWeek - day });
  }
  function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled) {
    if (isUnavailable === void 0 && isDisabled === void 0) {
      return true;
    }
    let dCurrent = start.add({ days: 1 });
    if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
      return false;
    }
    const dEnd = end;
    while (dCurrent.compare(dEnd) < 0) {
      dCurrent = dCurrent.add({ days: 1 });
      if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
        return false;
      }
    }
    return true;
  }
  const defaultPartOptions = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function createFormatter(initialLocale) {
    let locale = initialLocale;
    function setLocale(newLocale) {
      locale = newLocale;
    }
    function getLocale() {
      return locale;
    }
    function custom(date, options) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
    }
    function selectedDate(date, includeTime = true) {
      if (hasTime(date) && includeTime) {
        return custom(toDate(date), {
          dateStyle: "long",
          timeStyle: "long"
        });
      } else {
        return custom(toDate(date), {
          dateStyle: "long"
        });
      }
    }
    function fullMonthAndYear(date) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long", year: "numeric" }).format(date);
    }
    function fullMonth(date) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long" }).format(date);
    }
    function fullYear(date) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: "numeric" }).format(date);
    }
    function toParts(date, options) {
      if (isZonedDateTime(date)) {
        return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
          ...options,
          timeZone: date.timeZone
        }).formatToParts(toDate(date));
      } else {
        return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(date));
      }
    }
    function dayOfWeek(date, length = "narrow") {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: length }).format(date);
    }
    function dayPeriod(date, hourCycle = void 0) {
      var _a2;
      const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        hour: "numeric",
        minute: "numeric",
        hourCycle: hourCycle === 24 ? "h23" : void 0
      }).formatToParts(date);
      const value = (_a2 = parts.find((p2) => p2.type === "dayPeriod")) == null ? void 0 : _a2.value;
      if (value === "PM") {
        return "PM";
      }
      return "AM";
    }
    function part(dateObj, type, options = {}) {
      const opts = { ...defaultPartOptions, ...options };
      const parts = toParts(dateObj, opts);
      const part2 = parts.find((p2) => p2.type === type);
      return part2 ? part2.value : "";
    }
    return {
      setLocale,
      getLocale,
      fullMonth,
      fullYear,
      fullMonthAndYear,
      toParts,
      custom,
      part,
      dayPeriod,
      selectedDate,
      dayOfWeek
    };
  }
  function chunk(arr, size2) {
    const result2 = [];
    for (let i2 = 0; i2 < arr.length; i2 += size2) {
      result2.push(arr.slice(i2, i2 + size2));
    }
    return result2;
  }
  function isValidIndex(index2, arr) {
    return index2 >= 0 && index2 < arr.length;
  }
  function isCalendarDayNode(node) {
    if (!isHTMLElement$1(node)) return false;
    if (!node.hasAttribute("data-bits-day")) return false;
    return true;
  }
  function getDaysBetween(start, end) {
    const days = [];
    let dCurrent = start.add({ days: 1 });
    const dEnd = end;
    while (dCurrent.compare(dEnd) < 0) {
      days.push(dCurrent);
      dCurrent = dCurrent.add({ days: 1 });
    }
    return days;
  }
  function createMonth(props) {
    const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
    const daysInMonth = getDaysInMonth(dateObj);
    const datesArray = Array.from({ length: daysInMonth }, (_2, i2) => dateObj.set({ day: i2 + 1 }));
    const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
    const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
    const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
    const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);
    const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
    const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
    const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
    if (fixedWeeks && totalDays < 42) {
      const extraDays = 42 - totalDays;
      let startFrom = nextMonthDays[nextMonthDays.length - 1];
      if (!startFrom) {
        startFrom = dateObj.add({ months: 1 }).set({ day: 1 });
      }
      let length = extraDays;
      if (strict_equals(nextMonthDays.length, 0)) {
        length = extraDays - 1;
        nextMonthDays.push(startFrom);
      }
      const extraDaysArray = Array.from({ length }, (_2, i2) => {
        const incr = i2 + 1;
        return startFrom.add({ days: incr });
      });
      nextMonthDays.push(...extraDaysArray);
    }
    const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
    const weeks = chunk(allDays, 7);
    return { value: dateObj, dates: allDays, weeks };
  }
  function createMonths(props) {
    const { numberOfMonths, dateObj, ...monthProps } = props;
    const months = [];
    if (!numberOfMonths || strict_equals(numberOfMonths, 1)) {
      months.push(createMonth({ ...monthProps, dateObj }));
      return months;
    }
    months.push(createMonth({ ...monthProps, dateObj }));
    for (let i2 = 1; i2 < numberOfMonths; i2++) {
      const nextMonth = dateObj.add({ months: i2 });
      months.push(createMonth({ ...monthProps, dateObj: nextMonth }));
    }
    return months;
  }
  function getSelectableCells(calendarNode) {
    if (!calendarNode) return [];
    const selectableSelector = `[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])`;
    return Array.from(calendarNode.querySelectorAll(selectableSelector)).filter((el) => isHTMLElement$1(el));
  }
  function setPlaceholderToNodeValue(node, placeholder) {
    const cellValue = node.getAttribute("data-value");
    if (!cellValue) return;
    placeholder.current = parseStringToDateValue(cellValue, placeholder.current);
  }
  function shiftCalendarFocus({
    node,
    add,
    placeholder,
    calendarNode,
    isPrevButtonDisabled,
    isNextButtonDisabled,
    months,
    numberOfMonths
  }) {
    var _a2, _b2;
    const candidateCells = getSelectableCells(calendarNode);
    if (!candidateCells.length) return;
    const index2 = candidateCells.indexOf(node);
    const nextIndex = index2 + add;
    if (isValidIndex(nextIndex, candidateCells)) {
      const nextCell = candidateCells[nextIndex];
      setPlaceholderToNodeValue(nextCell, placeholder);
      return nextCell.focus();
    }
    if (nextIndex < 0) {
      if (isPrevButtonDisabled) return;
      const firstMonth = (_a2 = months[0]) == null ? void 0 : _a2.value;
      if (!firstMonth) return;
      placeholder.current = firstMonth.subtract({ months: numberOfMonths });
      afterTick(() => {
        const newCandidateCells = getSelectableCells(calendarNode);
        if (!newCandidateCells.length) return;
        const newIndex = newCandidateCells.length - Math.abs(nextIndex);
        if (isValidIndex(newIndex, newCandidateCells)) {
          const newCell = newCandidateCells[newIndex];
          setPlaceholderToNodeValue(newCell, placeholder);
          return newCell.focus();
        }
      });
    }
    if (nextIndex >= candidateCells.length) {
      if (isNextButtonDisabled) return;
      const firstMonth = (_b2 = months[0]) == null ? void 0 : _b2.value;
      if (!firstMonth) return;
      placeholder.current = firstMonth.add({ months: numberOfMonths });
      afterTick(() => {
        const newCandidateCells = getSelectableCells(calendarNode);
        if (!newCandidateCells.length) return;
        const newIndex = nextIndex - candidateCells.length;
        if (isValidIndex(newIndex, newCandidateCells)) {
          const nextCell = newCandidateCells[newIndex];
          return nextCell.focus();
        }
      });
    }
  }
  const ARROW_KEYS = [
    ARROW_DOWN,
    ARROW_UP,
    ARROW_LEFT,
    ARROW_RIGHT
  ];
  const SELECT_KEYS = [ENTER, SPACE];
  function handleCalendarKeydown({
    event: event2,
    handleCellClick,
    shiftFocus,
    placeholderValue
  }) {
    const currentCell = event2.target;
    if (!isCalendarDayNode(currentCell)) return;
    if (!ARROW_KEYS.includes(event2.key) && !SELECT_KEYS.includes(event2.key)) return;
    event2.preventDefault();
    const kbdFocusMap = {
      [ARROW_DOWN]: 7,
      [ARROW_UP]: -7,
      [ARROW_LEFT]: -1,
      [ARROW_RIGHT]: 1
    };
    if (ARROW_KEYS.includes(event2.key)) {
      const add = kbdFocusMap[event2.key];
      if (strict_equals(add, void 0, false)) {
        shiftFocus(currentCell, add);
      }
    }
    if (SELECT_KEYS.includes(event2.key)) {
      const cellValue = currentCell.getAttribute("data-value");
      if (!cellValue) return;
      handleCellClick(event2, parseStringToDateValue(cellValue, placeholderValue));
    }
  }
  function handleCalendarNextPage({
    months,
    setMonths,
    numberOfMonths,
    pagedNavigation,
    weekStartsOn,
    locale,
    fixedWeeks,
    setPlaceholder
  }) {
    var _a2;
    const firstMonth = (_a2 = months[0]) == null ? void 0 : _a2.value;
    if (!firstMonth) return;
    if (pagedNavigation) {
      setPlaceholder(firstMonth.add({ months: numberOfMonths }));
    } else {
      const newMonths = createMonths({
        dateObj: firstMonth.add({ months: 1 }),
        weekStartsOn,
        locale,
        fixedWeeks,
        numberOfMonths
      });
      setMonths(newMonths);
      const firstNewMonth = newMonths[0];
      if (!firstNewMonth) return;
      setPlaceholder(firstNewMonth.value.set({ day: 1 }));
    }
  }
  function handleCalendarPrevPage({
    months,
    setMonths,
    numberOfMonths,
    pagedNavigation,
    weekStartsOn,
    locale,
    fixedWeeks,
    setPlaceholder
  }) {
    var _a2;
    const firstMonth = (_a2 = months[0]) == null ? void 0 : _a2.value;
    if (!firstMonth) return;
    if (pagedNavigation) {
      setPlaceholder(firstMonth.subtract({ months: numberOfMonths }));
    } else {
      const newMonths = createMonths({
        dateObj: firstMonth.subtract({ months: 1 }),
        weekStartsOn,
        locale,
        fixedWeeks,
        numberOfMonths
      });
      setMonths(newMonths);
      const firstNewMonth = newMonths[0];
      if (!firstNewMonth) return;
      setPlaceholder(firstNewMonth.value.set({ day: 1 }));
    }
  }
  function getWeekdays({ months, formatter, weekdayFormat }) {
    if (!months.length) return [];
    const firstMonth = months[0];
    const firstWeek = firstMonth.weeks[0];
    if (!firstWeek) return [];
    return firstWeek.map((date) => formatter.dayOfWeek(toDate(date), weekdayFormat));
  }
  function useMonthViewOptionsSync(props) {
    const weekStartsOn = props.weekStartsOn.current;
    const locale = props.locale.current;
    const fixedWeeks = props.fixedWeeks.current;
    const numberOfMonths = props.numberOfMonths.current;
    untrack(() => {
      const placeholder = props.placeholder.current;
      if (!placeholder) return;
      const defaultMonthProps = {
        weekStartsOn,
        locale,
        fixedWeeks,
        numberOfMonths
      };
      props.setMonths(createMonths({ ...defaultMonthProps, dateObj: placeholder }));
    });
  }
  function useMonthViewPlaceholderSync({
    placeholder,
    getVisibleMonths,
    weekStartsOn,
    locale,
    fixedWeeks,
    numberOfMonths,
    setMonths
  }) {
    user_effect(() => {
      placeholder.current;
      untrack(() => {
        if (getVisibleMonths().some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, placeholder.current))) {
          return;
        }
        const defaultMonthProps = {
          weekStartsOn: weekStartsOn.current,
          locale: locale.current,
          fixedWeeks: fixedWeeks.current,
          numberOfMonths: numberOfMonths.current
        };
        setMonths(createMonths({
          ...defaultMonthProps,
          dateObj: placeholder.current
        }));
      });
    });
  }
  function getIsNextButtonDisabled({ maxValue, months, disabled }) {
    var _a2;
    if (!maxValue || !months.length) return false;
    if (disabled) return true;
    const lastMonthInView = (_a2 = months[months.length - 1]) == null ? void 0 : _a2.value;
    if (!lastMonthInView) return false;
    const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
    return isAfter(firstMonthOfNextPage, maxValue);
  }
  function getIsPrevButtonDisabled({ minValue, months, disabled }) {
    var _a2;
    if (!minValue || !months.length) return false;
    if (disabled) return true;
    const firstMonthInView = (_a2 = months[0]) == null ? void 0 : _a2.value;
    if (!firstMonthInView) return false;
    const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
    return isBefore(lastMonthOfPrevPage, minValue);
  }
  function getCalendarHeadingValue({ months, locale, formatter }) {
    if (!months.length) return "";
    if (strict_equals(locale, formatter.getLocale(), false)) {
      formatter.setLocale(locale);
    }
    if (strict_equals(months.length, 1)) {
      const month = toDate(months[0].value);
      return `${formatter.fullMonthAndYear(month)}`;
    }
    const startMonth = toDate(months[0].value);
    const endMonth = toDate(months[months.length - 1].value);
    const startMonthName = formatter.fullMonth(startMonth);
    const endMonthName = formatter.fullMonth(endMonth);
    const startMonthYear = formatter.fullYear(startMonth);
    const endMonthYear = formatter.fullYear(endMonth);
    const content = strict_equals(startMonthYear, endMonthYear) ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    return content;
  }
  function getCalendarElementProps({
    fullCalendarLabel,
    id,
    isInvalid,
    disabled,
    readonly
  }) {
    return {
      id,
      role: "application",
      "aria-label": fullCalendarLabel,
      "data-invalid": getDataInvalid(isInvalid),
      "data-disabled": getDataDisabled(disabled),
      "data-readonly": getDataReadonly(readonly)
    };
  }
  class CalendarHeadingState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _headingValue, /* @__PURE__ */ derived(() => this.root.headingValue));
      __privateAdd(this, _props11, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        "aria-hidden": getAriaHidden(true),
        "data-disabled": getDataDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        [this.root.getBitsAttr("heading")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get headingValue() {
      return get$2(__privateGet(this, _headingValue));
    }
    set headingValue(_2) {
      throw new Error("Cannot update a derived property ('headingValue')");
    }
    get props() {
      return get$2(__privateGet(this, _props11));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _headingValue = new WeakMap();
  _props11 = new WeakMap();
  class CalendarNextButtonState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _isDisabled3, /* @__PURE__ */ derived(() => this.root.isNextButtonDisabled));
      __privateAdd(this, _props12, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        role: "button",
        type: "button",
        "aria-label": "Next",
        "aria-disabled": getAriaDisabled(this.isDisabled),
        "data-disabled": getDataDisabled(this.isDisabled),
        disabled: this.isDisabled,
        [this.root.getBitsAttr("next-button")]: "",
        //
        onclick: this.onclick
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      this.onclick = this.onclick.bind(this);
      useRefById({ id: this.id, ref: this.ref });
    }
    get isDisabled() {
      return get$2(__privateGet(this, _isDisabled3));
    }
    set isDisabled(_2) {
      throw new Error("Cannot update a derived property ('isDisabled')");
    }
    onclick(_2) {
      if (this.isDisabled) return;
      this.root.nextPage();
    }
    get props() {
      return get$2(__privateGet(this, _props12));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _isDisabled3 = new WeakMap();
  _props12 = new WeakMap();
  class CalendarPrevButtonState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _isDisabled4, /* @__PURE__ */ derived(() => this.root.isPrevButtonDisabled));
      __privateAdd(this, _props13, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        role: "button",
        type: "button",
        "aria-label": "Previous",
        "aria-disabled": getAriaDisabled(this.isDisabled),
        "data-disabled": getDataDisabled(this.isDisabled),
        disabled: this.isDisabled,
        [this.root.getBitsAttr("prev-button")]: "",
        //
        onclick: this.onclick
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      this.onclick = this.onclick.bind(this);
      useRefById({ id: this.id, ref: this.ref });
    }
    get isDisabled() {
      return get$2(__privateGet(this, _isDisabled4));
    }
    set isDisabled(_2) {
      throw new Error("Cannot update a derived property ('isDisabled')");
    }
    onclick(_2) {
      if (this.isDisabled) return;
      this.root.prevPage();
    }
    get props() {
      return get$2(__privateGet(this, _props13));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _isDisabled4 = new WeakMap();
  _props13 = new WeakMap();
  class CalendarGridState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _props14, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        tabindex: -1,
        role: "grid",
        "aria-readonly": getAriaReadonly(this.root.readonly.current),
        "aria-disabled": getAriaDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        "data-disabled": getDataDisabled(this.root.disabled.current),
        [this.root.getBitsAttr("grid")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get props() {
      return get$2(__privateGet(this, _props14));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _props14 = new WeakMap();
  class CalendarGridBodyState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _props15, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        "data-disabled": getDataDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        [this.root.getBitsAttr("grid-body")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get props() {
      return get$2(__privateGet(this, _props15));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _props15 = new WeakMap();
  class CalendarGridHeadState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _props16, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        "data-disabled": getDataDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        [this.root.getBitsAttr("grid-head")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get props() {
      return get$2(__privateGet(this, _props16));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _props16 = new WeakMap();
  class CalendarGridRowState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _props17, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        "data-disabled": getDataDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        [this.root.getBitsAttr("grid-row")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get props() {
      return get$2(__privateGet(this, _props17));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _props17 = new WeakMap();
  class CalendarHeadCellState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _props18, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        "data-disabled": getDataDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        [this.root.getBitsAttr("head-cell")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get props() {
      return get$2(__privateGet(this, _props18));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _props18 = new WeakMap();
  class CalendarHeaderState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _props19, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        "data-disabled": getDataDisabled(this.root.disabled.current),
        "data-readonly": getDataReadonly(this.root.readonly.current),
        [this.root.getBitsAttr("header")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
    }
    get props() {
      return get$2(__privateGet(this, _props19));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _props19 = new WeakMap();
  const [
    setCalendarRootContext,
    getCalendarRootContext
  ] = createContext(["Calendar.Root", "RangeCalendar.Root"], "Calendar.Root", false);
  createContext("Calendar.Cell");
  function useCalendarGrid(props) {
    const root2 = getCalendarRootContext();
    return new CalendarGridState(props, root2);
  }
  function useCalendarNextButton(props) {
    const root2 = getCalendarRootContext();
    return new CalendarNextButtonState(props, root2);
  }
  function useCalendarPrevButton(props) {
    const root2 = getCalendarRootContext();
    return new CalendarPrevButtonState(props, root2);
  }
  function useCalendarGridBody(props) {
    const root2 = getCalendarRootContext();
    return new CalendarGridBodyState(props, root2);
  }
  function useCalendarGridHead(props) {
    const root2 = getCalendarRootContext();
    return new CalendarGridHeadState(props, root2);
  }
  function useCalendarGridRow(props) {
    const root2 = getCalendarRootContext();
    return new CalendarGridRowState(props, root2);
  }
  function useCalendarHeadCell(props) {
    const root2 = getCalendarRootContext();
    return new CalendarHeadCellState(props, root2);
  }
  function useCalendarHeader(props) {
    const root2 = getCalendarRootContext();
    return new CalendarHeaderState(props, root2);
  }
  function useCalendarHeading(props) {
    const root2 = getCalendarRootContext();
    return new CalendarHeadingState(props, root2);
  }
  mark_module_start();
  Calendar_grid[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte";
  var root_2$j = add_locations(/* @__PURE__ */ template(`<table><!></table>`), Calendar_grid[FILENAME], [[29, 1]]);
  function Calendar_grid($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_grid);
    validate_prop_bindings($$props, ["ref"], [], Calendar_grid);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const gridState = useCalendarGrid({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, gridState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var table = root_2$j();
        let attributes;
        var node_2 = child(table);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(table, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, table);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_grid);
  mark_module_start();
  Calendar_grid_body[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte";
  var root_2$i = add_locations(/* @__PURE__ */ template(`<tbody><!></tbody>`), Calendar_grid_body[FILENAME], [[29, 1]]);
  function Calendar_grid_body($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_grid_body);
    validate_prop_bindings($$props, ["ref"], [], Calendar_grid_body);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const gridBodyState = useCalendarGridBody({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, gridBodyState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var tbody = root_2$i();
        let attributes;
        var node_2 = child(tbody);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(tbody, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, tbody);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_grid_body);
  mark_module_start();
  Calendar_grid_head[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte";
  var root_2$h = add_locations(/* @__PURE__ */ template(`<thead><!></thead>`), Calendar_grid_head[FILENAME], [[29, 1]]);
  function Calendar_grid_head($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_grid_head);
    validate_prop_bindings($$props, ["ref"], [], Calendar_grid_head);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const gridHeadState = useCalendarGridHead({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, gridHeadState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var thead = root_2$h();
        let attributes;
        var node_2 = child(thead);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(thead, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, thead);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_grid_head);
  mark_module_start();
  Calendar_head_cell[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte";
  var root_2$g = add_locations(/* @__PURE__ */ template(`<th><!></th>`), Calendar_head_cell[FILENAME], [[29, 1]]);
  function Calendar_head_cell($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_head_cell);
    validate_prop_bindings($$props, ["ref"], [], Calendar_head_cell);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const headCellState = useCalendarHeadCell({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, headCellState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var th = root_2$g();
        let attributes;
        var node_2 = child(th);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(th, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, th);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_head_cell);
  mark_module_start();
  Calendar_grid_row[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte";
  var root_2$f = add_locations(/* @__PURE__ */ template(`<tr><!></tr>`), Calendar_grid_row[FILENAME], [[29, 1]]);
  function Calendar_grid_row($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_grid_row);
    validate_prop_bindings($$props, ["ref"], [], Calendar_grid_row);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const gridRowState = useCalendarGridRow({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, gridRowState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var tr = root_2$f();
        let attributes;
        var node_2 = child(tr);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(tr, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, tr);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_grid_row);
  mark_module_start();
  Calendar_header[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte";
  var root_2$e = add_locations(/* @__PURE__ */ template(`<header><!></header>`), Calendar_header[FILENAME], [[29, 1]]);
  function Calendar_header($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_header);
    validate_prop_bindings($$props, ["ref"], [], Calendar_header);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const headerState = useCalendarHeader({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, headerState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var header = root_2$e();
        let attributes;
        var node_2 = child(header);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(header, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, header);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_header);
  mark_module_start();
  Calendar_heading[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte";
  var root_2$d = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Calendar_heading[FILENAME], [[29, 1]]);
  function Calendar_heading($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_heading);
    validate_prop_bindings($$props, ["ref"], [], Calendar_heading);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "ref",
        "id"
      ],
      "restProps"
    );
    const headingState = useCalendarHeading({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, headingState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({
          props: get$2(mergedProps),
          headingValue: headingState.headingValue
        }));
        append($$anchor2, fragment_1);
      };
      var alternate_1 = ($$anchor2) => {
        var div = root_2$d();
        let attributes;
        var node_2 = child(div);
        {
          var consequent_1 = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children ?? noop$1, () => ({ headingValue: headingState.headingValue }));
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var text$1 = text();
            template_effect(() => set_text(text$1, headingState.headingValue));
            append($$anchor3, text$1);
          };
          if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          });
        }
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_heading);
  mark_module_start();
  Calendar_next_button[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte";
  var root_2$c = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Calendar_next_button[FILENAME], [[29, 1]]);
  function Calendar_next_button($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_next_button);
    validate_prop_bindings($$props, ["ref"], [], Calendar_next_button);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref"
      ],
      "restProps"
    );
    const nextButtonState = useCalendarNextButton({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, nextButtonState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$c();
        let attributes;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(button, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_next_button);
  mark_module_start();
  Calendar_prev_button[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte";
  var root_2$b = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Calendar_prev_button[FILENAME], [[29, 1]]);
  function Calendar_prev_button($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar_prev_button);
    validate_prop_bindings($$props, ["ref"], [], Calendar_prev_button);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref"
      ],
      "restProps"
    );
    const prevButtonState = useCalendarPrevButton({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, prevButtonState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$b();
        let attributes;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(button, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar_prev_button);
  const sides = ["top", "right", "bottom", "left"];
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v2) => ({
    x: v2,
    y: v2
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y2,
      left: x2,
      right: x2 + width,
      bottom: y2 + height,
      x: x2,
      y: y2
    };
  }
  function computeCoordsFromPlacement(_ref17, placement, rtl) {
    let {
      reference,
      floating
    } = _ref17;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data,
        reset: reset2
      } = await fn({
        x: x2,
        y: y2,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y2 = nextY != null ? nextY : y2;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset2 && resetCount <= 50) {
        resetCount++;
        if (typeof reset2 === "object") {
          if (reset2.placement) {
            statefulPlacement = reset2.placement;
          }
          if (reset2.rects) {
            rects = reset2.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset2.rects;
          }
          ({
            x: x2,
            y: y2
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
      }
    }
    return {
      x: x2,
      y: y2,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state2, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y2,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state2;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state2);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element2 = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y2,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const arrow$1 = (options) => ({
    name: "arrow",
    options,
    async fn(state2) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state2;
      const {
        element: element2,
        padding = 0
      } = evaluate(options, state2) || {};
      if (element2 == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y: y2
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element2);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  const flip$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state2) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state2;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state2);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state2, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d2.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  const hide$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "hide",
      options,
      async fn(state2) {
        const {
          rects
        } = state2;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options, state2);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state2, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state2, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  async function convertValueToCoords(state2, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state2;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state2);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$1 = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state2) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y: y2,
          placement,
          middlewareData
        } = state2;
        const diffCoords = await convertValueToCoords(state2, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y2 + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state2) {
        const {
          x: x2,
          y: y2,
          placement
        } = state2;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref17) => {
              let {
                x: x3,
                y: y3
              } = _ref17;
              return {
                x: x3,
                y: y3
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state2);
        const coords = {
          x: x2,
          y: y2
        };
        const overflow = await detectOverflow(state2, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state2,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y2,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  const limitShift$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state2) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          middlewareData
        } = state2;
        const {
          offset: offset2 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options, state2);
        const coords = {
          x: x2,
          y: y2
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset2, state2);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = ["top", "left"].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  const size$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state2) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state2;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state2);
        const overflow = await detectOverflow(state2, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state2.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state2,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref17;
    return (_ref17 = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref17.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element2) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element2);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element2) {
    return ["table", "td", "th"].includes(getNodeName(element2));
  }
  function isTopLayer(element2) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element2.matches(selector);
      } catch (e) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
    return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element2) {
    let currentNode = getParentNode(element2);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle$1(element2) {
    return getWindow(element2).getComputedStyle(element2);
  }
  function getNodeScroll(element2) {
    if (isElement(element2)) {
      return {
        scrollLeft: element2.scrollLeft,
        scrollTop: element2.scrollTop
      };
    }
    return {
      scrollLeft: element2.scrollX,
      scrollTop: element2.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result2 = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result2) ? result2.host : result2;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element2) {
    const css = getComputedStyle$1(element2);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element2);
    const offsetWidth = hasOffset ? element2.offsetWidth : width;
    const offsetHeight = hasOffset ? element2.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element2) {
    return !isElement(element2) ? element2.contextElement : element2;
  }
  function getScale(element2) {
    const domElement = unwrapElement(element2);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x2 = ($ ? round(rect.width) : rect.width) / width;
    let y2 = ($ ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y2 || !Number.isFinite(y2)) {
      y2 = 1;
    }
    return {
      x: x2,
      y: y2
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element2) {
    const win = getWindow(element2);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element2.getBoundingClientRect();
    const domElement = unwrapElement(element2);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element2);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale.x;
    let y2 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y2 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y2 += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y2
    });
  }
  function getWindowScrollBarX(element2, rect) {
    const leftScroll = getNodeScroll(element2).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element2)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y2 = htmlRect.top + scroll.scrollTop;
    return {
      x: x2,
      y: y2
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref17) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref17;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element2) {
    return Array.from(element2.getClientRects());
  }
  function getDocumentRect(element2) {
    const html = getDocumentElement(element2);
    const scroll = getNodeScroll(element2);
    const body = element2.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element2);
    const y2 = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getViewportRect(element2, strategy) {
    const win = getWindow(element2);
    const html = getDocumentElement(element2);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getInnerBoundingClientRect(element2, strategy) {
    const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
    const top = clientRect.top + element2.clientTop;
    const left = clientRect.left + element2.clientLeft;
    const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
    const width = element2.clientWidth * scale.x;
    const height = element2.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y2 = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element2, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element2));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element2);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element2, stopNode) {
    const parentNode = getParentNode(element2);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element2, cache2) {
    const cachedResult = cache2.get(element2);
    if (cachedResult) {
      return cachedResult;
    }
    let result2 = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element2).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element2) : element2;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
      if (shouldDropCurrentNode) {
        result2 = result2.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache2.set(element2, result2);
    return result2;
  }
  function getClippingRect(_ref17) {
    let {
      element: element2,
      boundary,
      rootBoundary,
      strategy
    } = _ref17;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element2) {
    const {
      width,
      height
    } = getCssDimensions(element2);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y: y2,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element2) {
    return getComputedStyle$1(element2).position === "static";
  }
  function getTrueOffsetParent(element2, polyfill) {
    if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element2);
    }
    let rawOffsetParent = element2.offsetParent;
    if (getDocumentElement(element2) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element2, polyfill) {
    const win = getWindow(element2);
    if (isTopLayer(element2)) {
      return win;
    }
    if (!isHTMLElement(element2)) {
      let svgOffsetParent = getParentNode(element2);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element2, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element2) || win;
  }
  const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element2) {
    return getComputedStyle$1(element2).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function observeMove(element2, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element2);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const {
        left,
        top,
        width,
        height
      } = element2.getBoundingClientRect();
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root2.ownerDocument
        });
      } catch (e) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element2);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update2, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update2, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update2);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref17) => {
        let [firstEntry] = _ref17;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update2();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
        update2();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update2();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update2);
        ancestorResize && ancestor.removeEventListener("resize", update2);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  const offset = offset$1;
  const shift = shift$1;
  const flip = flip$1;
  const size = size$1;
  const hide = hide$1;
  const arrow = arrow$1;
  const limitShift = limitShift$1;
  const computePosition = (reference, floating, options) => {
    const cache2 = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache2
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  function get(valueOrGetValue) {
    return strict_equals(typeof valueOrGetValue, "function") ? valueOrGetValue() : valueOrGetValue;
  }
  function getDPR(element2) {
    if (strict_equals(typeof window, "undefined")) return 1;
    const win = element2.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element2, value) {
    const dpr = getDPR(element2);
    return Math.round(value * dpr) / dpr;
  }
  function getFloatingContentCSSVars(name) {
    return {
      [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,
      [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,
      [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,
      [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,
      [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`
    };
  }
  function useFloating(options) {
    const whileElementsMountedOption = options.whileElementsMounted;
    const openOption = /* @__PURE__ */ derived(() => get(options.open) ?? true);
    const middlewareOption = /* @__PURE__ */ derived(() => get(options.middleware));
    const transformOption = /* @__PURE__ */ derived(() => get(options.transform) ?? true);
    const placementOption = /* @__PURE__ */ derived(() => get(options.placement) ?? "bottom");
    const strategyOption = /* @__PURE__ */ derived(() => get(options.strategy) ?? "absolute");
    const reference = options.reference;
    let x2 = state(0);
    let y2 = state(0);
    const floating = box(null);
    let strategy = state(proxy(get$2(strategyOption)));
    let placement = state(proxy(get$2(placementOption)));
    let middlewareData = state(proxy({}));
    let isPositioned = state(false);
    const floatingStyles = /* @__PURE__ */ derived(() => {
      const initialStyles = {
        position: get$2(strategy),
        left: "0",
        top: "0"
      };
      if (!floating.current) {
        return initialStyles;
      }
      const xVal = roundByDPR(floating.current, get$2(x2));
      const yVal = roundByDPR(floating.current, get$2(y2));
      if (get$2(transformOption)) {
        return {
          ...initialStyles,
          transform: `translate(${xVal}px, ${yVal}px)`,
          ...getDPR(floating.current) >= 1.5 && { willChange: "transform" }
        };
      }
      return {
        position: get$2(strategy),
        left: `${xVal}px`,
        top: `${yVal}px`
      };
    });
    let whileElementsMountedCleanup;
    function update2() {
      if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
      computePosition(reference.current, floating.current, {
        middleware: get$2(middlewareOption),
        placement: get$2(placementOption),
        strategy: get$2(strategyOption)
      }).then((position) => {
        set(x2, proxy(position.x, null, x2));
        set(y2, proxy(position.y, null, y2));
        set(strategy, proxy(position.strategy, null, strategy));
        set(placement, proxy(position.placement, null, placement));
        set(middlewareData, proxy(position.middlewareData, null, middlewareData));
        set(isPositioned, true);
      });
    }
    function cleanup() {
      if (strict_equals(typeof whileElementsMountedCleanup, "function")) {
        whileElementsMountedCleanup();
        whileElementsMountedCleanup = void 0;
      }
    }
    function attach() {
      cleanup();
      if (strict_equals(whileElementsMountedOption, void 0)) {
        update2();
        return;
      }
      if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
      whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update2);
    }
    function reset2() {
      if (!get$2(openOption)) {
        set(isPositioned, false);
      }
    }
    user_effect(update2);
    user_effect(attach);
    user_effect(reset2);
    user_effect(() => cleanup);
    return {
      floating,
      reference,
      get strategy() {
        return get$2(strategy);
      },
      get placement() {
        return get$2(placement);
      },
      get middlewareData() {
        return get$2(middlewareData);
      },
      get isPositioned() {
        return get$2(isPositioned);
      },
      get floatingStyles() {
        return get$2(floatingStyles);
      },
      get update() {
        return update2;
      }
    };
  }
  const OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  };
  class FloatingRootState {
    constructor() {
      __publicField(this, "anchorNode", box(null));
      __publicField(this, "customAnchorNode", box(null));
      __publicField(this, "triggerNode", box(null));
      user_effect(() => {
        if (this.customAnchorNode.current) {
          if (strict_equals(typeof this.customAnchorNode.current, "string")) {
            this.anchorNode.current = document.querySelector(this.customAnchorNode.current);
          } else {
            this.anchorNode.current = this.customAnchorNode.current;
          }
        } else {
          this.anchorNode.current = this.triggerNode.current;
        }
      });
    }
  }
  class FloatingContentState {
    constructor(props, root2) {
      // state
      __publicField(this, "root");
      // nodes
      __publicField(this, "contentRef", box(null));
      __publicField(this, "wrapperRef", box(null));
      __publicField(this, "arrowRef", box(null));
      // ids
      __publicField(this, "arrowId", box(useId()));
      __publicField(this, "id");
      __publicField(this, "wrapperId");
      __publicField(this, "style");
      __privateAdd(this, _transformedStyle, /* @__PURE__ */ derived(() => {
        if (strict_equals(typeof this.style, "string")) return cssToStyleObj(this.style);
        if (!this.style) return {};
      }));
      __privateAdd(this, _dir);
      __privateAdd(this, _side);
      __privateAdd(this, _sideOffset);
      __privateAdd(this, _align);
      __privateAdd(this, _alignOffset);
      __privateAdd(this, _arrowPadding);
      __privateAdd(this, _avoidCollisions);
      __privateAdd(this, _collisionBoundary);
      __privateAdd(this, _collisionPadding);
      __privateAdd(this, _sticky);
      __privateAdd(this, _hideWhenDetached);
      __privateAdd(this, _strategy);
      __privateAdd(this, _updatePositionStrategy);
      __publicField(this, "onPlaced");
      __publicField(this, "enabled");
      __privateAdd(this, _arrowSize, new ElementSize(() => this.arrowRef.current ?? void 0));
      __privateAdd(this, _arrowWidth, /* @__PURE__ */ derived(() => {
        var _a2;
        return ((_a2 = __privateGet(this, _arrowSize)) == null ? void 0 : _a2.width) ?? 0;
      }));
      __privateAdd(this, _arrowHeight, /* @__PURE__ */ derived(() => {
        var _a2;
        return ((_a2 = __privateGet(this, _arrowSize)) == null ? void 0 : _a2.height) ?? 0;
      }));
      __privateAdd(this, _desiredPlacement, /* @__PURE__ */ derived(() => {
        var _a2;
        return ((_a2 = __privateGet(this, _side)) == null ? void 0 : _a2.current) + (strict_equals(__privateGet(this, _align).current, "center", false) ? `-${__privateGet(this, _align).current}` : "");
      }));
      __privateAdd(this, _boundary, /* @__PURE__ */ derived(() => Array.isArray(__privateGet(this, _collisionBoundary).current) ? __privateGet(this, _collisionBoundary).current : [__privateGet(this, _collisionBoundary).current]));
      __privateAdd(this, _hasExplicitBoundaries, /* @__PURE__ */ derived(() => get$2(__privateGet(this, _boundary)).length > 0));
      __privateAdd(this, _detectOverflowOptions, /* @__PURE__ */ derived(() => ({
        padding: __privateGet(this, _collisionPadding).current,
        boundary: get$2(__privateGet(this, _boundary)).filter(isNotNull),
        altBoundary: this.hasExplicitBoundaries
      })));
      __privateAdd(this, _availableWidth, state(void 0));
      __privateAdd(this, _availableHeight, state(void 0));
      __privateAdd(this, _anchorWidth, state(void 0));
      __privateAdd(this, _anchorHeight, state(void 0));
      __privateAdd(this, _middleware, /* @__PURE__ */ derived(() => [
        offset({
          mainAxis: __privateGet(this, _sideOffset).current + get$2(__privateGet(this, _arrowHeight)),
          alignmentAxis: __privateGet(this, _alignOffset).current
        }),
        __privateGet(this, _avoidCollisions).current && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: strict_equals(__privateGet(this, _sticky).current, "partial") ? limitShift() : void 0,
          ...this.detectOverflowOptions
        }),
        __privateGet(this, _avoidCollisions).current && flip({ ...this.detectOverflowOptions }),
        size({
          ...this.detectOverflowOptions,
          apply: ({ rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            set(__privateGet(this, _availableWidth), proxy(availableWidth, null, __privateGet(this, _availableWidth)));
            set(__privateGet(this, _availableHeight), proxy(availableHeight, null, __privateGet(this, _availableHeight)));
            set(__privateGet(this, _anchorWidth), proxy(anchorWidth, null, __privateGet(this, _anchorWidth)));
            set(__privateGet(this, _anchorHeight), proxy(anchorHeight, null, __privateGet(this, _anchorHeight)));
          }
        }),
        this.arrowRef.current && arrow({
          element: this.arrowRef.current,
          padding: __privateGet(this, _arrowPadding).current
        }),
        transformOrigin({
          arrowWidth: get$2(__privateGet(this, _arrowWidth)),
          arrowHeight: get$2(__privateGet(this, _arrowHeight))
        }),
        __privateGet(this, _hideWhenDetached).current && hide({
          strategy: "referenceHidden",
          ...this.detectOverflowOptions
        })
      ].filter(Boolean)));
      __publicField(this, "floating");
      __privateAdd(this, _placedSide, /* @__PURE__ */ derived(() => getSideFromPlacement(this.floating.placement)));
      __privateAdd(this, _placedAlign, /* @__PURE__ */ derived(() => getAlignFromPlacement(this.floating.placement)));
      __privateAdd(this, _arrowX, /* @__PURE__ */ derived(() => {
        var _a2;
        return ((_a2 = this.floating.middlewareData.arrow) == null ? void 0 : _a2.x) ?? 0;
      }));
      __privateAdd(this, _arrowY, /* @__PURE__ */ derived(() => {
        var _a2;
        return ((_a2 = this.floating.middlewareData.arrow) == null ? void 0 : _a2.y) ?? 0;
      }));
      __privateAdd(this, _cannotCenterArrow, /* @__PURE__ */ derived(() => {
        var _a2;
        return strict_equals((_a2 = this.floating.middlewareData.arrow) == null ? void 0 : _a2.centerOffset, 0, false);
      }));
      __privateAdd(this, _contentZIndex, state());
      __privateAdd(this, _arrowBaseSide, /* @__PURE__ */ derived(() => OPPOSITE_SIDE[this.placedSide]));
      __privateAdd(this, _wrapperProps, /* @__PURE__ */ derived(() => {
        var _a2, _b2, _c;
        return {
          id: this.wrapperId.current,
          "data-bits-floating-content-wrapper": "",
          style: {
            ...this.floating.floatingStyles,
            // keep off page when measuring
            transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: this.contentZIndex,
            "--bits-floating-transform-origin": `${(_a2 = this.floating.middlewareData.transformOrigin) == null ? void 0 : _a2.x} ${(_b2 = this.floating.middlewareData.transformOrigin) == null ? void 0 : _b2.y}`,
            "--bits-floating-available-width": `${get$2(__privateGet(this, _availableWidth))}px`,
            "--bits-floating-available-height": `${get$2(__privateGet(this, _availableHeight))}px`,
            "--bits-floating-anchor-width": `${get$2(__privateGet(this, _anchorWidth))}px`,
            "--bits-floating-anchor-height": `${get$2(__privateGet(this, _anchorHeight))}px`,
            // hide the content if using the hide middleware and should be hidden
            ...((_c = this.floating.middlewareData.hide) == null ? void 0 : _c.referenceHidden) && {
              visibility: "hidden",
              "pointer-events": "none"
            },
            ...get$2(__privateGet(this, _transformedStyle))
          },
          // Floating UI calculates logical alignment based the `dir` attribute
          dir: __privateGet(this, _dir).current
        };
      }));
      __privateAdd(this, _props20, /* @__PURE__ */ derived(() => ({
        "data-side": this.placedSide,
        "data-align": this.placedAlign,
        style: styleToString({
          ...get$2(__privateGet(this, _transformedStyle))
          // if the FloatingContent hasn't been placed yet (not all measurements done)
        })
      })));
      __privateAdd(this, _arrowStyle, /* @__PURE__ */ derived(() => ({
        position: "absolute",
        left: this.arrowX ? `${this.arrowX}px` : void 0,
        top: this.arrowY ? `${this.arrowY}px` : void 0,
        [this.arrowBaseSide]: 0,
        "transform-origin": {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[this.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[this.placedSide],
        visibility: this.cannotCenterArrow ? "hidden" : void 0
      })));
      this.id = props.id;
      __privateSet(this, _side, props.side);
      __privateSet(this, _sideOffset, props.sideOffset);
      __privateSet(this, _align, props.align);
      __privateSet(this, _alignOffset, props.alignOffset);
      __privateSet(this, _arrowPadding, props.arrowPadding);
      __privateSet(this, _avoidCollisions, props.avoidCollisions);
      __privateSet(this, _collisionBoundary, props.collisionBoundary);
      __privateSet(this, _collisionPadding, props.collisionPadding);
      __privateSet(this, _sticky, props.sticky);
      __privateSet(this, _hideWhenDetached, props.hideWhenDetached);
      __privateSet(this, _updatePositionStrategy, props.updatePositionStrategy);
      this.onPlaced = props.onPlaced;
      __privateSet(this, _strategy, props.strategy);
      __privateSet(this, _dir, props.dir);
      this.style = props.style;
      this.root = root2;
      this.enabled = props.enabled;
      this.wrapperId = props.wrapperId;
      if (props.customAnchor) {
        this.root.customAnchorNode.current = props.customAnchor.current;
      }
      user_effect(() => {
        props.customAnchor.current;
        untrack(() => {
          this.root.customAnchorNode.current = props.customAnchor.current;
        });
      });
      useRefById({
        id: this.wrapperId,
        ref: this.wrapperRef,
        deps: () => this.enabled.current
      });
      useRefById({
        id: this.id,
        ref: this.contentRef,
        deps: () => this.enabled.current
      });
      this.floating = useFloating({
        strategy: () => __privateGet(this, _strategy).current,
        placement: () => get$2(__privateGet(this, _desiredPlacement)),
        middleware: () => this.middleware,
        reference: this.root.anchorNode,
        whileElementsMounted: (...args) => {
          var _a2;
          const cleanup = autoUpdate(...args, {
            animationFrame: strict_equals((_a2 = __privateGet(this, _updatePositionStrategy)) == null ? void 0 : _a2.current, "always")
          });
          return cleanup;
        },
        open: () => this.enabled.current
      });
      user_effect(() => {
        var _a2;
        if (!this.floating.isPositioned) return;
        (_a2 = this.onPlaced) == null ? void 0 : _a2.current();
      });
      user_effect(() => {
        const contentNode = this.contentRef.current;
        if (!contentNode) return;
        untrack(() => {
          this.contentZIndex = window.getComputedStyle(contentNode).zIndex;
        });
      });
      user_effect(() => {
        this.floating.floating.current = this.wrapperRef.current;
      });
    }
    get hasExplicitBoundaries() {
      return get$2(__privateGet(this, _hasExplicitBoundaries));
    }
    set hasExplicitBoundaries(_2) {
      throw new Error("Cannot update a derived property ('hasExplicitBoundaries')");
    }
    get detectOverflowOptions() {
      return get$2(__privateGet(this, _detectOverflowOptions));
    }
    set detectOverflowOptions(_2) {
      throw new Error("Cannot update a derived property ('detectOverflowOptions')");
    }
    get middleware() {
      return get$2(__privateGet(this, _middleware));
    }
    set middleware(_2) {
      throw new Error("Cannot update a derived property ('middleware')");
    }
    get placedSide() {
      return get$2(__privateGet(this, _placedSide));
    }
    set placedSide(_2) {
      throw new Error("Cannot update a derived property ('placedSide')");
    }
    get placedAlign() {
      return get$2(__privateGet(this, _placedAlign));
    }
    set placedAlign(_2) {
      throw new Error("Cannot update a derived property ('placedAlign')");
    }
    get arrowX() {
      return get$2(__privateGet(this, _arrowX));
    }
    set arrowX(_2) {
      throw new Error("Cannot update a derived property ('arrowX')");
    }
    get arrowY() {
      return get$2(__privateGet(this, _arrowY));
    }
    set arrowY(_2) {
      throw new Error("Cannot update a derived property ('arrowY')");
    }
    get cannotCenterArrow() {
      return get$2(__privateGet(this, _cannotCenterArrow));
    }
    set cannotCenterArrow(_2) {
      throw new Error("Cannot update a derived property ('cannotCenterArrow')");
    }
    get contentZIndex() {
      return get$2(__privateGet(this, _contentZIndex));
    }
    set contentZIndex(value) {
      set(__privateGet(this, _contentZIndex), proxy(value, null, __privateGet(this, _contentZIndex)));
    }
    get arrowBaseSide() {
      return get$2(__privateGet(this, _arrowBaseSide));
    }
    set arrowBaseSide(_2) {
      throw new Error("Cannot update a derived property ('arrowBaseSide')");
    }
    get wrapperProps() {
      return get$2(__privateGet(this, _wrapperProps));
    }
    set wrapperProps(_2) {
      throw new Error("Cannot update a derived property ('wrapperProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props20));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    get arrowStyle() {
      return get$2(__privateGet(this, _arrowStyle));
    }
    set arrowStyle(_2) {
      throw new Error("Cannot update a derived property ('arrowStyle')");
    }
    [ADD_OWNER](owner) {
      add_owner(get$2(__privateGet(this, _contentZIndex)), owner, false);
    }
  }
  _transformedStyle = new WeakMap();
  _dir = new WeakMap();
  _side = new WeakMap();
  _sideOffset = new WeakMap();
  _align = new WeakMap();
  _alignOffset = new WeakMap();
  _arrowPadding = new WeakMap();
  _avoidCollisions = new WeakMap();
  _collisionBoundary = new WeakMap();
  _collisionPadding = new WeakMap();
  _sticky = new WeakMap();
  _hideWhenDetached = new WeakMap();
  _strategy = new WeakMap();
  _updatePositionStrategy = new WeakMap();
  _arrowSize = new WeakMap();
  _arrowWidth = new WeakMap();
  _arrowHeight = new WeakMap();
  _desiredPlacement = new WeakMap();
  _boundary = new WeakMap();
  _hasExplicitBoundaries = new WeakMap();
  _detectOverflowOptions = new WeakMap();
  _availableWidth = new WeakMap();
  _availableHeight = new WeakMap();
  _anchorWidth = new WeakMap();
  _anchorHeight = new WeakMap();
  _middleware = new WeakMap();
  _placedSide = new WeakMap();
  _placedAlign = new WeakMap();
  _arrowX = new WeakMap();
  _arrowY = new WeakMap();
  _cannotCenterArrow = new WeakMap();
  _contentZIndex = new WeakMap();
  _arrowBaseSide = new WeakMap();
  _wrapperProps = new WeakMap();
  _props20 = new WeakMap();
  _arrowStyle = new WeakMap();
  class FloatingAnchorState {
    constructor(props, root2) {
      __publicField(this, "ref", box(null));
      if (props.virtualEl && props.virtualEl.current) {
        root2.triggerNode = box.from(props.virtualEl.current);
      } else {
        useRefById({
          id: props.id,
          ref: this.ref,
          onRefChange: (node) => {
            root2.triggerNode.current = node;
          }
        });
      }
    }
  }
  const [
    setFloatingRootContext,
    getFloatingRootContext
  ] = createContext("Floating.Root");
  const [
    setFloatingContentContext,
    getFloatingContentContext
  ] = createContext("Floating.Content");
  function useFloatingRootState() {
    return setFloatingRootContext(new FloatingRootState());
  }
  function useFloatingContentState(props) {
    return setFloatingContentContext(new FloatingContentState(props, getFloatingRootContext()));
  }
  function useFloatingAnchorState(props) {
    return new FloatingAnchorState(props, getFloatingRootContext());
  }
  function transformOrigin(options) {
    return {
      name: "transformOrigin",
      options,
      fn(data) {
        var _a2, _b2, _c;
        const { placement, rects, middlewareData } = data;
        const cannotCenterArrow = strict_equals((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset, 0, false);
        const isArrowHidden = cannotCenterArrow;
        const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
        const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
        const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
        const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
        const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
        const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
        let x2 = "";
        let y2 = "";
        if (strict_equals(placedSide, "bottom")) {
          x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
          y2 = `${-arrowHeight}px`;
        } else if (strict_equals(placedSide, "top")) {
          x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
          y2 = `${rects.floating.height + arrowHeight}px`;
        } else if (strict_equals(placedSide, "right")) {
          x2 = `${-arrowHeight}px`;
          y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
        } else if (strict_equals(placedSide, "left")) {
          x2 = `${rects.floating.width + arrowHeight}px`;
          y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
        }
        return { data: { x: x2, y: y2 } };
      }
    };
  }
  function getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [side, align];
  }
  function getSideFromPlacement(placement) {
    return getSideAndAlignFromPlacement(placement)[0];
  }
  function getAlignFromPlacement(placement) {
    return getSideAndAlignFromPlacement(placement)[1];
  }
  mark_module_start();
  Floating_layer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte";
  function Floating_layer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Floating_layer);
    validate_prop_bindings($$props, [], [], Floating_layer);
    useFloatingRootState();
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.children ?? noop$1);
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Floating_layer);
  mark_module_start();
  Floating_layer_anchor[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte";
  function Floating_layer_anchor($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Floating_layer_anchor);
    validate_prop_bindings($$props, [], [], Floating_layer_anchor);
    useFloatingAnchorState({
      id: box.with(() => $$props.id),
      virtualEl: box.with(() => $$props.virtualEl)
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.children ?? noop$1);
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Floating_layer_anchor);
  mark_module_start();
  Floating_layer_content[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte";
  function Floating_layer_content($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Floating_layer_content);
    validate_prop_bindings($$props, [], [], Floating_layer_content);
    let side = prop($$props, "side", 3, "bottom"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), alignOffset = prop($$props, "alignOffset", 3, 0), arrowPadding = prop($$props, "arrowPadding", 3, 0), avoidCollisions = prop($$props, "avoidCollisions", 3, true), collisionBoundary = prop($$props, "collisionBoundary", 19, () => []), collisionPadding = prop($$props, "collisionPadding", 3, 0), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), onPlaced = prop($$props, "onPlaced", 3, () => {
    }), sticky = prop($$props, "sticky", 3, "partial"), updatePositionStrategy = prop($$props, "updatePositionStrategy", 3, "optimized"), strategy = prop($$props, "strategy", 3, "fixed"), dir = prop($$props, "dir", 3, "ltr"), style = prop($$props, "style", 19, () => ({})), wrapperId = prop($$props, "wrapperId", 19, useId), customAnchor = prop($$props, "customAnchor", 3, null);
    const contentState = useFloatingContentState({
      side: box.with(() => side()),
      sideOffset: box.with(() => sideOffset()),
      align: box.with(() => align()),
      alignOffset: box.with(() => alignOffset()),
      id: box.with(() => $$props.id),
      arrowPadding: box.with(() => arrowPadding()),
      avoidCollisions: box.with(() => avoidCollisions()),
      collisionBoundary: box.with(() => collisionBoundary()),
      collisionPadding: box.with(() => collisionPadding()),
      hideWhenDetached: box.with(() => hideWhenDetached()),
      onPlaced: box.with(() => onPlaced()),
      sticky: box.with(() => sticky()),
      updatePositionStrategy: box.with(() => updatePositionStrategy()),
      strategy: box.with(() => strategy()),
      dir: box.with(() => dir()),
      style: box.with(() => style()),
      enabled: box.with(() => false),
      wrapperId: box.with(() => wrapperId()),
      customAnchor: box.with(() => customAnchor())
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(contentState.wrapperProps, { style: { pointerEvents: "auto" } }));
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.content ?? noop$1, () => ({
      props: contentState.props,
      wrapperProps: get$2(mergedProps)
    }));
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Floating_layer_content);
  mark_module_start();
  Floating_layer_content_static[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte";
  function Floating_layer_content_static($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Floating_layer_content_static);
    validate_prop_bindings($$props, [], [], Floating_layer_content_static);
    onMount(() => {
      var _a2;
      (_a2 = $$props.onPlaced) == null ? void 0 : _a2.call($$props);
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.content ?? noop$1, () => ({ props: {}, wrapperProps: {} }));
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Floating_layer_content_static);
  mark_module_start();
  Popper_content[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte";
  function Popper_content($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popper_content);
    validate_prop_bindings($$props, [], [], Popper_content);
    let isStatic = prop($$props, "isStatic", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "content",
        "isStatic",
        "onPlaced"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        Floating_layer_content_static($$anchor2, {
          get content() {
            return $$props.content;
          },
          get onPlaced() {
            return $$props.onPlaced;
          }
        });
      };
      var alternate = ($$anchor2) => {
        Floating_layer_content($$anchor2, spread_props(
          {
            get content() {
              return $$props.content;
            },
            get onPlaced() {
              return $$props.onPlaced;
            }
          },
          () => restProps
        ));
      };
      if_block(node, ($$render) => {
        if (isStatic()) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popper_content);
  mark_module_start();
  Popper_layer_inner[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte";
  var root_1$6 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Popper_layer_inner[FILENAME], []);
  function Popper_layer_inner($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popper_layer_inner);
    validate_prop_bindings($$props, [], [], Popper_layer_inner);
    let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "popper",
        "onEscapeKeydown",
        "escapeKeydownBehavior",
        "preventOverflowTextSelection",
        "id",
        "onPointerDown",
        "onPointerUp",
        "side",
        "sideOffset",
        "align",
        "alignOffset",
        "arrowPadding",
        "avoidCollisions",
        "collisionBoundary",
        "collisionPadding",
        "sticky",
        "hideWhenDetached",
        "updatePositionStrategy",
        "strategy",
        "dir",
        "preventScroll",
        "wrapperId",
        "style",
        "onPlaced",
        "onInteractOutside",
        "onCloseAutoFocus",
        "onOpenAutoFocus",
        "onFocusOutside",
        "interactOutsideBehavior",
        "loop",
        "trapFocus",
        "isValidEvent",
        "customAnchor",
        "isStatic",
        "enabled"
      ],
      "restProps"
    );
    {
      const content = wrap_snippet(Popper_layer_inner, ($$anchor2, $$arg0) => {
        let floatingProps = () => $$arg0 == null ? void 0 : $$arg0().props;
        floatingProps();
        let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
        wrapperProps();
        var fragment_1 = root_1$6();
        var node = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            Scroll_lock($$anchor3, {
              get preventScroll() {
                return $$props.preventScroll;
              }
            });
          };
          var alternate = ($$anchor3) => {
            var fragment_3 = comment();
            var node_1 = first_child(fragment_3);
            {
              var consequent_1 = ($$anchor4) => {
                Scroll_lock($$anchor4, {
                  get preventScroll() {
                    return $$props.preventScroll;
                  }
                });
              };
              if_block(
                node_1,
                ($$render) => {
                  if (!$$props.forceMount) $$render(consequent_1);
                },
                true
              );
            }
            append($$anchor3, fragment_3);
          };
          if_block(node, ($$render) => {
            if ($$props.forceMount && $$props.enabled) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        var node_2 = sibling(node, 2);
        var trapFocus_1 = /* @__PURE__ */ derived(() => $$props.enabled && trapFocus());
        {
          const focusScope = wrap_snippet(Popper_layer_inner, ($$anchor3, $$arg02) => {
            let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
            focusScopeProps();
            Escape_layer($$anchor3, {
              get onEscapeKeydown() {
                return $$props.onEscapeKeydown;
              },
              get escapeKeydownBehavior() {
                return $$props.escapeKeydownBehavior;
              },
              get enabled() {
                return $$props.enabled;
              },
              children: wrap_snippet(Popper_layer_inner, ($$anchor4, $$slotProps) => {
                {
                  const children = wrap_snippet(Popper_layer_inner, ($$anchor5, $$arg03) => {
                    let dismissibleProps = () => $$arg03 == null ? void 0 : $$arg03().props;
                    dismissibleProps();
                    Text_selection_layer($$anchor5, {
                      get id() {
                        return $$props.id;
                      },
                      get preventOverflowTextSelection() {
                        return $$props.preventOverflowTextSelection;
                      },
                      get onPointerDown() {
                        return $$props.onPointerDown;
                      },
                      get onPointerUp() {
                        return $$props.onPointerUp;
                      },
                      get enabled() {
                        return $$props.enabled;
                      },
                      children: wrap_snippet(Popper_layer_inner, ($$anchor6, $$slotProps2) => {
                        var fragment_8 = comment();
                        var node_3 = first_child(fragment_8);
                        var render_arg = /* @__PURE__ */ derived_safe_equal(() => ({
                          props: mergeProps(restProps, floatingProps(), dismissibleProps(), focusScopeProps(), { style: { pointerEvents: "auto" } }),
                          wrapperProps: wrapperProps()
                        }));
                        snippet(node_3, () => $$props.popper ?? noop$1, () => get$2(render_arg));
                        append($$anchor6, fragment_8);
                      }),
                      $$slots: { default: true }
                    });
                  });
                  Dismissible_layer($$anchor4, {
                    get id() {
                      return $$props.id;
                    },
                    get onInteractOutside() {
                      return $$props.onInteractOutside;
                    },
                    get onFocusOutside() {
                      return $$props.onFocusOutside;
                    },
                    get interactOutsideBehavior() {
                      return interactOutsideBehavior();
                    },
                    get isValidEvent() {
                      return isValidEvent2();
                    },
                    get enabled() {
                      return $$props.enabled;
                    },
                    children,
                    $$slots: { default: true }
                  });
                }
              }),
              $$slots: { default: true }
            });
          });
          Focus_scope(node_2, {
            get id() {
              return $$props.id;
            },
            get onOpenAutoFocus() {
              return $$props.onOpenAutoFocus;
            },
            get onCloseAutoFocus() {
              return $$props.onCloseAutoFocus;
            },
            get loop() {
              return $$props.loop;
            },
            get trapFocus() {
              return get$2(trapFocus_1);
            },
            get forceMount() {
              return $$props.forceMount;
            },
            focusScope,
            $$slots: { focusScope: true }
          });
        }
        append($$anchor2, fragment_1);
      });
      Popper_content($$anchor, {
        get isStatic() {
          return isStatic();
        },
        get id() {
          return $$props.id;
        },
        get side() {
          return $$props.side;
        },
        get sideOffset() {
          return $$props.sideOffset;
        },
        get align() {
          return $$props.align;
        },
        get alignOffset() {
          return $$props.alignOffset;
        },
        get arrowPadding() {
          return $$props.arrowPadding;
        },
        get avoidCollisions() {
          return $$props.avoidCollisions;
        },
        get collisionBoundary() {
          return $$props.collisionBoundary;
        },
        get collisionPadding() {
          return $$props.collisionPadding;
        },
        get sticky() {
          return $$props.sticky;
        },
        get hideWhenDetached() {
          return $$props.hideWhenDetached;
        },
        get updatePositionStrategy() {
          return $$props.updatePositionStrategy;
        },
        get strategy() {
          return $$props.strategy;
        },
        get dir() {
          return $$props.dir;
        },
        get wrapperId() {
          return $$props.wrapperId;
        },
        get style() {
          return $$props.style;
        },
        get onPlaced() {
          return $$props.onPlaced;
        },
        get customAnchor() {
          return customAnchor();
        },
        content,
        $$slots: { content: true }
      });
    }
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popper_layer_inner);
  mark_module_start();
  Popper_layer[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte";
  function Popper_layer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popper_layer);
    validate_prop_bindings($$props, [], [], Popper_layer);
    let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "popper",
        "present",
        "onEscapeKeydown",
        "escapeKeydownBehavior",
        "preventOverflowTextSelection",
        "id",
        "onPointerDown",
        "onPointerUp",
        "side",
        "sideOffset",
        "align",
        "alignOffset",
        "arrowPadding",
        "avoidCollisions",
        "collisionBoundary",
        "collisionPadding",
        "sticky",
        "hideWhenDetached",
        "updatePositionStrategy",
        "strategy",
        "dir",
        "preventScroll",
        "wrapperId",
        "style",
        "onPlaced",
        "onInteractOutside",
        "onCloseAutoFocus",
        "onOpenAutoFocus",
        "onFocusOutside",
        "interactOutsideBehavior",
        "loop",
        "trapFocus",
        "isValidEvent",
        "customAnchor",
        "isStatic"
      ],
      "restProps"
    );
    {
      const presence = wrap_snippet(Popper_layer, ($$anchor2, $$arg0) => {
        let present = () => $$arg0 == null ? void 0 : $$arg0().present;
        present();
        Popper_layer_inner($$anchor2, spread_props(
          {
            get popper() {
              return $$props.popper;
            },
            get onEscapeKeydown() {
              return $$props.onEscapeKeydown;
            },
            get escapeKeydownBehavior() {
              return $$props.escapeKeydownBehavior;
            },
            get preventOverflowTextSelection() {
              return $$props.preventOverflowTextSelection;
            },
            get id() {
              return $$props.id;
            },
            get onPointerDown() {
              return $$props.onPointerDown;
            },
            get onPointerUp() {
              return $$props.onPointerUp;
            },
            get side() {
              return $$props.side;
            },
            get sideOffset() {
              return $$props.sideOffset;
            },
            get align() {
              return $$props.align;
            },
            get alignOffset() {
              return $$props.alignOffset;
            },
            get arrowPadding() {
              return $$props.arrowPadding;
            },
            get avoidCollisions() {
              return $$props.avoidCollisions;
            },
            get collisionBoundary() {
              return $$props.collisionBoundary;
            },
            get collisionPadding() {
              return $$props.collisionPadding;
            },
            get sticky() {
              return $$props.sticky;
            },
            get hideWhenDetached() {
              return $$props.hideWhenDetached;
            },
            get updatePositionStrategy() {
              return $$props.updatePositionStrategy;
            },
            get strategy() {
              return $$props.strategy;
            },
            get dir() {
              return $$props.dir;
            },
            get preventScroll() {
              return $$props.preventScroll;
            },
            get wrapperId() {
              return $$props.wrapperId;
            },
            get style() {
              return $$props.style;
            },
            get onPlaced() {
              return $$props.onPlaced;
            },
            get customAnchor() {
              return customAnchor();
            },
            get isStatic() {
              return isStatic();
            },
            get enabled() {
              return present().current;
            },
            get onInteractOutside() {
              return $$props.onInteractOutside;
            },
            get onCloseAutoFocus() {
              return $$props.onCloseAutoFocus;
            },
            get onOpenAutoFocus() {
              return $$props.onOpenAutoFocus;
            },
            get interactOutsideBehavior() {
              return interactOutsideBehavior();
            },
            get loop() {
              return $$props.loop;
            },
            get trapFocus() {
              return trapFocus();
            },
            get isValidEvent() {
              return isValidEvent2();
            },
            get onFocusOutside() {
              return $$props.onFocusOutside;
            },
            forceMount: false
          },
          () => restProps
        ));
      });
      Presence_layer($$anchor, spread_props(
        {
          get id() {
            return $$props.id;
          },
          get present() {
            return $$props.present;
          }
        },
        () => restProps,
        { presence, $$slots: { presence: true } }
      ));
    }
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popper_layer);
  mark_module_start();
  Popper_layer_force_mount[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte";
  function Popper_layer_force_mount($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popper_layer_force_mount);
    validate_prop_bindings($$props, [], [], Popper_layer_force_mount);
    let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "popper",
        "onEscapeKeydown",
        "escapeKeydownBehavior",
        "preventOverflowTextSelection",
        "id",
        "onPointerDown",
        "onPointerUp",
        "side",
        "sideOffset",
        "align",
        "alignOffset",
        "arrowPadding",
        "avoidCollisions",
        "collisionBoundary",
        "collisionPadding",
        "sticky",
        "hideWhenDetached",
        "updatePositionStrategy",
        "strategy",
        "dir",
        "preventScroll",
        "wrapperId",
        "style",
        "onPlaced",
        "onInteractOutside",
        "onCloseAutoFocus",
        "onOpenAutoFocus",
        "onFocusOutside",
        "interactOutsideBehavior",
        "loop",
        "trapFocus",
        "isValidEvent",
        "customAnchor",
        "isStatic",
        "enabled"
      ],
      "restProps"
    );
    Popper_layer_inner($$anchor, spread_props(
      {
        get popper() {
          return $$props.popper;
        },
        get onEscapeKeydown() {
          return $$props.onEscapeKeydown;
        },
        get escapeKeydownBehavior() {
          return $$props.escapeKeydownBehavior;
        },
        get preventOverflowTextSelection() {
          return $$props.preventOverflowTextSelection;
        },
        get id() {
          return $$props.id;
        },
        get onPointerDown() {
          return $$props.onPointerDown;
        },
        get onPointerUp() {
          return $$props.onPointerUp;
        },
        get side() {
          return $$props.side;
        },
        get sideOffset() {
          return $$props.sideOffset;
        },
        get align() {
          return $$props.align;
        },
        get alignOffset() {
          return $$props.alignOffset;
        },
        get arrowPadding() {
          return $$props.arrowPadding;
        },
        get avoidCollisions() {
          return $$props.avoidCollisions;
        },
        get collisionBoundary() {
          return $$props.collisionBoundary;
        },
        get collisionPadding() {
          return $$props.collisionPadding;
        },
        get sticky() {
          return $$props.sticky;
        },
        get hideWhenDetached() {
          return $$props.hideWhenDetached;
        },
        get updatePositionStrategy() {
          return $$props.updatePositionStrategy;
        },
        get strategy() {
          return $$props.strategy;
        },
        get dir() {
          return $$props.dir;
        },
        get preventScroll() {
          return $$props.preventScroll;
        },
        get wrapperId() {
          return $$props.wrapperId;
        },
        get style() {
          return $$props.style;
        },
        get onPlaced() {
          return $$props.onPlaced;
        },
        get customAnchor() {
          return customAnchor();
        },
        get isStatic() {
          return isStatic();
        },
        get enabled() {
          return $$props.enabled;
        },
        get onInteractOutside() {
          return $$props.onInteractOutside;
        },
        get onCloseAutoFocus() {
          return $$props.onCloseAutoFocus;
        },
        get onOpenAutoFocus() {
          return $$props.onOpenAutoFocus;
        },
        get interactOutsideBehavior() {
          return interactOutsideBehavior();
        },
        get loop() {
          return $$props.loop;
        },
        get trapFocus() {
          return trapFocus();
        },
        get isValidEvent() {
          return isValidEvent2();
        },
        get onFocusOutside() {
          return $$props.onFocusOutside;
        }
      },
      () => restProps,
      { forceMount: true }
    ));
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popper_layer_force_mount);
  class PopoverRootState {
    constructor(props) {
      __publicField(this, "open");
      __privateAdd(this, _contentNode2, state(null));
      __privateAdd(this, _contentId2, state(void 0));
      __privateAdd(this, _triggerNode2, state(null));
      this.open = props.open;
    }
    get contentNode() {
      return get$2(__privateGet(this, _contentNode2));
    }
    set contentNode(value) {
      set(__privateGet(this, _contentNode2), proxy(value, null, __privateGet(this, _contentNode2)));
    }
    get contentId() {
      return get$2(__privateGet(this, _contentId2));
    }
    set contentId(value) {
      set(__privateGet(this, _contentId2), proxy(value, null, __privateGet(this, _contentId2)));
    }
    get triggerNode() {
      return get$2(__privateGet(this, _triggerNode2));
    }
    set triggerNode(value) {
      set(__privateGet(this, _triggerNode2), proxy(value, null, __privateGet(this, _triggerNode2)));
    }
    toggleOpen() {
      this.open.current = !this.open.current;
    }
    handleClose() {
      if (!this.open.current) return;
      this.open.current = false;
    }
    [ADD_OWNER](owner) {
      add_owner(get$2(__privateGet(this, _contentNode2)), owner, false);
      add_owner(get$2(__privateGet(this, _contentId2)), owner, false);
      add_owner(get$2(__privateGet(this, _triggerNode2)), owner, false);
    }
  }
  _contentNode2 = new WeakMap();
  _contentId2 = new WeakMap();
  _triggerNode2 = new WeakMap();
  class PopoverTriggerState {
    constructor(props, root2) {
      __privateAdd(this, _PopoverTriggerState_instances);
      __privateAdd(this, _id12);
      __privateAdd(this, _ref12);
      __privateAdd(this, _disabled4);
      __privateAdd(this, _root6);
      __privateAdd(this, _props21, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id12).current,
        "aria-haspopup": "dialog",
        "aria-expanded": getAriaExpanded(__privateGet(this, _root6).open.current),
        "data-state": getDataOpenClosed(__privateGet(this, _root6).open.current),
        "aria-controls": __privateMethod(this, _PopoverTriggerState_instances, getAriaControls_fn).call(this),
        "data-popover-trigger": "",
        disabled: __privateGet(this, _disabled4).current,
        //
        onpointerdown: this.onpointerdown,
        onkeydown: this.onkeydown,
        onclick: this.onclick
      })));
      __privateSet(this, _id12, props.id);
      __privateSet(this, _root6, root2);
      __privateSet(this, _ref12, props.ref);
      __privateSet(this, _disabled4, props.disabled);
      useRefById({
        id: __privateGet(this, _id12),
        ref: __privateGet(this, _ref12),
        onRefChange: (node) => {
          __privateGet(this, _root6).triggerNode = node;
        }
      });
      this.onclick = this.onclick.bind(this);
      this.onpointerdown = this.onpointerdown.bind(this);
      this.onkeydown = this.onkeydown.bind(this);
    }
    onclick(e) {
      if (__privateGet(this, _disabled4).current) return;
      if (strict_equals(e.button, 0, false)) return;
      __privateGet(this, _root6).toggleOpen();
    }
    onpointerdown(e) {
      if (__privateGet(this, _disabled4).current) return;
      if (strict_equals(e.button, 0, false)) return;
      e.preventDefault();
    }
    onkeydown(e) {
      if (__privateGet(this, _disabled4).current) return;
      if (!(strict_equals(e.key, ENTER) || strict_equals(e.key, SPACE))) return;
      e.preventDefault();
      __privateGet(this, _root6).toggleOpen();
    }
    get props() {
      return get$2(__privateGet(this, _props21));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id12 = new WeakMap();
  _ref12 = new WeakMap();
  _disabled4 = new WeakMap();
  _root6 = new WeakMap();
  _PopoverTriggerState_instances = new WeakSet();
  getAriaControls_fn = function() {
    if (__privateGet(this, _root6).open.current && __privateGet(this, _root6).contentId) {
      return __privateGet(this, _root6).contentId;
    }
    return void 0;
  };
  _props21 = new WeakMap();
  class PopoverContentState {
    constructor(props, root2) {
      __privateAdd(this, _id13);
      __privateAdd(this, _ref13);
      __publicField(this, "root");
      __privateAdd(this, _snippetProps4, /* @__PURE__ */ derived(() => ({ open: this.root.open.current })));
      __privateAdd(this, _props22, /* @__PURE__ */ derived(() => ({
        id: __privateGet(this, _id13).current,
        tabindex: -1,
        "data-state": getDataOpenClosed(this.root.open.current),
        "data-popover-content": "",
        style: { pointerEvents: "auto" }
      })));
      __privateSet(this, _id13, props.id);
      this.root = root2;
      __privateSet(this, _ref13, props.ref);
      useRefById({
        id: __privateGet(this, _id13),
        ref: __privateGet(this, _ref13),
        deps: () => this.root.open.current,
        onRefChange: (node) => {
          this.root.contentNode = node;
          this.root.contentId = node == null ? void 0 : node.id;
        }
      });
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps4));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props22));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id13 = new WeakMap();
  _ref13 = new WeakMap();
  _snippetProps4 = new WeakMap();
  _props22 = new WeakMap();
  const [setPopoverRootContext, getPopoverRootContext] = createContext("Popover.Root");
  function usePopoverRoot(props) {
    return setPopoverRootContext(new PopoverRootState(props));
  }
  function usePopoverTrigger(props) {
    return new PopoverTriggerState(props, getPopoverRootContext());
  }
  function usePopoverContent(props) {
    return new PopoverContentState(props, getPopoverRootContext());
  }
  mark_module_start();
  Popover_content$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte";
  var root_4$1 = add_locations(/* @__PURE__ */ template(`<div><div><!></div></div>`), Popover_content$1[FILENAME], [[77, 4, [[78, 5]]]]);
  var root_9$1 = add_locations(/* @__PURE__ */ template(`<div><div><!></div></div>`), Popover_content$1[FILENAME], [[105, 4, [[106, 5]]]]);
  function Popover_content$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popover_content$1);
    validate_prop_bindings($$props, ["ref"], [], Popover_content$1);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop), onInteractOutside = prop($$props, "onInteractOutside", 3, noop), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "child",
        "children",
        "ref",
        "id",
        "forceMount",
        "onCloseAutoFocus",
        "onEscapeKeydown",
        "onInteractOutside",
        "trapFocus",
        "preventScroll"
      ],
      "restProps"
    );
    const contentState = usePopoverContent({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, contentState.props));
    function handleInteractOutside(e) {
      onInteractOutside()(e);
      if (e.defaultPrevented) return;
      if (isHTMLElement$1(e.target) && e.target.closest("[data-popover-trigger")) return;
      contentState.root.handleClose();
    }
    function handleEscapeKeydown(e) {
      onEscapeKeydown()(e);
      if (e.defaultPrevented) return;
      contentState.root.handleClose();
    }
    function handleCloseAutoFocus(e) {
      var _a2;
      onCloseAutoFocus()(e);
      if (e.defaultPrevented) return;
      e.preventDefault();
      (_a2 = contentState.root.triggerNode) == null ? void 0 : _a2.focus();
    }
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent_1 = ($$anchor2) => {
        {
          const popper = wrap_snippet(Popover_content$1, ($$anchor3, $$arg0) => {
            let props = () => $$arg0 == null ? void 0 : $$arg0().props;
            props();
            let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
            wrapperProps();
            var fragment_2 = comment();
            const finalProps = /* @__PURE__ */ derived(() => mergeProps(props(), {
              style: getFloatingContentCSSVars("popover")
            }));
            get$2(finalProps);
            var node_1 = first_child(fragment_2);
            {
              var consequent = ($$anchor4) => {
                var fragment_3 = comment();
                var node_2 = first_child(fragment_3);
                snippet(node_2, () => $$props.child, () => ({
                  props: get$2(finalProps),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                append($$anchor4, fragment_3);
              };
              var alternate = ($$anchor4) => {
                var div = root_4$1();
                let attributes;
                var div_1 = child(div);
                let attributes_1;
                var node_3 = child(div_1);
                snippet(node_3, () => $$props.children ?? noop$1);
                reset(div_1);
                reset(div);
                template_effect(() => {
                  attributes = set_attributes(div, attributes, { ...wrapperProps() });
                  attributes_1 = set_attributes(div_1, attributes_1, { ...get$2(finalProps) });
                });
                append($$anchor4, div);
              };
              if_block(node_1, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              });
            }
            append($$anchor3, fragment_2);
          });
          Popper_layer_force_mount($$anchor2, spread_props(() => get$2(mergedProps), {
            get enabled() {
              return contentState.root.open.current;
            },
            get id() {
              return id();
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            onCloseAutoFocus: handleCloseAutoFocus,
            get trapFocus() {
              return trapFocus();
            },
            get preventScroll() {
              return preventScroll();
            },
            loop: true,
            forceMount: true,
            popper,
            $$slots: { popper: true }
          }));
        }
      };
      var alternate_2 = ($$anchor2) => {
        var fragment_4 = comment();
        var node_4 = first_child(fragment_4);
        {
          var consequent_3 = ($$anchor3) => {
            {
              const popper = wrap_snippet(Popover_content$1, ($$anchor4, $$arg0) => {
                let props = () => $$arg0 == null ? void 0 : $$arg0().props;
                props();
                let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
                wrapperProps();
                var fragment_6 = comment();
                const finalProps = /* @__PURE__ */ derived(() => mergeProps(props(), {
                  style: getFloatingContentCSSVars("popover")
                }));
                get$2(finalProps);
                var node_5 = first_child(fragment_6);
                {
                  var consequent_2 = ($$anchor5) => {
                    var fragment_7 = comment();
                    var node_6 = first_child(fragment_7);
                    snippet(node_6, () => $$props.child, () => ({
                      props: get$2(finalProps),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    append($$anchor5, fragment_7);
                  };
                  var alternate_1 = ($$anchor5) => {
                    var div_2 = root_9$1();
                    let attributes_2;
                    var div_3 = child(div_2);
                    let attributes_3;
                    var node_7 = child(div_3);
                    snippet(node_7, () => $$props.children ?? noop$1);
                    reset(div_3);
                    reset(div_2);
                    template_effect(() => {
                      attributes_2 = set_attributes(div_2, attributes_2, { ...wrapperProps() });
                      attributes_3 = set_attributes(div_3, attributes_3, { ...get$2(finalProps) });
                    });
                    append($$anchor5, div_2);
                  };
                  if_block(node_5, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  });
                }
                append($$anchor4, fragment_6);
              });
              Popper_layer($$anchor3, spread_props(() => get$2(mergedProps), {
                get present() {
                  return contentState.root.open.current;
                },
                get id() {
                  return id();
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                onCloseAutoFocus: handleCloseAutoFocus,
                get trapFocus() {
                  return trapFocus();
                },
                get preventScroll() {
                  return preventScroll();
                },
                loop: true,
                forceMount: false,
                popper,
                $$slots: { popper: true }
              }));
            }
          };
          if_block(
            node_4,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          );
        }
        append($$anchor2, fragment_4);
      };
      if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popover_content$1);
  mark_module_start();
  Popover_trigger[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte";
  var root_3$2 = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Popover_trigger[FILENAME], [[34, 2]]);
  function Popover_trigger($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popover_trigger);
    validate_prop_bindings($$props, ["ref"], [], Popover_trigger);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref",
        "type",
        "disabled"
      ],
      "restProps"
    );
    const triggerState = usePopoverTrigger({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2)),
      disabled: box.with(() => Boolean(disabled()))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
    Floating_layer_anchor($$anchor, {
      get id() {
        return id();
      },
      children: wrap_snippet(Popover_trigger, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var button = root_3$2();
            let attributes;
            var node_2 = child(button);
            snippet(node_2, () => $$props.children ?? noop$1);
            reset(button);
            template_effect(() => attributes = set_attributes(button, attributes, { ...get$2(mergedProps) }));
            append($$anchor3, button);
          };
          if_block(node, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    });
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popover_trigger);
  class RangeCalendarRootState {
    constructor(props) {
      __privateAdd(this, _RangeCalendarRootState_instances);
      __publicField(this, "id");
      __publicField(this, "ref");
      __publicField(this, "value");
      __publicField(this, "placeholder");
      __publicField(this, "preventDeselect");
      __publicField(this, "minValue");
      __publicField(this, "maxValue");
      __publicField(this, "disabled");
      __publicField(this, "pagedNavigation");
      __publicField(this, "weekStartsOn");
      __publicField(this, "weekdayFormat");
      __publicField(this, "isDateDisabledProp");
      __publicField(this, "isDateUnavailableProp");
      __publicField(this, "fixedWeeks");
      __publicField(this, "numberOfMonths");
      __publicField(this, "locale");
      __publicField(this, "calendarLabel");
      __publicField(this, "readonly");
      __publicField(this, "disableDaysOutsideMonth");
      __publicField(this, "onRangeSelect");
      __publicField(this, "startValue");
      __publicField(this, "endValue");
      __privateAdd(this, _months, state(proxy([])));
      __privateAdd(this, _visibleMonths, /* @__PURE__ */ derived(() => this.months.map((month) => month.value)));
      __publicField(this, "announcer");
      __publicField(this, "formatter");
      __publicField(this, "accessibleHeadingId", useId());
      __privateAdd(this, _focusedValue, state(void 0));
      __privateAdd(this, _lastPressedDateValue, state(void 0));
      __publicField(this, "setMonths", (months) => {
        this.months = months;
      });
      __privateAdd(this, _weekdays, /* @__PURE__ */ derived(() => {
        return getWeekdays({
          months: this.months,
          formatter: this.formatter,
          weekdayFormat: this.weekdayFormat.current
        });
      }));
      __privateAdd(this, _isStartInvalid, /* @__PURE__ */ derived(() => {
        if (!this.startValue.current) return false;
        return this.isDateUnavailable(this.startValue.current) || this.isDateDisabled(this.startValue.current);
      }));
      __privateAdd(this, _isEndInvalid, /* @__PURE__ */ derived(() => {
        if (!this.endValue.current) return false;
        return this.isDateUnavailable(this.endValue.current) || this.isDateDisabled(this.endValue.current);
      }));
      __privateAdd(this, _isInvalid, /* @__PURE__ */ derived(() => {
        if (this.isStartInvalid || this.isEndInvalid) return true;
        if (this.endValue.current && this.startValue.current && isBefore(this.endValue.current, this.startValue.current)) return true;
        return false;
      }));
      __privateAdd(this, _isNextButtonDisabled, /* @__PURE__ */ derived(() => {
        return getIsNextButtonDisabled({
          maxValue: this.maxValue.current,
          months: this.months,
          disabled: this.disabled.current
        });
      }));
      __privateAdd(this, _isPrevButtonDisabled, /* @__PURE__ */ derived(() => {
        return getIsPrevButtonDisabled({
          minValue: this.minValue.current,
          months: this.months,
          disabled: this.disabled.current
        });
      }));
      __privateAdd(this, _headingValue2, /* @__PURE__ */ derived(() => {
        return getCalendarHeadingValue({
          months: this.months,
          formatter: this.formatter,
          locale: this.locale.current
        });
      }));
      __privateAdd(this, _fullCalendarLabel, /* @__PURE__ */ derived(() => `${this.calendarLabel.current} ${this.headingValue}`));
      __privateAdd(this, _highlightedRange, /* @__PURE__ */ derived(() => {
        if (this.startValue.current && this.endValue.current) return null;
        if (!this.startValue.current || !this.focusedValue) return null;
        const isStartBeforeFocused = isBefore(this.startValue.current, this.focusedValue);
        const start = isStartBeforeFocused ? this.startValue.current : this.focusedValue;
        const end = isStartBeforeFocused ? this.focusedValue : this.startValue.current;
        if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start.add({ days: 1 }), end)) {
          return { start, end };
        }
        const isValid = areAllDaysBetweenValid(start, end, this.isDateUnavailable, this.isDateDisabled);
        if (isValid) {
          return { start, end };
        }
        return null;
      }));
      __privateAdd(this, _snippetProps5, /* @__PURE__ */ derived(() => ({ months: this.months, weekdays: this.weekdays })));
      __privateAdd(this, _props23, /* @__PURE__ */ derived(() => ({
        ...getCalendarElementProps({
          fullCalendarLabel: this.fullCalendarLabel,
          id: this.id.current,
          isInvalid: this.isInvalid,
          disabled: this.disabled.current,
          readonly: this.readonly.current
        }),
        [this.getBitsAttr("root")]: "",
        //
        onkeydown: this.onkeydown
      })));
      this.value = props.value;
      this.placeholder = props.placeholder;
      this.preventDeselect = props.preventDeselect;
      this.minValue = props.minValue;
      this.maxValue = props.maxValue;
      this.disabled = props.disabled;
      this.pagedNavigation = props.pagedNavigation;
      this.weekStartsOn = props.weekStartsOn;
      this.weekdayFormat = props.weekdayFormat;
      this.isDateDisabledProp = props.isDateDisabled;
      this.isDateUnavailableProp = props.isDateUnavailable;
      this.fixedWeeks = props.fixedWeeks;
      this.numberOfMonths = props.numberOfMonths;
      this.locale = props.locale;
      this.calendarLabel = props.calendarLabel;
      this.readonly = props.readonly;
      this.disableDaysOutsideMonth = props.disableDaysOutsideMonth;
      this.id = props.id;
      this.ref = props.ref;
      this.onRangeSelect = props.onRangeSelect;
      this.startValue = props.startValue;
      this.endValue = props.endValue;
      this.announcer = getAnnouncer();
      this.formatter = createFormatter(this.locale.current);
      useRefById({ id: this.id, ref: this.ref });
      this.months = createMonths({
        dateObj: this.placeholder.current,
        weekStartsOn: this.weekStartsOn.current,
        locale: this.locale.current,
        fixedWeeks: this.fixedWeeks.current,
        numberOfMonths: this.numberOfMonths.current
      });
      user_effect(() => {
        if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
        this.formatter.setLocale(this.locale.current);
      });
      useMonthViewPlaceholderSync({
        placeholder: this.placeholder,
        getVisibleMonths: () => this.visibleMonths,
        weekStartsOn: this.weekStartsOn,
        locale: this.locale,
        fixedWeeks: this.fixedWeeks,
        numberOfMonths: this.numberOfMonths,
        setMonths: this.setMonths
      });
      useMonthViewOptionsSync({
        fixedWeeks: this.fixedWeeks,
        locale: this.locale,
        numberOfMonths: this.numberOfMonths,
        placeholder: this.placeholder,
        setMonths: this.setMonths,
        weekStartsOn: this.weekStartsOn
      });
      user_effect(() => {
        const node = document.getElementById(this.accessibleHeadingId);
        if (!node) return;
        node.textContent = this.fullCalendarLabel;
      });
      user_effect(() => {
        const value = this.value.current;
        untrack(() => {
          if (value.start && value.end) {
            this.startValue.current = value.start;
            this.endValue.current = value.end;
          } else if (value.start) {
            this.startValue.current = value.start;
            this.endValue.current = void 0;
          }
        });
      });
      user_effect(() => {
        this.value.current;
        untrack(() => {
          const startValue = this.value.current.start;
          if (startValue && strict_equals(this.placeholder.current, startValue, false)) {
            this.placeholder.current = startValue;
          }
        });
      });
      user_effect(() => {
        const startValue = this.startValue.current;
        const endValue = this.endValue.current;
        untrack(() => {
          const value = this.value.current;
          if (value && strict_equals(value.start, startValue) && strict_equals(value.end, endValue)) {
            return;
          }
          if (startValue && endValue) {
            __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn).call(this, (prev) => {
              if (strict_equals(prev.start, startValue) && strict_equals(prev.end, endValue)) return prev;
              if (isBefore(endValue, startValue)) {
                const start = startValue;
                const end = endValue;
                __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, end);
                __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, start);
                return { start: endValue, end: startValue };
              } else {
                return { start: startValue, end: endValue };
              }
            });
          } else if (value && value.start && value.end) {
            this.value.current = { start: void 0, end: void 0 };
          }
        });
      });
      this.shiftFocus = this.shiftFocus.bind(this);
      this.handleCellClick = this.handleCellClick.bind(this);
      this.onkeydown = this.onkeydown.bind(this);
      this.nextPage = this.nextPage.bind(this);
      this.prevPage = this.prevPage.bind(this);
      this.nextYear = this.nextYear.bind(this);
      this.prevYear = this.prevYear.bind(this);
      this.setYear = this.setYear.bind(this);
      this.setMonth = this.setMonth.bind(this);
      this.isDateDisabled = this.isDateDisabled.bind(this);
      this.isDateUnavailable = this.isDateUnavailable.bind(this);
      this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
      this.isSelected = this.isSelected.bind(this);
    }
    get months() {
      return get$2(__privateGet(this, _months));
    }
    set months(value) {
      set(__privateGet(this, _months), proxy(value, null, __privateGet(this, _months)));
    }
    get visibleMonths() {
      return get$2(__privateGet(this, _visibleMonths));
    }
    set visibleMonths(_2) {
      throw new Error("Cannot update a derived property ('visibleMonths')");
    }
    get focusedValue() {
      return get$2(__privateGet(this, _focusedValue));
    }
    set focusedValue(value) {
      set(__privateGet(this, _focusedValue), proxy(value, null, __privateGet(this, _focusedValue)));
    }
    get lastPressedDateValue() {
      return get$2(__privateGet(this, _lastPressedDateValue));
    }
    set lastPressedDateValue(value) {
      set(__privateGet(this, _lastPressedDateValue), proxy(value, null, __privateGet(this, _lastPressedDateValue)));
    }
    get weekdays() {
      return get$2(__privateGet(this, _weekdays));
    }
    set weekdays(_2) {
      throw new Error("Cannot update a derived property ('weekdays')");
    }
    isOutsideVisibleMonths(date) {
      return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
    }
    isDateDisabled(date) {
      if (this.isDateDisabledProp.current(date) || this.disabled.current) return true;
      const minValue = this.minValue.current;
      const maxValue = this.maxValue.current;
      if (minValue && isBefore(date, minValue)) return true;
      if (maxValue && isAfter(date, maxValue)) return true;
      return false;
    }
    isDateUnavailable(date) {
      if (this.isDateUnavailableProp.current(date)) return true;
      return false;
    }
    get isStartInvalid() {
      return get$2(__privateGet(this, _isStartInvalid));
    }
    set isStartInvalid(_2) {
      throw new Error("Cannot update a derived property ('isStartInvalid')");
    }
    get isEndInvalid() {
      return get$2(__privateGet(this, _isEndInvalid));
    }
    set isEndInvalid(_2) {
      throw new Error("Cannot update a derived property ('isEndInvalid')");
    }
    get isInvalid() {
      return get$2(__privateGet(this, _isInvalid));
    }
    set isInvalid(_2) {
      throw new Error("Cannot update a derived property ('isInvalid')");
    }
    get isNextButtonDisabled() {
      return get$2(__privateGet(this, _isNextButtonDisabled));
    }
    set isNextButtonDisabled(_2) {
      throw new Error("Cannot update a derived property ('isNextButtonDisabled')");
    }
    get isPrevButtonDisabled() {
      return get$2(__privateGet(this, _isPrevButtonDisabled));
    }
    set isPrevButtonDisabled(_2) {
      throw new Error("Cannot update a derived property ('isPrevButtonDisabled')");
    }
    get headingValue() {
      return get$2(__privateGet(this, _headingValue2));
    }
    set headingValue(_2) {
      throw new Error("Cannot update a derived property ('headingValue')");
    }
    get fullCalendarLabel() {
      return get$2(__privateGet(this, _fullCalendarLabel));
    }
    set fullCalendarLabel(_2) {
      throw new Error("Cannot update a derived property ('fullCalendarLabel')");
    }
    isSelectionStart(date) {
      if (!this.startValue.current) return false;
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.startValue.current);
    }
    isSelectionEnd(date) {
      if (!this.endValue.current) return false;
      return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.endValue.current);
    }
    isSelected(date) {
      if (this.startValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.startValue.current, date)) return true;
      if (this.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.endValue.current, date)) return true;
      if (this.startValue.current && this.endValue.current) {
        return isBetweenInclusive(date, this.startValue.current, this.endValue.current);
      }
      return false;
    }
    get highlightedRange() {
      return get$2(__privateGet(this, _highlightedRange));
    }
    set highlightedRange(_2) {
      throw new Error("Cannot update a derived property ('highlightedRange')");
    }
    shiftFocus(node, add) {
      return shiftCalendarFocus({
        node,
        add,
        placeholder: this.placeholder,
        calendarNode: this.ref.current,
        isPrevButtonDisabled: this.isPrevButtonDisabled,
        isNextButtonDisabled: this.isNextButtonDisabled,
        months: this.months,
        numberOfMonths: this.numberOfMonths.current
      });
    }
    handleCellClick(e, date) {
      if (this.isDateDisabled(date) || this.isDateUnavailable(date)) return;
      const prevLastPressedDate = this.lastPressedDateValue;
      this.lastPressedDateValue = date;
      if (this.startValue.current && strict_equals(this.highlightedRange, null)) {
        if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(this.startValue.current, date) && !this.preventDeselect.current && !this.endValue.current) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
          this.placeholder.current = date;
          __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
          return;
        } else if (!this.endValue.current) {
          e.preventDefault();
          if (prevLastPressedDate && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevLastPressedDate, date)) {
            __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
            __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
          }
        }
      }
      if (this.startValue.current && this.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.endValue.current, date) && !this.preventDeselect.current) {
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
        __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
        this.placeholder.current = date;
        __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
        return;
      }
      if (!this.startValue.current) {
        __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
      } else if (!this.endValue.current) {
        __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedRange_fn).call(this, this.startValue.current, date);
        __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, date);
      } else if (this.endValue.current && this.startValue.current) {
        __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
        __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
      }
    }
    onkeydown(event2) {
      return handleCalendarKeydown({
        event: event2,
        handleCellClick: this.handleCellClick,
        placeholderValue: this.placeholder.current,
        shiftFocus: this.shiftFocus
      });
    }
    /**
     * Navigates to the next page of the calendar.
     */
    nextPage() {
      handleCalendarNextPage({
        fixedWeeks: this.fixedWeeks.current,
        locale: this.locale.current,
        numberOfMonths: this.numberOfMonths.current,
        pagedNavigation: this.pagedNavigation.current,
        setMonths: this.setMonths,
        setPlaceholder: (date) => this.placeholder.current = date,
        weekStartsOn: this.weekStartsOn.current,
        months: this.months
      });
    }
    /**
     * Navigates to the previous page of the calendar.
     */
    prevPage() {
      handleCalendarPrevPage({
        fixedWeeks: this.fixedWeeks.current,
        locale: this.locale.current,
        numberOfMonths: this.numberOfMonths.current,
        pagedNavigation: this.pagedNavigation.current,
        setMonths: this.setMonths,
        setPlaceholder: (date) => this.placeholder.current = date,
        weekStartsOn: this.weekStartsOn.current,
        months: this.months
      });
    }
    nextYear() {
      this.placeholder.current = this.placeholder.current.add({ years: 1 });
    }
    prevYear() {
      this.placeholder.current = this.placeholder.current.subtract({ years: 1 });
    }
    setYear(year) {
      this.placeholder.current = this.placeholder.current.set({ year });
    }
    setMonth(month) {
      this.placeholder.current = this.placeholder.current.set({ month });
    }
    getBitsAttr(part) {
      return `data-range-calendar-${part}`;
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps5));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props23));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
      add_owner(get$2(__privateGet(this, _months)), owner, false);
      add_owner(get$2(__privateGet(this, _focusedValue)), owner, false);
      add_owner(get$2(__privateGet(this, _lastPressedDateValue)), owner, false);
    }
  }
  _months = new WeakMap();
  _visibleMonths = new WeakMap();
  _focusedValue = new WeakMap();
  _lastPressedDateValue = new WeakMap();
  _RangeCalendarRootState_instances = new WeakSet();
  updateValue_fn = function(cb) {
    var _a2, _b2;
    const value = this.value.current;
    const newValue = cb(value);
    this.value.current = newValue;
    if (newValue.start && newValue.end) {
      (_b2 = (_a2 = this.onRangeSelect) == null ? void 0 : _a2.current) == null ? void 0 : _b2.call(_a2);
    }
  };
  setStartValue_fn = function(value) {
    this.startValue.current = value;
  };
  setEndValue_fn = function(value) {
    this.endValue.current = value;
  };
  _weekdays = new WeakMap();
  _isStartInvalid = new WeakMap();
  _isEndInvalid = new WeakMap();
  _isInvalid = new WeakMap();
  _isNextButtonDisabled = new WeakMap();
  _isPrevButtonDisabled = new WeakMap();
  _headingValue2 = new WeakMap();
  _fullCalendarLabel = new WeakMap();
  _highlightedRange = new WeakMap();
  announceEmpty_fn = function() {
    this.announcer.announce("Selected date is now empty.", "polite");
  };
  announceSelectedDate_fn = function(date) {
    this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(date, false)}`, "polite");
  };
  announceSelectedRange_fn = function(start, end) {
    this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(start, false)} to ${this.formatter.selectedDate(end, false)}`, "polite");
  };
  _snippetProps5 = new WeakMap();
  _props23 = new WeakMap();
  class RangeCalendarCellState {
    constructor(props, root2) {
      __publicField(this, "root");
      __publicField(this, "id");
      __publicField(this, "ref");
      __publicField(this, "date");
      __publicField(this, "month");
      __privateAdd(this, _cellDate, /* @__PURE__ */ derived(() => toDate(this.date.current)));
      __privateAdd(this, _isDisabled5, /* @__PURE__ */ derived(() => this.root.isDateDisabled(this.date.current)));
      __privateAdd(this, _isUnavailable, /* @__PURE__ */ derived(() => this.root.isDateUnavailableProp.current(this.date.current)));
      __privateAdd(this, _isDateToday, /* @__PURE__ */ derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())));
      __privateAdd(this, _isOutsideMonth, /* @__PURE__ */ derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.date.current, this.month.current)));
      __privateAdd(this, _isOutsideVisibleMonths, /* @__PURE__ */ derived(() => this.root.isOutsideVisibleMonths(this.date.current)));
      __privateAdd(this, _isFocusedDate, /* @__PURE__ */ derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.date.current, this.root.placeholder.current)));
      __privateAdd(this, _isSelectedDate, /* @__PURE__ */ derived(() => this.root.isSelected(this.date.current)));
      __privateAdd(this, _isSelectionStart, /* @__PURE__ */ derived(() => this.root.isSelectionStart(this.date.current)));
      __privateAdd(this, _isSelectionEnd, /* @__PURE__ */ derived(() => this.root.isSelectionEnd(this.date.current)));
      __privateAdd(this, _isHighlighted, /* @__PURE__ */ derived(() => this.root.highlightedRange ? isBetweenInclusive(this.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : false));
      __privateAdd(this, _labelText, /* @__PURE__ */ derived(() => this.root.formatter.custom(this.cellDate, {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      })));
      __privateAdd(this, _snippetProps6, /* @__PURE__ */ derived(() => ({
        disabled: this.isDisabled,
        unavailable: this.isUnavailable,
        selected: this.isSelectedDate
      })));
      __privateAdd(this, _ariaDisabled, /* @__PURE__ */ derived(() => {
        return this.isDisabled || this.isOutsideMonth && this.root.disableDaysOutsideMonth.current || this.isUnavailable;
      }));
      __privateAdd(this, _sharedDataAttrs, /* @__PURE__ */ derived(() => ({
        "data-unavailable": getDataUnavailable(this.isUnavailable),
        "data-today": this.isDateToday ? "" : void 0,
        "data-outside-month": this.isOutsideMonth ? "" : void 0,
        "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
        "data-focused": this.isFocusedDate ? "" : void 0,
        "data-selection-start": this.isSelectionStart ? "" : void 0,
        "data-selection-end": this.isSelectionEnd ? "" : void 0,
        "data-highlighted": this.isHighlighted ? "" : void 0,
        "data-selected": getDataSelected(this.isSelectedDate),
        "data-value": this.date.current.toString(),
        "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.disableDaysOutsideMonth.current)
      })));
      __privateAdd(this, _props24, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        role: "gridcell",
        "aria-selected": getAriaSelected(this.isSelectedDate),
        "aria-disabled": getAriaDisabled(this.ariaDisabled),
        ...this.sharedDataAttrs,
        [this.root.getBitsAttr("cell")]: ""
      })));
      this.root = root2;
      this.id = props.id;
      this.ref = props.ref;
      this.date = props.date;
      this.month = props.month;
      useRefById({ id: this.id, ref: this.ref });
    }
    get cellDate() {
      return get$2(__privateGet(this, _cellDate));
    }
    set cellDate(_2) {
      throw new Error("Cannot update a derived property ('cellDate')");
    }
    get isDisabled() {
      return get$2(__privateGet(this, _isDisabled5));
    }
    set isDisabled(_2) {
      throw new Error("Cannot update a derived property ('isDisabled')");
    }
    get isUnavailable() {
      return get$2(__privateGet(this, _isUnavailable));
    }
    set isUnavailable(_2) {
      throw new Error("Cannot update a derived property ('isUnavailable')");
    }
    get isDateToday() {
      return get$2(__privateGet(this, _isDateToday));
    }
    set isDateToday(_2) {
      throw new Error("Cannot update a derived property ('isDateToday')");
    }
    get isOutsideMonth() {
      return get$2(__privateGet(this, _isOutsideMonth));
    }
    set isOutsideMonth(_2) {
      throw new Error("Cannot update a derived property ('isOutsideMonth')");
    }
    get isOutsideVisibleMonths() {
      return get$2(__privateGet(this, _isOutsideVisibleMonths));
    }
    set isOutsideVisibleMonths(_2) {
      throw new Error("Cannot update a derived property ('isOutsideVisibleMonths')");
    }
    get isFocusedDate() {
      return get$2(__privateGet(this, _isFocusedDate));
    }
    set isFocusedDate(_2) {
      throw new Error("Cannot update a derived property ('isFocusedDate')");
    }
    get isSelectedDate() {
      return get$2(__privateGet(this, _isSelectedDate));
    }
    set isSelectedDate(_2) {
      throw new Error("Cannot update a derived property ('isSelectedDate')");
    }
    get isSelectionStart() {
      return get$2(__privateGet(this, _isSelectionStart));
    }
    set isSelectionStart(_2) {
      throw new Error("Cannot update a derived property ('isSelectionStart')");
    }
    get isSelectionEnd() {
      return get$2(__privateGet(this, _isSelectionEnd));
    }
    set isSelectionEnd(_2) {
      throw new Error("Cannot update a derived property ('isSelectionEnd')");
    }
    get isHighlighted() {
      return get$2(__privateGet(this, _isHighlighted));
    }
    set isHighlighted(_2) {
      throw new Error("Cannot update a derived property ('isHighlighted')");
    }
    get labelText() {
      return get$2(__privateGet(this, _labelText));
    }
    set labelText(_2) {
      throw new Error("Cannot update a derived property ('labelText')");
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps6));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get ariaDisabled() {
      return get$2(__privateGet(this, _ariaDisabled));
    }
    set ariaDisabled(_2) {
      throw new Error("Cannot update a derived property ('ariaDisabled')");
    }
    get sharedDataAttrs() {
      return get$2(__privateGet(this, _sharedDataAttrs));
    }
    set sharedDataAttrs(_2) {
      throw new Error("Cannot update a derived property ('sharedDataAttrs')");
    }
    get props() {
      return get$2(__privateGet(this, _props24));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _cellDate = new WeakMap();
  _isDisabled5 = new WeakMap();
  _isUnavailable = new WeakMap();
  _isDateToday = new WeakMap();
  _isOutsideMonth = new WeakMap();
  _isOutsideVisibleMonths = new WeakMap();
  _isFocusedDate = new WeakMap();
  _isSelectedDate = new WeakMap();
  _isSelectionStart = new WeakMap();
  _isSelectionEnd = new WeakMap();
  _isHighlighted = new WeakMap();
  _labelText = new WeakMap();
  _snippetProps6 = new WeakMap();
  _ariaDisabled = new WeakMap();
  _sharedDataAttrs = new WeakMap();
  _props24 = new WeakMap();
  class RangeCalendarDayState {
    constructor(props, cell) {
      __publicField(this, "cell");
      __publicField(this, "id");
      __publicField(this, "ref");
      __privateAdd(this, _tabindex, /* @__PURE__ */ derived(() => this.cell.isFocusedDate ? 0 : this.cell.isOutsideMonth && this.cell.root.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : -1));
      __privateAdd(this, _snippetProps7, /* @__PURE__ */ derived(() => ({
        disabled: this.cell.isDisabled,
        unavailable: this.cell.isUnavailable,
        selected: this.cell.isSelectedDate,
        day: `${this.cell.date.current.day}`
      })));
      __privateAdd(this, _props25, /* @__PURE__ */ derived(() => ({
        id: this.id.current,
        role: "button",
        "aria-label": this.cell.labelText,
        "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
        ...this.cell.sharedDataAttrs,
        tabindex: get$2(__privateGet(this, _tabindex)),
        [this.cell.root.getBitsAttr("day")]: "",
        // Shared logic for range calendar and calendar
        "data-bits-day": "",
        //
        onclick: this.onclick,
        onmouseenter: this.onmouseenter,
        onfocusin: this.onfocusin
      })));
      this.cell = cell;
      this.id = props.id;
      this.ref = props.ref;
      useRefById({ id: this.id, ref: this.ref });
      this.onclick = this.onclick.bind(this);
      this.onmouseenter = this.onmouseenter.bind(this);
      this.onfocusin = this.onfocusin.bind(this);
    }
    onclick(e) {
      if (this.cell.isDisabled) return;
      this.cell.root.handleCellClick(e, this.cell.date.current);
    }
    onmouseenter(_2) {
      if (this.cell.isDisabled) return;
      this.cell.root.focusedValue = this.cell.date.current;
    }
    onfocusin(_2) {
      if (this.cell.isDisabled) return;
      this.cell.root.focusedValue = this.cell.date.current;
    }
    get snippetProps() {
      return get$2(__privateGet(this, _snippetProps7));
    }
    set snippetProps(_2) {
      throw new Error("Cannot update a derived property ('snippetProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props25));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _tabindex = new WeakMap();
  _snippetProps7 = new WeakMap();
  _props25 = new WeakMap();
  const [
    setRangeCalendarRootContext,
    getRangeCalendarRootContext
  ] = createContext(["Calendar.Root", "RangeCalendar.Root"], "Calendar.Root", false);
  const [
    setRangeCalendarCellContext,
    getRangeCalendarCellContext
  ] = createContext("RangeCalendar.Cell");
  function useRangeCalendarRoot(props) {
    return setRangeCalendarRootContext(new RangeCalendarRootState(props));
  }
  function useRangeCalendarCell(props) {
    return setRangeCalendarCellContext(new RangeCalendarCellState(props, getRangeCalendarRootContext()));
  }
  function useRangeCalendarDay(props) {
    return new RangeCalendarDayState(props, getRangeCalendarCellContext());
  }
  mark_module_start();
  Range_calendar_cell$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte";
  var root_2$a = add_locations(/* @__PURE__ */ template(`<td><!></td>`), Range_calendar_cell$1[FILENAME], [[33, 1]]);
  function Range_calendar_cell$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_cell$1);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_cell$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref",
        "date",
        "month"
      ],
      "restProps"
    );
    const cellState = useRangeCalendarCell({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2)),
      date: box.with(() => $$props.date),
      month: box.with(() => $$props.month)
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, cellState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({
          props: get$2(mergedProps),
          ...cellState.snippetProps
        }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var td = root_2$a();
        let attributes;
        var node_2 = child(td);
        snippet(node_2, () => $$props.children ?? noop$1, () => cellState.snippetProps);
        template_effect(() => attributes = set_attributes(td, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, td);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_cell$1);
  mark_module_start();
  Range_calendar_day$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte";
  var root_2$9 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Range_calendar_day$1[FILENAME], [[29, 1]]);
  function Range_calendar_day$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_day$1);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_day$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref"
      ],
      "restProps"
    );
    const dayState = useRangeCalendarDay({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, dayState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({
          props: get$2(mergedProps),
          ...dayState.snippetProps
        }));
        append($$anchor2, fragment_1);
      };
      var alternate_1 = ($$anchor2) => {
        var div = root_2$9();
        let attributes;
        var node_2 = child(div);
        {
          var consequent_1 = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.children ?? noop$1, () => dayState.snippetProps);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var text$1 = text();
            template_effect(() => set_text(text$1, dayState.cell.date.current.day));
            append($$anchor3, text$1);
          };
          if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          });
        }
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_day$1);
  mark_module_start();
  Dialog[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte";
  function Dialog($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog);
    validate_prop_bindings($$props, ["open"], [], Dialog);
    let open2 = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop), controlledOpen = prop($$props, "controlledOpen", 3, false);
    useDialogRoot({
      variant: box.with(() => "dialog"),
      open: box.with(() => open2(), (v2) => {
        if (controlledOpen()) {
          onOpenChange()(v2);
        } else {
          open2(v2);
          onOpenChange()(v2);
        }
      })
    });
    var fragment = comment();
    var node = first_child(fragment);
    snippet(node, () => $$props.children ?? noop$1);
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog);
  mark_module_start();
  Dialog_close[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte";
  var root_2$8 = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Dialog_close[FILENAME], [[32, 1]]);
  function Dialog_close($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_close);
    validate_prop_bindings($$props, ["ref"], [], Dialog_close);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref",
        "disabled"
      ],
      "restProps"
    );
    const closeState = useDialogClose({
      variant: box.with(() => "close"),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2)),
      disabled: box.with(() => Boolean(disabled()))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, closeState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$8();
        let attributes;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(button, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_close);
  mark_module_start();
  Dialog_content$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte";
  var root_6$2 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Dialog_content$1[FILENAME], []);
  var root_8$1 = add_locations(/* @__PURE__ */ template(`<!> <div><!></div>`, 1), Dialog_content$1[FILENAME], [[88, 8]]);
  function Dialog_content$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_content$1);
    validate_prop_bindings($$props, ["ref"], [], Dialog_content$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop), onInteractOutside = prop($$props, "onInteractOutside", 3, noop), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "id",
        "children",
        "child",
        "ref",
        "forceMount",
        "onCloseAutoFocus",
        "onEscapeKeydown",
        "onInteractOutside",
        "trapFocus",
        "preventScroll",
        "restoreScrollDelay"
      ],
      "restProps"
    );
    const contentState = useDialogContent({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, contentState.props));
    var present_1 = /* @__PURE__ */ derived(() => contentState.root.open.current || forceMount());
    {
      const presence = wrap_snippet(Dialog_content$1, ($$anchor2, $$arg0) => {
        let present = () => $$arg0 == null ? void 0 : $$arg0().present;
        present();
        var trapFocus_1 = /* @__PURE__ */ derived(() => shouldTrapFocus({
          forceMount: forceMount(),
          present: present().current,
          trapFocus: trapFocus(),
          open: contentState.root.open.current
        }));
        {
          const focusScope = wrap_snippet(Dialog_content$1, ($$anchor3, $$arg02) => {
            let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
            focusScopeProps();
            Escape_layer($$anchor3, spread_props(() => get$2(mergedProps), {
              get enabled() {
                return present().current;
              },
              onEscapeKeydown: (e) => {
                onEscapeKeydown()(e);
                if (e.defaultPrevented) return;
                contentState.root.handleClose();
              },
              children: wrap_snippet(Dialog_content$1, ($$anchor4, $$slotProps) => {
                Dismissible_layer($$anchor4, spread_props(() => get$2(mergedProps), {
                  get enabled() {
                    return present().current;
                  },
                  onInteractOutside: (e) => {
                    onInteractOutside()(e);
                    if (e.defaultPrevented) return;
                    contentState.root.handleClose();
                  },
                  children: wrap_snippet(Dialog_content$1, ($$anchor5, $$slotProps2) => {
                    Text_selection_layer($$anchor5, spread_props(() => get$2(mergedProps), {
                      get enabled() {
                        return present().current;
                      },
                      children: wrap_snippet(Dialog_content$1, ($$anchor6, $$slotProps3) => {
                        var fragment_5 = comment();
                        var node = first_child(fragment_5);
                        {
                          var consequent_1 = ($$anchor7) => {
                            var fragment_6 = root_6$2();
                            var node_1 = first_child(fragment_6);
                            {
                              var consequent = ($$anchor8) => {
                                Scroll_lock($$anchor8, {
                                  get preventScroll() {
                                    return preventScroll();
                                  },
                                  get restoreScrollDelay() {
                                    return restoreScrollDelay();
                                  }
                                });
                              };
                              if_block(node_1, ($$render) => {
                                if (contentState.root.open.current) $$render(consequent);
                              });
                            }
                            var node_2 = sibling(node_1, 2);
                            var render_arg = /* @__PURE__ */ derived_safe_equal(() => ({
                              props: mergeProps(get$2(mergedProps), focusScopeProps()),
                              ...contentState.snippetProps
                            }));
                            snippet(node_2, () => $$props.child, () => get$2(render_arg));
                            append($$anchor7, fragment_6);
                          };
                          var alternate = ($$anchor7) => {
                            var fragment_8 = root_8$1();
                            var node_3 = first_child(fragment_8);
                            Scroll_lock(node_3, {
                              get preventScroll() {
                                return preventScroll();
                              }
                            });
                            var div = sibling(node_3, 2);
                            const spread_with_call = /* @__PURE__ */ derived(() => mergeProps(get$2(mergedProps), focusScopeProps()));
                            let attributes;
                            var node_4 = child(div);
                            snippet(node_4, () => $$props.children ?? noop$1);
                            reset(div);
                            template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(spread_with_call) }));
                            append($$anchor7, fragment_8);
                          };
                          if_block(node, ($$render) => {
                            if ($$props.child) $$render(consequent_1);
                            else $$render(alternate, false);
                          });
                        }
                        append($$anchor6, fragment_5);
                      }),
                      $$slots: { default: true }
                    }));
                  }),
                  $$slots: { default: true }
                }));
              }),
              $$slots: { default: true }
            }));
          });
          Focus_scope($$anchor2, spread_props(
            {
              loop: true,
              get trapFocus() {
                return get$2(trapFocus_1);
              }
            },
            () => get$2(mergedProps),
            {
              onCloseAutoFocus: (e) => {
                var _a2;
                onCloseAutoFocus()(e);
                if (e.defaultPrevented) return;
                (_a2 = contentState.root.triggerNode) == null ? void 0 : _a2.focus();
              },
              focusScope,
              $$slots: { focusScope: true }
            }
          ));
        }
      });
      Presence_layer($$anchor, spread_props(() => get$2(mergedProps), {
        get forceMount() {
          return forceMount();
        },
        get present() {
          return get$2(present_1);
        },
        presence,
        $$slots: { presence: true }
      }));
    }
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_content$1);
  const ROOT_ATTR$1 = "data-label-root";
  class LabelRootState {
    constructor(props) {
      __privateAdd(this, _id14);
      __privateAdd(this, _ref14);
      __privateAdd(this, _props26, /* @__PURE__ */ derived(() => ({
        [ROOT_ATTR$1]: "",
        onmousedown: this.onmousedown
      })));
      __privateSet(this, _id14, props.id);
      __privateSet(this, _ref14, props.ref);
      this.onmousedown = this.onmousedown.bind(this);
      useRefById({ id: __privateGet(this, _id14), ref: __privateGet(this, _ref14) });
    }
    onmousedown(e) {
      if (e.detail > 1) e.preventDefault();
    }
    get props() {
      return get$2(__privateGet(this, _props26));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id14 = new WeakMap();
  _ref14 = new WeakMap();
  _props26 = new WeakMap();
  function setLabelRootState(props) {
    return new LabelRootState(props);
  }
  mark_module_start();
  Label$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/label/components/label.svelte";
  var root_2$7 = add_locations(/* @__PURE__ */ template(`<label><!></label>`), Label$1[FILENAME], [[29, 1]]);
  function Label$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Label$1);
    validate_prop_bindings($$props, ["ref"], [], Label$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref",
        "for"
      ],
      "restProps"
    );
    const rootState = setLabelRootState({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, rootState.props, { for: $$props.for }));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({ props: get$2(mergedProps) }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var label = root_2$7();
        let attributes;
        var node_2 = child(label);
        snippet(node_2, () => $$props.children ?? noop$1);
        template_effect(() => attributes = set_attributes(label, attributes, { ...get$2(mergedProps), for: $$props.for }));
        append($$anchor2, label);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Label$1);
  mark_module_start();
  Popover[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/popover/components/popover.svelte";
  function Popover($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popover);
    validate_prop_bindings($$props, ["open"], [], Popover);
    let open2 = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop), controlledOpen = prop($$props, "controlledOpen", 3, false);
    usePopoverRoot({
      open: box.with(() => open2(), (v2) => {
        if (controlledOpen()) {
          onOpenChange()(v2);
        } else {
          open2(v2);
          onOpenChange()(v2);
        }
      })
    });
    Floating_layer($$anchor, {
      children: wrap_snippet(Popover, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        snippet(node, () => $$props.children ?? noop$1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    });
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popover);
  mark_module_start();
  Range_calendar$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte";
  var root_2$6 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Range_calendar$1[FILENAME], [[131, 1]]);
  function Range_calendar$1($$anchor, $$props) {
    var _a2, _b2, _c;
    check_target(new.target);
    push($$props, true, Range_calendar$1);
    validate_prop_bindings($$props, ["ref", "value", "placeholder"], [], Range_calendar$1);
    let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), weekStartsOn = prop($$props, "weekStartsOn", 3, 0), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), locale = prop($$props, "locale", 3, "en"), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop), onEndValueChange = prop($$props, "onEndValueChange", 3, noop), controlledPlaceholder = prop($$props, "controlledPlaceholder", 3, false), controlledValue = prop($$props, "controlledValue", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "children",
        "child",
        "id",
        "ref",
        "value",
        "onValueChange",
        "placeholder",
        "onPlaceholderChange",
        "weekdayFormat",
        "weekStartsOn",
        "pagedNavigation",
        "isDateDisabled",
        "isDateUnavailable",
        "fixedWeeks",
        "numberOfMonths",
        "locale",
        "calendarLabel",
        "disabled",
        "readonly",
        "minValue",
        "maxValue",
        "preventDeselect",
        "disableDaysOutsideMonth",
        "onStartValueChange",
        "onEndValueChange",
        "controlledPlaceholder",
        "controlledValue"
      ],
      "restProps"
    );
    let startValue = state(proxy((_a2 = value()) == null ? void 0 : _a2.start));
    let endValue = state(proxy((_b2 = value()) == null ? void 0 : _b2.end));
    if (strict_equals(placeholder(), void 0)) {
      const defaultPlaceholder = getDefaultDate({
        defaultPlaceholder: void 0,
        defaultValue: (_c = value()) == null ? void 0 : _c.start
      });
      if (controlledPlaceholder()) {
        onPlaceholderChange()(defaultPlaceholder);
      } else {
        placeholder(defaultPlaceholder);
      }
    }
    if (strict_equals(value(), void 0)) {
      const defaultValue = { start: void 0, end: void 0 };
      if (controlledValue()) {
        onValueChange()(defaultValue);
      } else {
        value(defaultValue);
      }
    }
    const rootState = useRangeCalendarRoot({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2)),
      value: box.with(() => value(), (v2) => {
        if (controlledValue()) {
          onValueChange()(v2);
        } else {
          value(v2);
          onValueChange()(v2);
        }
      }),
      placeholder: box.with(() => placeholder(), (v2) => {
        if (controlledPlaceholder()) {
          onPlaceholderChange()(v2);
        } else {
          placeholder(v2);
          onPlaceholderChange()(v2);
        }
      }),
      disabled: box.with(() => disabled()),
      readonly: box.with(() => readonly()),
      preventDeselect: box.with(() => preventDeselect()),
      minValue: box.with(() => minValue()),
      maxValue: box.with(() => maxValue()),
      isDateUnavailable: box.with(() => isDateUnavailable()),
      isDateDisabled: box.with(() => isDateDisabled()),
      pagedNavigation: box.with(() => pagedNavigation()),
      weekStartsOn: box.with(() => weekStartsOn()),
      weekdayFormat: box.with(() => weekdayFormat()),
      numberOfMonths: box.with(() => numberOfMonths()),
      locale: box.with(() => locale()),
      calendarLabel: box.with(() => calendarLabel()),
      fixedWeeks: box.with(() => fixedWeeks()),
      disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
      startValue: box.with(() => get$2(startValue), (v2) => {
        set(startValue, proxy(v2, null, startValue));
        onStartValueChange()(v2);
      }),
      endValue: box.with(() => get$2(endValue), (v2) => {
        set(endValue, proxy(v2, null, endValue));
        onEndValueChange()(v2);
      })
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, rootState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({
          props: get$2(mergedProps),
          ...rootState.snippetProps
        }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var div = root_2$6();
        let attributes;
        var node_2 = child(div);
        snippet(node_2, () => $$props.children ?? noop$1, () => rootState.snippetProps);
        template_effect(() => attributes = set_attributes(div, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, div);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar$1);
  const ROOT_ATTR = "data-switch-root";
  const THUMB_ATTR = "data-switch-thumb";
  class SwitchRootState {
    constructor(props) {
      __privateAdd(this, _SwitchRootState_instances);
      __privateAdd(this, _id15);
      __privateAdd(this, _ref15);
      __publicField(this, "checked");
      __publicField(this, "disabled");
      __publicField(this, "required");
      __publicField(this, "name");
      __publicField(this, "value");
      __privateAdd(this, _sharedProps2, /* @__PURE__ */ derived(() => ({
        "data-disabled": getDataDisabled(this.disabled.current),
        "data-state": getDataChecked(this.checked.current),
        "data-required": getDataRequired(this.required.current)
      })));
      __privateAdd(this, _props27, /* @__PURE__ */ derived(() => ({
        ...this.sharedProps,
        id: __privateGet(this, _id15).current,
        role: "switch",
        disabled: getDisabled(this.disabled.current),
        "aria-checked": getAriaChecked(this.checked.current),
        "aria-required": getAriaRequired(this.required.current),
        [ROOT_ATTR]: "",
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown
      })));
      this.checked = props.checked;
      this.disabled = props.disabled;
      this.required = props.required;
      this.name = props.name;
      this.value = props.value;
      __privateSet(this, _id15, props.id);
      __privateSet(this, _ref15, props.ref);
      useRefById({ id: __privateGet(this, _id15), ref: __privateGet(this, _ref15) });
      this.onkeydown = this.onkeydown.bind(this);
      this.onclick = this.onclick.bind(this);
    }
    onkeydown(e) {
      if (!(strict_equals(e.key, ENTER) || strict_equals(e.key, SPACE)) || this.disabled.current) return;
      e.preventDefault();
      __privateMethod(this, _SwitchRootState_instances, toggle_fn).call(this);
    }
    onclick(_2) {
      if (this.disabled.current) return;
      __privateMethod(this, _SwitchRootState_instances, toggle_fn).call(this);
    }
    get sharedProps() {
      return get$2(__privateGet(this, _sharedProps2));
    }
    set sharedProps(_2) {
      throw new Error("Cannot update a derived property ('sharedProps')");
    }
    get props() {
      return get$2(__privateGet(this, _props27));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id15 = new WeakMap();
  _ref15 = new WeakMap();
  _SwitchRootState_instances = new WeakSet();
  toggle_fn = function() {
    this.checked.current = !this.checked.current;
  };
  _sharedProps2 = new WeakMap();
  _props27 = new WeakMap();
  class SwitchInputState {
    constructor(root2) {
      __privateAdd(this, _root7);
      __privateAdd(this, _shouldRender, /* @__PURE__ */ derived(() => strict_equals(__privateGet(this, _root7).name.current, void 0, false)));
      __privateAdd(this, _props28, /* @__PURE__ */ derived(() => ({
        type: "checkbox",
        name: __privateGet(this, _root7).name.current,
        value: __privateGet(this, _root7).value.current,
        checked: __privateGet(this, _root7).checked.current,
        disabled: __privateGet(this, _root7).disabled.current,
        required: __privateGet(this, _root7).required.current,
        "aria-hidden": getAriaHidden(true),
        style: styleToString(srOnlyStyles)
      })));
      __privateSet(this, _root7, root2);
    }
    get shouldRender() {
      return get$2(__privateGet(this, _shouldRender));
    }
    set shouldRender(_2) {
      throw new Error("Cannot update a derived property ('shouldRender')");
    }
    get props() {
      return get$2(__privateGet(this, _props28));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _root7 = new WeakMap();
  _shouldRender = new WeakMap();
  _props28 = new WeakMap();
  class SwitchThumbState {
    constructor(props, root2) {
      __privateAdd(this, _id16);
      __privateAdd(this, _ref16);
      __publicField(this, "root");
      __privateAdd(this, _props29, /* @__PURE__ */ derived(() => ({
        ...this.root.sharedProps,
        id: __privateGet(this, _id16).current,
        [THUMB_ATTR]: ""
      })));
      this.root = root2;
      __privateSet(this, _id16, props.id);
      __privateSet(this, _ref16, props.ref);
      useRefById({ id: __privateGet(this, _id16), ref: __privateGet(this, _ref16) });
    }
    get props() {
      return get$2(__privateGet(this, _props29));
    }
    set props(_2) {
      throw new Error("Cannot update a derived property ('props')");
    }
    [ADD_OWNER](owner) {
    }
  }
  _id16 = new WeakMap();
  _ref16 = new WeakMap();
  _props29 = new WeakMap();
  const [setSwitchRootContext, getSwitchRootContext] = createContext("Switch.Root");
  function useSwitchRoot(props) {
    return setSwitchRootContext(new SwitchRootState(props));
  }
  function useSwitchInput() {
    return new SwitchInputState(getSwitchRootContext());
  }
  function useSwitchThumb(props) {
    return new SwitchThumbState(props, getSwitchRootContext());
  }
  mark_module_start();
  Switch_input[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte";
  var root_1$5 = add_locations(/* @__PURE__ */ template(`<input>`), Switch_input[FILENAME], [[8, 1]]);
  function Switch_input($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, Switch_input);
    const inputState = useSwitchInput();
    init();
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var input = root_1$5();
        let attributes;
        template_effect(() => attributes = set_attributes(input, attributes, { ...inputState.props }));
        append($$anchor2, input);
      };
      if_block(node, ($$render) => {
        if (inputState.shouldRender) $$render(consequent);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Switch_input);
  mark_module_start();
  Switch$1[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/switch/components/switch.svelte";
  var root_2$5 = add_locations(/* @__PURE__ */ template(`<button><!></button>`), Switch$1[FILENAME], [[54, 1]]);
  var root$6 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Switch$1[FILENAME], []);
  function Switch$1($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Switch$1);
    validate_prop_bindings($$props, ["ref", "checked"], [], Switch$1);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), checked = prop($$props, "checked", 15, false), value = prop($$props, "value", 3, "on"), name = prop($$props, "name", 3, void 0), type = prop($$props, "type", 3, "button"), onCheckedChange = prop($$props, "onCheckedChange", 3, noop), controlledChecked = prop($$props, "controlledChecked", 3, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "child",
        "children",
        "ref",
        "id",
        "disabled",
        "required",
        "checked",
        "value",
        "name",
        "type",
        "onCheckedChange",
        "controlledChecked"
      ],
      "restProps"
    );
    const rootState = useSwitchRoot({
      checked: box.with(() => checked(), (v2) => {
        var _a2;
        if (controlledChecked()) {
          onCheckedChange()(v2);
        } else {
          checked(v2);
          (_a2 = onCheckedChange()) == null ? void 0 : _a2(v2);
        }
      }),
      disabled: box.with(() => disabled() ?? false),
      required: box.with(() => required()),
      value: box.with(() => value()),
      name: box.with(() => name()),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, rootState.props, { type: type() }));
    var fragment = root$6();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({
          props: get$2(mergedProps),
          checked: rootState.checked.current
        }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var button = root_2$5();
        let attributes;
        var node_2 = child(button);
        snippet(node_2, () => $$props.children ?? noop$1, () => ({ checked: rootState.checked.current }));
        template_effect(() => attributes = set_attributes(button, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, button);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    var node_3 = sibling(node, 2);
    Switch_input(node_3, {});
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Switch$1);
  mark_module_start();
  Switch_thumb[FILENAME] = "node_modules/.pnpm/bits-ui@1.0.0-next.74_svelte@5.16.0/node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte";
  var root_2$4 = add_locations(/* @__PURE__ */ template(`<span><!></span>`), Switch_thumb[FILENAME], [[29, 1]]);
  function Switch_thumb($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Switch_thumb);
    validate_prop_bindings($$props, ["ref"], [], Switch_thumb);
    let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, useId), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "child",
        "children",
        "ref",
        "id"
      ],
      "restProps"
    );
    const thumbState = useSwitchThumb({
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v2) => ref(v2))
    });
    const mergedProps = /* @__PURE__ */ derived(() => mergeProps(restProps, thumbState.props));
    var fragment = comment();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor2) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.child, () => ({
          props: get$2(mergedProps),
          checked: thumbState.root.checked.current
        }));
        append($$anchor2, fragment_1);
      };
      var alternate = ($$anchor2) => {
        var span = root_2$4();
        let attributes;
        var node_2 = child(span);
        snippet(node_2, () => $$props.children ?? noop$1, () => ({ checked: thumbState.root.checked.current }));
        template_effect(() => attributes = set_attributes(span, attributes, { ...get$2(mergedProps) }));
        append($$anchor2, span);
      };
      if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Switch_thumb);
  mark_module_start();
  Dialog_title[FILENAME] = "src/lib/components/shadcn-ui/dialog/dialog-title.svelte";
  function Dialog_title($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_title);
    validate_prop_bindings($$props, ["ref"], [], Dialog_title);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("text-lg font-semibold leading-none tracking-tight", $$props.class));
    component(node, () => Dialog_title$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_title);
  mark_module_start();
  Dialog_footer[FILENAME] = "src/lib/components/shadcn-ui/dialog/dialog-footer.svelte";
  var root$5 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Dialog_footer[FILENAME], [[14, 0]]);
  function Dialog_footer($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_footer);
    validate_prop_bindings($$props, ["ref"], [], Dialog_footer);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "children"
      ],
      "restProps"
    );
    var div = root$5();
    let attributes;
    var node = child(div);
    snippet(node, () => $$props.children ?? noop$1);
    bind_this(div, ($$value) => ref($$value), () => ref());
    template_effect(() => attributes = set_attributes(div, attributes, {
      class: cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", $$props.class),
      ...restProps
    }));
    append($$anchor, div);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_footer);
  mark_module_start();
  Dialog_header[FILENAME] = "src/lib/components/shadcn-ui/dialog/dialog-header.svelte";
  var root$4 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Dialog_header[FILENAME], [[14, 0]]);
  function Dialog_header($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_header);
    validate_prop_bindings($$props, ["ref"], [], Dialog_header);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "children"
      ],
      "restProps"
    );
    var div = root$4();
    let attributes;
    var node = child(div);
    snippet(node, () => $$props.children ?? noop$1);
    bind_this(div, ($$value) => ref($$value), () => ref());
    template_effect(() => attributes = set_attributes(div, attributes, {
      class: cn("flex flex-col space-y-1.5 text-center sm:text-left", $$props.class),
      ...restProps
    }));
    append($$anchor, div);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_header);
  mark_module_start();
  Dialog_overlay[FILENAME] = "src/lib/components/shadcn-ui/dialog/dialog-overlay.svelte";
  function Dialog_overlay($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_overlay);
    validate_prop_bindings($$props, ["ref"], [], Dialog_overlay);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", $$props.class));
    component(node, () => Dialog_overlay$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_overlay);
  /**
   * @license lucide-svelte v0.469.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const defaultAttributes$1 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  mark_module_start();
  Icon$1[FILENAME] = "node_modules/.pnpm/lucide-svelte@0.469.0_svelte@5.16.0/node_modules/lucide-svelte/dist/Icon.svelte";
  var root$3 = add_locations(/* @__PURE__ */ ns_template(`<svg><!><!></svg>`), Icon$1[FILENAME], [[14, 0]]);
  function Icon$1($$anchor, $$props) {
    check_target(new.target);
    const $$sanitized_props = legacy_rest_props($$props, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    const $$restProps = legacy_rest_props($$sanitized_props, [
      "name",
      "color",
      "size",
      "strokeWidth",
      "absoluteStrokeWidth",
      "iconNode"
    ]);
    push($$props, false, Icon$1);
    let name = prop($$props, "name", 8, void 0);
    let color = prop($$props, "color", 8, "currentColor");
    let size2 = prop($$props, "size", 8, 24);
    let strokeWidth = prop($$props, "strokeWidth", 8, 2);
    let absoluteStrokeWidth = prop($$props, "absoluteStrokeWidth", 8, false);
    let iconNode = prop($$props, "iconNode", 24, () => []);
    const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
      return Boolean(className) && strict_equals(array.indexOf(className), index2);
    }).join(" ");
    init();
    var svg = root$3();
    let attributes;
    var node = child(svg);
    each(node, 1, iconNode, index, ($$anchor2, $$item) => {
      let tag = () => get$2($$item)[0];
      tag();
      let attrs = () => get$2($$item)[1];
      attrs();
      var fragment = comment();
      var node_1 = first_child(fragment);
      validate_dynamic_element_tag(tag);
      element(
        node_1,
        tag,
        true,
        ($$element, $$anchor3) => {
          let attributes_1;
          template_effect(() => attributes_1 = set_attributes($$element, attributes_1, { ...attrs() }, void 0, $$element.namespaceURI === NAMESPACE_SVG, $$element.nodeName.includes("-")));
        },
        void 0,
        [35, 4]
      );
      append($$anchor2, fragment);
    });
    var node_2 = sibling(node);
    slot(node_2, $$props, "default", {});
    template_effect(() => attributes = set_attributes(
      svg,
      attributes,
      {
        ...defaultAttributes$1,
        ...$$restProps,
        width: size2(),
        height: size2(),
        stroke: color(),
        "stroke-width": absoluteStrokeWidth() ? Number(strokeWidth()) * 24 / Number(size2()) : strokeWidth(),
        class: mergeClasses("lucide-icon", "lucide", name() ? `lucide-${name()}` : "", $$sanitized_props.class)
      },
      void 0,
      true
    ));
    append($$anchor, svg);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Icon$1);
  mark_module_start();
  X[FILENAME] = "node_modules/.pnpm/lucide-svelte@0.469.0_svelte@5.16.0/node_modules/lucide-svelte/dist/icons/x.svelte";
  function X($$anchor, $$props) {
    check_target(new.target);
    const $$sanitized_props = legacy_rest_props($$props, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    push($$props, false, X);
    const iconNode = [
      ["path", { "d": "M18 6 6 18" }],
      ["path", { "d": "m6 6 12 12" }]
    ];
    Icon$1($$anchor, spread_props({ name: "x" }, () => $$sanitized_props, {
      iconNode,
      children: wrap_snippet(X, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        slot(node, $$props, "default", {}, null);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
    return pop({ ...legacy_api() });
  }
  mark_module_end(X);
  mark_module_start();
  Dialog_content[FILENAME] = "src/lib/components/shadcn-ui/dialog/dialog-content.svelte";
  var root_3$1 = add_locations(/* @__PURE__ */ template(`<!> <span class="sr-only">Close</span>`, 1), Dialog_content[FILENAME], [[35, 3]]);
  var root_2$3 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Dialog_content[FILENAME], []);
  var root_1$4 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Dialog_content[FILENAME], []);
  function Dialog_content($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_content);
    validate_prop_bindings($$props, ["ref"], [], Dialog_content);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "portalProps",
        "children"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    component(node, () => Portal, ($$anchor2, $$component) => {
      $$component($$anchor2, spread_props(() => $$props.portalProps, {
        children: wrap_snippet(Dialog_content, ($$anchor3, $$slotProps) => {
          var fragment_1 = root_1$4();
          var node_1 = first_child(fragment_1);
          component(node_1, () => Dialog_overlay, ($$anchor4, $$component2) => {
            $$component2($$anchor4, {});
          });
          var node_2 = sibling(node_1, 2);
          var class_1 = /* @__PURE__ */ derived(() => cn("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", $$props.class));
          component(node_2, () => Dialog_content$1, ($$anchor4, $$component2) => {
            {
              add_owner_effect(ref, $$component2);
              $$component2($$anchor4, spread_props(
                {
                  get class() {
                    return get$2(class_1);
                  }
                },
                () => restProps,
                {
                  get ref() {
                    return ref();
                  },
                  set ref($$value) {
                    ref($$value);
                  },
                  children: wrap_snippet(Dialog_content, ($$anchor5, $$slotProps2) => {
                    var fragment_2 = root_2$3();
                    var node_3 = first_child(fragment_2);
                    snippet(node_3, () => $$props.children ?? noop$1);
                    var node_4 = sibling(node_3, 2);
                    component(node_4, () => Dialog_close, ($$anchor6, $$component3) => {
                      $$component3($$anchor6, {
                        class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none",
                        children: wrap_snippet(Dialog_content, ($$anchor7, $$slotProps3) => {
                          var fragment_3 = root_3$1();
                          var node_5 = first_child(fragment_3);
                          X(node_5, { class: "size-4" });
                          next(2);
                          append($$anchor7, fragment_3);
                        }),
                        $$slots: { default: true }
                      });
                    });
                    append($$anchor5, fragment_2);
                  }),
                  $$slots: { default: true }
                }
              ));
            }
          });
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }));
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_content);
  mark_module_start();
  Dialog_description[FILENAME] = "src/lib/components/shadcn-ui/dialog/dialog-description.svelte";
  function Dialog_description($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Dialog_description);
    validate_prop_bindings($$props, ["ref"], [], Dialog_description);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("text-sm text-muted-foreground", $$props.class));
    component(node, () => Dialog_description$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Dialog_description);
  const Root$1 = Dialog;
  const Trigger$1 = Dialog_trigger;
  const Portal = Portal$1;
  studyTable;
  mark_module_start();
  Accordion_content[FILENAME] = "src/lib/components/shadcn-ui/accordion/accordion-content.svelte";
  var root_1$3 = add_locations(/* @__PURE__ */ template(`<div class="pb-4 pt-0"><!></div>`), Accordion_content[FILENAME], [[21, 1]]);
  function Accordion_content($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_content);
    validate_prop_bindings($$props, ["ref"], [], Accordion_content);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "children"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down", $$props.class));
    component(node, () => Accordion_content$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            },
            children: wrap_snippet(Accordion_content, ($$anchor3, $$slotProps) => {
              var div = root_1$3();
              var node_1 = child(div);
              snippet(node_1, () => $$props.children ?? noop$1);
              reset(div);
              append($$anchor3, div);
            }),
            $$slots: { default: true }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_content);
  mark_module_start();
  Accordion_item[FILENAME] = "src/lib/components/shadcn-ui/accordion/accordion-item.svelte";
  function Accordion_item($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_item);
    validate_prop_bindings($$props, ["ref"], [], Accordion_item);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("border-b", $$props.class));
    component(node, () => Accordion_item$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_item);
  mark_module_start();
  Chevron_down[FILENAME] = "node_modules/.pnpm/lucide-svelte@0.469.0_svelte@5.16.0/node_modules/lucide-svelte/dist/icons/chevron-down.svelte";
  function Chevron_down($$anchor, $$props) {
    check_target(new.target);
    const $$sanitized_props = legacy_rest_props($$props, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    push($$props, false, Chevron_down);
    const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
    Icon$1($$anchor, spread_props({ name: "chevron-down" }, () => $$sanitized_props, {
      iconNode,
      children: wrap_snippet(Chevron_down, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        slot(node, $$props, "default", {}, null);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
    return pop({ ...legacy_api() });
  }
  mark_module_end(Chevron_down);
  mark_module_start();
  Accordion_trigger[FILENAME] = "src/lib/components/shadcn-ui/accordion/accordion-trigger.svelte";
  var root_2$2 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Accordion_trigger[FILENAME], []);
  function Accordion_trigger($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Accordion_trigger);
    validate_prop_bindings($$props, ["ref"], [], Accordion_trigger);
    let ref = prop($$props, "ref", 15, null), level = prop($$props, "level", 3, 3), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "level",
        "children"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    component(node, () => Accordion_header, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        get level() {
          return level();
        },
        class: "flex",
        children: wrap_snippet(Accordion_trigger, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          var class_1 = /* @__PURE__ */ derived(() => cn("flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", $$props.class));
          component(node_1, () => Accordion_trigger$1, ($$anchor4, $$component2) => {
            {
              add_owner_effect(ref, $$component2);
              $$component2($$anchor4, spread_props(
                {
                  get class() {
                    return get$2(class_1);
                  }
                },
                () => restProps,
                {
                  get ref() {
                    return ref();
                  },
                  set ref($$value) {
                    ref($$value);
                  },
                  children: wrap_snippet(Accordion_trigger, ($$anchor5, $$slotProps2) => {
                    var fragment_2 = root_2$2();
                    var node_2 = first_child(fragment_2);
                    snippet(node_2, () => $$props.children ?? noop$1);
                    var node_3 = sibling(node_2, 2);
                    Chevron_down(node_3, {
                      class: "size-4 shrink-0 transition-transform duration-200"
                    });
                    append($$anchor5, fragment_2);
                  }),
                  $$slots: { default: true }
                }
              ));
            }
          });
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Accordion_trigger);
  studyTable;
  mark_module_start();
  Popover_content[FILENAME] = "src/lib/components/shadcn-ui/popover/popover-content.svelte";
  function Popover_content($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Popover_content);
    validate_prop_bindings($$props, ["ref"], [], Popover_content);
    let ref = prop($$props, "ref", 15, null), sideOffset = prop($$props, "sideOffset", 3, 4), align = prop($$props, "align", 3, "center"), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "sideOffset",
        "align",
        "portalProps"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    component(node, () => Portal$1, ($$anchor2, $$component) => {
      $$component($$anchor2, spread_props(() => $$props.portalProps, {
        children: wrap_snippet(Popover_content, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          var class_1 = /* @__PURE__ */ derived(() => cn("z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", $$props.class));
          component(node_1, () => Popover_content$1, ($$anchor4, $$component2) => {
            {
              add_owner_effect(ref, $$component2);
              $$component2($$anchor4, spread_props(
                {
                  get sideOffset() {
                    return sideOffset();
                  },
                  get align() {
                    return align();
                  },
                  get class() {
                    return get$2(class_1);
                  }
                },
                () => restProps,
                {
                  get ref() {
                    return ref();
                  },
                  set ref($$value) {
                    ref($$value);
                  }
                }
              ));
            }
          });
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      }));
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Popover_content);
  const Root = Popover;
  const Trigger = Popover_trigger;
  studyTable;
  mark_module_start();
  Switch[FILENAME] = "src/lib/components/shadcn-ui/switch/switch.svelte";
  function Switch($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Switch);
    validate_prop_bindings($$props, ["ref", "checked"], [], Switch);
    let ref = prop($$props, "ref", 15, null), checked = prop($$props, "checked", 15, false), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "checked"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input", $$props.class));
    component(node, () => Switch$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        add_owner_effect(checked, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            },
            get checked() {
              return checked();
            },
            set checked($$value) {
              checked($$value);
            },
            children: wrap_snippet(Switch, ($$anchor3, $$slotProps) => {
              var fragment_1 = comment();
              var node_1 = first_child(fragment_1);
              var class_2 = /* @__PURE__ */ derived(() => cn("pointer-events-none block size-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"));
              component(node_1, () => Switch_thumb, ($$anchor4, $$component2) => {
                $$component2($$anchor4, {
                  get class() {
                    return get$2(class_2);
                  }
                });
              });
              append($$anchor3, fragment_1);
            }),
            $$slots: { default: true }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Switch);
  studyTable;
  mark_module_start();
  Label[FILENAME] = "src/lib/components/shadcn-ui/label/label.svelte";
  function Label($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Label);
    validate_prop_bindings($$props, ["ref"], [], Label);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", $$props.class));
    component(node, () => Label$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Label);
  studyTable;
  studyTable;
  mark_module_start();
  Range_calendar[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar.svelte";
  var root_2$1 = add_locations(/* @__PURE__ */ template(`<!> <!> <!>`, 1), Range_calendar[FILENAME], []);
  var root_5$1 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Range_calendar[FILENAME], []);
  var root_1$2 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Range_calendar[FILENAME], []);
  function Range_calendar($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar);
    validate_prop_bindings($$props, ["ref", "value", "placeholder"], [], Range_calendar);
    let ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), placeholder = prop($$props, "placeholder", 15), weekdayFormat = prop($$props, "weekdayFormat", 3, "short"), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "value",
        "placeholder",
        "weekdayFormat",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("p-3", $$props.class));
    component(node, () => Range_calendar$1, ($$anchor2, $$component) => {
      {
        const children = wrap_snippet(Range_calendar, ($$anchor3, $$arg0) => {
          let months = () => $$arg0 == null ? void 0 : $$arg0().months;
          months();
          let weekdays = () => $$arg0 == null ? void 0 : $$arg0().weekdays;
          weekdays();
          var fragment_1 = root_1$2();
          var node_1 = first_child(fragment_1);
          component(node_1, () => Range_calendar_header, ($$anchor4, $$component2) => {
            $$component2($$anchor4, {
              children: wrap_snippet(Range_calendar, ($$anchor5, $$slotProps) => {
                var fragment_2 = root_2$1();
                var node_2 = first_child(fragment_2);
                component(node_2, () => Range_calendar_prev_button, ($$anchor6, $$component3) => {
                  $$component3($$anchor6, {});
                });
                var node_3 = sibling(node_2, 2);
                component(node_3, () => Range_calendar_heading, ($$anchor6, $$component3) => {
                  $$component3($$anchor6, {});
                });
                var node_4 = sibling(node_3, 2);
                component(node_4, () => Range_calendar_next_button, ($$anchor6, $$component3) => {
                  $$component3($$anchor6, {});
                });
                append($$anchor5, fragment_2);
              }),
              $$slots: { default: true }
            });
          });
          var node_5 = sibling(node_1, 2);
          component(node_5, () => Range_calendar_months, ($$anchor4, $$component2) => {
            $$component2($$anchor4, {
              children: wrap_snippet(Range_calendar, ($$anchor5, $$slotProps) => {
                var fragment_3 = comment();
                var node_6 = first_child(fragment_3);
                each(node_6, 17, months, index, ($$anchor6, month) => {
                  var fragment_4 = comment();
                  var node_7 = first_child(fragment_4);
                  component(node_7, () => Range_calendar_grid, ($$anchor7, $$component3) => {
                    $$component3($$anchor7, {
                      children: wrap_snippet(Range_calendar, ($$anchor8, $$slotProps2) => {
                        var fragment_5 = root_5$1();
                        var node_8 = first_child(fragment_5);
                        component(node_8, () => GridHead, ($$anchor9, $$component4) => {
                          $$component4($$anchor9, {
                            children: wrap_snippet(Range_calendar, ($$anchor10, $$slotProps3) => {
                              var fragment_6 = comment();
                              var node_9 = first_child(fragment_6);
                              component(node_9, () => Range_calendar_grid_row, ($$anchor11, $$component5) => {
                                $$component5($$anchor11, {
                                  class: "flex",
                                  children: wrap_snippet(Range_calendar, ($$anchor12, $$slotProps4) => {
                                    var fragment_7 = comment();
                                    var node_10 = first_child(fragment_7);
                                    each(node_10, 17, weekdays, index, ($$anchor13, weekday) => {
                                      var fragment_8 = comment();
                                      var node_11 = first_child(fragment_8);
                                      component(node_11, () => Range_calendar_head_cell, ($$anchor14, $$component6) => {
                                        $$component6($$anchor14, {
                                          children: wrap_snippet(Range_calendar, ($$anchor15, $$slotProps5) => {
                                            next();
                                            var text$1 = text();
                                            template_effect(() => set_text(text$1, get$2(weekday).slice(0, 2)));
                                            append($$anchor15, text$1);
                                          }),
                                          $$slots: { default: true }
                                        });
                                      });
                                      append($$anchor13, fragment_8);
                                    });
                                    append($$anchor12, fragment_7);
                                  }),
                                  $$slots: { default: true }
                                });
                              });
                              append($$anchor10, fragment_6);
                            }),
                            $$slots: { default: true }
                          });
                        });
                        var node_12 = sibling(node_8, 2);
                        component(node_12, () => GridBody, ($$anchor9, $$component4) => {
                          $$component4($$anchor9, {
                            children: wrap_snippet(Range_calendar, ($$anchor10, $$slotProps3) => {
                              var fragment_10 = comment();
                              var node_13 = first_child(fragment_10);
                              each(node_13, 17, () => get$2(month).weeks, index, ($$anchor11, weekDates) => {
                                var fragment_11 = comment();
                                var node_14 = first_child(fragment_11);
                                component(node_14, () => Range_calendar_grid_row, ($$anchor12, $$component5) => {
                                  $$component5($$anchor12, {
                                    class: "mt-2 w-full",
                                    children: wrap_snippet(Range_calendar, ($$anchor13, $$slotProps4) => {
                                      var fragment_12 = comment();
                                      var node_15 = first_child(fragment_12);
                                      each(node_15, 17, () => get$2(weekDates), index, ($$anchor14, date) => {
                                        var fragment_13 = comment();
                                        var node_16 = first_child(fragment_13);
                                        component(node_16, () => Range_calendar_cell, ($$anchor15, $$component6) => {
                                          $$component6($$anchor15, {
                                            get date() {
                                              return get$2(date);
                                            },
                                            get month() {
                                              return get$2(month).value;
                                            },
                                            children: wrap_snippet(Range_calendar, ($$anchor16, $$slotProps5) => {
                                              var fragment_14 = comment();
                                              var node_17 = first_child(fragment_14);
                                              component(node_17, () => Range_calendar_day, ($$anchor17, $$component7) => {
                                                $$component7($$anchor17, {});
                                              });
                                              append($$anchor16, fragment_14);
                                            }),
                                            $$slots: { default: true }
                                          });
                                        });
                                        append($$anchor14, fragment_13);
                                      });
                                      append($$anchor13, fragment_12);
                                    }),
                                    $$slots: { default: true }
                                  });
                                });
                                append($$anchor11, fragment_11);
                              });
                              append($$anchor10, fragment_10);
                            }),
                            $$slots: { default: true }
                          });
                        });
                        append($$anchor8, fragment_5);
                      }),
                      $$slots: { default: true }
                    });
                  });
                  append($$anchor6, fragment_4);
                });
                append($$anchor5, fragment_3);
              }),
              $$slots: { default: true }
            });
          });
          append($$anchor3, fragment_1);
        });
        add_owner_effect(ref, $$component);
        add_owner_effect(value, $$component);
        add_owner_effect(placeholder, $$component);
        $$component($$anchor2, spread_props(
          {
            get weekdayFormat() {
              return weekdayFormat();
            },
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            },
            get value() {
              return value();
            },
            set value($$value) {
              value($$value);
            },
            get placeholder() {
              return placeholder();
            },
            set placeholder($$value) {
              placeholder($$value);
            },
            children,
            $$slots: { default: true }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar);
  mark_module_start();
  Range_calendar_cell[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-cell.svelte";
  function Range_calendar_cell($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_cell);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_cell);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("relative size-9 p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:bg-accent first:[&:has([data-selected])]:rounded-l-md last:[&:has([data-selected])]:rounded-r-md [&:has([data-selected][data-outside-month])]:bg-accent/50 [&:has([data-selected][data-selection-end])]:rounded-r-md [&:has([data-selected][data-selection-start])]:rounded-l-md", $$props.class));
    component(node, () => Range_calendar_cell$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_cell);
  mark_module_start();
  Range_calendar_day[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-day.svelte";
  function Range_calendar_day($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_day);
    validate_prop_bindings($$props, ["ref"], ["class"], Range_calendar_day);
    let ref = prop($$props, "ref", 15, null), className = prop($$props, "class", 7), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn(
      buttonVariants({ variant: "ghost" }),
      "size-9 p-0 font-normal data-[selected]:opacity-100",
      "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
      // Selection Start
      "data-[selection-start]:bg-primary data-[selection-start]:text-primary-foreground data-[selection-start]:hover:bg-primary data-[selection-start]:hover:text-primary-foreground data-[selection-start]:focus:bg-primary data-[selection-start]:focus:text-primary-foreground",
      // Selection End
      "data-[selection-end]:bg-primary data-[selection-end]:text-primary-foreground data-[selection-end]:hover:bg-primary data-[selection-end]:hover:text-primary-foreground data-[selection-end]:focus:bg-primary data-[selection-end]:focus:text-primary-foreground",
      // Outside months
      "data-[outside-month]:pointer-events-none data-[outside-month]:text-muted-foreground data-[outside-month]:opacity-50 [&[data-outside-month][data-selected]]:bg-accent/50 [&[data-outside-month][data-selected]]:text-muted-foreground [&[data-outside-month][data-selected]]:opacity-30",
      // Disabled
      "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
      // Unavailable
      "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
      className()
    ));
    component(node, () => Range_calendar_day$1, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({
      get class() {
        return className();
      },
      set class($$value) {
        className($$value);
      },
      ...legacy_api()
    });
  }
  mark_module_end(Range_calendar_day);
  mark_module_start();
  Range_calendar_grid[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-grid.svelte";
  function Range_calendar_grid($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_grid);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_grid);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("w-full border-collapse space-y-1", $$props.class));
    component(node, () => Calendar_grid, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_grid);
  mark_module_start();
  Range_calendar_header[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-header.svelte";
  function Range_calendar_header($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_header);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_header);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("relative flex w-full items-center justify-between pt-1", $$props.class));
    component(node, () => Calendar_header, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_header);
  mark_module_start();
  Range_calendar_months[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-months.svelte";
  var root$2 = add_locations(/* @__PURE__ */ template(`<div><!></div>`), Range_calendar_months[FILENAME], [[14, 0]]);
  function Range_calendar_months($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_months);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_months);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "children"
      ],
      "restProps"
    );
    var div = root$2();
    let attributes;
    var node = child(div);
    snippet(node, () => $$props.children ?? noop$1);
    bind_this(div, ($$value) => ref($$value), () => ref());
    template_effect(() => attributes = set_attributes(div, attributes, {
      class: cn("mt-4 flex flex-col space-y-4 sm:flex-row sm:space-x-4 sm:space-y-0", $$props.class),
      ...restProps
    }));
    append($$anchor, div);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_months);
  mark_module_start();
  Range_calendar_grid_row[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-grid-row.svelte";
  function Range_calendar_grid_row($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_grid_row);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_grid_row);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("flex", $$props.class));
    component(node, () => Calendar_grid_row, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_grid_row);
  mark_module_start();
  Range_calendar_heading[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-heading.svelte";
  function Range_calendar_heading($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_heading);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_heading);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("text-sm font-medium", $$props.class));
    component(node, () => Calendar_heading, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_heading);
  mark_module_start();
  Range_calendar_head_cell[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-head-cell.svelte";
  function Range_calendar_head_cell($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_head_cell);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_head_cell);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class"
      ],
      "restProps"
    );
    var fragment = comment();
    var node = first_child(fragment);
    var class_1 = /* @__PURE__ */ derived(() => cn("w-9 rounded-md text-[0.8rem] font-normal text-muted-foreground", $$props.class));
    component(node, () => Calendar_head_cell, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_head_cell);
  mark_module_start();
  Chevron_right[FILENAME] = "node_modules/.pnpm/lucide-svelte@0.469.0_svelte@5.16.0/node_modules/lucide-svelte/dist/icons/chevron-right.svelte";
  function Chevron_right($$anchor, $$props) {
    check_target(new.target);
    const $$sanitized_props = legacy_rest_props($$props, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    push($$props, false, Chevron_right);
    const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
    Icon$1($$anchor, spread_props({ name: "chevron-right" }, () => $$sanitized_props, {
      iconNode,
      children: wrap_snippet(Chevron_right, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        slot(node, $$props, "default", {}, null);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
    return pop({ ...legacy_api() });
  }
  mark_module_end(Chevron_right);
  mark_module_start();
  Range_calendar_next_button[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-next-button.svelte";
  const Fallback$1 = wrap_snippet(Range_calendar_next_button, ($$anchor) => {
    Chevron_right($$anchor, { class: "size-4" });
  });
  function Range_calendar_next_button($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_next_button);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_next_button);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "children"
      ],
      "restProps"
    );
    var fragment_1 = comment();
    var node = first_child(fragment_1);
    var class_1 = /* @__PURE__ */ derived(() => cn(buttonVariants({ variant: "outline" }), "size-7 bg-transparent p-0 opacity-50 hover:opacity-100", $$props.class));
    var children_1 = /* @__PURE__ */ derived(() => $$props.children || Fallback$1);
    component(node, () => Calendar_next_button, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            },
            get children() {
              return get$2(children_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment_1);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_next_button);
  mark_module_start();
  Chevron_left[FILENAME] = "node_modules/.pnpm/lucide-svelte@0.469.0_svelte@5.16.0/node_modules/lucide-svelte/dist/icons/chevron-left.svelte";
  function Chevron_left($$anchor, $$props) {
    check_target(new.target);
    const $$sanitized_props = legacy_rest_props($$props, [
      "children",
      "$$slots",
      "$$events",
      "$$legacy"
    ]);
    push($$props, false, Chevron_left);
    const iconNode = [["path", { "d": "m15 18-6-6 6-6" }]];
    Icon$1($$anchor, spread_props({ name: "chevron-left" }, () => $$sanitized_props, {
      iconNode,
      children: wrap_snippet(Chevron_left, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        slot(node, $$props, "default", {}, null);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
    return pop({ ...legacy_api() });
  }
  mark_module_end(Chevron_left);
  mark_module_start();
  Range_calendar_prev_button[FILENAME] = "src/lib/components/shadcn-ui/range-calendar/range-calendar-prev-button.svelte";
  const Fallback = wrap_snippet(Range_calendar_prev_button, ($$anchor) => {
    Chevron_left($$anchor, { class: "size-4" });
  });
  function Range_calendar_prev_button($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Range_calendar_prev_button);
    validate_prop_bindings($$props, ["ref"], [], Range_calendar_prev_button);
    let ref = prop($$props, "ref", 15, null), restProps = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "ref",
        "class",
        "children"
      ],
      "restProps"
    );
    var fragment_1 = comment();
    var node = first_child(fragment_1);
    var class_1 = /* @__PURE__ */ derived(() => cn(buttonVariants({ variant: "outline" }), "size-7 bg-transparent p-0 opacity-50 hover:opacity-100", $$props.class));
    var children_1 = /* @__PURE__ */ derived(() => $$props.children || Fallback);
    component(node, () => Calendar_prev_button, ($$anchor2, $$component) => {
      {
        add_owner_effect(ref, $$component);
        $$component($$anchor2, spread_props(
          {
            get class() {
              return get$2(class_1);
            },
            get children() {
              return get$2(children_1);
            }
          },
          () => restProps,
          {
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          }
        ));
      }
    });
    append($$anchor, fragment_1);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Range_calendar_prev_button);
  const GridHead = Calendar_grid_head;
  const GridBody = Calendar_grid_body;
  studyTable;
  /**
   * @license @lucide/svelte v0.483.0 - ISC
   *
   * ISC License
   * 
   * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2022 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2022.
   * 
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   * 
   */
  const defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  mark_module_start();
  Icon[FILENAME] = "node_modules/.pnpm/@lucide+svelte@0.483.0_svelte@5.16.0/node_modules/@lucide/svelte/dist/Icon.svelte";
  var root$1 = add_locations(/* @__PURE__ */ ns_template(`<svg><!><!></svg>`), Icon[FILENAME], [[5, 0]]);
  function Icon($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Icon);
    validate_prop_bindings($$props, [], [], Icon);
    const color = prop($$props, "color", 3, "currentColor"), size2 = prop($$props, "size", 3, 24), strokeWidth = prop($$props, "strokeWidth", 3, 2), absoluteStrokeWidth = prop($$props, "absoluteStrokeWidth", 3, false), iconNode = prop($$props, "iconNode", 19, () => []), props = /* @__PURE__ */ rest_props(
      $$props,
      [
        "$$slots",
        "$$events",
        "$$legacy",
        "name",
        "color",
        "size",
        "strokeWidth",
        "absoluteStrokeWidth",
        "iconNode",
        "children"
      ],
      "props"
    );
    var svg = root$1();
    let attributes;
    var node = child(svg);
    each(node, 17, iconNode, index, ($$anchor2, $$item) => {
      let tag = () => get$2($$item)[0];
      tag();
      let attrs = () => get$2($$item)[1];
      attrs();
      var fragment = comment();
      var node_1 = first_child(fragment);
      validate_dynamic_element_tag(tag);
      element(
        node_1,
        tag,
        true,
        ($$element, $$anchor3) => {
          let attributes_1;
          template_effect(() => attributes_1 = set_attributes($$element, attributes_1, { ...attrs() }, void 0, $$element.namespaceURI === NAMESPACE_SVG, $$element.nodeName.includes("-")));
        },
        void 0,
        [15, 4]
      );
      append($$anchor2, fragment);
    });
    var node_2 = sibling(node);
    snippet(node_2, () => $$props.children ?? noop$1);
    template_effect(() => attributes = set_attributes(
      svg,
      attributes,
      {
        ...defaultAttributes,
        ...props,
        width: size2(),
        height: size2(),
        stroke: color(),
        "stroke-width": absoluteStrokeWidth() ? Number(strokeWidth()) * 24 / Number(size2()) : strokeWidth(),
        class: [
          "lucide-icon lucide",
          $$props.name && `lucide-${$$props.name}`,
          $$props.class
        ]
      },
      void 0,
      true
    ));
    append($$anchor, svg);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Icon);
  mark_module_start();
  Calendar[FILENAME] = "node_modules/.pnpm/@lucide+svelte@0.483.0_svelte@5.16.0/node_modules/@lucide/svelte/dist/icons/calendar.svelte";
  function Calendar($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Calendar);
    validate_prop_bindings($$props, [], [], Calendar);
    let props = /* @__PURE__ */ rest_props($$props, ["$$slots", "$$events", "$$legacy"], "props");
    const iconNode = [
      ["path", { "d": "M8 2v4" }],
      ["path", { "d": "M16 2v4" }],
      [
        "rect",
        {
          "width": "18",
          "height": "18",
          "x": "3",
          "y": "4",
          "rx": "2"
        }
      ],
      ["path", { "d": "M3 10h18" }]
    ];
    Icon($$anchor, spread_props({ name: "calendar" }, () => props, {
      iconNode,
      children: wrap_snippet(Calendar, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        snippet(node, () => $$props.children ?? noop$1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }));
    return pop({ ...legacy_api() });
  }
  mark_module_end(Calendar);
  const constants = {
    appName: "KMITL DLC",
    utcOffset: 7,
    messages: {
      scrapeError: "Scraping error."
    },
    scraper: {
      classTypes: {
        lecture: ["ท", "L"],
        lab: ["ป", "P"]
      },
      days: {
        "อา.": 0,
        "จ.": 1,
        "อ.": 2,
        "พ.": 3,
        "พฤ.": 4,
        "ศ.": 5,
        "ส.": 6,
        Sun: 0,
        Mon: 1,
        Tue: 2,
        Wed: 3,
        Thu: 4,
        Fri: 5,
        Sat: 6
      }
    },
    apiPaths: {
      newReg: "https://k8s.reg.kmitl.ac.th/reg/api/?level_id=1&function="
    }
  };
  studyTable;
  var FileSaver_min$1 = { exports: {} };
  var FileSaver_min = FileSaver_min$1.exports;
  var hasRequiredFileSaver_min;
  function requireFileSaver_min() {
    if (hasRequiredFileSaver_min) return FileSaver_min$1.exports;
    hasRequiredFileSaver_min = 1;
    (function(module, exports) {
      (function(a2, b2) {
        b2();
      })(FileSaver_min, function() {
        function b2(a3, b3) {
          return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
        }
        function c2(a3, b3, c3) {
          var d3 = new XMLHttpRequest();
          d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
            g2(d3.response, b3, c3);
          }, d3.onerror = function() {
            console.error("could not download file");
          }, d3.send();
        }
        function d2(a3) {
          var b3 = new XMLHttpRequest();
          b3.open("HEAD", a3, false);
          try {
            b3.send();
          } catch (a4) {
          }
          return 200 <= b3.status && 299 >= b3.status;
        }
        function e(a3) {
          try {
            a3.dispatchEvent(new MouseEvent("click"));
          } catch (c3) {
            var b3 = document.createEvent("MouseEvents");
            b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
          }
        }
        var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
          var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
          g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", "string" == typeof b3 ? (j2.href = b3, j2.origin === location.origin ? e(j2) : d2(j2.href) ? c2(b3, g3, h2) : e(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
            i2.revokeObjectURL(j2.href);
          }, 4e4), setTimeout(function() {
            e(j2);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
          if (g3 = g3 || f3.name || "download", "string" != typeof f3) navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
          else if (d2(f3)) c2(f3, g3, h2);
          else {
            var i2 = document.createElement("a");
            i2.href = f3, i2.target = "_blank", setTimeout(function() {
              e(i2);
            });
          }
        } : function(b3, d3, e2, g3) {
          if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3) return c2(b3, d3, e2);
          var h2 = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j2 || h2 && i2 || a2) && "undefined" != typeof FileReader) {
            var k = new FileReader();
            k.onloadend = function() {
              var a3 = k.result;
              a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
            }, k.readAsDataURL(b3);
          } else {
            var l2 = f2.URL || f2.webkitURL, m = l2.createObjectURL(b3);
            g3 ? g3.location = m : location.href = m, g3 = null, setTimeout(function() {
              l2.revokeObjectURL(m);
            }, 4e4);
          }
        });
        f2.saveAs = g2.saveAs = g2, module.exports = g2;
      });
    })(FileSaver_min$1);
    return FileSaver_min$1.exports;
  }
  var FileSaver_minExports = requireFileSaver_min();
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var uuidRandom = { exports: {} };
  const __viteBrowserExternal = new Proxy({}, {
    get(_2, key) {
      throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.  See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
    }
  });
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var hasRequiredUuidRandom;
  function requireUuidRandom() {
    if (hasRequiredUuidRandom) return uuidRandom.exports;
    hasRequiredUuidRandom = 1;
    (function(module) {
      (function() {
        var buf, bufIdx = 0, hexBytes = [], i2;
        for (i2 = 0; i2 < 256; i2++) {
          hexBytes[i2] = (i2 + 256).toString(16).substr(1);
        }
        uuid2.BUFFER_SIZE = 4096;
        uuid2.bin = uuidBin;
        uuid2.clearBuffer = function() {
          buf = null;
          bufIdx = 0;
        };
        uuid2.test = function(uuid3) {
          if (typeof uuid3 === "string") {
            return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid3);
          }
          return false;
        };
        var crypt0;
        if (typeof crypto !== "undefined") {
          crypt0 = crypto;
        } else if (typeof window !== "undefined" && typeof window.msCrypto !== "undefined") {
          crypt0 = window.msCrypto;
        }
        if (typeof commonjsRequire === "function") {
          crypt0 = crypt0 || require$$0;
          module.exports = uuid2;
        } else if (typeof window !== "undefined") {
          window.uuid = uuid2;
        }
        uuid2.randomBytes = function() {
          if (crypt0) {
            if (crypt0.randomBytes) {
              return crypt0.randomBytes;
            }
            if (crypt0.getRandomValues) {
              if (typeof Uint8Array.prototype.slice !== "function") {
                return function(n) {
                  var bytes = new Uint8Array(n);
                  crypt0.getRandomValues(bytes);
                  return Array.from(bytes);
                };
              }
              return function(n) {
                var bytes = new Uint8Array(n);
                crypt0.getRandomValues(bytes);
                return bytes;
              };
            }
          }
          return function(n) {
            var i3, r2 = [];
            for (i3 = 0; i3 < n; i3++) {
              r2.push(Math.floor(Math.random() * 256));
            }
            return r2;
          };
        }();
        function randomBytesBuffered(n) {
          if (!buf || bufIdx + n > uuid2.BUFFER_SIZE) {
            bufIdx = 0;
            buf = uuid2.randomBytes(uuid2.BUFFER_SIZE);
          }
          return buf.slice(bufIdx, bufIdx += n);
        }
        function uuidBin() {
          var b2 = randomBytesBuffered(16);
          b2[6] = b2[6] & 15 | 64;
          b2[8] = b2[8] & 63 | 128;
          return b2;
        }
        function uuid2() {
          var b2 = uuidBin();
          return hexBytes[b2[0]] + hexBytes[b2[1]] + hexBytes[b2[2]] + hexBytes[b2[3]] + "-" + hexBytes[b2[4]] + hexBytes[b2[5]] + "-" + hexBytes[b2[6]] + hexBytes[b2[7]] + "-" + hexBytes[b2[8]] + hexBytes[b2[9]] + "-" + hexBytes[b2[10]] + hexBytes[b2[11]] + hexBytes[b2[12]] + hexBytes[b2[13]] + hexBytes[b2[14]] + hexBytes[b2[15]];
        }
      })();
    })(uuidRandom);
    return uuidRandom.exports;
  }
  var uuidRandomExports = requireUuidRandom();
  const G = /* @__PURE__ */ getDefaultExportFromCjs(uuidRandomExports);
  var b = ((u2) => (u2.SECONDLY = "SECONDLY", u2.MINUTELY = "MINUTELY", u2.HOURLY = "HOURLY", u2.DAILY = "DAILY", u2.WEEKLY = "WEEKLY", u2.MONTHLY = "MONTHLY", u2.YEARLY = "YEARLY", u2))(b || {}), A = ((u2) => (u2.SU = "SU", u2.MO = "MO", u2.TU = "TU", u2.WE = "WE", u2.TH = "TH", u2.FR = "FR", u2.SA = "SA", u2))(A || {});
  function o(a2, t, e, n) {
    if ((a2 == null ? void 0 : a2.startsWith("/")) && (a2 = a2.substr(1)), typeof t == "string" || t instanceof Date) {
      let i2 = new Date(t), s = i2.getUTCFullYear() + String(i2.getUTCMonth() + 1).padStart(2, "0") + i2.getUTCDate().toString().padStart(2, "0");
      return a2 && (s = i2.getFullYear() + String(i2.getMonth() + 1).padStart(2, "0") + i2.getDate().toString().padStart(2, "0")), e ? s : a2 ? (s += "T" + i2.getHours().toString().padStart(2, "0") + i2.getMinutes().toString().padStart(2, "0") + i2.getSeconds().toString().padStart(2, "0"), s) : (s += "T" + i2.getUTCHours().toString().padStart(2, "0") + i2.getUTCMinutes().toString().padStart(2, "0") + i2.getUTCSeconds().toString().padStart(2, "0") + (n ? "" : "Z"), s);
    } else if (S(t)) {
      let i2 = a2 ? F(t) && !t.tz() ? t.clone().tz(a2) : t : n || e && F(t) && t.tz() ? t : t.utc();
      return i2.format("YYYYMMDD") + (e ? "" : "T" + i2.format("HHmmss") + (n || a2 ? "" : "Z"));
    } else if (R(t)) {
      let i2 = a2 ? t.setZone(a2) : n || e && t.zone.type !== "system" ? t : t.setZone("utc");
      return i2.toFormat("yyyyLLdd") + (e ? "" : "T" + i2.toFormat("HHmmss") + (n || a2 ? "" : "Z"));
    } else {
      let i2 = t;
      if (a2) i2 = typeof t.tz == "function" ? t.tz(a2) : t;
      else if (!n) if (typeof t.utc == "function") i2 = t.utc();
      else throw new Error("Unable to convert dayjs object to UTC value: UTC plugin is not available!");
      return i2.format("YYYYMMDD") + (e ? "" : "T" + i2.format("HHmmss") + (n || a2 ? "" : "Z"));
    }
  }
  function E(a2, t, e, n) {
    let i2 = "", s = (n == null ? void 0 : n.floating) || false;
    return (n == null ? void 0 : n.timezone) && (i2 = ";TZID=" + n.timezone, s = true), t + i2 + ":" + o(a2, e, false, s);
  }
  function r(a2, t) {
    return String(a2).replace(t ? /[\\"]/g : /[\\;,]/g, function(e) {
      return "\\" + e;
    }).replace(/(?:\r\n|\r|\n)/g, "\\n");
  }
  function v(a2) {
    return a2.split(`\r
`).map(function(t) {
      let e = "", n = 0;
      for (let i2 = 0; i2 < t.length; i2++) {
        let s = t.charAt(i2);
        s >= "\uD800" && s <= "\uDBFF" && (s += t.charAt(++i2));
        let k = new TextEncoder().encode(s).length;
        n += k, n > 74 && (e += `\r
 `, n = k), e += s;
      }
      return e;
    }).join(`\r
`);
  }
  function l(a2, t, e) {
    if (Array.isArray(t)) a2.x = t.map((n) => {
      if (Array.isArray(n)) return n;
      if (typeof n.key != "string" || typeof n.value != "string") throw new Error("Either key or value is not a string!");
      if (n.key.substr(0, 2) !== "X-") throw new Error("Key has to start with `X-`!");
      return [n.key, n.value];
    });
    else if (typeof t == "object") a2.x = Object.entries(t).map(([n, i2]) => {
      if (typeof n != "string" || typeof i2 != "string") throw new Error("Either key or value is not a string!");
      if (n.substr(0, 2) !== "X-") throw new Error("Key has to start with `X-`!");
      return [n, i2];
    });
    else if (typeof t == "string" && typeof e == "string") {
      if (t.substr(0, 2) !== "X-") throw new Error("Key has to start with `X-`!");
      a2.x.push([t, e]);
    } else return a2.x.map((n) => ({ key: n[0], value: n[1] }));
  }
  function D(a2) {
    let t = a2.x.map(([e, n]) => e.toUpperCase() + ":" + r(n, false)).join(`\r
`);
    return t.length ? t + `\r
` : "";
  }
  function p(a2, t) {
    let e = null;
    if (typeof t == "string") {
      let n = t.match(/^(.+) ?<([^>]+)>$/);
      n ? e = { name: n[1].trim(), email: n[2].trim() } : t.includes("@") && (e = { name: t.trim(), email: t.trim() });
    } else typeof t == "object" && (e = { name: t.name, email: t.email, mailto: t.mailto, sentBy: t.sentBy });
    if (!e && typeof t == "string") throw new Error("`" + a2 + "` isn't formated correctly. See https://sebbo2002.github.io/ical-generator/develop/reference/interfaces/ICalOrganizer.html");
    if (!e) throw new Error("`" + a2 + "` needs to be a valid formed string or an object. See https://sebbo2002.github.io/ical-generator/develop/reference/interfaces/ICalOrganizer.html");
    if (!e.name) throw new Error("`" + a2 + ".name` is empty!");
    return e;
  }
  function d(a2, t) {
    let e = Object.values(a2), n = String(t).toUpperCase();
    if (!n || !e.includes(n)) throw new Error(`Input must be one of the following: ${e.join(", ")}`);
    return n;
  }
  function h(a2, t) {
    if (a2 instanceof Date && isNaN(a2.getTime()) || typeof a2 == "string" && isNaN(new Date(a2).getTime())) throw new Error(`\`${t}\` has to be a valid date!`);
    if (a2 instanceof Date || typeof a2 == "string" || R(a2) && a2.isValid === true || (S(a2) || j(a2)) && a2.isValid()) return a2;
    throw new Error(`\`${t}\` has to be a valid date!`);
  }
  function N(a2) {
    return typeof a2 == "string" || a2 instanceof Date ? new Date(a2) : R(a2) ? a2.toJSDate() : a2.toDate();
  }
  function S(a2) {
    return a2 != null && a2._isAMomentObject != null;
  }
  function F(a2) {
    return S(a2) && "tz" in a2 && typeof a2.tz == "function";
  }
  function j(a2) {
    return typeof a2 == "object" && a2 !== null && !(a2 instanceof Date) && !S(a2) && !R(a2);
  }
  function R(a2) {
    return typeof a2 == "object" && a2 !== null && "toJSDate" in a2 && typeof a2.toJSDate == "function";
  }
  function J(a2) {
    return a2 !== null && typeof a2 == "object" && "asSeconds" in a2 && typeof a2.asSeconds == "function";
  }
  function x(a2) {
    return a2 !== null && typeof a2 == "object" && "between" in a2 && typeof a2.between == "function" && typeof a2.toString == "function";
  }
  function g(a2) {
    return a2 ? typeof a2 == "string" ? a2 : a2.toJSON() : null;
  }
  function C(a2) {
    let t = "";
    return a2 < 0 && (t = "-", a2 *= -1), t += "P", a2 >= 86400 && (t += Math.floor(a2 / 86400) + "D", a2 %= 86400), !a2 && t.length > 1 || (t += "T", a2 >= 3600 && (t += Math.floor(a2 / 3600) + "H", a2 %= 3600), a2 >= 60 && (t += Math.floor(a2 / 60) + "M", a2 %= 60), a2 > 0 ? t += a2 + "S" : t.length <= 2 && (t += "0S")), t;
  }
  var O = ((i2) => (i2.CHAIR = "CHAIR", i2.REQ = "REQ-PARTICIPANT", i2.OPT = "OPT-PARTICIPANT", i2.NON = "NON-PARTICIPANT", i2))(O || {}), M = ((s) => (s.ACCEPTED = "ACCEPTED", s.TENTATIVE = "TENTATIVE", s.DECLINED = "DECLINED", s.DELEGATED = "DELEGATED", s.NEEDSACTION = "NEEDS-ACTION", s))(M || {}), w = ((s) => (s.INDIVIDUAL = "INDIVIDUAL", s.GROUP = "GROUP", s.RESOURCE = "RESOURCE", s.ROOM = "ROOM", s.UNKNOWN = "UNKNOWN", s))(w || {}), f = class a2 {
    constructor(t, e) {
      __publicField(this, "data");
      __publicField(this, "parent");
      if (this.data = { name: null, email: "", mailto: null, sentBy: null, status: null, role: "REQ-PARTICIPANT", rsvp: null, type: null, delegatedTo: null, delegatedFrom: null, x: [] }, this.parent = e, !this.parent) throw new Error("`event` option required!");
      if (!t.email) throw new Error("No value for `email` in ICalAttendee given!");
      t.name !== void 0 && this.name(t.name), t.email !== void 0 && this.email(t.email), t.mailto !== void 0 && this.mailto(t.mailto), t.sentBy !== void 0 && this.sentBy(t.sentBy), t.status !== void 0 && this.status(t.status), t.role !== void 0 && this.role(t.role), t.rsvp !== void 0 && this.rsvp(t.rsvp), t.type !== void 0 && this.type(t.type), t.delegatedTo !== void 0 && this.delegatedTo(t.delegatedTo), t.delegatedFrom !== void 0 && this.delegatedFrom(t.delegatedFrom), t.delegatesTo && this.delegatesTo(t.delegatesTo), t.delegatesFrom && this.delegatesFrom(t.delegatesFrom), t.x !== void 0 && this.x(t.x);
    }
    name(t) {
      return t === void 0 ? this.data.name : (this.data.name = t || null, this);
    }
    email(t) {
      return t ? (this.data.email = t, this) : this.data.email;
    }
    mailto(t) {
      return t === void 0 ? this.data.mailto : (this.data.mailto = t || null, this);
    }
    sentBy(t) {
      return t ? (this.data.sentBy = t, this) : this.data.sentBy;
    }
    role(t) {
      return t === void 0 ? this.data.role : (this.data.role = d(O, t), this);
    }
    rsvp(t) {
      return t === void 0 ? this.data.rsvp : t === null ? (this.data.rsvp = null, this) : (this.data.rsvp = !!t, this);
    }
    status(t) {
      return t === void 0 ? this.data.status : t ? (this.data.status = d(M, t), this) : (this.data.status = null, this);
    }
    type(t) {
      return t === void 0 ? this.data.type : t ? (this.data.type = d(w, t), this) : (this.data.type = null, this);
    }
    delegatedTo(t) {
      return t === void 0 ? this.data.delegatedTo : t ? (typeof t == "string" ? this.data.delegatedTo = new a2({ email: t, ...p("delegatedTo", t) }, this.parent) : t instanceof a2 ? this.data.delegatedTo = t : this.data.delegatedTo = new a2(t, this.parent), this.data.status = "DELEGATED", this) : (this.data.delegatedTo = null, this.data.status === "DELEGATED" && (this.data.status = null), this);
    }
    delegatedFrom(t) {
      return t === void 0 ? this.data.delegatedFrom : (t ? typeof t == "string" ? this.data.delegatedFrom = new a2({ email: t, ...p("delegatedFrom", t) }, this.parent) : t instanceof a2 ? this.data.delegatedFrom = t : this.data.delegatedFrom = new a2(t, this.parent) : this.data.delegatedFrom = null, this);
    }
    delegatesTo(t) {
      let e = t instanceof a2 ? t : this.parent.createAttendee(t);
      return this.delegatedTo(e), e.delegatedFrom(this), e;
    }
    delegatesFrom(t) {
      let e = t instanceof a2 ? t : this.parent.createAttendee(t);
      return this.delegatedFrom(e), e.delegatedTo(this), e;
    }
    x(t, e) {
      if (t === void 0) return l(this.data);
      if (typeof t == "string" && typeof e == "string") l(this.data, t, e);
      else if (typeof t == "object") l(this.data, t);
      else throw new Error("Either key or value is not a string!");
      return this;
    }
    toJSON() {
      var _a2, _b2;
      return Object.assign({}, this.data, { delegatedTo: ((_a2 = this.data.delegatedTo) == null ? void 0 : _a2.email()) || null, delegatedFrom: ((_b2 = this.data.delegatedFrom) == null ? void 0 : _b2.email()) || null, x: this.x() });
    }
    toString() {
      let t = "ATTENDEE";
      if (!this.data.email) throw new Error("No value for `email` in ICalAttendee given!");
      return t += ";ROLE=" + this.data.role, this.data.type && (t += ";CUTYPE=" + this.data.type), this.data.status && (t += ";PARTSTAT=" + this.data.status), this.data.rsvp !== null && (t += ";RSVP=" + this.data.rsvp.toString().toUpperCase()), this.data.sentBy !== null && (t += ';SENT-BY="mailto:' + this.data.sentBy + '"'), this.data.delegatedTo && (t += ';DELEGATED-TO="' + this.data.delegatedTo.email() + '"'), this.data.delegatedFrom && (t += ';DELEGATED-FROM="' + this.data.delegatedFrom.email() + '"'), this.data.name && (t += ';CN="' + r(this.data.name, true) + '"'), this.data.email && this.data.mailto && (t += ";EMAIL=" + r(this.data.email, false)), this.data.x.length && (t += ";" + this.data.x.map(([e, n]) => e.toUpperCase() + "=" + r(n, false)).join(";")), t += ":MAILTO:" + r(this.data.mailto || this.data.email, false) + `\r
`, t;
    }
  };
  var V = ((n) => (n.display = "display", n.audio = "audio", n.email = "email", n))(V || {}), Y = { end: "END", start: "START" }, I = class {
    constructor(t, e) {
      __publicField(this, "data");
      __publicField(this, "event");
      if (this.data = { type: "display", trigger: -600, relatesTo: null, repeat: null, interval: null, attach: null, description: null, summary: null, attendees: [], x: [] }, this.event = e, !e) throw new Error("`event` option required!");
      t.type !== void 0 && this.type(t.type), "trigger" in t && t.trigger !== void 0 && this.trigger(t.trigger), "triggerBefore" in t && t.triggerBefore !== void 0 && this.triggerBefore(t.triggerBefore), "triggerAfter" in t && t.triggerAfter !== void 0 && this.triggerAfter(t.triggerAfter), t.repeat && this.repeat(t.repeat), t.attach !== void 0 && this.attach(t.attach), t.description !== void 0 && this.description(t.description), t.summary !== void 0 && this.summary(t.summary), t.attendees !== void 0 && this.attendees(t.attendees), t.x !== void 0 && this.x(t.x);
    }
    type(t) {
      if (t === void 0) return this.data.type;
      if (!t || !Object.keys(V).includes(t)) throw new Error("`type` is not correct, must be either `display` or `audio`!");
      return this.data.type = t, this;
    }
    trigger(t) {
      if (t === void 0 && typeof this.data.trigger == "number") return -1 * this.data.trigger;
      if (t === void 0) return this.data.trigger;
      if (typeof t == "number" && isFinite(t)) this.data.trigger = -1 * t;
      else {
        if (!t || typeof t == "number") throw new Error("`trigger` is not correct, must be a finite number or a supported date!");
        this.data.trigger = h(t, "trigger");
      }
      return this;
    }
    relatesTo(t) {
      if (t === void 0) return this.data.relatesTo;
      if (!t) return this.data.relatesTo = null, this;
      if (!Object.values(Y).includes(t)) throw new Error("`relatesTo` is not correct, must be either `START` or `END`!");
      return this.data.relatesTo = t, this;
    }
    triggerAfter(t) {
      return t === void 0 ? this.data.trigger : this.trigger(typeof t == "number" ? -1 * t : t);
    }
    triggerBefore(t) {
      return t === void 0 ? this.trigger() : this.trigger(t);
    }
    repeat(t) {
      if (t === void 0) return this.data.repeat;
      if (!t) return this.data.repeat = null, this;
      if (typeof t != "object") throw new Error("`repeat` is not correct, must be an object!");
      if (typeof t.times != "number" || !isFinite(t.times)) throw new Error("`repeat.times` is not correct, must be numeric!");
      if (typeof t.interval != "number" || !isFinite(t.interval)) throw new Error("`repeat.interval` is not correct, must be numeric!");
      return this.data.repeat = t, this;
    }
    attach(t) {
      if (t === void 0) return this.data.attach;
      if (!t) return this.data.attach = null, this;
      let e = null;
      if (typeof t == "string") e = { uri: t, mime: null };
      else if (typeof t == "object") e = { uri: t.uri, mime: t.mime || null };
      else throw new Error("`attachment` needs to be a valid formed string or an object. See https://sebbo2002.github.io/ical-generator/develop/reference/classes/ICalAlarm.html#attach");
      if (!e.uri) throw new Error("`attach.uri` is empty!");
      return this.data.attach = { uri: e.uri, mime: e.mime }, this;
    }
    description(t) {
      return t === void 0 ? this.data.description : t ? (this.data.description = t, this) : (this.data.description = null, this);
    }
    summary(t) {
      return t === void 0 ? this.data.summary : t ? (this.data.summary = t, this) : (this.data.summary = null, this);
    }
    createAttendee(t) {
      if (t instanceof f) return this.data.attendees.push(t), t;
      typeof t == "string" && (t = { email: t, ...p("data", t) });
      let e = new f(t, this);
      return this.data.attendees.push(e), e;
    }
    attendees(t) {
      return t ? (t.forEach((e) => this.createAttendee(e)), this) : this.data.attendees;
    }
    x(t, e) {
      if (t === void 0) return l(this.data);
      if (typeof t == "string" && typeof e == "string") l(this.data, t, e);
      else if (typeof t == "object") l(this.data, t);
      else throw new Error("Either key or value is not a string!");
      return this;
    }
    toJSON() {
      let t = this.trigger();
      return Object.assign({}, this.data, { trigger: typeof t == "number" ? t : g(t), x: this.x() });
    }
    toString() {
      var _a2;
      let t = `BEGIN:VALARM\r
`;
      if (t += "ACTION:" + this.data.type.toUpperCase() + `\r
`, typeof this.data.trigger == "number" && this.data.relatesTo === null ? this.data.trigger > 0 ? t += "TRIGGER;RELATED=END:" + C(this.data.trigger) + `\r
` : t += "TRIGGER:" + C(this.data.trigger) + `\r
` : typeof this.data.trigger == "number" ? t += "TRIGGER;RELATED=" + ((_a2 = this.data.relatesTo) == null ? void 0 : _a2.toUpperCase()) + ":" + C(this.data.trigger) + `\r
` : t += "TRIGGER;VALUE=DATE-TIME:" + o(this.event.timezone(), this.data.trigger) + `\r
`, this.data.repeat) {
        if (!this.data.repeat.times) throw new Error("No value for `repeat.times` in ICalAlarm given, but required for `interval`!");
        if (!this.data.repeat.interval) throw new Error("No value for `repeat.interval` in ICalAlarm given, but required for `repeat`!");
        t += "REPEAT:" + this.data.repeat.times + `\r
`, t += "DURATION:" + C(this.data.repeat.interval) + `\r
`;
      }
      return this.data.type === "audio" && this.data.attach && this.data.attach.mime ? t += "ATTACH;FMTTYPE=" + r(this.data.attach.mime, false) + ":" + r(this.data.attach.uri, false) + `\r
` : this.data.type === "audio" && this.data.attach ? t += "ATTACH;VALUE=URI:" + r(this.data.attach.uri, false) + `\r
` : this.data.type === "audio" && (t += `ATTACH;VALUE=URI:Basso\r
`), this.data.type !== "audio" && this.data.description ? t += "DESCRIPTION:" + r(this.data.description, false) + `\r
` : this.data.type !== "audio" && (t += "DESCRIPTION:" + r(this.event.summary(), false) + `\r
`), this.data.type === "email" && this.data.summary ? t += "SUMMARY:" + r(this.data.summary, false) + `\r
` : this.data.type === "email" && (t += "SUMMARY:" + r(this.event.summary(), false) + `\r
`), this.data.type === "email" && this.data.attendees.forEach((e) => {
        t += e.toString();
      }), t += D(this.data), t += `END:VALARM\r
`, t;
    }
  };
  var c = class {
    constructor(t) {
      __publicField(this, "data");
      if (this.data = { name: "" }, !t.name) throw new Error("No value for `name` in ICalCategory given!");
      this.name(t.name);
    }
    name(t) {
      return t === void 0 ? this.data.name : (this.data.name = t, this);
    }
    toJSON() {
      return Object.assign({}, this.data);
    }
    toString() {
      return r(this.data.name, false);
    }
  };
  var L = ((n) => (n.CONFIRMED = "CONFIRMED", n.TENTATIVE = "TENTATIVE", n.CANCELLED = "CANCELLED", n))(L || {}), z = ((i2) => (i2.FREE = "FREE", i2.TENTATIVE = "TENTATIVE", i2.BUSY = "BUSY", i2.OOF = "OOF", i2))(z || {}), U = ((e) => (e.TRANSPARENT = "TRANSPARENT", e.OPAQUE = "OPAQUE", e))(U || {}), B = ((n) => (n.PUBLIC = "PUBLIC", n.PRIVATE = "PRIVATE", n.CONFIDENTIAL = "CONFIDENTIAL", n))(B || {}), y = class {
    constructor(t, e) {
      __publicField(this, "data");
      __publicField(this, "calendar");
      if (this.data = { id: G(), sequence: 0, start: /* @__PURE__ */ new Date(), end: null, recurrenceId: null, timezone: null, stamp: /* @__PURE__ */ new Date(), allDay: false, floating: false, repeating: null, summary: "", location: null, description: null, organizer: null, attendees: [], alarms: [], categories: [], status: null, busystatus: null, priority: null, url: null, attachments: [], transparency: null, created: null, lastModified: null, class: null, x: [] }, this.calendar = e, !e) throw new Error("`calendar` option required!");
      t.id && this.id(t.id), t.sequence !== void 0 && this.sequence(t.sequence), t.start && this.start(t.start), t.end !== void 0 && this.end(t.end), t.recurrenceId !== void 0 && this.recurrenceId(t.recurrenceId), t.timezone !== void 0 && this.timezone(t.timezone), t.stamp !== void 0 && this.stamp(t.stamp), t.allDay !== void 0 && this.allDay(t.allDay), t.floating !== void 0 && this.floating(t.floating), t.repeating !== void 0 && this.repeating(t.repeating), t.summary !== void 0 && this.summary(t.summary), t.location !== void 0 && this.location(t.location), t.description !== void 0 && this.description(t.description), t.organizer !== void 0 && this.organizer(t.organizer), t.attendees !== void 0 && this.attendees(t.attendees), t.alarms !== void 0 && this.alarms(t.alarms), t.categories !== void 0 && this.categories(t.categories), t.status !== void 0 && this.status(t.status), t.busystatus !== void 0 && this.busystatus(t.busystatus), t.priority !== void 0 && this.priority(t.priority), t.url !== void 0 && this.url(t.url), t.attachments !== void 0 && this.attachments(t.attachments), t.transparency !== void 0 && this.transparency(t.transparency), t.created !== void 0 && this.created(t.created), t.lastModified !== void 0 && this.lastModified(t.lastModified), t.class !== void 0 && this.class(t.class), t.x !== void 0 && this.x(t.x);
    }
    id(t) {
      return t === void 0 ? this.data.id : (this.data.id = String(t), this);
    }
    uid(t) {
      return t === void 0 ? this.id() : this.id(t);
    }
    sequence(t) {
      if (t === void 0) return this.data.sequence;
      let e = parseInt(String(t), 10);
      if (isNaN(e)) throw new Error("`sequence` must be a number!");
      return this.data.sequence = t, this;
    }
    start(t) {
      return t === void 0 ? (this.swapStartAndEndIfRequired(), this.data.start) : (this.data.start = h(t, "start"), this);
    }
    end(t) {
      return t === void 0 ? (this.swapStartAndEndIfRequired(), this.data.end) : t === null ? (this.data.end = null, this) : (this.data.end = h(t, "end"), this);
    }
    swapStartAndEndIfRequired() {
      if (this.data.start && this.data.end && N(this.data.start).getTime() > N(this.data.end).getTime()) {
        let t = this.data.start;
        this.data.start = this.data.end, this.data.end = t;
      }
    }
    recurrenceId(t) {
      return t === void 0 ? this.data.recurrenceId : t === null ? (this.data.recurrenceId = null, this) : (this.data.recurrenceId = h(t, "recurrenceId"), this);
    }
    timezone(t) {
      return t === void 0 && this.data.timezone !== null ? this.data.timezone : t === void 0 ? this.calendar.timezone() : (this.data.timezone = t && t !== "UTC" ? t.toString() : null, this.data.timezone && (this.data.floating = false), this);
    }
    stamp(t) {
      return t === void 0 ? this.data.stamp : (this.data.stamp = h(t, "stamp"), this);
    }
    timestamp(t) {
      return t === void 0 ? this.stamp() : this.stamp(t);
    }
    allDay(t) {
      return t === void 0 ? this.data.allDay : (this.data.allDay = !!t, this);
    }
    floating(t) {
      return t === void 0 ? this.data.floating : (this.data.floating = !!t, this.data.floating && (this.data.timezone = null), this);
    }
    repeating(t) {
      if (t === void 0) return this.data.repeating;
      if (!t) return this.data.repeating = null, this;
      if (x(t) || typeof t == "string") return this.data.repeating = t, this;
      if (this.data.repeating = { freq: d(b, t.freq) }, t.count) {
        if (!isFinite(t.count)) throw new Error("`repeating.count` must be a finite number!");
        this.data.repeating.count = t.count;
      }
      if (t.interval) {
        if (!isFinite(t.interval)) throw new Error("`repeating.interval` must be a finite number!");
        this.data.repeating.interval = t.interval;
      }
      if (t.until !== void 0 && (this.data.repeating.until = h(t.until, "repeating.until")), t.byDay) {
        let e = Array.isArray(t.byDay) ? t.byDay : [t.byDay];
        this.data.repeating.byDay = e.map((n) => d(A, n));
      }
      if (t.byMonth) {
        let e = Array.isArray(t.byMonth) ? t.byMonth : [t.byMonth];
        this.data.repeating.byMonth = e.map((n) => {
          if (typeof n != "number" || n < 1 || n > 12) throw new Error("`repeating.byMonth` contains invalid value `" + n + "`!");
          return n;
        });
      }
      if (t.byMonthDay) {
        let e = Array.isArray(t.byMonthDay) ? t.byMonthDay : [t.byMonthDay];
        this.data.repeating.byMonthDay = e.map((n) => {
          if (typeof n != "number" || n < -31 || n > 31 || n === 0) throw new Error("`repeating.byMonthDay` contains invalid value `" + n + "`!");
          return n;
        });
      }
      if (t.bySetPos) {
        if (!this.data.repeating.byDay) throw "`repeating.bySetPos` must be used along with `repeating.byDay`!";
        let e = Array.isArray(t.bySetPos) ? t.bySetPos : [t.bySetPos];
        this.data.repeating.bySetPos = e.map((n) => {
          if (typeof n != "number" || n < -366 || n > 366 || n === 0) throw "`repeating.bySetPos` contains invalid value `" + n + "`!";
          return n;
        });
      }
      if (t.exclude) {
        let e = Array.isArray(t.exclude) ? t.exclude : [t.exclude];
        this.data.repeating.exclude = e.map((n, i2) => h(n, `repeating.exclude[${i2}]`));
      }
      return t.startOfWeek && (this.data.repeating.startOfWeek = d(A, t.startOfWeek)), this;
    }
    summary(t) {
      return t === void 0 ? this.data.summary : (this.data.summary = t ? String(t) : "", this);
    }
    location(t) {
      if (t === void 0) return this.data.location;
      if (typeof t == "string") return this.data.location = { title: t }, this;
      if (t && ("title" in t && !t.title || (t == null ? void 0 : t.geo) && (typeof t.geo.lat != "number" || !isFinite(t.geo.lat) || typeof t.geo.lon != "number" || !isFinite(t.geo.lon)) || !("title" in t) && !(t == null ? void 0 : t.geo))) throw new Error("`location` isn't formatted correctly. See https://sebbo2002.github.io/ical-generator/develop/reference/classes/ICalEvent.html#location");
      return this.data.location = t || null, this;
    }
    description(t) {
      return t === void 0 ? this.data.description : t === null ? (this.data.description = null, this) : (typeof t == "string" ? this.data.description = { plain: t } : this.data.description = t, this);
    }
    organizer(t) {
      return t === void 0 ? this.data.organizer : t === null ? (this.data.organizer = null, this) : (this.data.organizer = p("organizer", t), this);
    }
    createAttendee(t) {
      if (t instanceof f) return this.data.attendees.push(t), t;
      typeof t == "string" && (t = { email: t, ...p("data", t) });
      let e = new f(t, this);
      return this.data.attendees.push(e), e;
    }
    attendees(t) {
      return t ? (t.forEach((e) => this.createAttendee(e)), this) : this.data.attendees;
    }
    createAlarm(t) {
      let e = t instanceof I ? t : new I(t, this);
      return this.data.alarms.push(e), e;
    }
    alarms(t) {
      return t ? (t.forEach((e) => this.createAlarm(e)), this) : this.data.alarms;
    }
    createCategory(t) {
      let e = t instanceof c ? t : new c(t);
      return this.data.categories.push(e), e;
    }
    categories(t) {
      return t ? (t.forEach((e) => this.createCategory(e)), this) : this.data.categories;
    }
    status(t) {
      return t === void 0 ? this.data.status : t === null ? (this.data.status = null, this) : (this.data.status = d(L, t), this);
    }
    busystatus(t) {
      return t === void 0 ? this.data.busystatus : t === null ? (this.data.busystatus = null, this) : (this.data.busystatus = d(z, t), this);
    }
    priority(t) {
      if (t === void 0) return this.data.priority;
      if (t === null) return this.data.priority = null, this;
      if (t < 0 || t > 9) throw new Error("`priority` is invalid, musst be 0 ≤ priority ≤ 9.");
      return this.data.priority = Math.round(t), this;
    }
    url(t) {
      return t === void 0 ? this.data.url : (this.data.url = t ? String(t) : null, this);
    }
    createAttachment(t) {
      return this.data.attachments.push(t), this;
    }
    attachments(t) {
      return t ? (t.forEach((e) => this.createAttachment(e)), this) : this.data.attachments;
    }
    transparency(t) {
      return t === void 0 ? this.data.transparency : t ? (this.data.transparency = d(U, t), this) : (this.data.transparency = null, this);
    }
    created(t) {
      return t === void 0 ? this.data.created : t === null ? (this.data.created = null, this) : (this.data.created = h(t, "created"), this);
    }
    lastModified(t) {
      return t === void 0 ? this.data.lastModified : t === null ? (this.data.lastModified = null, this) : (this.data.lastModified = h(t, "lastModified"), this);
    }
    class(t) {
      return t === void 0 ? this.data.class : t === null ? (this.data.class = null, this) : (this.data.class = d(B, t), this);
    }
    x(t, e) {
      return t === void 0 ? l(this.data) : (typeof t == "string" && typeof e == "string" && l(this.data, t, e), typeof t == "object" && l(this.data, t), this);
    }
    toJSON() {
      var _a2;
      let t = null;
      return x(this.data.repeating) || typeof this.data.repeating == "string" ? t = this.data.repeating.toString() : this.data.repeating && (t = Object.assign({}, this.data.repeating, { until: g(this.data.repeating.until) || void 0, exclude: (_a2 = this.data.repeating.exclude) == null ? void 0 : _a2.map((e) => g(e)) })), this.swapStartAndEndIfRequired(), Object.assign({}, this.data, { start: g(this.data.start) || null, end: g(this.data.end) || null, recurrenceId: g(this.data.recurrenceId) || null, stamp: g(this.data.stamp) || null, created: g(this.data.created) || null, lastModified: g(this.data.lastModified) || null, repeating: t, x: this.x() });
    }
    toString() {
      var _a2, _b2, _c, _d;
      let t = "";
      if (t += `BEGIN:VEVENT\r
`, t += "UID:" + this.data.id + `\r
`, t += "SEQUENCE:" + this.data.sequence + `\r
`, this.swapStartAndEndIfRequired(), t += "DTSTAMP:" + o(this.calendar.timezone(), this.data.stamp) + `\r
`, this.data.allDay ? (t += "DTSTART;VALUE=DATE:" + o(this.timezone(), this.data.start, true) + `\r
`, this.data.end && (t += "DTEND;VALUE=DATE:" + o(this.timezone(), this.data.end, true) + `\r
`), t += `X-MICROSOFT-CDO-ALLDAYEVENT:TRUE\r
`, t += `X-MICROSOFT-MSNCALENDAR-ALLDAYEVENT:TRUE\r
`) : (t += E(this.timezone(), "DTSTART", this.data.start, this.data) + `\r
`, this.data.end && (t += E(this.timezone(), "DTEND", this.data.end, this.data) + `\r
`)), x(this.data.repeating) || typeof this.data.repeating == "string") {
        let e = this.data.repeating.toString().replace(/\r\n/g, `
`).split(`
`).filter((n) => n && !n.startsWith("DTSTART:")).join(`\r
`);
        !e.includes(`\r
`) && !e.startsWith("RRULE:") && (e = "RRULE:" + e), t += e.trim() + `\r
`;
      } else this.data.repeating && (t += "RRULE:FREQ=" + this.data.repeating.freq, this.data.repeating.count && (t += ";COUNT=" + this.data.repeating.count), this.data.repeating.interval && (t += ";INTERVAL=" + this.data.repeating.interval), this.data.repeating.until && (t += ";UNTIL=" + o(this.calendar.timezone(), this.data.repeating.until, false, this.floating())), this.data.repeating.byDay && (t += ";BYDAY=" + this.data.repeating.byDay.join(",")), this.data.repeating.byMonth && (t += ";BYMONTH=" + this.data.repeating.byMonth.join(",")), this.data.repeating.byMonthDay && (t += ";BYMONTHDAY=" + this.data.repeating.byMonthDay.join(",")), this.data.repeating.bySetPos && (t += ";BYSETPOS=" + this.data.repeating.bySetPos.join(",")), this.data.repeating.startOfWeek && (t += ";WKST=" + this.data.repeating.startOfWeek), t += `\r
`, this.data.repeating.exclude && (this.data.allDay ? t += "EXDATE;VALUE=DATE:" + this.data.repeating.exclude.map((e) => o(this.calendar.timezone(), e, true)).join(",") + `\r
` : (t += "EXDATE", this.timezone() ? t += ";TZID=" + this.timezone() + ":" + this.data.repeating.exclude.map((e) => o(this.timezone(), e, false, true)).join(",") + `\r
` : t += ":" + this.data.repeating.exclude.map((e) => o(this.timezone(), e, false, this.floating())).join(",") + `\r
`)));
      return this.data.recurrenceId && (t += E(this.timezone(), "RECURRENCE-ID", this.data.recurrenceId, this.data) + `\r
`), t += "SUMMARY:" + r(this.data.summary, false) + `\r
`, this.data.transparency && (t += "TRANSP:" + r(this.data.transparency, false) + `\r
`), this.data.location && "title" in this.data.location && this.data.location.title && (t += "LOCATION:" + r(this.data.location.title + (this.data.location.address ? `
` + this.data.location.address : ""), false) + `\r
`, this.data.location.radius && this.data.location.geo && (t += "X-APPLE-STRUCTURED-LOCATION;VALUE=URI;" + (this.data.location.address ? "X-ADDRESS=" + r(this.data.location.address, false) + ";" : "") + "X-APPLE-RADIUS=" + r(this.data.location.radius, false) + ";X-TITLE=" + r(this.data.location.title, false) + ":geo:" + r((_a2 = this.data.location.geo) == null ? void 0 : _a2.lat, false) + "," + r((_b2 = this.data.location.geo) == null ? void 0 : _b2.lon, false) + `\r
`)), ((_d = (_c = this.data.location) == null ? void 0 : _c.geo) == null ? void 0 : _d.lat) && this.data.location.geo.lon && (t += "GEO:" + r(this.data.location.geo.lat, false) + ";" + r(this.data.location.geo.lon, false) + `\r
`), this.data.description && (t += "DESCRIPTION:" + r(this.data.description.plain, false) + `\r
`, this.data.description.html && (t += "X-ALT-DESC;FMTTYPE=text/html:" + r(this.data.description.html, false) + `\r
`)), this.data.organizer && (t += 'ORGANIZER;CN="' + r(this.data.organizer.name, true) + '"', this.data.organizer.sentBy && (t += ';SENT-BY="mailto:' + r(this.data.organizer.sentBy, true) + '"'), this.data.organizer.email && this.data.organizer.mailto && (t += ";EMAIL=" + r(this.data.organizer.email, false)), t += ":", this.data.organizer.email && (t += "mailto:" + r(this.data.organizer.mailto || this.data.organizer.email, false)), t += `\r
`), this.data.attendees.forEach(function(e) {
        t += e.toString();
      }), this.data.alarms.forEach(function(e) {
        t += e.toString();
      }), this.data.categories.length > 0 && (t += "CATEGORIES:" + this.data.categories.map((e) => e.toString()).join() + `\r
`), this.data.url && (t += "URL;VALUE=URI:" + r(this.data.url, false) + `\r
`), this.data.attachments.length > 0 && this.data.attachments.forEach((e) => {
        t += "ATTACH:" + r(e, false) + `\r
`;
      }), this.data.status && (t += "STATUS:" + this.data.status.toUpperCase() + `\r
`), this.data.busystatus && (t += "X-MICROSOFT-CDO-BUSYSTATUS:" + this.data.busystatus.toUpperCase() + `\r
`), this.data.priority !== null && (t += "PRIORITY:" + this.data.priority + `\r
`), t += D(this.data), this.data.created && (t += "CREATED:" + o(this.calendar.timezone(), this.data.created) + `\r
`), this.data.lastModified && (t += "LAST-MODIFIED:" + o(this.calendar.timezone(), this.data.lastModified) + `\r
`), this.data.class && (t += "CLASS:" + this.data.class.toUpperCase() + `\r
`), t += `END:VEVENT\r
`, t;
    }
  };
  var P = ((m) => (m.PUBLISH = "PUBLISH", m.REQUEST = "REQUEST", m.REPLY = "REPLY", m.ADD = "ADD", m.CANCEL = "CANCEL", m.REFRESH = "REFRESH", m.COUNTER = "COUNTER", m.DECLINECOUNTER = "DECLINECOUNTER", m))(P || {}), T = class {
    constructor(t = {}) {
      __publicField(this, "data");
      this.data = { prodId: "//sebbo.net//ical-generator//EN", method: null, name: null, description: null, timezone: null, source: null, url: null, scale: null, ttl: null, events: [], x: [] }, t.prodId !== void 0 && this.prodId(t.prodId), t.method !== void 0 && this.method(t.method), t.name !== void 0 && this.name(t.name), t.description !== void 0 && this.description(t.description), t.timezone !== void 0 && this.timezone(t.timezone), t.source !== void 0 && this.source(t.source), t.url !== void 0 && this.url(t.url), t.scale !== void 0 && this.scale(t.scale), t.ttl !== void 0 && this.ttl(t.ttl), t.events !== void 0 && this.events(t.events), t.x !== void 0 && this.x(t.x);
    }
    prodId(t) {
      if (!t) return this.data.prodId;
      if (typeof t == "string") return this.data.prodId = t, this;
      if (typeof t != "object") throw new Error("`prodid` needs to be a string or an object!");
      if (!t.company) throw new Error("`prodid.company` is a mandatory item!");
      if (!t.product) throw new Error("`prodid.product` is a mandatory item!");
      let e = (t.language || "EN").toUpperCase();
      return this.data.prodId = "//" + t.company + "//" + t.product + "//" + e, this;
    }
    method(t) {
      return t === void 0 ? this.data.method : t ? (this.data.method = d(P, t), this) : (this.data.method = null, this);
    }
    name(t) {
      return t === void 0 ? this.data.name : (this.data.name = t ? String(t) : null, this);
    }
    description(t) {
      return t === void 0 ? this.data.description : (this.data.description = t ? String(t) : null, this);
    }
    timezone(t) {
      var _a2;
      return t === void 0 ? ((_a2 = this.data.timezone) == null ? void 0 : _a2.name) || null : (t === "UTC" ? this.data.timezone = null : typeof t == "string" ? this.data.timezone = { name: t } : t === null ? this.data.timezone = null : this.data.timezone = t, this);
    }
    source(t) {
      return t === void 0 ? this.data.source : (this.data.source = t || null, this);
    }
    url(t) {
      return t === void 0 ? this.data.url : (this.data.url = t || null, this);
    }
    scale(t) {
      return t === void 0 ? this.data.scale : (t === null ? this.data.scale = null : this.data.scale = t.toUpperCase(), this);
    }
    ttl(t) {
      return t === void 0 ? this.data.ttl : (J(t) ? this.data.ttl = t.asSeconds() : t && t > 0 ? this.data.ttl = t : this.data.ttl = null, this);
    }
    createEvent(t) {
      let e = t instanceof y ? t : new y(t, this);
      return this.data.events.push(e), e;
    }
    events(t) {
      return t ? (t.forEach((e) => this.createEvent(e)), this) : this.data.events;
    }
    clear() {
      return this.data.events = [], this;
    }
    x(t, e) {
      if (t === void 0) return l(this.data);
      if (typeof t == "string" && typeof e == "string") l(this.data, t, e);
      else if (typeof t == "object") l(this.data, t);
      else throw new Error("Either key or value is not a string!");
      return this;
    }
    toJSON() {
      return Object.assign({}, this.data, { timezone: this.timezone(), events: this.data.events.map((t) => t.toJSON()), x: this.x() });
    }
    length() {
      return this.data.events.length;
    }
    toString() {
      var _a2, _b2;
      let t = "";
      return t = `BEGIN:VCALENDAR\r
VERSION:2.0\r
`, t += "PRODID:-" + this.data.prodId + `\r
`, this.data.url && (t += "URL:" + this.data.url + `\r
`), this.data.source && (t += "SOURCE;VALUE=URI:" + this.data.source + `\r
`), this.data.scale && (t += "CALSCALE:" + this.data.scale + `\r
`), this.data.method && (t += "METHOD:" + this.data.method + `\r
`), this.data.name && (t += "NAME:" + this.data.name + `\r
`, t += "X-WR-CALNAME:" + this.data.name + `\r
`), this.data.description && (t += "X-WR-CALDESC:" + this.data.description + `\r
`), ((_a2 = this.data.timezone) == null ? void 0 : _a2.generator) && [.../* @__PURE__ */ new Set([this.timezone(), ...this.data.events.map((n) => n.timezone())])].filter((n) => n !== null && !n.startsWith("/")).forEach((n) => {
        var _a3;
        if (!((_a3 = this.data.timezone) == null ? void 0 : _a3.generator)) return;
        let i2 = this.data.timezone.generator(n);
        i2 && (t += i2.replace(/\r\n/g, `
`).replace(/\n/g, `\r
`).trim() + `\r
`);
      }), ((_b2 = this.data.timezone) == null ? void 0 : _b2.name) && (t += "TIMEZONE-ID:" + this.data.timezone.name + `\r
`, t += "X-WR-TIMEZONE:" + this.data.timezone.name + `\r
`), this.data.ttl && (t += "REFRESH-INTERVAL;VALUE=DURATION:" + C(this.data.ttl) + `\r
`, t += "X-PUBLISHED-TTL:" + C(this.data.ttl) + `\r
`), this.data.events.forEach((e) => t += e.toString()), t += D(this.data), t += "END:VCALENDAR", v(t);
    }
  };
  function H(a2) {
    return new T(a2);
  }
  var It = H;
  function getDayIndexOfWeek(date, dayIndex) {
    const day = date.getDay();
    const offset2 = dayIndex - day;
    const adjestedDate = new Date(date.getTime() + offset2 * (1e3 * 3600 * 24));
    return adjestedDate;
  }
  async function generateIcalStudy(scheduleItems, repeatingRange) {
    if (!repeatingRange.start || !repeatingRange.end)
      throw new Error("Invalid repeatingRange");
    function convertEvent(scheduleItem) {
      const event2 = {
        summary: `${scheduleItem.subjectName} (${scheduleItem.type})`,
        location: `${scheduleItem.building}:${scheduleItem.room}`,
        start: getDayIndexOfWeek(
          $11d87f3f76e88657$export$b21e0b124e224484(
            repeatingRange.start,
            new $35ea8db9cb2ccb90$export$680ea196effce5f(Number(scheduleItem.start.slice(0, 2)), Number(scheduleItem.start.slice(-2)))
          ).toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2()),
          scheduleItem.day
        ),
        end: getDayIndexOfWeek(
          $11d87f3f76e88657$export$b21e0b124e224484(
            repeatingRange.start,
            new $35ea8db9cb2ccb90$export$680ea196effce5f(Number(scheduleItem.start.slice(0, 2)), Number(scheduleItem.start.slice(-2)))
          ).toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2()),
          scheduleItem.day
        ),
        repeating: {
          freq: b.WEEKLY,
          until: repeatingRange.end.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2())
        }
      };
      return event2;
    }
    const calendarName = `Study (${constants.appName}@${(/* @__PURE__ */ new Date()).toString()})`;
    const calendar = It({ name: calendarName, prodId: constants.appName });
    scheduleItems.forEach((item) => {
      const event2 = convertEvent(item);
      calendar.createEvent(event2);
    });
    const calendarBlob = new Blob([calendar.toString()], { type: "text/calendar;charset=utf-8" });
    FileSaver_minExports.saveAs(calendarBlob, `${calendarName}.ical`);
  }
  studyTable;
  studyTable;
  mark_module_start();
  Generate[FILENAME] = "src/lib/components/calendar/generate.svelte";
  var root_7$1 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Generate[FILENAME], []);
  var root_6$1 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Generate[FILENAME], []);
  var root_3 = add_locations(/* @__PURE__ */ template(`<!> <h3>Set repeating range</h3> <div class="grid gap-2"><!></div> <!>`, 1), Generate[FILENAME], [[48, 4], [49, 4]]);
  var root_1$1 = add_locations(/* @__PURE__ */ template(`<!> <!>`, 1), Generate[FILENAME], []);
  function Generate($$anchor, $$props) {
    check_target(new.target);
    push($$props, true, Generate);
    validate_prop_bindings($$props, [], [], Generate);
    const df = new $fb18d541ea1ad717$export$ad991b66133851cf("en-US", { dateStyle: "medium" });
    const today = /* @__PURE__ */ new Date();
    let value = state(proxy({
      start: new $35ea8db9cb2ccb90$export$99faa760c7908e4f(today.getFullYear(), today.getMonth() + 1, today.getDate()),
      end: new $35ea8db9cb2ccb90$export$99faa760c7908e4f(today.getFullYear(), today.getMonth() + 1, today.getDate())
    }));
    let startValue = state(void 0);
    var fragment = comment();
    var node = first_child(fragment);
    component(node, () => Root$1, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        children: wrap_snippet(Generate, ($$anchor3, $$slotProps) => {
          var fragment_1 = root_1$1();
          var node_1 = first_child(fragment_1);
          var class_1 = /* @__PURE__ */ derived(() => buttonVariants({ variant: "outline" }));
          component(node_1, () => Trigger$1, ($$anchor4, $$component2) => {
            $$component2($$anchor4, {
              get class() {
                return get$2(class_1);
              },
              children: wrap_snippet(Generate, ($$anchor5, $$slotProps2) => {
                next();
                var text$1 = text("Generate Calendar");
                append($$anchor5, text$1);
              }),
              $$slots: { default: true }
            });
          });
          var node_2 = sibling(node_1, 2);
          component(node_2, () => Dialog_content, ($$anchor4, $$component2) => {
            $$component2($$anchor4, {
              class: "sm:max-w-[425px]",
              children: wrap_snippet(Generate, ($$anchor5, $$slotProps2) => {
                var fragment_2 = root_3();
                var node_3 = first_child(fragment_2);
                component(node_3, () => Dialog_header, ($$anchor6, $$component3) => {
                  $$component3($$anchor6, {
                    children: wrap_snippet(Generate, ($$anchor7, $$slotProps3) => {
                      var fragment_3 = comment();
                      var node_4 = first_child(fragment_3);
                      component(node_4, () => Dialog_title, ($$anchor8, $$component4) => {
                        $$component4($$anchor8, {
                          children: wrap_snippet(Generate, ($$anchor9, $$slotProps4) => {
                            next();
                            var text_1 = text("Generate Calendar");
                            append($$anchor9, text_1);
                          }),
                          $$slots: { default: true }
                        });
                      });
                      append($$anchor7, fragment_3);
                    }),
                    $$slots: { default: true }
                  });
                });
                var div = sibling(node_3, 4);
                var node_5 = child(div);
                component(node_5, () => Root, ($$anchor6, $$component3) => {
                  $$component3($$anchor6, {
                    children: wrap_snippet(Generate, ($$anchor7, $$slotProps3) => {
                      var fragment_4 = root_6$1();
                      var node_6 = first_child(fragment_4);
                      var class_2 = /* @__PURE__ */ derived(() => cn(buttonVariants({ variant: "outline" }), !get$2(value) && "text-muted-foreground"));
                      component(node_6, () => Trigger, ($$anchor8, $$component4) => {
                        $$component4($$anchor8, {
                          get class() {
                            return get$2(class_2);
                          },
                          children: wrap_snippet(Generate, ($$anchor9, $$slotProps4) => {
                            var fragment_5 = root_7$1();
                            var node_7 = first_child(fragment_5);
                            Calendar(node_7, { class: "mr-2 size-4" });
                            var node_8 = sibling(node_7, 2);
                            {
                              var consequent_1 = ($$anchor10) => {
                                var fragment_6 = comment();
                                var node_9 = first_child(fragment_6);
                                {
                                  var consequent = ($$anchor11) => {
                                    var text_2 = text();
                                    const stringified_text = /* @__PURE__ */ derived(() => df.format(get$2(value).start.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2())) ?? "");
                                    const stringified_text_1 = /* @__PURE__ */ derived(() => df.format(get$2(value).end.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2())) ?? "");
                                    template_effect(() => set_text(text_2, `${get$2(stringified_text)} - ${get$2(stringified_text_1)}`));
                                    append($$anchor11, text_2);
                                  };
                                  var alternate = ($$anchor11) => {
                                    var text_3 = text();
                                    template_effect(() => set_text(text_3, df.format(get$2(value).start.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2()))));
                                    append($$anchor11, text_3);
                                  };
                                  if_block(node_9, ($$render) => {
                                    if (get$2(value).end) $$render(consequent);
                                    else $$render(alternate, false);
                                  });
                                }
                                append($$anchor10, fragment_6);
                              };
                              var alternate_2 = ($$anchor10) => {
                                var fragment_9 = comment();
                                var node_10 = first_child(fragment_9);
                                {
                                  var consequent_2 = ($$anchor11) => {
                                    var text_4 = text();
                                    template_effect(() => set_text(text_4, df.format(get$2(startValue).toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2()))));
                                    append($$anchor11, text_4);
                                  };
                                  var alternate_1 = ($$anchor11) => {
                                    var text_5 = text("Pick a date");
                                    append($$anchor11, text_5);
                                  };
                                  if_block(
                                    node_10,
                                    ($$render) => {
                                      if (get$2(startValue)) $$render(consequent_2);
                                      else $$render(alternate_1, false);
                                    },
                                    true
                                  );
                                }
                                append($$anchor10, fragment_9);
                              };
                              if_block(node_8, ($$render) => {
                                if (get$2(value) && get$2(value).start) $$render(consequent_1);
                                else $$render(alternate_2, false);
                              });
                            }
                            append($$anchor9, fragment_5);
                          }),
                          $$slots: { default: true }
                        });
                      });
                      var node_11 = sibling(node_6, 2);
                      component(node_11, () => Popover_content, ($$anchor8, $$component4) => {
                        $$component4($$anchor8, {
                          class: "w-auto p-0",
                          align: "start",
                          children: wrap_snippet(Generate, ($$anchor9, $$slotProps4) => {
                            {
                              add_owner_effect(() => get$2(value), Range_calendar);
                              Range_calendar($$anchor9, {
                                onStartValueChange: (v2) => {
                                  set(startValue, proxy(v2, null, startValue));
                                },
                                numberOfMonths: 2,
                                get value() {
                                  return get$2(value);
                                },
                                set value($$value) {
                                  set(value, proxy($$value, null, value));
                                }
                              });
                            }
                          }),
                          $$slots: { default: true }
                        });
                      });
                      append($$anchor7, fragment_4);
                    }),
                    $$slots: { default: true }
                  });
                });
                reset(div);
                var node_12 = sibling(div, 2);
                component(node_12, () => Dialog_footer, ($$anchor6, $$component3) => {
                  $$component3($$anchor6, {
                    children: wrap_snippet(Generate, ($$anchor7, $$slotProps3) => {
                      Button($$anchor7, {
                        onclick: () => generateIcalStudy($$props.schedule, get$2(value)),
                        children: wrap_snippet(Generate, ($$anchor8, $$slotProps4) => {
                          next();
                          var text_6 = text("Generate");
                          append($$anchor8, text_6);
                        }),
                        $$slots: { default: true }
                      });
                    }),
                    $$slots: { default: true }
                  });
                });
                append($$anchor5, fragment_2);
              }),
              $$slots: { default: true }
            });
          });
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Generate);
  function resolveUrl(url, baseUrl) {
    if (url.match(/^[a-z]+:\/\//i)) {
      return url;
    }
    if (url.match(/^\/\//)) {
      return window.location.protocol + url;
    }
    if (url.match(/^[a-z]+:/i)) {
      return url;
    }
    const doc = document.implementation.createHTMLDocument();
    const base = doc.createElement("base");
    const a2 = doc.createElement("a");
    doc.head.appendChild(base);
    doc.body.appendChild(a2);
    if (baseUrl) {
      base.href = baseUrl;
    }
    a2.href = url;
    return a2.href;
  }
  const uuid = /* @__PURE__ */ (() => {
    let counter = 0;
    const random = () => (
      // eslint-disable-next-line no-bitwise
      `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
    );
    return () => {
      counter += 1;
      return `u${random()}${counter}`;
    };
  })();
  function toArray(arrayLike) {
    const arr = [];
    for (let i2 = 0, l2 = arrayLike.length; i2 < l2; i2++) {
      arr.push(arrayLike[i2]);
    }
    return arr;
  }
  function px(node, styleProperty) {
    const win = node.ownerDocument.defaultView || window;
    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
    return val ? parseFloat(val.replace("px", "")) : 0;
  }
  function getNodeWidth(node) {
    const leftBorder = px(node, "border-left-width");
    const rightBorder = px(node, "border-right-width");
    return node.clientWidth + leftBorder + rightBorder;
  }
  function getNodeHeight(node) {
    const topBorder = px(node, "border-top-width");
    const bottomBorder = px(node, "border-bottom-width");
    return node.clientHeight + topBorder + bottomBorder;
  }
  function getImageSize(targetNode, options = {}) {
    const width = options.width || getNodeWidth(targetNode);
    const height = options.height || getNodeHeight(targetNode);
    return { width, height };
  }
  function getPixelRatio() {
    let ratio;
    let FINAL_PROCESS;
    try {
      FINAL_PROCESS = process;
    } catch (e) {
    }
    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
    if (val) {
      ratio = parseInt(val, 10);
      if (Number.isNaN(ratio)) {
        ratio = 1;
      }
    }
    return ratio || window.devicePixelRatio || 1;
  }
  const canvasDimensionLimit = 16384;
  function checkCanvasDimensions(canvas) {
    if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
        if (canvas.width > canvas.height) {
          canvas.height *= canvasDimensionLimit / canvas.width;
          canvas.width = canvasDimensionLimit;
        } else {
          canvas.width *= canvasDimensionLimit / canvas.height;
          canvas.height = canvasDimensionLimit;
        }
      } else if (canvas.width > canvasDimensionLimit) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    }
  }
  function createImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.decode = () => resolve(img);
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.src = url;
    });
  }
  async function svgToDataURL(svg) {
    return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
  }
  async function nodeToDataURL(node, width, height) {
    const xmlns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(xmlns, "svg");
    const foreignObject = document.createElementNS(xmlns, "foreignObject");
    svg.setAttribute("width", `${width}`);
    svg.setAttribute("height", `${height}`);
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    foreignObject.setAttribute("width", "100%");
    foreignObject.setAttribute("height", "100%");
    foreignObject.setAttribute("x", "0");
    foreignObject.setAttribute("y", "0");
    foreignObject.setAttribute("externalResourcesRequired", "true");
    svg.appendChild(foreignObject);
    foreignObject.appendChild(node);
    return svgToDataURL(svg);
  }
  const isInstanceOfElement = (node, instance) => {
    if (node instanceof instance)
      return true;
    const nodePrototype = Object.getPrototypeOf(node);
    if (nodePrototype === null)
      return false;
    return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
  };
  function formatCSSText(style) {
    const content = style.getPropertyValue("content");
    return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
  }
  function formatCSSProperties(style) {
    return toArray(style).map((name) => {
      const value = style.getPropertyValue(name);
      const priority = style.getPropertyPriority(name);
      return `${name}: ${value}${priority ? " !important" : ""};`;
    }).join(" ");
  }
  function getPseudoElementStyle(className, pseudo, style) {
    const selector = `.${className}:${pseudo}`;
    const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);
    return document.createTextNode(`${selector}{${cssText}}`);
  }
  function clonePseudoElement(nativeNode, clonedNode, pseudo) {
    const style = window.getComputedStyle(nativeNode, pseudo);
    const content = style.getPropertyValue("content");
    if (content === "" || content === "none") {
      return;
    }
    const className = uuid();
    try {
      clonedNode.className = `${clonedNode.className} ${className}`;
    } catch (err) {
      return;
    }
    const styleElement = document.createElement("style");
    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
    clonedNode.appendChild(styleElement);
  }
  function clonePseudoElements(nativeNode, clonedNode) {
    clonePseudoElement(nativeNode, clonedNode, ":before");
    clonePseudoElement(nativeNode, clonedNode, ":after");
  }
  const WOFF = "application/font-woff";
  const JPEG = "image/jpeg";
  const mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: "application/font-truetype",
    eot: "application/vnd.ms-fontobject",
    png: "image/png",
    jpg: JPEG,
    jpeg: JPEG,
    gif: "image/gif",
    tiff: "image/tiff",
    svg: "image/svg+xml",
    webp: "image/webp"
  };
  function getExtension(url) {
    const match = /\.([^./]*?)$/g.exec(url);
    return match ? match[1] : "";
  }
  function getMimeType(url) {
    const extension = getExtension(url).toLowerCase();
    return mimes[extension] || "";
  }
  function getContentFromDataUrl(dataURL) {
    return dataURL.split(/,/)[1];
  }
  function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
  }
  function makeDataUrl(content, mimeType) {
    return `data:${mimeType};base64,${content}`;
  }
  async function fetchAsDataURL(url, init2, process2) {
    const res = await fetch(url, init2);
    if (res.status === 404) {
      throw new Error(`Resource "${res.url}" not found`);
    }
    const blob = await res.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = reject;
      reader.onloadend = () => {
        try {
          resolve(process2({ res, result: reader.result }));
        } catch (error) {
          reject(error);
        }
      };
      reader.readAsDataURL(blob);
    });
  }
  const cache = {};
  function getCacheKey(url, contentType, includeQueryParams) {
    let key = url.replace(/\?.*/, "");
    if (includeQueryParams) {
      key = url;
    }
    if (/ttf|otf|eot|woff2?/i.test(key)) {
      key = key.replace(/.*\//, "");
    }
    return contentType ? `[${contentType}]${key}` : key;
  }
  async function resourceToDataURL(resourceUrl, contentType, options) {
    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
    if (cache[cacheKey] != null) {
      return cache[cacheKey];
    }
    if (options.cacheBust) {
      resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
    }
    let dataURL;
    try {
      const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result: result2 }) => {
        if (!contentType) {
          contentType = res.headers.get("Content-Type") || "";
        }
        return getContentFromDataUrl(result2);
      });
      dataURL = makeDataUrl(content, contentType);
    } catch (error) {
      dataURL = options.imagePlaceholder || "";
      let msg = `Failed to fetch resource: ${resourceUrl}`;
      if (error) {
        msg = typeof error === "string" ? error : error.message;
      }
      if (msg) {
        console.warn(msg);
      }
    }
    cache[cacheKey] = dataURL;
    return dataURL;
  }
  async function cloneCanvasElement(canvas) {
    const dataURL = canvas.toDataURL();
    if (dataURL === "data:,") {
      return canvas.cloneNode(false);
    }
    return createImage(dataURL);
  }
  async function cloneVideoElement(video, options) {
    if (video.currentSrc) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = video.clientWidth;
      canvas.height = video.clientHeight;
      ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const dataURL2 = canvas.toDataURL();
      return createImage(dataURL2);
    }
    const poster = video.poster;
    const contentType = getMimeType(poster);
    const dataURL = await resourceToDataURL(poster, contentType, options);
    return createImage(dataURL);
  }
  async function cloneIFrameElement(iframe) {
    var _a2;
    try {
      if ((_a2 = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body) {
        return await cloneNode(iframe.contentDocument.body, {}, true);
      }
    } catch (_b2) {
    }
    return iframe.cloneNode(false);
  }
  async function cloneSingleNode(node, options) {
    if (isInstanceOfElement(node, HTMLCanvasElement)) {
      return cloneCanvasElement(node);
    }
    if (isInstanceOfElement(node, HTMLVideoElement)) {
      return cloneVideoElement(node, options);
    }
    if (isInstanceOfElement(node, HTMLIFrameElement)) {
      return cloneIFrameElement(node);
    }
    return node.cloneNode(false);
  }
  const isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
  async function cloneChildren(nativeNode, clonedNode, options) {
    var _a2, _b2;
    let children = [];
    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
      children = toArray(nativeNode.assignedNodes());
    } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a2 = nativeNode.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body)) {
      children = toArray(nativeNode.contentDocument.body.childNodes);
    } else {
      children = toArray(((_b2 = nativeNode.shadowRoot) !== null && _b2 !== void 0 ? _b2 : nativeNode).childNodes);
    }
    if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
      return clonedNode;
    }
    await children.reduce((deferred, child2) => deferred.then(() => cloneNode(child2, options)).then((clonedChild) => {
      if (clonedChild) {
        clonedNode.appendChild(clonedChild);
      }
    }), Promise.resolve());
    return clonedNode;
  }
  function cloneCSSStyle(nativeNode, clonedNode) {
    const targetStyle = clonedNode.style;
    if (!targetStyle) {
      return;
    }
    const sourceStyle = window.getComputedStyle(nativeNode);
    if (sourceStyle.cssText) {
      targetStyle.cssText = sourceStyle.cssText;
      targetStyle.transformOrigin = sourceStyle.transformOrigin;
    } else {
      toArray(sourceStyle).forEach((name) => {
        let value = sourceStyle.getPropertyValue(name);
        if (name === "font-size" && value.endsWith("px")) {
          const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
          value = `${reducedFont}px`;
        }
        if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
          value = "block";
        }
        if (name === "d" && clonedNode.getAttribute("d")) {
          value = `path(${clonedNode.getAttribute("d")})`;
        }
        targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
      });
    }
  }
  function cloneInputValue(nativeNode, clonedNode) {
    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
      clonedNode.innerHTML = nativeNode.value;
    }
    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
      clonedNode.setAttribute("value", nativeNode.value);
    }
  }
  function cloneSelectValue(nativeNode, clonedNode) {
    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
      const clonedSelect = clonedNode;
      const selectedOption = Array.from(clonedSelect.children).find((child2) => nativeNode.value === child2.getAttribute("value"));
      if (selectedOption) {
        selectedOption.setAttribute("selected", "");
      }
    }
  }
  function decorate(nativeNode, clonedNode) {
    if (isInstanceOfElement(clonedNode, Element)) {
      cloneCSSStyle(nativeNode, clonedNode);
      clonePseudoElements(nativeNode, clonedNode);
      cloneInputValue(nativeNode, clonedNode);
      cloneSelectValue(nativeNode, clonedNode);
    }
    return clonedNode;
  }
  async function ensureSVGSymbols(clone, options) {
    const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
    if (uses.length === 0) {
      return clone;
    }
    const processedDefs = {};
    for (let i2 = 0; i2 < uses.length; i2++) {
      const use = uses[i2];
      const id = use.getAttribute("xlink:href");
      if (id) {
        const exist = clone.querySelector(id);
        const definition2 = document.querySelector(id);
        if (!exist && definition2 && !processedDefs[id]) {
          processedDefs[id] = await cloneNode(definition2, options, true);
        }
      }
    }
    const nodes = Object.values(processedDefs);
    if (nodes.length) {
      const ns = "http://www.w3.org/1999/xhtml";
      const svg = document.createElementNS(ns, "svg");
      svg.setAttribute("xmlns", ns);
      svg.style.position = "absolute";
      svg.style.width = "0";
      svg.style.height = "0";
      svg.style.overflow = "hidden";
      svg.style.display = "none";
      const defs = document.createElementNS(ns, "defs");
      svg.appendChild(defs);
      for (let i2 = 0; i2 < nodes.length; i2++) {
        defs.appendChild(nodes[i2]);
      }
      clone.appendChild(svg);
    }
    return clone;
  }
  async function cloneNode(node, options, isRoot) {
    if (!isRoot && options.filter && !options.filter(node)) {
      return null;
    }
    return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
  }
  const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
  const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
  const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
  function toRegex(url) {
    const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
    return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
  }
  function parseURLs(cssText) {
    const urls = [];
    cssText.replace(URL_REGEX, (raw, quotation, url) => {
      urls.push(url);
      return raw;
    });
    return urls.filter((url) => !isDataUrl(url));
  }
  async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
    try {
      const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
      const contentType = getMimeType(resourceURL);
      let dataURL;
      if (getContentFromUrl) ;
      else {
        dataURL = await resourceToDataURL(resolvedURL, contentType, options);
      }
      return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
    } catch (error) {
    }
    return cssText;
  }
  function filterPreferredFontFormat(str, { preferredFontFormat }) {
    return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match) => {
      while (true) {
        const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
        if (!format) {
          return "";
        }
        if (format === preferredFontFormat) {
          return `src: ${src};`;
        }
      }
    });
  }
  function shouldEmbed(url) {
    return url.search(URL_REGEX) !== -1;
  }
  async function embedResources(cssText, baseUrl, options) {
    if (!shouldEmbed(cssText)) {
      return cssText;
    }
    const filteredCSSText = filterPreferredFontFormat(cssText, options);
    const urls = parseURLs(filteredCSSText);
    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
  }
  async function embedProp(propName, node, options) {
    var _a2;
    const propValue = (_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.getPropertyValue(propName);
    if (propValue) {
      const cssString = await embedResources(propValue, null, options);
      node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
      return true;
    }
    return false;
  }
  async function embedBackground(clonedNode, options) {
    if (!await embedProp("background", clonedNode, options)) {
      await embedProp("background-image", clonedNode, options);
    }
    if (!await embedProp("mask", clonedNode, options)) {
      await embedProp("mask-image", clonedNode, options);
    }
  }
  async function embedImageNode(clonedNode, options) {
    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
    if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
      return;
    }
    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
    const dataURL = await resourceToDataURL(url, getMimeType(url), options);
    await new Promise((resolve, reject) => {
      clonedNode.onload = resolve;
      clonedNode.onerror = reject;
      const image = clonedNode;
      if (image.decode) {
        image.decode = resolve;
      }
      if (image.loading === "lazy") {
        image.loading = "eager";
      }
      if (isImageElement) {
        clonedNode.srcset = "";
        clonedNode.src = dataURL;
      } else {
        clonedNode.href.baseVal = dataURL;
      }
    });
  }
  async function embedChildren(clonedNode, options) {
    const children = toArray(clonedNode.childNodes);
    const deferreds = children.map((child2) => embedImages(child2, options));
    await Promise.all(deferreds).then(() => clonedNode);
  }
  async function embedImages(clonedNode, options) {
    if (isInstanceOfElement(clonedNode, Element)) {
      await embedBackground(clonedNode, options);
      await embedImageNode(clonedNode, options);
      await embedChildren(clonedNode, options);
    }
  }
  function applyStyle(node, options) {
    const { style } = node;
    if (options.backgroundColor) {
      style.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
      style.width = `${options.width}px`;
    }
    if (options.height) {
      style.height = `${options.height}px`;
    }
    const manual = options.style;
    if (manual != null) {
      Object.keys(manual).forEach((key) => {
        style[key] = manual[key];
      });
    }
    return node;
  }
  const cssFetchCache = {};
  async function fetchCSS(url) {
    let cache2 = cssFetchCache[url];
    if (cache2 != null) {
      return cache2;
    }
    const res = await fetch(url);
    const cssText = await res.text();
    cache2 = { url, cssText };
    cssFetchCache[url] = cache2;
    return cache2;
  }
  async function embedFonts(data, options) {
    let cssText = data.cssText;
    const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
    const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
    const loadFonts = fontLocs.map(async (loc) => {
      let url = loc.replace(regexUrl, "$1");
      if (!url.startsWith("https://")) {
        url = new URL(url, data.url).href;
      }
      return fetchAsDataURL(url, options.fetchRequestInit, ({ result: result2 }) => {
        cssText = cssText.replace(loc, `url(${result2})`);
        return [loc, result2];
      });
    });
    return Promise.all(loadFonts).then(() => cssText);
  }
  function parseCSS(source2) {
    if (source2 == null) {
      return [];
    }
    const result2 = [];
    const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
    let cssText = source2.replace(commentsRegex, "");
    const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
    while (true) {
      const matches = keyframesRegex.exec(cssText);
      if (matches === null) {
        break;
      }
      result2.push(matches[0]);
    }
    cssText = cssText.replace(keyframesRegex, "");
    const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
    const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
    const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
    while (true) {
      let matches = importRegex.exec(cssText);
      if (matches === null) {
        matches = unifiedRegex.exec(cssText);
        if (matches === null) {
          break;
        } else {
          importRegex.lastIndex = unifiedRegex.lastIndex;
        }
      } else {
        unifiedRegex.lastIndex = importRegex.lastIndex;
      }
      result2.push(matches[0]);
    }
    return result2;
  }
  async function getCSSRules(styleSheets, options) {
    const ret = [];
    const deferreds = [];
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray(sheet.cssRules || []).forEach((item, index2) => {
            if (item.type === CSSRule.IMPORT_RULE) {
              let importIndex = index2 + 1;
              const url = item.href;
              const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
                try {
                  sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
                } catch (error) {
                  console.error("Error inserting rule from remote css", {
                    rule,
                    error
                  });
                }
              })).catch((e) => {
                console.error("Error loading remote css", e.toString());
              });
              deferreds.push(deferred);
            }
          });
        } catch (e) {
          const inline = styleSheets.find((a2) => a2.href == null) || document.styleSheets[0];
          if (sheet.href != null) {
            deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              inline.insertRule(rule, sheet.cssRules.length);
            })).catch((err) => {
              console.error("Error loading remote stylesheet", err);
            }));
          }
          console.error("Error inlining remote css file", e);
        }
      }
    });
    return Promise.all(deferreds).then(() => {
      styleSheets.forEach((sheet) => {
        if ("cssRules" in sheet) {
          try {
            toArray(sheet.cssRules || []).forEach((item) => {
              ret.push(item);
            });
          } catch (e) {
            console.error(`Error while reading CSS rules from ${sheet.href}`, e);
          }
        }
      });
      return ret;
    });
  }
  function getWebFontRules(cssRules) {
    return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
  }
  async function parseWebFontRules(node, options) {
    if (node.ownerDocument == null) {
      throw new Error("Provided element is not within a Document");
    }
    const styleSheets = toArray(node.ownerDocument.styleSheets);
    const cssRules = await getCSSRules(styleSheets, options);
    return getWebFontRules(cssRules);
  }
  async function getWebFontCSS(node, options) {
    const rules = await parseWebFontRules(node, options);
    const cssTexts = await Promise.all(rules.map((rule) => {
      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
      return embedResources(rule.cssText, baseUrl, options);
    }));
    return cssTexts.join("\n");
  }
  async function embedWebFonts(clonedNode, options) {
    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
    if (cssText) {
      const styleNode = document.createElement("style");
      const sytleContent = document.createTextNode(cssText);
      styleNode.appendChild(sytleContent);
      if (clonedNode.firstChild) {
        clonedNode.insertBefore(styleNode, clonedNode.firstChild);
      } else {
        clonedNode.appendChild(styleNode);
      }
    }
  }
  async function toSvg(node, options = {}) {
    const { width, height } = getImageSize(node, options);
    const clonedNode = await cloneNode(node, options, true);
    await embedWebFonts(clonedNode, options);
    await embedImages(clonedNode, options);
    applyStyle(clonedNode, options);
    const datauri = await nodeToDataURL(clonedNode, width, height);
    return datauri;
  }
  async function toCanvas(node, options = {}) {
    const { width, height } = getImageSize(node, options);
    const svg = await toSvg(node, options);
    const img = await createImage(svg);
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const ratio = options.pixelRatio || getPixelRatio();
    const canvasWidth = options.canvasWidth || width;
    const canvasHeight = options.canvasHeight || height;
    canvas.width = canvasWidth * ratio;
    canvas.height = canvasHeight * ratio;
    if (!options.skipAutoScale) {
      checkCanvasDimensions(canvas);
    }
    canvas.style.width = `${canvasWidth}`;
    canvas.style.height = `${canvasHeight}`;
    if (options.backgroundColor) {
      context.fillStyle = options.backgroundColor;
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    context.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas;
  }
  async function toPng(node, options = {}) {
    const canvas = await toCanvas(node, options);
    return canvas.toDataURL();
  }
  mark_module_start();
  Study_table[FILENAME] = "src/lib/components/study-table.svelte";
  var root_4 = add_locations(/* @__PURE__ */ template(`<td class="w-[2.08333%] py-1"></td>`), Study_table[FILENAME], [[168, 8]]);
  var root_5 = add_locations(/* @__PURE__ */ template(`<td><div><p class="absolute top-1 text-xs"> </p> <p class="flex h-full items-center justify-center px-1"> </p> <p class="absolute bottom-1 text-xs"> </p> <p class="absolute bottom-1 right-1 text-xs"> </p></div></td>`), Study_table[FILENAME], [
    [
      170,
      8,
      [
        [
          171,
          9,
          [
            [177, 10],
            [181, 10],
            [184, 10],
            [187, 10]
          ]
        ]
      ]
    ]
  ]);
  var root_2 = add_locations(/* @__PURE__ */ template(`<tr class="h-[14.28571%] hover:bg-slate-100"><td class="p-1"> </td><!></tr>`), Study_table[FILENAME], [[164, 5, [[165, 6]]]]);
  var root_1 = add_locations(/* @__PURE__ */ template(`<div class="flex w-full flex-col justify-center p-5 shadow"><div class="w-full rounded-t-lg p-4 text-white"><p class="text-center"> </p> <p class="text-center"> </p> <p class="text-center"> </p> <p class="text-center"> </p></div> <table class="h-screen w-full rounded-b-lg bg-white shadow"><thead><tr><th class="p-1 font-light"></th><th class="p-1 font-light" colspan="4">08:00 - 09:00</th><th class="p-1 font-light" colspan="4">09:00 - 10:00</th><th class="p-1 font-light" colspan="4">10:00 - 11:00</th><th class="p-1 font-light" colspan="4">11:00 - 12:00</th><th class="p-1 font-light" colspan="4">12:00 - 13:00</th><th class="p-1 font-light" colspan="4">13:00 - 14:00</th><th class="p-1 font-light" colspan="4">14:00 - 15:00</th><th class="p-1 font-light" colspan="4">15:00 - 16:00</th><th class="p-1 font-light" colspan="4">16:00 - 17:00</th><th class="p-1 font-light" colspan="4">17:00 - 18:00</th><th class="p-1 font-light" colspan="4">18:00 - 19:00</th><th class="p-1 font-light" colspan="4">19:00 - 20:00</th></tr></thead><tbody></tbody></table></div>`), Study_table[FILENAME], [
    [
      137,
      1,
      [
        [
          138,
          2,
          [
            [139, 3],
            [140, 3],
            [141, 3],
            [142, 3]
          ]
        ],
        [
          144,
          2,
          [
            [
              145,
              3,
              [
                [
                  146,
                  4,
                  [
                    [147, 5],
                    [148, 5],
                    [149, 5],
                    [150, 5],
                    [151, 5],
                    [152, 5],
                    [153, 5],
                    [154, 5],
                    [155, 5],
                    [156, 5],
                    [157, 5],
                    [158, 5],
                    [159, 5]
                  ]
                ]
              ]
            ],
            [162, 3]
          ]
        ]
      ]
    ]
  ]);
  var root_6 = add_locations(/* @__PURE__ */ template(`<div></div>`), Study_table[FILENAME], [[200, 1]]);
  var root_9 = add_locations(/* @__PURE__ */ template(`<div class="flex items-center gap-2"><div class="relative flex flex-col gap-2"><p class="text-sm"> </p> <div class="flex gap-2"><div><input type="color" class="absolute h-5 w-5 opacity-0"> <div></div></div> <p class="text-sm">Background Color</p></div></div></div>`), Study_table[FILENAME], [
    [
      232,
      7,
      [
        [
          233,
          8,
          [
            [234, 9],
            [
              235,
              9,
              [
                [
                  236,
                  10,
                  [[237, 11], [242, 11]]
                ],
                [249, 10]
              ]
            ]
          ]
        ]
      ]
    ]
  ]);
  var root_8 = add_locations(/* @__PURE__ */ template(`<div class="absolute bottom-[110%] right-0 flex h-56 w-96 flex-col gap-2 overflow-y-auto rounded-lg border bg-white p-4 shadow"><div class="flex flex-col gap-2"><p class="text-sm">Theme</p> <div class="flex items-center gap-2"><div class="relative flex flex-col gap-2"><p class="text-sm">Header</p> <div class="flex gap-2"><div><input type="color" class="absolute h-5 w-5 opacity-0"> <div></div></div> <p class="text-sm">Background Color</p></div></div></div> <!> <button class=" flex cursor-pointer items-center justify-center rounded-lg bg-orange-500 p-2 text-white transition-all hover:bg-orange-600 active:bg-orange-400">Reset Theme</button></div></div>`), Study_table[FILENAME], [
    [
      207,
      4,
      [
        [
          210,
          5,
          [
            [211, 6],
            [
              212,
              6,
              [
                [
                  213,
                  7,
                  [
                    [214, 8],
                    [
                      215,
                      8,
                      [
                        [
                          216,
                          9,
                          [[217, 10], [222, 10]]
                        ],
                        [227, 9]
                      ]
                    ]
                  ]
                ]
              ]
            ],
            [254, 6]
          ]
        ]
      ]
    ]
  ]);
  var root_7 = add_locations(/* @__PURE__ */ template(`<div class="relative"><!> <button class=" flex cursor-pointer items-center justify-center rounded-full bg-orange-500 p-2 text-white transition-all hover:bg-orange-600 active:bg-orange-400" aria-label="customize"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125"></path></svg></button></div>`), Study_table[FILENAME], [
    [
      205,
      2,
      [
        [
          265,
          3,
          [[272, 4, [[280, 5]]]]
        ]
      ]
    ]
  ]);
  var root_10 = add_locations(/* @__PURE__ */ template(`<button class=" flex cursor-pointer items-center justify-center rounded-full bg-orange-500 p-2 text-white transition-all hover:bg-orange-600 active:bg-orange-400" aria-label="download"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"></path></svg></button>`), Study_table[FILENAME], [
    [
      290,
      2,
      [[295, 3, [[303, 4]]]]
    ]
  ]);
  var root = add_locations(/* @__PURE__ */ template(`<!> <div class="fixed bottom-3 right-3 flex gap-2"><!> <!> <button class=" flex cursor-pointer items-center justify-center rounded-full bg-orange-500 p-2 text-white transition-all hover:bg-orange-600 active:bg-orange-400"> </button> <!></div>`, 1), Study_table[FILENAME], [[203, 0, [[311, 1]]]]);
  function Study_table($$anchor, $$props) {
    check_target(new.target);
    push($$props, false, Study_table);
    let schedule = prop($$props, "schedule", 24, () => []);
    let oldTable = prop($$props, "oldTable", 12);
    let faculty = prop($$props, "faculty", 8, "");
    let department = prop($$props, "department", 8, "");
    let major = prop($$props, "major", 8, "");
    let semester = prop($$props, "semester", 8, "");
    let year = prop($$props, "year", 8, "");
    let studentId = prop($$props, "studentId", 8, "");
    let studentName = prop($$props, "studentName", 8, "");
    const englishDays = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    let newTableContainer = mutable_state();
    let mode = mutable_state("new");
    const download = async () => {
      const dataUrl = await toPng(get$2(newTableContainer));
      const link2 = document.createElement("a");
      link2.download = "image.png";
      link2.href = dataUrl;
      link2.click();
    };
    const color = [
      "#ef4444",
      "#f97316",
      "#f59e0b",
      "#eab308",
      "#84cc16",
      "#22c55e",
      "#10b981",
      "#14b8a6",
      "#06b6d4",
      "#0ea5e9",
      "#3b82f6",
      "#6366f1",
      "#8b5cf6",
      "#a855f7",
      "#d946ef",
      "#ec4899",
      "#f43f5e"
    ];
    const makeTheme = () => {
      let theme2 = [];
      let usedColor = [];
      schedule().forEach((item) => {
        let themeColor = color[Math.floor(Math.random() * color.length)];
        while (usedColor.includes(themeColor)) {
          themeColor = color[Math.floor(Math.random() * color.length)];
        }
        const isAlready = theme2.find((t) => strict_equals(item.subjectId, t.subjectId));
        if (isAlready) {
          return;
        }
        theme2.push({
          subjectId: item.subjectId,
          subjectName: item.subjectName,
          color: themeColor
        });
        usedColor.push(themeColor);
      });
      return theme2;
    };
    let theme = mutable_state(makeTheme());
    const getTheme = (subjectId) => {
      const filtered = get$2(theme).filter((item) => strict_equals(item.subjectId, subjectId));
      if (filtered.length > 0) {
        return filtered[0].color;
      } else {
        return false;
      }
    };
    const createTimeSlot = (dayIndex) => {
      const filtered = schedule().filter((item) => strict_equals(item.day, dayIndex));
      const timeSlots = [];
      for (let index2 = 0; index2 < 12 * 4; index2++) {
        timeSlots.push(void 0);
      }
      filtered.forEach((item, index2) => {
        const start = item.start.split(":");
        const end = item.end.split(":");
        const startHour = parseInt(start[0]);
        const startMinute = parseInt(start[1]);
        const endHour = parseInt(end[0]);
        const endMinute = parseInt(end[1]);
        const startSlot = (startHour - 8) * 4 + Math.floor(startMinute / 15);
        const endSlot = (endHour - 8) * 4 + Math.floor(endMinute / 15);
        for (let i2 = startSlot; i2 < endSlot; i2++) {
          timeSlots[i2] = {
            subjectName: item.subjectName,
            subjectIndex: index2,
            colspan: endSlot - startSlot,
            color: color[Math.floor(Math.random() * color.length)],
            info: item
          };
        }
      });
      const final = [];
      timeSlots.forEach((item) => {
        var _a2;
        if (strict_equals(item, void 0)) {
          final.push(void 0);
        } else if (strict_equals(final[final.length - 1], void 0, false)) {
          if (strict_equals((_a2 = final[final.length - 1]) == null ? void 0 : _a2.subjectIndex, item.subjectIndex, false)) {
            final.push(item);
          }
        } else {
          final.push(item);
        }
      });
      return final;
    };
    let customizeMenu = mutable_state(false);
    let headerColor = mutable_state("#f97316");
    init();
    var fragment = root();
    var node = first_child(fragment);
    {
      var consequent_1 = ($$anchor2) => {
        var div = root_1();
        var div_1 = child(div);
        var p2 = child(div_1);
        var text2 = child(p2);
        var p_1 = sibling(p2, 2);
        var text_1 = child(p_1);
        var p_2 = sibling(p_1, 2);
        var text_2 = child(p_2);
        var p_3 = sibling(p_2, 2);
        var text_3 = child(p_3);
        var table = sibling(div_1, 2);
        var tbody = sibling(child(table));
        each(tbody, 5, () => englishDays, index, ($$anchor3, dayLabel, index$1) => {
          var tr = root_2();
          var td = child(tr);
          var text_4 = child(td);
          var node_1 = sibling(td);
          each(node_1, 1, () => createTimeSlot(index$1), index, ($$anchor4, timeSlot) => {
            var fragment_1 = comment();
            var node_2 = first_child(fragment_1);
            {
              var consequent = ($$anchor5) => {
                var td_1 = root_4();
                append($$anchor5, td_1);
              };
              var alternate = ($$anchor5) => {
                var td_2 = root_5();
                set_class(td_2, `w-[2.08333%] px-0 py-1 text-white`);
                var div_2 = child(td_2);
                set_class(div_2, `relative h-full w-full rounded p-1`);
                const style_derived = /* @__PURE__ */ derived_safe_equal(() => `background-color: ${get$2(theme) ? `${getTheme(get$2(timeSlot).info.subjectId)}` : "#64748b"}`);
                var p_4 = child(div_2);
                var text_5 = child(p_4);
                var p_5 = sibling(p_4, 2);
                var text_6 = child(p_5);
                var p_6 = sibling(p_5, 2);
                var text_7 = child(p_6);
                var p_7 = sibling(p_6, 2);
                var text_8 = child(p_7);
                template_effect(() => {
                  set_attribute(td_2, "colspan", get$2(timeSlot).colspan);
                  set_attribute(div_2, "style", get$2(style_derived));
                  set_text(text_5, `${(get$2(timeSlot).info.building ? get$2(timeSlot).info.building : "") ?? ""}
											${(get$2(timeSlot).info.room ? get$2(timeSlot).info.room : "") ?? ""}`);
                  set_text(text_6, get$2(timeSlot).subjectName);
                  set_text(text_7, `Section ${get$2(timeSlot).info.sec ?? ""} (${get$2(timeSlot).info.type ?? ""})`);
                  set_text(text_8, `${get$2(timeSlot).info.start ?? ""} - ${get$2(timeSlot).info.end ?? ""}`);
                });
                append($$anchor5, td_2);
              };
              if_block(node_2, ($$render) => {
                if (strict_equals(get$2(timeSlot), void 0)) $$render(consequent);
                else $$render(alternate, false);
              });
            }
            append($$anchor4, fragment_1);
          });
          template_effect(() => set_text(text_4, get$2(dayLabel)));
          append($$anchor3, tr);
        });
        bind_this(div, ($$value) => set(newTableContainer, $$value), () => get$2(newTableContainer));
        template_effect(() => {
          set_attribute(div_1, "style", `background-color: ${get$2(headerColor) ?? ""};`);
          set_text(text2, faculty());
          set_text(text_1, `${department() ?? ""} ${major() ?? ""}`);
          set_text(text_2, `${semester() ?? ""} ${year() ?? ""}`);
          set_text(text_3, `${studentId() ?? ""} ${studentName() ?? ""}`);
        });
        append($$anchor2, div);
      };
      var alternate_1 = ($$anchor2) => {
        var div_3 = root_6();
        bind_this(div_3, ($$value) => oldTable($$value), () => oldTable());
        append($$anchor2, div_3);
      };
      if_block(node, ($$render) => {
        if (equals(get$2(mode), "new")) $$render(consequent_1);
        else $$render(alternate_1, false);
      });
    }
    var div_4 = sibling(node, 2);
    var node_3 = child(div_4);
    {
      var consequent_3 = ($$anchor2) => {
        var div_5 = root_7();
        var node_4 = child(div_5);
        {
          var consequent_2 = ($$anchor3) => {
            var div_6 = root_8();
            var div_7 = child(div_6);
            var div_8 = sibling(child(div_7), 2);
            var div_9 = child(div_8);
            var div_10 = sibling(child(div_9), 2);
            var div_11 = child(div_10);
            var input = child(div_11);
            var div_12 = sibling(input, 2);
            set_class(div_12, `h-5 w-5 rounded-full`);
            var node_5 = sibling(div_8, 2);
            each(node_5, 1, () => get$2(theme), index, ($$anchor4, item, $$index_2) => {
              var div_13 = root_9();
              var div_14 = child(div_13);
              var p_8 = child(div_14);
              var text_9 = child(p_8);
              var div_15 = sibling(p_8, 2);
              var div_16 = child(div_15);
              var input_1 = child(div_16);
              var div_17 = sibling(input_1, 2);
              set_class(div_17, `h-5 w-5 rounded-full`);
              const style_derived_1 = /* @__PURE__ */ derived_safe_equal(() => `background-color: ${get$2(theme) ? `${getTheme(get$2(item).subjectId)}` : "#64748b"}`);
              template_effect(() => {
                set_text(text_9, get$2(item).subjectName);
                set_attribute(div_17, "style", get$2(style_derived_1));
              });
              bind_value(input_1, () => get$2(item).color, ($$value) => (get$2(item).color = $$value, invalidate_inner_signals(() => get$2(theme))));
              append($$anchor4, div_13);
            });
            var button = sibling(node_5, 2);
            template_effect(() => set_attribute(div_12, "style", `background-color: ${get$2(headerColor)}`));
            bind_value(input, () => get$2(headerColor), ($$value) => set(headerColor, $$value));
            event("click", button, () => {
              set(theme, makeTheme());
              set(headerColor, "#f97316");
            });
            append($$anchor3, div_6);
          };
          if_block(node_4, ($$render) => {
            if (get$2(customizeMenu)) $$render(consequent_2);
          });
        }
        var button_1 = sibling(node_4, 2);
        event("click", button_1, () => {
          set(customizeMenu, !get$2(customizeMenu));
        });
        append($$anchor2, div_5);
      };
      if_block(node_3, ($$render) => {
        if (equals(get$2(mode), "new")) $$render(consequent_3);
      });
    }
    var node_6 = sibling(node_3, 2);
    {
      var consequent_4 = ($$anchor2) => {
        var button_2 = root_10();
        event("click", button_2, download);
        append($$anchor2, button_2);
      };
      if_block(node_6, ($$render) => {
        if (equals(get$2(mode), "new")) $$render(consequent_4);
      });
    }
    var button_3 = sibling(node_6, 2);
    var text_10 = child(button_3);
    var node_7 = sibling(button_3, 2);
    Generate(node_7, {
      get schedule() {
        return schedule();
      }
    });
    template_effect(() => set_text(text_10, equals(get$2(mode), "new") ? "Old Design" : "New Design"));
    event("click", button_3, () => {
      set(mode, equals(get$2(mode), "new") ? "old" : "new");
    });
    append($$anchor, fragment);
    return pop({ ...legacy_api() });
  }
  mark_module_end(Study_table);
  function getinfo(rawTable) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h;
    const table = rawTable.querySelectorAll("tbody")[1];
    const facultyName = ((_b2 = (_a2 = table.childNodes[6]) == null ? void 0 : _a2.textContent) == null ? void 0 : _b2.trim()) || constants.messages.scrapeError;
    const departmentSubject = ((_d = (_c = table.childNodes[10]) == null ? void 0 : _c.textContent) == null ? void 0 : _d.trim().split("   ")) || constants.messages.scrapeError;
    const departmentTerm = ((_f = (_e = table.childNodes[14]) == null ? void 0 : _e.textContent) == null ? void 0 : _f.trim().split("   ")) || constants.messages.scrapeError;
    const studentName = ((_h = (_g = table.childNodes[18]) == null ? void 0 : _g.textContent) == null ? void 0 : _h.trim().split("   ")) || constants.messages.scrapeError;
    return {
      facultyName,
      department: departmentSubject[0].trim(),
      major: departmentSubject[1].trim(),
      semester: departmentTerm[0].trim(),
      year: departmentTerm[1].trim(),
      studentId: studentName[0].trim(),
      studentName: studentName[1].trim()
    };
  }
  function scrapeTable(rawTable) {
    const studyTableRows = rawTable.querySelectorAll("tr");
    const studyTableRowsArray = Array.from(studyTableRows).filter((item) => {
      return item.childNodes.length == 37;
    }).splice(1);
    const scrapedData = [];
    studyTableRowsArray.forEach((item) => {
      const subjectId = item.childNodes[5].textContent || constants.messages.scrapeError;
      const subjectName = item.childNodes[9].textContent || constants.messages.scrapeError;
      const subjectCredits = item.childNodes[13].textContent || constants.messages.scrapeError;
      const roomInfo = item.childNodes[29];
      const room = [];
      roomInfo.childNodes.forEach((item2) => {
        if (item2.textContent) {
          room.push(item2.textContent);
        }
      });
      const lectureRoom = room[0];
      const labRoom = room[1];
      const buildingInfo = item.childNodes[33];
      const building = [];
      buildingInfo.childNodes.forEach((item2) => {
        if (item2.textContent) {
          building.push(item2.textContent);
        }
      });
      const lectureBuilding = building[0];
      const labBuilding = building[1];
      const subjectLecture = {
        building: lectureBuilding,
        room: lectureRoom,
        sec: item.childNodes[17].textContent || constants.messages.scrapeError,
        periods: []
      };
      const subjectLab = {
        building: labBuilding,
        room: labRoom,
        sec: item.childNodes[21].textContent || constants.messages.scrapeError,
        periods: []
      };
      const subjectDescription = item.childNodes[35].textContent || constants.messages.scrapeError;
      const subjectPeriod = item.childNodes[25];
      subjectPeriod.childNodes.forEach((item2) => {
        if (!item2.textContent) return;
        console.log(item2.textContent);
        const splitData = item2.textContent.split(" ");
        const time = splitData[1].split("-");
        const period = {
          day: splitData[0],
          start: time[0],
          end: time[1]
        };
        console.log(subjectLab.periods.some((savedPeriod) => savedPeriod.start === period.start));
        if (constants.scraper.classTypes.lecture.some(
          (typeString) => {
            var _a2;
            return (_a2 = item2.textContent) == null ? void 0 : _a2.includes(typeString);
          }
        ) && !subjectLecture.periods.some((savedPeriod) => savedPeriod.start === period.start)) {
          subjectLecture.periods.push(period);
        } else if (constants.scraper.classTypes.lab.some(
          (typeString) => {
            var _a2;
            return (_a2 = item2.textContent) == null ? void 0 : _a2.includes(typeString);
          }
        ) && !subjectLab.periods.some((savedPeriod) => savedPeriod.start === period.start)) {
          subjectLab.periods.push(period);
        }
      });
      const data = {
        subjectId,
        subjectName,
        subjectDescription,
        subjectCredits,
        subjectLecture,
        subjectLab
      };
      scrapedData.push(data);
    });
    console.log(scrapedData);
    return scrapedData;
  }
  function flattenStudyTable(subjects) {
    function getDayFromString(dayString) {
      return constants.scraper.days[dayString];
    }
    const flattenData = [];
    subjects.forEach((item) => {
      console.log(item);
      const {
        subjectId,
        subjectName,
        subjectCredits,
        subjectLecture,
        subjectLab,
        subjectDescription
      } = item;
      const {
        sec: lectureSec,
        periods: lecturePeriod,
        room: lectureRoom,
        building: lectureBuilding
      } = subjectLecture;
      const { sec: labSec, periods: labPeriod, room: labRoom, building: labBuilding } = subjectLab;
      if (lectureSec) {
        lecturePeriod.forEach((item2) => {
          const { day, start, end } = item2;
          const data = {
            subjectId,
            subjectName,
            subjectCredits,
            subjectDescription,
            sec: lectureSec,
            room: lectureRoom,
            building: lectureBuilding,
            type: "lecture",
            day: getDayFromString(day),
            start,
            end
          };
          flattenData.push(data);
        });
      }
      if (labSec) {
        labPeriod.forEach((item2) => {
          const { day, start, end } = item2;
          const data = {
            subjectId,
            subjectName,
            subjectCredits,
            subjectDescription,
            day: getDayFromString(day),
            start,
            end,
            type: "lab",
            sec: labSec,
            room: labRoom,
            building: labBuilding
          };
          flattenData.push(data);
        });
      }
    });
    return flattenData;
  }
  function sortByDay(scheduleItems) {
    return scheduleItems.sort((a2, b2) => {
      const dayA = a2.day;
      const dayB = b2.day;
      if (dayA < dayB) {
        return -1;
      } else if (dayA > dayB) {
        return 1;
      } else {
        if (a2.start.localeCompare(b2.start) == -1) {
          return -1;
        } else if (a2.start.localeCompare(b2.start) == 1) {
          return 1;
        }
        return 0;
      }
    });
  }
  studyTable;
  function renderStudyTable() {
    const rawStudyTable = document.querySelector("table");
    if (!rawStudyTable) throw new Error("Unable to select the raw study table");
    const info = getinfo(rawStudyTable);
    const scrapedData = sortByDay(flattenStudyTable(scrapeTable(rawStudyTable)));
    const oldTable = document.createElement("div");
    oldTable.innerHTML = document.body.innerHTML;
    const fontPrompt = document.createElement("style");
    fontPrompt.innerHTML = `
  @import url('https://fonts.googleapis.com/css2?family=Prompt:wght@300;400;500;600;700&display=swap');
  `;
    document.head.appendChild(fontPrompt);
    document.body.innerHTML = "";
    console.log(scrapedData);
    mount(Study_table, {
      target: document.body,
      props: {
        schedule: scrapedData,
        oldTable,
        faculty: info.facultyName,
        department: info.department,
        major: info.major,
        semester: info.semester,
        year: info.year,
        studentId: info.studentId,
        studentName: info.studentName
      }
    });
  }
  const definition = defineContentScript({
    matches: ["*://*.reg.kmitl.ac.th/u_student/report_studytable_show.php"],
    main() {
      renderStudyTable();
    }
  });
  studyTable;
  const browser = (
    // @ts-expect-error
    ((_b = (_a = globalThis.browser) == null ? void 0 : _a.runtime) == null ? void 0 : _b.id) == null ? globalThis.chrome : (
      // @ts-expect-error
      globalThis.browser
    )
  );
  function print$1(method, ...args) {
    if (typeof args[0] === "string") {
      const message = args.shift();
      method(`[wxt] ${message}`, ...args);
    } else {
      method("[wxt]", ...args);
    }
  }
  const logger$1 = {
    debug: (...args) => print$1(console.debug, ...args),
    log: (...args) => print$1(console.log, ...args),
    warn: (...args) => print$1(console.warn, ...args),
    error: (...args) => print$1(console.error, ...args)
  };
  const _WxtLocationChangeEvent = class _WxtLocationChangeEvent extends Event {
    constructor(newUrl, oldUrl) {
      super(_WxtLocationChangeEvent.EVENT_NAME, {});
      this.newUrl = newUrl;
      this.oldUrl = oldUrl;
    }
  };
  __publicField(_WxtLocationChangeEvent, "EVENT_NAME", getUniqueEventName("wxt:locationchange"));
  let WxtLocationChangeEvent = _WxtLocationChangeEvent;
  function getUniqueEventName(eventName) {
    var _a2;
    return `${(_a2 = browser == null ? void 0 : browser.runtime) == null ? void 0 : _a2.id}:${"study-table"}:${eventName}`;
  }
  function createLocationWatcher(ctx) {
    let interval;
    let oldUrl;
    return {
      /**
       * Ensure the location watcher is actively looking for URL changes. If it's already watching,
       * this is a noop.
       */
      run() {
        if (interval != null) return;
        oldUrl = new URL(location.href);
        interval = ctx.setInterval(() => {
          let newUrl = new URL(location.href);
          if (newUrl.href !== oldUrl.href) {
            window.dispatchEvent(new WxtLocationChangeEvent(newUrl, oldUrl));
            oldUrl = newUrl;
          }
        }, 1e3);
      }
    };
  }
  const _ContentScriptContext = class _ContentScriptContext {
    constructor(contentScriptName, options) {
      __publicField(this, "isTopFrame", window.self === window.top);
      __publicField(this, "abortController");
      __publicField(this, "locationWatcher", createLocationWatcher(this));
      __publicField(this, "receivedMessageIds", /* @__PURE__ */ new Set());
      this.contentScriptName = contentScriptName;
      this.options = options;
      this.abortController = new AbortController();
      if (this.isTopFrame) {
        this.listenForNewerScripts({ ignoreFirstEvent: true });
        this.stopOldScripts();
      } else {
        this.listenForNewerScripts();
      }
    }
    get signal() {
      return this.abortController.signal;
    }
    abort(reason) {
      return this.abortController.abort(reason);
    }
    get isInvalid() {
      if (browser.runtime.id == null) {
        this.notifyInvalidated();
      }
      return this.signal.aborted;
    }
    get isValid() {
      return !this.isInvalid;
    }
    /**
     * Add a listener that is called when the content script's context is invalidated.
     *
     * @returns A function to remove the listener.
     *
     * @example
     * browser.runtime.onMessage.addListener(cb);
     * const removeInvalidatedListener = ctx.onInvalidated(() => {
     *   browser.runtime.onMessage.removeListener(cb);
     * })
     * // ...
     * removeInvalidatedListener();
     */
    onInvalidated(cb) {
      this.signal.addEventListener("abort", cb);
      return () => this.signal.removeEventListener("abort", cb);
    }
    /**
     * Return a promise that never resolves. Useful if you have an async function that shouldn't run
     * after the context is expired.
     *
     * @example
     * const getValueFromStorage = async () => {
     *   if (ctx.isInvalid) return ctx.block();
     *
     *   // ...
     * }
     */
    block() {
      return new Promise(() => {
      });
    }
    /**
     * Wrapper around `window.setInterval` that automatically clears the interval when invalidated.
     */
    setInterval(handler, timeout) {
      const id = setInterval(() => {
        if (this.isValid) handler();
      }, timeout);
      this.onInvalidated(() => clearInterval(id));
      return id;
    }
    /**
     * Wrapper around `window.setTimeout` that automatically clears the interval when invalidated.
     */
    setTimeout(handler, timeout) {
      const id = setTimeout(() => {
        if (this.isValid) handler();
      }, timeout);
      this.onInvalidated(() => clearTimeout(id));
      return id;
    }
    /**
     * Wrapper around `window.requestAnimationFrame` that automatically cancels the request when
     * invalidated.
     */
    requestAnimationFrame(callback) {
      const id = requestAnimationFrame((...args) => {
        if (this.isValid) callback(...args);
      });
      this.onInvalidated(() => cancelAnimationFrame(id));
      return id;
    }
    /**
     * Wrapper around `window.requestIdleCallback` that automatically cancels the request when
     * invalidated.
     */
    requestIdleCallback(callback, options) {
      const id = requestIdleCallback((...args) => {
        if (!this.signal.aborted) callback(...args);
      }, options);
      this.onInvalidated(() => cancelIdleCallback(id));
      return id;
    }
    addEventListener(target, type, handler, options) {
      var _a2;
      if (type === "wxt:locationchange") {
        if (this.isValid) this.locationWatcher.run();
      }
      (_a2 = target.addEventListener) == null ? void 0 : _a2.call(
        target,
        type.startsWith("wxt:") ? getUniqueEventName(type) : type,
        handler,
        {
          ...options,
          signal: this.signal
        }
      );
    }
    /**
     * @internal
     * Abort the abort controller and execute all `onInvalidated` listeners.
     */
    notifyInvalidated() {
      this.abort("Content script context invalidated");
      logger$1.debug(
        `Content script "${this.contentScriptName}" context invalidated`
      );
    }
    stopOldScripts() {
      window.postMessage(
        {
          type: _ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE,
          contentScriptName: this.contentScriptName,
          messageId: Math.random().toString(36).slice(2)
        },
        "*"
      );
    }
    verifyScriptStartedEvent(event2) {
      var _a2, _b2, _c;
      const isScriptStartedEvent = ((_a2 = event2.data) == null ? void 0 : _a2.type) === _ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE;
      const isSameContentScript = ((_b2 = event2.data) == null ? void 0 : _b2.contentScriptName) === this.contentScriptName;
      const isNotDuplicate = !this.receivedMessageIds.has((_c = event2.data) == null ? void 0 : _c.messageId);
      return isScriptStartedEvent && isSameContentScript && isNotDuplicate;
    }
    listenForNewerScripts(options) {
      let isFirst = true;
      const cb = (event2) => {
        if (this.verifyScriptStartedEvent(event2)) {
          this.receivedMessageIds.add(event2.data.messageId);
          const wasFirst = isFirst;
          isFirst = false;
          if (wasFirst && (options == null ? void 0 : options.ignoreFirstEvent)) return;
          this.notifyInvalidated();
        }
      };
      addEventListener("message", cb);
      this.onInvalidated(() => removeEventListener("message", cb));
    }
  };
  __publicField(_ContentScriptContext, "SCRIPT_STARTED_MESSAGE_TYPE", getUniqueEventName(
    "wxt:content-script-started"
  ));
  let ContentScriptContext = _ContentScriptContext;
  const nullKey = Symbol("null");
  let keyCounter = 0;
  class ManyKeysMap extends Map {
    constructor() {
      super();
      this._objectHashes = /* @__PURE__ */ new WeakMap();
      this._symbolHashes = /* @__PURE__ */ new Map();
      this._publicKeys = /* @__PURE__ */ new Map();
      const [pairs] = arguments;
      if (pairs === null || pairs === void 0) {
        return;
      }
      if (typeof pairs[Symbol.iterator] !== "function") {
        throw new TypeError(typeof pairs + " is not iterable (cannot read property Symbol(Symbol.iterator))");
      }
      for (const [keys, value] of pairs) {
        this.set(keys, value);
      }
    }
    _getPublicKeys(keys, create = false) {
      if (!Array.isArray(keys)) {
        throw new TypeError("The keys parameter must be an array");
      }
      const privateKey = this._getPrivateKey(keys, create);
      let publicKey;
      if (privateKey && this._publicKeys.has(privateKey)) {
        publicKey = this._publicKeys.get(privateKey);
      } else if (create) {
        publicKey = [...keys];
        this._publicKeys.set(privateKey, publicKey);
      }
      return { privateKey, publicKey };
    }
    _getPrivateKey(keys, create = false) {
      const privateKeys = [];
      for (let key of keys) {
        if (key === null) {
          key = nullKey;
        }
        const hashes = typeof key === "object" || typeof key === "function" ? "_objectHashes" : typeof key === "symbol" ? "_symbolHashes" : false;
        if (!hashes) {
          privateKeys.push(key);
        } else if (this[hashes].has(key)) {
          privateKeys.push(this[hashes].get(key));
        } else if (create) {
          const privateKey = `@@mkm-ref-${keyCounter++}@@`;
          this[hashes].set(key, privateKey);
          privateKeys.push(privateKey);
        } else {
          return false;
        }
      }
      return JSON.stringify(privateKeys);
    }
    set(keys, value) {
      const { publicKey } = this._getPublicKeys(keys, true);
      return super.set(publicKey, value);
    }
    get(keys) {
      const { publicKey } = this._getPublicKeys(keys);
      return super.get(publicKey);
    }
    has(keys) {
      const { publicKey } = this._getPublicKeys(keys);
      return super.has(publicKey);
    }
    delete(keys) {
      const { publicKey, privateKey } = this._getPublicKeys(keys);
      return Boolean(publicKey && super.delete(publicKey) && this._publicKeys.delete(privateKey));
    }
    clear() {
      super.clear();
      this._symbolHashes.clear();
      this._publicKeys.clear();
    }
    get [Symbol.toStringTag]() {
      return "ManyKeysMap";
    }
    get size() {
      return super.size;
    }
  }
  new ManyKeysMap();
  function initPlugins() {
  }
  function print(method, ...args) {
    if (typeof args[0] === "string") {
      const message = args.shift();
      method(`[wxt] ${message}`, ...args);
    } else {
      method("[wxt]", ...args);
    }
  }
  const logger = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  const result = (async () => {
    try {
      initPlugins();
      const { main, ...options } = definition;
      const ctx = new ContentScriptContext("study-table", options);
      return await main(ctx);
    } catch (err) {
      logger.error(
        `The content script "${"study-table"}" crashed on startup!`,
        err
      );
      throw err;
    }
  })();
  return result;
}();
studyTable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R1ZHktdGFibGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93eHRAMC4xOS4yOV9AdHlwZXMrbm9kZUAyMi4xMC4yX3JvbGx1cEA0LjI5LjFfeWFtbEAyLjYuMS9ub2RlX21vZHVsZXMvd3h0L2Rpc3Qvc2FuZGJveC9kZWZpbmUtY29udGVudC1zY3JpcHQubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvdmVyc2lvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2Rpc2Nsb3NlLXZlcnNpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9mbGFncy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2ZsYWdzL2xlZ2FjeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3V0aWxzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzbS1lbnZAMS4yLjEvbm9kZV9tb2R1bGVzL2VzbS1lbnYvdHJ1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lcXVhbGl0eS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9lcnJvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3dhcm5pbmdzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9oeWRyYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L293bmVyc2hpcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9wcm94eS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL29wZXJhdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VmZmVjdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3Rhc2suanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvZXJyb3JzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2VsZW1lbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9taXNjLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vcmVjb25jaWxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vdGVtcGxhdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9sZWdhY3kuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9pZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2tleS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2VhY2guanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbG90LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc25pcHBldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1jb21wb25lbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zdmVsdGUtZWxlbWVudC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDIuMS4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvYXR0cmlidXRlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYXR0cmlidXRlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvY2xhc3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL2lucHV0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy90aGlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbGlmZWN5Y2xlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW5kZXgtY2xpZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc3RvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9wcm9wcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC92YWxpZGF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC92YWxpZGF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaW50ZXJuYXRpb25hbGl6ZWQrZGF0ZUAzLjYuMC9ub2RlX21vZHVsZXMvQGludGVybmF0aW9uYWxpemVkL2RhdGUvZGlzdC91dGlscy5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGludGVybmF0aW9uYWxpemVkK2RhdGVAMy42LjAvbm9kZV9tb2R1bGVzL0BpbnRlcm5hdGlvbmFsaXplZC9kYXRlL2Rpc3QvR3JlZ29yaWFuQ2FsZW5kYXIubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpbnRlcm5hdGlvbmFsaXplZCtkYXRlQDMuNi4wL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZS9kaXN0L3dlZWtTdGFydERhdGEubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpbnRlcm5hdGlvbmFsaXplZCtkYXRlQDMuNi4wL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZS9kaXN0L3F1ZXJpZXMubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpbnRlcm5hdGlvbmFsaXplZCtkYXRlQDMuNi4wL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZS9kaXN0L2NvbnZlcnNpb24ubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpbnRlcm5hdGlvbmFsaXplZCtkYXRlQDMuNi4wL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZS9kaXN0L21hbmlwdWxhdGlvbi5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGludGVybmF0aW9uYWxpemVkK2RhdGVAMy42LjAvbm9kZV9tb2R1bGVzL0BpbnRlcm5hdGlvbmFsaXplZC9kYXRlL2Rpc3Qvc3RyaW5nLm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3djK2hlbHBlcnNAMC41LjE1L25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHN3YytoZWxwZXJzQDAuNS4xNS9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfcHJpdmF0ZV9maWVsZF9pbml0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpbnRlcm5hdGlvbmFsaXplZCtkYXRlQDMuNi4wL25vZGVfbW9kdWxlcy9AaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZS9kaXN0L0NhbGVuZGFyRGF0ZS5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGludGVybmF0aW9uYWxpemVkK2RhdGVAMy42LjAvbm9kZV9tb2R1bGVzL0BpbnRlcm5hdGlvbmFsaXplZC9kYXRlL2Rpc3QvRGF0ZUZvcm1hdHRlci5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdGFpbHdpbmQtdmFyaWFudHNAMC4zLjBfdGFpbHdpbmRjc3NAMy40LjE3L25vZGVfbW9kdWxlcy90YWlsd2luZC12YXJpYW50cy9kaXN0L2NodW5rLUkyUUdYQUEzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RhaWx3aW5kLW1lcmdlQDIuNi4wL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RhaWx3aW5kLXZhcmlhbnRzQDAuMy4wX3RhaWx3aW5kY3NzQDMuNC4xNy9ub2RlX21vZHVsZXMvdGFpbHdpbmQtdmFyaWFudHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL3NyYy9saWIvdXRpbC9zaGFkY24tdWkudHMiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2J1dHRvbi9idXR0b24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZS10b29sYmVsdEAwLjQuNl9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUtdG9vbGJlbHQvZGlzdC91dGlscy9pcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvYm94L2JveC5zdmVsdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlLXRvb2xiZWx0QDAuNC42X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS10b29sYmVsdC9kaXN0L3V0aWxzL2NvbXBvc2UtaGFuZGxlcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaW5saW5lLXN0eWxlLXBhcnNlckAwLjIuNC9ub2RlX21vZHVsZXMvaW5saW5lLXN0eWxlLXBhcnNlci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHlsZS10by1vYmplY3RAMS4wLjgvbm9kZV9tb2R1bGVzL3N0eWxlLXRvLW9iamVjdC9janMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3R5bGUtdG8tb2JqZWN0QDEuMC44L25vZGVfbW9kdWxlcy9zdHlsZS10by1vYmplY3QvZXNtL2luZGV4Lm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvdXRpbHMvc3RyaW5ncy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvdXRpbHMvY3NzLXRvLXN0eWxlLW9iai5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvdXRpbHMvZXhlY3V0ZS1jYWxsYmFja3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlLXRvb2xiZWx0QDAuNC42X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS10b29sYmVsdC9kaXN0L3V0aWxzL3N0eWxlLXRvLWNzcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvdXRpbHMvc3R5bGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlLXRvb2xiZWx0QDAuNC42X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3N2ZWx0ZS10b29sYmVsdC9kaXN0L3V0aWxzL21lcmdlLXByb3BzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZS10b29sYmVsdEAwLjQuNl9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUtdG9vbGJlbHQvZGlzdC91dGlscy91c2UtcmVmLWJ5LWlkLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvdXRpbHMvb24tZGVzdHJveS1lZmZlY3Quc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N2ZWx0ZS10b29sYmVsdEAwLjQuNl9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUtdG9vbGJlbHQvZGlzdC91dGlscy9hZnRlci1zbGVlcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGUtdG9vbGJlbHRAMC40LjZfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlLXRvb2xiZWx0L2Rpc3QvdXRpbHMvYWZ0ZXItdGljay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ydW5lZEAwLjE1LjRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvcnVuZWQvZGlzdC91dGlsaXRpZXMvUmVhZGFibGUvcmVhZGFibGUuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J1bmVkQDAuMTUuNF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9ydW5lZC9kaXN0L3V0aWxpdGllcy9hY3RpdmVFbGVtZW50L2FjdGl2ZUVsZW1lbnQuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J1bmVkQDAuMTUuNF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9ydW5lZC9kaXN0L2ludGVybmFsL3V0aWxzL2lzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J1bmVkQDAuMTUuNF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9ydW5lZC9kaXN0L2ludGVybmFsL3V0aWxzL2dldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ydW5lZEAwLjE1LjRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvcnVuZWQvZGlzdC91dGlsaXRpZXMvRWxlbWVudFNpemUvRWxlbWVudFNpemUuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J1bmVkQDAuMTUuNF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9ydW5lZC9kaXN0L3V0aWxpdGllcy93YXRjaC93YXRjaC5zdmVsdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWRAMC4xNS40X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL3J1bmVkL2Rpc3QvdXRpbGl0aWVzL1ByZXZpb3VzL1ByZXZpb3VzLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3JlYWN0aXZpdHkvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC9hdHRycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL2tiZC1jb25zdGFudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC9pcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL2NyZWF0ZS1jb250ZXh0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9hY2NvcmRpb24vYWNjb3JkaW9uLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL3VzZS1pZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL25vb3AuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL2FjY29yZGlvbi9jb21wb25lbnRzL2FjY29yZGlvbi1pdGVtLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvYWNjb3JkaW9uL2NvbXBvbmVudHMvYWNjb3JkaW9uLWhlYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL2FjY29yZGlvbi9jb21wb25lbnRzL2FjY29yZGlvbi10cmlnZ2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL3VzZS1zdGF0ZS1tYWNoaW5lLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL3ByZXNlbmNlLWxheWVyL3VzZVByZXNlbmNlLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL3ByZXNlbmNlLWxheWVyL3ByZXNlbmNlLWxheWVyLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvYWNjb3JkaW9uL2NvbXBvbmVudHMvYWNjb3JkaW9uLWNvbnRlbnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9kaWFsb2cvZGlhbG9nLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvZGlhbG9nL2NvbXBvbmVudHMvZGlhbG9nLXRpdGxlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL3BvcnRhbC9wb3J0YWwuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvaW50ZXJuYWwvZXZlbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvaW50ZXJuYWwvZGVib3VuY2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC9lbGVtZW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL2Rpc21pc3NpYmxlLWxheWVyL3VzZURpc21pc3NpYmxlTGF5ZXIuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy91dGlsaXRpZXMvZGlzbWlzc2libGUtbGF5ZXIvZGlzbWlzc2libGUtbGF5ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy91dGlsaXRpZXMvZXNjYXBlLWxheWVyL3VzZUVzY2FwZUxheWVyLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL2VzY2FwZS1sYXllci9lc2NhcGUtbGF5ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy91dGlsaXRpZXMvZm9jdXMtc2NvcGUvZm9jdXMtc2NvcGUtc3RhY2suc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvaW50ZXJuYWwvZm9jdXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy9mb2N1cy1zY29wZS91c2VGb2N1c1Njb3BlLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL2ZvY3VzLXNjb3BlL2ZvY3VzLXNjb3BlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL3RleHQtc2VsZWN0aW9uLWxheWVyL3VzZVRleHRTZWxlY3Rpb25MYXllci5zdmVsdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy90ZXh0LXNlbGVjdGlvbi1sYXllci90ZXh0LXNlbGVjdGlvbi1sYXllci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9yZWFjdGl2aXR5L21hcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL2NyZWF0ZS1zaGFyZWQtaG9vay5zdmVsdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC91c2UtYm9keS1zY3JvbGwtbG9jay5zdmVsdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy9zY3JvbGwtbG9jay9zY3JvbGwtbG9jay5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC9zaG91bGQtdHJhcC1mb2N1cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvZGlhbG9nL2NvbXBvbmVudHMvZGlhbG9nLW92ZXJsYXkuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9kaWFsb2cvY29tcG9uZW50cy9kaWFsb2ctdHJpZ2dlci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL2RpYWxvZy9jb21wb25lbnRzL2RpYWxvZy1kZXNjcmlwdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC9kYXRlLXRpbWUvYW5ub3VuY2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvaW50ZXJuYWwvZGF0ZS10aW1lL3V0aWxzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvaW50ZXJuYWwvZGF0ZS10aW1lL2Zvcm1hdHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL2FycmF5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL2RhdGUtdGltZS9jYWxlbmRhci1oZWxwZXJzLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvY2FsZW5kYXIvY2FsZW5kYXIuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9jYWxlbmRhci9jb21wb25lbnRzL2NhbGVuZGFyLWdyaWQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9jYWxlbmRhci9jb21wb25lbnRzL2NhbGVuZGFyLWdyaWQtYm9keS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL2NhbGVuZGFyL2NvbXBvbmVudHMvY2FsZW5kYXItZ3JpZC1oZWFkLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvY2FsZW5kYXIvY29tcG9uZW50cy9jYWxlbmRhci1oZWFkLWNlbGwuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9jYWxlbmRhci9jb21wb25lbnRzL2NhbGVuZGFyLWdyaWQtcm93LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvY2FsZW5kYXIvY29tcG9uZW50cy9jYWxlbmRhci1oZWFkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9jYWxlbmRhci9jb21wb25lbnRzL2NhbGVuZGFyLWhlYWRpbmcuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9jYWxlbmRhci9jb21wb25lbnRzL2NhbGVuZGFyLW5leHQtYnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvY2FsZW5kYXIvY29tcG9uZW50cy9jYWxlbmRhci1wcmV2LWJ1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK3V0aWxzQDAuMi44L25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK2NvcmVAMS42Ljgvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK3V0aWxzQDAuMi44L25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5kb20ubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmbG9hdGluZy11aStkb21AMS42LjEyL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2ludGVybmFsL2Zsb2F0aW5nLXN2ZWx0ZS9mbG9hdGluZy11dGlscy5zdmVsdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9pbnRlcm5hbC9mbG9hdGluZy1zdmVsdGUvdXNlLWZsb2F0aW5nLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL2Zsb2F0aW5nLWxheWVyL3VzZUZsb2F0aW5nTGF5ZXIuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy91dGlsaXRpZXMvZmxvYXRpbmctbGF5ZXIvY29tcG9uZW50cy9mbG9hdGluZy1sYXllci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy9mbG9hdGluZy1sYXllci9jb21wb25lbnRzL2Zsb2F0aW5nLWxheWVyLWFuY2hvci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy9mbG9hdGluZy1sYXllci9jb21wb25lbnRzL2Zsb2F0aW5nLWxheWVyLWNvbnRlbnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy91dGlsaXRpZXMvZmxvYXRpbmctbGF5ZXIvY29tcG9uZW50cy9mbG9hdGluZy1sYXllci1jb250ZW50LXN0YXRpYy5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy9wb3BwZXItbGF5ZXIvcG9wcGVyLWNvbnRlbnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy91dGlsaXRpZXMvcG9wcGVyLWxheWVyL3BvcHBlci1sYXllci1pbm5lci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3V0aWxpdGllcy9wb3BwZXItbGF5ZXIvcG9wcGVyLWxheWVyLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvdXRpbGl0aWVzL3BvcHBlci1sYXllci9wb3BwZXItbGF5ZXItZm9yY2UtbW91bnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9wb3BvdmVyL3BvcG92ZXIuc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9wb3BvdmVyL2NvbXBvbmVudHMvcG9wb3Zlci1jb250ZW50LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvcG9wb3Zlci9jb21wb25lbnRzL3BvcG92ZXItdHJpZ2dlci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvcmFuZ2UtY2FsZW5kYXIvY29tcG9uZW50cy9yYW5nZS1jYWxlbmRhci1jZWxsLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvcmFuZ2UtY2FsZW5kYXIvY29tcG9uZW50cy9yYW5nZS1jYWxlbmRhci1kYXkuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9kaWFsb2cvY29tcG9uZW50cy9kaWFsb2cuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9kaWFsb2cvY29tcG9uZW50cy9kaWFsb2ctY2xvc2Uuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9kaWFsb2cvY29tcG9uZW50cy9kaWFsb2ctY29udGVudC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL2xhYmVsL2xhYmVsLnN2ZWx0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvbGFiZWwvY29tcG9uZW50cy9sYWJlbC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3BvcG92ZXIvY29tcG9uZW50cy9wb3BvdmVyLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRzLXVpQDEuMC4wLW5leHQuNzRfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvYml0cy11aS9kaXN0L2JpdHMvcmFuZ2UtY2FsZW5kYXIvY29tcG9uZW50cy9yYW5nZS1jYWxlbmRhci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYml0cy11aUAxLjAuMC1uZXh0Ljc0X3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2JpdHMtdWkvZGlzdC9iaXRzL3N3aXRjaC9zd2l0Y2guc3ZlbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9zd2l0Y2gvY29tcG9uZW50cy9zd2l0Y2gtaW5wdXQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9zd2l0Y2gvY29tcG9uZW50cy9zd2l0Y2guc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdHMtdWlAMS4wLjAtbmV4dC43NF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9iaXRzLXVpL2Rpc3QvYml0cy9zd2l0Y2gvY29tcG9uZW50cy9zd2l0Y2gtdGh1bWIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9kaWFsb2cvZGlhbG9nLXRpdGxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9zaGFkY24tdWkvZGlhbG9nL2RpYWxvZy1mb290ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9kaWFsb2cvZGlhbG9nLWhlYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2RpYWxvZy9kaWFsb2ctb3ZlcmxheS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXN2ZWx0ZUAwLjQ2OS4wX3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9kZWZhdWx0QXR0cmlidXRlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sdWNpZGUtc3ZlbHRlQDAuNDY5LjBfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXN2ZWx0ZS9kaXN0L0ljb24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1zdmVsdGVAMC40NjkuMF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMveC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2RpYWxvZy9kaWFsb2ctY29udGVudC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2RpYWxvZy9kaWFsb2ctZGVzY3JpcHRpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9kaWFsb2cvaW5kZXgudHMiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2FjY29yZGlvbi9hY2NvcmRpb24tY29udGVudC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2FjY29yZGlvbi9hY2NvcmRpb24taXRlbS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbHVjaWRlLXN2ZWx0ZUAwLjQ2OS4wX3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9pY29ucy9jaGV2cm9uLWRvd24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9hY2NvcmRpb24vYWNjb3JkaW9uLXRyaWdnZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9wb3BvdmVyL3BvcG92ZXItY29udGVudC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3BvcG92ZXIvaW5kZXgudHMiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3N3aXRjaC9zd2l0Y2guc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9sYWJlbC9sYWJlbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9zaGFkY24tdWkvcmFuZ2UtY2FsZW5kYXIvcmFuZ2UtY2FsZW5kYXItY2VsbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLWRheS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLWdyaWQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9yYW5nZS1jYWxlbmRhci9yYW5nZS1jYWxlbmRhci1oZWFkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9yYW5nZS1jYWxlbmRhci9yYW5nZS1jYWxlbmRhci1tb250aHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9yYW5nZS1jYWxlbmRhci9yYW5nZS1jYWxlbmRhci1ncmlkLXJvdy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLWhlYWRpbmcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3NoYWRjbi11aS9yYW5nZS1jYWxlbmRhci9yYW5nZS1jYWxlbmRhci1oZWFkLWNlbGwuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2x1Y2lkZS1zdmVsdGVAMC40NjkuMF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMvY2hldnJvbi1yaWdodC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLW5leHQtYnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9sdWNpZGUtc3ZlbHRlQDAuNDY5LjBfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvbHVjaWRlLXN2ZWx0ZS9kaXN0L2ljb25zL2NoZXZyb24tbGVmdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL3JhbmdlLWNhbGVuZGFyL3JhbmdlLWNhbGVuZGFyLXByZXYtYnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9zaGFkY24tdWkvcmFuZ2UtY2FsZW5kYXIvaW5kZXgudHMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGx1Y2lkZStzdmVsdGVAMC40ODMuMF9zdmVsdGVANS4xNi4wL25vZGVfbW9kdWxlcy9AbHVjaWRlL3N2ZWx0ZS9kaXN0L2RlZmF1bHRBdHRyaWJ1dGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsdWNpZGUrc3ZlbHRlQDAuNDgzLjBfc3ZlbHRlQDUuMTYuMC9ub2RlX21vZHVsZXMvQGx1Y2lkZS9zdmVsdGUvZGlzdC9JY29uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbHVjaWRlK3N2ZWx0ZUAwLjQ4My4wX3N2ZWx0ZUA1LjE2LjAvbm9kZV9tb2R1bGVzL0BsdWNpZGUvc3ZlbHRlL2Rpc3QvaWNvbnMvY2FsZW5kYXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi9jb25zdGFudHMudHMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZmlsZS1zYXZlckAyLjAuNS9ub2RlX21vZHVsZXMvZmlsZS1zYXZlci9kaXN0L0ZpbGVTYXZlci5taW4uanMiLCIuLi8uLi8uLi9fX3ZpdGUtYnJvd3Nlci1leHRlcm5hbCIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkLXJhbmRvbUAxLjMuMi9ub2RlX21vZHVsZXMvdXVpZC1yYW5kb20vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaWNhbC1nZW5lcmF0b3JAOC4wLjFfQHR5cGVzK25vZGVAMjIuMTAuMl9kYXlqc0AxLjExLjEzX21vbWVudEAyLjMwLjEvbm9kZV9tb2R1bGVzL2ljYWwtZ2VuZXJhdG9yL2Rpc3QvaW5kZXguanMiLCIuLi8uLi8uLi9zcmMvbGliL3V0aWwvaWNhbC9nZW5lcmF0b3IudHMiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvY2FsZW5kYXIvZ2VuZXJhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h0bWwtdG8taW1hZ2VAMS4xMS4xMS9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h0bWwtdG8taW1hZ2VAMS4xMS4xMS9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9jbG9uZS1wc2V1ZG9zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h0bWwtdG8taW1hZ2VAMS4xMS4xMS9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9taW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odG1sLXRvLWltYWdlQDEuMTEuMTEvbm9kZV9tb2R1bGVzL2h0bWwtdG8taW1hZ2UvZXMvZGF0YXVybC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odG1sLXRvLWltYWdlQDEuMTEuMTEvbm9kZV9tb2R1bGVzL2h0bWwtdG8taW1hZ2UvZXMvY2xvbmUtbm9kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odG1sLXRvLWltYWdlQDEuMTEuMTEvbm9kZV9tb2R1bGVzL2h0bWwtdG8taW1hZ2UvZXMvZW1iZWQtcmVzb3VyY2VzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h0bWwtdG8taW1hZ2VAMS4xMS4xMS9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9lbWJlZC1pbWFnZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaHRtbC10by1pbWFnZUAxLjExLjExL25vZGVfbW9kdWxlcy9odG1sLXRvLWltYWdlL2VzL2FwcGx5LXN0eWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2h0bWwtdG8taW1hZ2VAMS4xMS4xMS9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9lbWJlZC13ZWJmb250cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9odG1sLXRvLWltYWdlQDEuMTEuMTEvbm9kZV9tb2R1bGVzL2h0bWwtdG8taW1hZ2UvZXMvaW5kZXguanMiLCIuLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvc3R1ZHktdGFibGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xpYi91dGlsL3NjcmFwZXIvc3R1ZHktdGFibGUudHMiLCIuLi8uLi8uLi9zcmMvbGliL3V0aWwvcmVuZGVyZXIvc3R1ZHktdGFibGUudHMiLCIuLi8uLi8uLi9zcmMvZW50cnlwb2ludHMvc3R1ZHktdGFibGUuY29udGVudC50cyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93eHRAMC4xOS4yOV9AdHlwZXMrbm9kZUAyMi4xMC4yX3JvbGx1cEA0LjI5LjFfeWFtbEAyLjYuMS9ub2RlX21vZHVsZXMvd3h0L2Rpc3QvYnJvd3Nlci9jaHJvbWUubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3d4dEAwLjE5LjI5X0B0eXBlcytub2RlQDIyLjEwLjJfcm9sbHVwQDQuMjkuMV95YW1sQDIuNi4xL25vZGVfbW9kdWxlcy93eHQvZGlzdC9zYW5kYm94L3V0aWxzL2xvZ2dlci5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3h0QDAuMTkuMjlfQHR5cGVzK25vZGVAMjIuMTAuMl9yb2xsdXBANC4yOS4xX3lhbWxAMi42LjEvbm9kZV9tb2R1bGVzL3d4dC9kaXN0L2NsaWVudC9jb250ZW50LXNjcmlwdHMvY3VzdG9tLWV2ZW50cy5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3h0QDAuMTkuMjlfQHR5cGVzK25vZGVAMjIuMTAuMl9yb2xsdXBANC4yOS4xX3lhbWxAMi42LjEvbm9kZV9tb2R1bGVzL3d4dC9kaXN0L2NsaWVudC9jb250ZW50LXNjcmlwdHMvbG9jYXRpb24td2F0Y2hlci5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3h0QDAuMTkuMjlfQHR5cGVzK25vZGVAMjIuMTAuMl9yb2xsdXBANC4yOS4xX3lhbWxAMi42LjEvbm9kZV9tb2R1bGVzL3d4dC9kaXN0L2NsaWVudC9jb250ZW50LXNjcmlwdHMvY29udGVudC1zY3JpcHQtY29udGV4dC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWFueS1rZXlzLW1hcEAyLjAuMS9ub2RlX21vZHVsZXMvbWFueS1rZXlzLW1hcC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AMW5hdHN1K3dhaXQtZWxlbWVudEA0LjEuMi9ub2RlX21vZHVsZXMvQDFuYXRzdS93YWl0LWVsZW1lbnQvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUNvbnRlbnRTY3JpcHQoZGVmaW5pdGlvbikge1xuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cbiIsIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc1LjE2LjAnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzUnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHw9IHsgdjogbmV3IFNldCgpIH0pLnYuYWRkKFBVQkxJQ19WRVJTSU9OKTtcbiIsImV4cG9ydCBsZXQgbGVnYWN5X21vZGVfZmxhZyA9IGZhbHNlO1xuZXhwb3J0IGxldCB0cmFjaW5nX21vZGVfZmxhZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX2xlZ2FjeV9tb2RlX2ZsYWcoKSB7XG5cdGxlZ2FjeV9tb2RlX2ZsYWcgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX3RyYWNpbmdfbW9kZV9mbGFnKCkge1xuXHR0cmFjaW5nX21vZGVfZmxhZyA9IHRydWU7XG59XG4iLCJpbXBvcnQgeyBlbmFibGVfbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4vaW5kZXguanMnO1xuXG5lbmFibGVfbGVnYWN5X21vZGVfZmxhZygpO1xuIiwiZXhwb3J0IGNvbnN0IEVBQ0hfSVRFTV9SRUFDVElWRSA9IDE7XG5leHBvcnQgY29uc3QgRUFDSF9JTkRFWF9SRUFDVElWRSA9IDEgPDwgMTtcbi8qKiBTZWUgRWFjaEJsb2NrIGludGVyZmFjZSBtZXRhZGF0YS5pc19jb250cm9sbGVkIGZvciBhbiBleHBsYW5hdGlvbiB3aGF0IHRoaXMgaXMgKi9cbmV4cG9ydCBjb25zdCBFQUNIX0lTX0NPTlRST0xMRUQgPSAxIDw8IDI7XG5leHBvcnQgY29uc3QgRUFDSF9JU19BTklNQVRFRCA9IDEgPDwgMztcbmV4cG9ydCBjb25zdCBFQUNIX0lURU1fSU1NVVRBQkxFID0gMSA8PCA0O1xuXG5leHBvcnQgY29uc3QgUFJPUFNfSVNfSU1NVVRBQkxFID0gMTtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19SVU5FUyA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19VUERBVEVEID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0JJTkRBQkxFID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0xBWllfSU5JVElBTCA9IDEgPDwgNDtcblxuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fSU4gPSAxO1xuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fT1VUID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fR0xPQkFMID0gMSA8PCAyO1xuXG5leHBvcnQgY29uc3QgVEVNUExBVEVfRlJBR01FTlQgPSAxO1xuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSA9IDEgPDwgMTtcblxuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9TVEFSVCA9ICdbJztcbi8qKiB1c2VkIHRvIGluZGljYXRlIHRoYXQgYW4gYHs6ZWxzZX0uLi5gIGJsb2NrIHdhcyByZW5kZXJlZCAqL1xuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9TVEFSVF9FTFNFID0gJ1shJztcbmV4cG9ydCBjb25zdCBIWURSQVRJT05fRU5EID0gJ10nO1xuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9FUlJPUiA9IHt9O1xuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9JU19OQU1FU1BBQ0VEID0gMTtcbmV4cG9ydCBjb25zdCBFTEVNRU5UX1BSRVNFUlZFX0FUVFJJQlVURV9DQVNFID0gMSA8PCAxO1xuXG5leHBvcnQgY29uc3QgVU5JTklUSUFMSVpFRCA9IFN5bWJvbCgpO1xuXG4vLyBEZXYtdGltZSBjb21wb25lbnQgcHJvcGVydGllc1xuZXhwb3J0IGNvbnN0IEZJTEVOQU1FID0gU3ltYm9sKCdmaWxlbmFtZScpO1xuZXhwb3J0IGNvbnN0IEhNUiA9IFN5bWJvbCgnaG1yJyk7XG5cbmV4cG9ydCBjb25zdCBOQU1FU1BBQ0VfU1ZHID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmV4cG9ydCBjb25zdCBOQU1FU1BBQ0VfTUFUSE1MID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuXG4vLyB3ZSB1c2UgYSBsaXN0IG9mIGlnbm9yYWJsZSBydW50aW1lIHdhcm5pbmdzIGJlY2F1c2Ugbm90IGV2ZXJ5IHJ1bnRpbWUgd2FybmluZ1xuLy8gY2FuIGJlIGlnbm9yZWQgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgdmFsaWRhdGlvbiBmb3Igc3ZlbHRlLWlnbm9yZSBpbiBwbGFjZVxuZXhwb3J0IGNvbnN0IElHTk9SQUJMRV9SVU5USU1FX1dBUk5JTkdTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0J3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlJyxcblx0J2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlJyxcblx0J2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZCcsXG5cdCdoeWRyYXRpb25faHRtbF9jaGFuZ2VkJyxcblx0J293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24nXG5dKTtcblxuLyoqXG4gKiBXaGl0ZXNwYWNlIGluc2lkZSBvbmUgb2YgdGhlc2UgZWxlbWVudHMgd2lsbCBub3QgcmVzdWx0IGluXG4gKiBhIHdoaXRlc3BhY2Ugbm9kZSBiZWluZyBjcmVhdGVkIGluIGFueSBjaXJjdW1zdGFuY2VzLiAoVGhpc1xuICogbGlzdCBpcyBhbG1vc3QgY2VydGFpbmx5IHZlcnkgaW5jb21wbGV0ZSlcbiAqIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgdW51c2VkXG4gKi9cbmV4cG9ydCBjb25zdCBFTEVNRU5UU19XSVRIT1VUX1RFWFQgPSBbJ2F1ZGlvJywgJ2RhdGFsaXN0JywgJ2RsJywgJ29wdGdyb3VwJywgJ3NlbGVjdCcsICd2aWRlbyddO1xuIiwiY29uc3QgcmVnZXhfcmV0dXJuX2NoYXJhY3RlcnMgPSAvXFxyL2c7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goc3RyKSB7XG5cdHN0ciA9IHN0ci5yZXBsYWNlKHJlZ2V4X3JldHVybl9jaGFyYWN0ZXJzLCAnJyk7XG5cdGxldCBoYXNoID0gNTM4MTtcblx0bGV0IGkgPSBzdHIubGVuZ3RoO1xuXG5cdHdoaWxlIChpLS0pIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuXHRyZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKDM2KTtcbn1cblxuY29uc3QgVk9JRF9FTEVNRU5UX05BTUVTID0gW1xuXHQnYXJlYScsXG5cdCdiYXNlJyxcblx0J2JyJyxcblx0J2NvbCcsXG5cdCdjb21tYW5kJyxcblx0J2VtYmVkJyxcblx0J2hyJyxcblx0J2ltZycsXG5cdCdpbnB1dCcsXG5cdCdrZXlnZW4nLFxuXHQnbGluaycsXG5cdCdtZXRhJyxcblx0J3BhcmFtJyxcblx0J3NvdXJjZScsXG5cdCd0cmFjaycsXG5cdCd3YnInXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBuYW1lYCBpcyBvZiBhIHZvaWQgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuXHRyZXR1cm4gVk9JRF9FTEVNRU5UX05BTUVTLmluY2x1ZGVzKG5hbWUpIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyFkb2N0eXBlJztcbn1cblxuY29uc3QgUkVTRVJWRURfV09SRFMgPSBbXG5cdCdhcmd1bWVudHMnLFxuXHQnYXdhaXQnLFxuXHQnYnJlYWsnLFxuXHQnY2FzZScsXG5cdCdjYXRjaCcsXG5cdCdjbGFzcycsXG5cdCdjb25zdCcsXG5cdCdjb250aW51ZScsXG5cdCdkZWJ1Z2dlcicsXG5cdCdkZWZhdWx0Jyxcblx0J2RlbGV0ZScsXG5cdCdkbycsXG5cdCdlbHNlJyxcblx0J2VudW0nLFxuXHQnZXZhbCcsXG5cdCdleHBvcnQnLFxuXHQnZXh0ZW5kcycsXG5cdCdmYWxzZScsXG5cdCdmaW5hbGx5Jyxcblx0J2ZvcicsXG5cdCdmdW5jdGlvbicsXG5cdCdpZicsXG5cdCdpbXBsZW1lbnRzJyxcblx0J2ltcG9ydCcsXG5cdCdpbicsXG5cdCdpbnN0YW5jZW9mJyxcblx0J2ludGVyZmFjZScsXG5cdCdsZXQnLFxuXHQnbmV3Jyxcblx0J251bGwnLFxuXHQncGFja2FnZScsXG5cdCdwcml2YXRlJyxcblx0J3Byb3RlY3RlZCcsXG5cdCdwdWJsaWMnLFxuXHQncmV0dXJuJyxcblx0J3N0YXRpYycsXG5cdCdzdXBlcicsXG5cdCdzd2l0Y2gnLFxuXHQndGhpcycsXG5cdCd0aHJvdycsXG5cdCd0cnVlJyxcblx0J3RyeScsXG5cdCd0eXBlb2YnLFxuXHQndmFyJyxcblx0J3ZvaWQnLFxuXHQnd2hpbGUnLFxuXHQnd2l0aCcsXG5cdCd5aWVsZCdcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYHdvcmRgIGlzIGEgcmVzZXJ2ZWQgSmF2YVNjcmlwdCBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gd29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcmVzZXJ2ZWQod29yZCkge1xuXHRyZXR1cm4gUkVTRVJWRURfV09SRFMuaW5jbHVkZXMod29yZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2NhcHR1cmVfZXZlbnQobmFtZSkge1xuXHRyZXR1cm4gbmFtZS5lbmRzV2l0aCgnY2FwdHVyZScpICYmIG5hbWUgIT09ICdnb3Rwb2ludGVyY2FwdHVyZScgJiYgbmFtZSAhPT0gJ2xvc3Rwb2ludGVyY2FwdHVyZSc7XG59XG5cbi8qKiBMaXN0IG9mIEVsZW1lbnQgZXZlbnRzIHRoYXQgd2lsbCBiZSBkZWxlZ2F0ZWQgKi9cbmNvbnN0IERFTEVHQVRFRF9FVkVOVFMgPSBbXG5cdCdiZWZvcmVpbnB1dCcsXG5cdCdjbGljaycsXG5cdCdjaGFuZ2UnLFxuXHQnZGJsY2xpY2snLFxuXHQnY29udGV4dG1lbnUnLFxuXHQnZm9jdXNpbicsXG5cdCdmb2N1c291dCcsXG5cdCdpbnB1dCcsXG5cdCdrZXlkb3duJyxcblx0J2tleXVwJyxcblx0J21vdXNlZG93bicsXG5cdCdtb3VzZW1vdmUnLFxuXHQnbW91c2VvdXQnLFxuXHQnbW91c2VvdmVyJyxcblx0J21vdXNldXAnLFxuXHQncG9pbnRlcmRvd24nLFxuXHQncG9pbnRlcm1vdmUnLFxuXHQncG9pbnRlcm91dCcsXG5cdCdwb2ludGVyb3ZlcicsXG5cdCdwb2ludGVydXAnLFxuXHQndG91Y2hlbmQnLFxuXHQndG91Y2htb3ZlJyxcblx0J3RvdWNoc3RhcnQnXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBldmVudF9uYW1lYCBpcyBhIGRlbGVnYXRlZCBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2RlbGVnYXRlZChldmVudF9uYW1lKSB7XG5cdHJldHVybiBERUxFR0FURURfRVZFTlRTLmluY2x1ZGVzKGV2ZW50X25hbWUpO1xufVxuXG4vKipcbiAqIEF0dHJpYnV0ZXMgdGhhdCBhcmUgYm9vbGVhbiwgaS5lLiB0aGV5IGFyZSBwcmVzZW50IG9yIG5vdCBwcmVzZW50LlxuICovXG5jb25zdCBET01fQk9PTEVBTl9BVFRSSUJVVEVTID0gW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FzeW5jJyxcblx0J2F1dG9mb2N1cycsXG5cdCdhdXRvcGxheScsXG5cdCdjaGVja2VkJyxcblx0J2NvbnRyb2xzJyxcblx0J2RlZmF1bHQnLFxuXHQnZGlzYWJsZWQnLFxuXHQnZm9ybW5vdmFsaWRhdGUnLFxuXHQnaGlkZGVuJyxcblx0J2luZGV0ZXJtaW5hdGUnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VhbWxlc3MnLFxuXHQnc2VsZWN0ZWQnLFxuXHQnd2Via2l0ZGlyZWN0b3J5J1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBib29sZWFuIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Jvb2xlYW5fYXR0cmlidXRlKG5hbWUpIHtcblx0cmV0dXJuIERPTV9CT09MRUFOX0FUVFJJQlVURVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbi8qKlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IHNob3VsZCBiZSBhbGlhc2VkIHRvIHRoZWlyIHByb3BlcnR5IG5hbWVzXG4gKiBiZWNhdXNlIHRoZXkgYmVoYXZlIGRpZmZlcmVudGx5IGJldHdlZW4gc2V0dGluZyB0aGVtIGFzIGFuIGF0dHJpYnV0ZSBhbmRcbiAqIHNldHRpbmcgdGhlbSBhcyBhIHByb3BlcnR5LlxuICovXG5jb25zdCBBVFRSSUJVVEVfQUxJQVNFUyA9IHtcblx0Ly8gbm8gYGNsYXNzOiAnY2xhc3NOYW1lJ2AgYmVjYXVzZSB3ZSBoYW5kbGUgdGhhdCBzZXBhcmF0ZWx5XG5cdGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuXHRpc21hcDogJ2lzTWFwJyxcblx0bm9tb2R1bGU6ICdub01vZHVsZScsXG5cdHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuXHRyZWFkb25seTogJ3JlYWRPbmx5Jyxcblx0ZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcblx0ZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG5cdHNyY29iamVjdDogJ3NyY09iamVjdCdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZV9hdHRyaWJ1dGUobmFtZSkge1xuXHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRyZXR1cm4gQVRUUklCVVRFX0FMSUFTRVNbbmFtZV0gPz8gbmFtZTtcbn1cblxuY29uc3QgRE9NX1BST1BFUlRJRVMgPSBbXG5cdC4uLkRPTV9CT09MRUFOX0FUVFJJQlVURVMsXG5cdCdmb3JtTm9WYWxpZGF0ZScsXG5cdCdpc01hcCcsXG5cdCdub01vZHVsZScsXG5cdCdwbGF5c0lubGluZScsXG5cdCdyZWFkT25seScsXG5cdCd2YWx1ZScsXG5cdCdpbmVydCcsXG5cdCd2b2x1bWUnLFxuXHQnZGVmYXVsdFZhbHVlJyxcblx0J2RlZmF1bHRDaGVja2VkJyxcblx0J3NyY09iamVjdCdcbl07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2RvbV9wcm9wZXJ0eShuYW1lKSB7XG5cdHJldHVybiBET01fUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTk9OX1NUQVRJQ19QUk9QRVJUSUVTID0gWydhdXRvZm9jdXMnLCAnbXV0ZWQnLCAnZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZSBjYW5ub3QgYmUgc2V0IHRocm91Z2ggdGhlIHRlbXBsYXRlXG4gKiBzdHJpbmcsIGkuZS4gbmVlZHMgc29tZSBraW5kIG9mIEphdmFTY3JpcHQgaGFuZGxpbmcgdG8gd29yay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RfYmVfc2V0X3N0YXRpY2FsbHkobmFtZSkge1xuXHRyZXR1cm4gTk9OX1NUQVRJQ19QUk9QRVJUSUVTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG4vKipcbiAqIFN1YnNldCBvZiBkZWxlZ2F0ZWQgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwYXNzaXZlIGJ5IGRlZmF1bHQuXG4gKiBUaGVzZSB0d28gYXJlIGFscmVhZHkgcGFzc2l2ZSB2aWEgYnJvd3NlciBkZWZhdWx0cyBvbiB3aW5kb3csIGRvY3VtZW50IGFuZCBib2R5LlxuICogQnV0IHNpbmNlXG4gKiAtIHdlJ3JlIGRlbGVnYXRpbmcgdGhlbVxuICogLSB0aGV5IGhhcHBlbiBvZnRlblxuICogLSB0aGV5IGFwcGx5IHRvIG1vYmlsZSB3aGljaCBpcyBnZW5lcmFsbHkgbGVzcyBwZXJmb3JtYW50XG4gKiB3ZSdyZSBtYXJraW5nIHRoZW0gYXMgcGFzc2l2ZSBieSBkZWZhdWx0IGZvciBvdGhlciBlbGVtZW50cywgdG9vLlxuICovXG5jb25zdCBQQVNTSVZFX0VWRU5UUyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBwYXNzaXZlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcGFzc2l2ZV9ldmVudChuYW1lKSB7XG5cdHJldHVybiBQQVNTSVZFX0VWRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgQ09OVEVOVF9FRElUQUJMRV9CSU5ESU5HUyA9IFsndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJywgJ2lubmVyVGV4dCddO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jb250ZW50X2VkaXRhYmxlX2JpbmRpbmcobmFtZSkge1xuXHRyZXR1cm4gQ09OVEVOVF9FRElUQUJMRV9CSU5ESU5HUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTE9BRF9FUlJPUl9FTEVNRU5UUyA9IFtcblx0J2JvZHknLFxuXHQnZW1iZWQnLFxuXHQnaWZyYW1lJyxcblx0J2ltZycsXG5cdCdsaW5rJyxcblx0J29iamVjdCcsXG5cdCdzY3JpcHQnLFxuXHQnc3R5bGUnLFxuXHQndHJhY2snXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50IGVtaXRzIGBsb2FkYCBhbmQgYGVycm9yYCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19sb2FkX2Vycm9yX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gTE9BRF9FUlJPUl9FTEVNRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgU1ZHX0VMRU1FTlRTID0gW1xuXHQnYWx0R2x5cGgnLFxuXHQnYWx0R2x5cGhEZWYnLFxuXHQnYWx0R2x5cGhJdGVtJyxcblx0J2FuaW1hdGUnLFxuXHQnYW5pbWF0ZUNvbG9yJyxcblx0J2FuaW1hdGVNb3Rpb24nLFxuXHQnYW5pbWF0ZVRyYW5zZm9ybScsXG5cdCdjaXJjbGUnLFxuXHQnY2xpcFBhdGgnLFxuXHQnY29sb3ItcHJvZmlsZScsXG5cdCdjdXJzb3InLFxuXHQnZGVmcycsXG5cdCdkZXNjJyxcblx0J2Rpc2NhcmQnLFxuXHQnZWxsaXBzZScsXG5cdCdmZUJsZW5kJyxcblx0J2ZlQ29sb3JNYXRyaXgnLFxuXHQnZmVDb21wb25lbnRUcmFuc2ZlcicsXG5cdCdmZUNvbXBvc2l0ZScsXG5cdCdmZUNvbnZvbHZlTWF0cml4Jyxcblx0J2ZlRGlmZnVzZUxpZ2h0aW5nJyxcblx0J2ZlRGlzcGxhY2VtZW50TWFwJyxcblx0J2ZlRGlzdGFudExpZ2h0Jyxcblx0J2ZlRHJvcFNoYWRvdycsXG5cdCdmZUZsb29kJyxcblx0J2ZlRnVuY0EnLFxuXHQnZmVGdW5jQicsXG5cdCdmZUZ1bmNHJyxcblx0J2ZlRnVuY1InLFxuXHQnZmVHYXVzc2lhbkJsdXInLFxuXHQnZmVJbWFnZScsXG5cdCdmZU1lcmdlJyxcblx0J2ZlTWVyZ2VOb2RlJyxcblx0J2ZlTW9ycGhvbG9neScsXG5cdCdmZU9mZnNldCcsXG5cdCdmZVBvaW50TGlnaHQnLFxuXHQnZmVTcGVjdWxhckxpZ2h0aW5nJyxcblx0J2ZlU3BvdExpZ2h0Jyxcblx0J2ZlVGlsZScsXG5cdCdmZVR1cmJ1bGVuY2UnLFxuXHQnZmlsdGVyJyxcblx0J2ZvbnQnLFxuXHQnZm9udC1mYWNlJyxcblx0J2ZvbnQtZmFjZS1mb3JtYXQnLFxuXHQnZm9udC1mYWNlLW5hbWUnLFxuXHQnZm9udC1mYWNlLXNyYycsXG5cdCdmb250LWZhY2UtdXJpJyxcblx0J2ZvcmVpZ25PYmplY3QnLFxuXHQnZycsXG5cdCdnbHlwaCcsXG5cdCdnbHlwaFJlZicsXG5cdCdoYXRjaCcsXG5cdCdoYXRjaHBhdGgnLFxuXHQnaGtlcm4nLFxuXHQnaW1hZ2UnLFxuXHQnbGluZScsXG5cdCdsaW5lYXJHcmFkaWVudCcsXG5cdCdtYXJrZXInLFxuXHQnbWFzaycsXG5cdCdtZXNoJyxcblx0J21lc2hncmFkaWVudCcsXG5cdCdtZXNocGF0Y2gnLFxuXHQnbWVzaHJvdycsXG5cdCdtZXRhZGF0YScsXG5cdCdtaXNzaW5nLWdseXBoJyxcblx0J21wYXRoJyxcblx0J3BhdGgnLFxuXHQncGF0dGVybicsXG5cdCdwb2x5Z29uJyxcblx0J3BvbHlsaW5lJyxcblx0J3JhZGlhbEdyYWRpZW50Jyxcblx0J3JlY3QnLFxuXHQnc2V0Jyxcblx0J3NvbGlkY29sb3InLFxuXHQnc3RvcCcsXG5cdCdzdmcnLFxuXHQnc3dpdGNoJyxcblx0J3N5bWJvbCcsXG5cdCd0ZXh0Jyxcblx0J3RleHRQYXRoJyxcblx0J3RyZWYnLFxuXHQndHNwYW4nLFxuXHQndW5rbm93bicsXG5cdCd1c2UnLFxuXHQndmlldycsXG5cdCd2a2Vybidcbl07XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3N2ZyhuYW1lKSB7XG5cdHJldHVybiBTVkdfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE1BVEhNTF9FTEVNRU5UUyA9IFtcblx0J2Fubm90YXRpb24nLFxuXHQnYW5ub3RhdGlvbi14bWwnLFxuXHQnbWFjdGlvbicsXG5cdCdtYXRoJyxcblx0J21lcnJvcicsXG5cdCdtZnJhYycsXG5cdCdtaScsXG5cdCdtbXVsdGlzY3JpcHRzJyxcblx0J21uJyxcblx0J21vJyxcblx0J21vdmVyJyxcblx0J21wYWRkZWQnLFxuXHQnbXBoYW50b20nLFxuXHQnbXByZXNjcmlwdHMnLFxuXHQnbXJvb3QnLFxuXHQnbXJvdycsXG5cdCdtcycsXG5cdCdtc3BhY2UnLFxuXHQnbXNxcnQnLFxuXHQnbXN0eWxlJyxcblx0J21zdWInLFxuXHQnbXN1YnN1cCcsXG5cdCdtc3VwJyxcblx0J210YWJsZScsXG5cdCdtdGQnLFxuXHQnbXRleHQnLFxuXHQnbXRyJyxcblx0J211bmRlcicsXG5cdCdtdW5kZXJvdmVyJyxcblx0J3NlbWFudGljcydcbl07XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX21hdGhtbChuYW1lKSB7XG5cdHJldHVybiBNQVRITUxfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFJVTkVTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0JyRzdGF0ZScsXG5cdCckc3RhdGUucmF3Jyxcblx0JyRzdGF0ZS5zbmFwc2hvdCcsXG5cdCckcHJvcHMnLFxuXHQnJGJpbmRhYmxlJyxcblx0JyRkZXJpdmVkJyxcblx0JyRkZXJpdmVkLmJ5Jyxcblx0JyRlZmZlY3QnLFxuXHQnJGVmZmVjdC5wcmUnLFxuXHQnJGVmZmVjdC50cmFja2luZycsXG5cdCckZWZmZWN0LnJvb3QnLFxuXHQnJGluc3BlY3QnLFxuXHQnJGluc3BlY3QoKS53aXRoJyxcblx0JyRpbnNwZWN0LnRyYWNlJyxcblx0JyRob3N0J1xuXSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFJVTkVTW251bWJlcl19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19ydW5lKG5hbWUpIHtcblx0cmV0dXJuIFJVTkVTLmluY2x1ZGVzKC8qKiBAdHlwZSB7UlVORVNbbnVtYmVyXX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqIExpc3Qgb2YgZWxlbWVudHMgdGhhdCByZXF1aXJlIHJhdyBjb250ZW50cyBhbmQgc2hvdWxkIG5vdCBoYXZlIFNTUiBjb21tZW50cyBwdXQgaW4gdGhlbSAqL1xuY29uc3QgUkFXX1RFWFRfRUxFTUVOVFMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWyd0ZXh0YXJlYScsICdzY3JpcHQnLCAnc3R5bGUnLCAndGl0bGUnXSk7XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Jhd190ZXh0X2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gUkFXX1RFWFRfRUxFTUVOVFMuaW5jbHVkZXMoLyoqIEB0eXBlIHtSQVdfVEVYVF9FTEVNRU5UU1tudW1iZXJdfSAqLyAobmFtZSkpO1xufVxuXG4vKipcbiAqIFByZXZlbnQgZGV2dG9vbHMgdHJ5aW5nIHRvIG1ha2UgYGxvY2F0aW9uYCBhIGNsaWNrYWJsZSBsaW5rIGJ5IGluc2VydGluZyBhIHplcm8td2lkdGggc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfbG9jYXRpb24obG9jYXRpb24pIHtcblx0cmV0dXJuIGxvY2F0aW9uPy5yZXBsYWNlKC9cXC8vZywgJy9cXHUyMDBiJyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB0cnVlO1xuIiwiLy8gU3RvcmUgdGhlIHJlZmVyZW5jZXMgdG8gZ2xvYmFscyBpbiBjYXNlIHNvbWVvbmUgdHJpZXMgdG8gbW9ua2V5IHBhdGNoIHRoZXNlLCBjYXVzaW5nIHRoZSBiZWxvd1xuLy8gdG8gZGUtb3B0ICh0aGlzIG9jY3VycyBvZnRlbiB3aGVuIHVzaW5nIHBvcHVsYXIgZXh0ZW5zaW9ucykuXG5leHBvcnQgdmFyIGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydCB2YXIgYXJyYXlfZnJvbSA9IEFycmF5LmZyb207XG5leHBvcnQgdmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXM7XG5leHBvcnQgdmFyIGRlZmluZV9wcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydCB2YXIgZ2V0X2Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZXhwb3J0IHZhciBnZXRfZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbmV4cG9ydCB2YXIgb2JqZWN0X3Byb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5leHBvcnQgdmFyIGFycmF5X3Byb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgZ2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBjb25zdCBub29wID0gKCkgPT4ge307XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuLyoqXG4gKiBAdGVtcGxhdGUgW1Q9YW55XVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUHJvbWlzZUxpa2U8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWU/LnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuLyoqIEBwYXJhbSB7QXJyYXk8KCkgPT4gdm9pZD59IGFyciAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoYXJyKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJyW2ldKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUT0RPIHJlcGxhY2Ugd2l0aCBQcm9taXNlLndpdGhSZXNvbHZlcnMgb25jZSBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaFxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuXHQvKiogQHR5cGUgeyh2YWx1ZTogVCkgPT4gdm9pZH0gKi9cblx0dmFyIHJlc29sdmU7XG5cblx0LyoqIEB0eXBlIHsocmVhc29uOiBhbnkpID0+IHZvaWR9ICovXG5cdHZhciByZWplY3Q7XG5cblx0LyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqL1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdHJlc29sdmUgPSByZXM7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHR9KTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge1YgfCAoKCkgPT4gVil9IGZhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsYXp5XVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWxsYmFjayh2YWx1ZSwgZmFsbGJhY2ssIGxhenkgPSBmYWxzZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuXHRcdD8gbGF6eVxuXHRcdFx0PyAvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykoKVxuXHRcdFx0OiAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjaylcblx0XHQ6IHZhbHVlO1xufVxuIiwiZXhwb3J0IGNvbnN0IERFUklWRUQgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgRUZGRUNUID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFJFTkRFUl9FRkZFQ1QgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgQkxPQ0tfRUZGRUNUID0gMSA8PCA0O1xuZXhwb3J0IGNvbnN0IEJSQU5DSF9FRkZFQ1QgPSAxIDw8IDU7XG5leHBvcnQgY29uc3QgUk9PVF9FRkZFQ1QgPSAxIDw8IDY7XG5leHBvcnQgY29uc3QgQk9VTkRBUllfRUZGRUNUID0gMSA8PCA3O1xuZXhwb3J0IGNvbnN0IFVOT1dORUQgPSAxIDw8IDg7XG5leHBvcnQgY29uc3QgRElTQ09OTkVDVEVEID0gMSA8PCA5O1xuZXhwb3J0IGNvbnN0IENMRUFOID0gMSA8PCAxMDtcbmV4cG9ydCBjb25zdCBESVJUWSA9IDEgPDwgMTE7XG5leHBvcnQgY29uc3QgTUFZQkVfRElSVFkgPSAxIDw8IDEyO1xuZXhwb3J0IGNvbnN0IElORVJUID0gMSA8PCAxMztcbmV4cG9ydCBjb25zdCBERVNUUk9ZRUQgPSAxIDw8IDE0O1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9SQU4gPSAxIDw8IDE1O1xuLyoqICdUcmFuc3BhcmVudCcgZWZmZWN0cyBkbyBub3QgY3JlYXRlIGEgdHJhbnNpdGlvbiBib3VuZGFyeSAqL1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9UUkFOU1BBUkVOVCA9IDEgPDwgMTY7XG4vKiogU3ZlbHRlIDQgbGVnYWN5IG1vZGUgcHJvcHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggZGVyaXZlZHMgYW5kIGJlIHJlY29nbml6ZWQgZWxzZXdoZXJlLCBoZW5jZSB0aGUgZGVkaWNhdGVkIGZsYWcgKi9cbmV4cG9ydCBjb25zdCBMRUdBQ1lfREVSSVZFRF9QUk9QID0gMSA8PCAxNztcbmV4cG9ydCBjb25zdCBJTlNQRUNUX0VGRkVDVCA9IDEgPDwgMTg7XG5leHBvcnQgY29uc3QgSEVBRF9FRkZFQ1QgPSAxIDw8IDE5O1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9IQVNfREVSSVZFRCA9IDEgPDwgMjA7XG5cbmV4cG9ydCBjb25zdCBTVEFURV9TWU1CT0wgPSBTeW1ib2woJyRzdGF0ZScpO1xuZXhwb3J0IGNvbnN0IFNUQVRFX1NZTUJPTF9NRVRBREFUQSA9IFN5bWJvbCgnJHN0YXRlIG1ldGFkYXRhJyk7XG5leHBvcnQgY29uc3QgTEVHQUNZX1BST1BTID0gU3ltYm9sKCdsZWdhY3kgcHJvcHMnKTtcbmV4cG9ydCBjb25zdCBMT0FESU5HX0FUVFJfU1lNQk9MID0gU3ltYm9sKCcnKTtcbiIsIi8qKiBAaW1wb3J0IHsgRXF1YWxzIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAdHlwZSB7RXF1YWxzfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHRoaXMudjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGFcblx0XHQ/IGIgPT0gYlxuXHRcdDogYSAhPT0gYiB8fCAoYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gYVxuICogQHBhcmFtIHt1bmtub3dufSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9PSBiO1xufVxuXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX2VxdWFscyh2YWx1ZSkge1xuXHRyZXR1cm4gIXNhZmVfbm90X2VxdWFsKHZhbHVlLCB0aGlzLnYpO1xufVxuIiwiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuLyoqXG4gKiBVc2luZyBgYmluZDp2YWx1ZWAgdG9nZXRoZXIgd2l0aCBhIGNoZWNrYm94IGlucHV0IGlzIG5vdCBhbGxvd2VkLiBVc2UgYGJpbmQ6Y2hlY2tlZGAgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZVxcblVzaW5nIFxcYGJpbmQ6dmFsdWVcXGAgdG9nZXRoZXIgd2l0aCBhIGNoZWNrYm94IGlucHV0IGlzIG5vdCBhbGxvd2VkLiBVc2UgXFxgYmluZDpjaGVja2VkXFxgIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogQ29tcG9uZW50ICVjb21wb25lbnQlIGhhcyBhbiBleHBvcnQgbmFtZWQgYCVrZXklYCB0aGF0IGEgY29uc3VtZXIgY29tcG9uZW50IGlzIHRyeWluZyB0byBhY2Nlc3MgdXNpbmcgYGJpbmQ6JWtleSVgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgYGJpbmQ6dGhpc2AgKGUuZy4gYDwlbmFtZSUgYmluZDp0aGlzPXtjb21wb25lbnR9IC8+YCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIGBjb21wb25lbnQuJWtleSVgKVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfaW52YWxpZF9leHBvcnQoY29tcG9uZW50LCBrZXksIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX2ludmFsaWRfZXhwb3J0XFxuQ29tcG9uZW50ICR7Y29tcG9uZW50fSBoYXMgYW4gZXhwb3J0IG5hbWVkIFxcYCR7a2V5fVxcYCB0aGF0IGEgY29uc3VtZXIgY29tcG9uZW50IGlzIHRyeWluZyB0byBhY2Nlc3MgdXNpbmcgXFxgYmluZDoke2tleX1cXGAsIHdoaWNoIGlzIGRpc2FsbG93ZWQuIEluc3RlYWQsIHVzZSBcXGBiaW5kOnRoaXNcXGAgKGUuZy4gXFxgPCR7bmFtZX0gYmluZDp0aGlzPXtjb21wb25lbnR9IC8+XFxgKSBhbmQgdGhlbiBhY2Nlc3MgdGhlIHByb3BlcnR5IG9uIHRoZSBib3VuZCBjb21wb25lbnQgaW5zdGFuY2UgKGUuZy4gXFxgY29tcG9uZW50LiR7a2V5fVxcYClcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgYCVrZXklYCBiZWxvbmdpbmcgdG8gJWNvbXBvbmVudCUgKGkuZS4gYDwlbmFtZSUgYmluZDola2V5JT17Li4ufT5gKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBgbGV0IHsgJWtleSUgPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClgXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ub3RfYmluZGFibGUoa2V5LCBjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX25vdF9iaW5kYWJsZVxcbkEgY29tcG9uZW50IGlzIGF0dGVtcHRpbmcgdG8gYmluZCB0byBhIG5vbi1iaW5kYWJsZSBwcm9wZXJ0eSBcXGAke2tleX1cXGAgYmVsb25naW5nIHRvICR7Y29tcG9uZW50fSAoaS5lLiBcXGA8JHtuYW1lfSBiaW5kOiR7a2V5fT17Li4ufT5cXGApLiBUbyBtYXJrIGEgcHJvcGVydHkgYXMgYmluZGFibGU6IFxcYGxldCB7ICR7a2V5fSA9ICRiaW5kYWJsZSgpIH0gPSAkcHJvcHMoKVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfbm90X2JpbmRhYmxlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX25vdF9iaW5kYWJsZWApO1xuXHR9XG59XG5cbi8qKlxuICogJXBhcmVudCUgY2FsbGVkIGAlbWV0aG9kJWAgb24gYW4gaW5zdGFuY2Ugb2YgJWNvbXBvbmVudCUsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X2FwaV9jaGFuZ2VkKHBhcmVudCwgbWV0aG9kLCBjb21wb25lbnQpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjb21wb25lbnRfYXBpX2NoYW5nZWRcXG4ke3BhcmVudH0gY2FsbGVkIFxcYCR7bWV0aG9kfVxcYCBvbiBhbiBpbnN0YW5jZSBvZiAke2NvbXBvbmVudH0sIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0ZWQgdG8gaW5zdGFudGlhdGUgJWNvbXBvbmVudCUgd2l0aCBgbmV3ICVuYW1lJWAsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNS4gSWYgdGhpcyBjb21wb25lbnQgaXMgbm90IHVuZGVyIHlvdXIgY29udHJvbCwgc2V0IHRoZSBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGlgIGNvbXBpbGVyIG9wdGlvbiB0byBgNGAgdG8ga2VlcCBpdCB3b3JraW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXcoY29tcG9uZW50LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld1xcbkF0dGVtcHRlZCB0byBpbnN0YW50aWF0ZSAke2NvbXBvbmVudH0gd2l0aCBcXGBuZXcgJHtuYW1lfVxcYCwgd2hpY2ggaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1LiBJZiB0aGlzIGNvbXBvbmVudCBpcyBub3QgdW5kZXIgeW91ciBjb250cm9sLCBzZXQgdGhlIFxcYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpXFxgIGNvbXBpbGVyIG9wdGlvbiB0byBcXGA0XFxgIHRvIGtlZXAgaXQgd29ya2luZy5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGRlcml2ZWQgdmFsdWUgY2Fubm90IHJlZmVyZW5jZSBpdHNlbGYgcmVjdXJzaXZlbHlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGRlcml2ZWRfcmVmZXJlbmNlc19zZWxmXFxuQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGZgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IGAldmFsdWUlYCBhdCBpbmRleGVzICVhJSBhbmQgJWIlXG4gKiBAcGFyYW0ge3N0cmluZ30gYVxuICogQHBhcmFtIHtzdHJpbmd9IGJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW3ZhbHVlXVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaF9rZXlfZHVwbGljYXRlKGEsIGIsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWFjaF9rZXlfZHVwbGljYXRlXFxuJHt2YWx1ZSA/IGBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IFxcYCR7dmFsdWV9XFxgIGF0IGluZGV4ZXMgJHthfSBhbmQgJHtifWAgOiBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWFjaF9rZXlfZHVwbGljYXRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJXJ1bmUlYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IGNsZWFudXAgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdGVhcmRvd24ocnVuZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl90ZWFyZG93blxcblxcYCR7cnVuZX1cXGAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3RlYXJkb3duYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdGVhcmRvd25gKTtcblx0fVxufVxuXG4vKipcbiAqIEVmZmVjdCBjYW5ub3QgYmUgY3JlYXRlZCBpbnNpZGUgYSBgJGRlcml2ZWRgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRcXG5FZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgXFxgJGRlcml2ZWRcXGAgdmFsdWUgdGhhdCB3YXMgbm90IGl0c2VsZiBjcmVhdGVkIGluc2lkZSBhbiBlZmZlY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJXJ1bmUlYCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgKGUuZy4gZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbilcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3Rfb3JwaGFuKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3Rfb3JwaGFuXFxuXFxgJHtydW5lfVxcYCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgKGUuZy4gZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbilcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3Rfb3JwaGFuYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3Rfb3JwaGFuYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSByZWFjdGl2ZSBibG9jayBvciBlZmZlY3QgcmVwZWF0ZWRseSBzZXRzIGEgbmV3IHZhbHVlLiBTdmVsdGUgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkXFxuTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgcmVhY3RpdmUgYmxvY2sgb3IgZWZmZWN0IHJlcGVhdGVkbHkgc2V0cyBhIG5ldyB2YWx1ZS4gU3ZlbHRlIGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBGYWlsZWQgdG8gaHlkcmF0ZSB0aGUgYXBwbGljYXRpb25cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9mYWlsZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaHlkcmF0aW9uX2ZhaWxlZFxcbkZhaWxlZCB0byBoeWRyYXRlIHRoZSBhcHBsaWNhdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9mYWlsZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9mYWlsZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENvdWxkIG5vdCBge0ByZW5kZXJ9YCBzbmlwcGV0IGR1ZSB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIGB7QHJlbmRlciBzbmlwcGV0Py4oKX1gXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9zbmlwcGV0XFxuQ291bGQgbm90IFxcYHtAcmVuZGVyfVxcYCBzbmlwcGV0IGR1ZSB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYC4gQ29uc2lkZXIgdXNpbmcgb3B0aW9uYWwgY2hhaW5pbmcgXFxge0ByZW5kZXIgc25pcHBldD8uKCl9XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2Fubm90IGJlIHVzZWQgaW4gcnVuZXMgbW9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9sZWdhY3lfb25seShuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5XFxuXFxgJHtuYW1lfSguLi4pXFxgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9sZWdhY3lfb25seWApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IGRvIGBiaW5kOiVrZXklPXt1bmRlZmluZWR9YCB3aGVuIGAla2V5JWAgaGFzIGEgZmFsbGJhY2sgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX2ludmFsaWRfdmFsdWUoa2V5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfaW52YWxpZF92YWx1ZVxcbkNhbm5vdCBkbyBcXGBiaW5kOiR7a2V5fT17dW5kZWZpbmVkfVxcYCB3aGVuIFxcYCR7a2V5fVxcYCBoYXMgYSBmYWxsYmFjayB2YWx1ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX2ludmFsaWRfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX2ludmFsaWRfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIFJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIGAkcHJvcHMoKWAgc3VjaCBhcyBgJXByb3BlcnR5JWAgYXJlIHJlYWRvbmx5XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX3Jlc3RfcmVhZG9ubHkocHJvcGVydHkpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBwcm9wc19yZXN0X3JlYWRvbmx5XFxuUmVzdCBlbGVtZW50IHByb3BlcnRpZXMgb2YgXFxgJHByb3BzKClcXGAgc3VjaCBhcyBcXGAke3Byb3BlcnR5fVxcYCBhcmUgcmVhZG9ubHlcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYCVydW5lJWAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgYC5zdmVsdGVgIGFuZCBgLnN2ZWx0ZS5qcy90c2AgZmlsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBydW5lX291dHNpZGVfc3ZlbHRlXFxuVGhlIFxcYCR7cnVuZX1cXGAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgXFxgLnN2ZWx0ZVxcYCBhbmQgXFxgLnN2ZWx0ZS5qcy90c1xcYCBmaWxlc1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblx0fVxufVxuXG4vKipcbiAqIFByb3BlcnR5IGRlc2NyaXB0b3JzIGRlZmluZWQgb24gYCRzdGF0ZWAgb2JqZWN0cyBtdXN0IGNvbnRhaW4gYHZhbHVlYCBhbmQgYWx3YXlzIGJlIGBlbnVtZXJhYmxlYCwgYGNvbmZpZ3VyYWJsZWAgYW5kIGB3cml0YWJsZWAuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9kZXNjcmlwdG9yc19maXhlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV9kZXNjcmlwdG9yc19maXhlZFxcblByb3BlcnR5IGRlc2NyaXB0b3JzIGRlZmluZWQgb24gXFxgJHN0YXRlXFxgIG9iamVjdHMgbXVzdCBjb250YWluIFxcYHZhbHVlXFxgIGFuZCBhbHdheXMgYmUgXFxgZW51bWVyYWJsZVxcYCwgXFxgY29uZmlndXJhYmxlXFxgIGFuZCBcXGB3cml0YWJsZVxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9kZXNjcmlwdG9yc19maXhlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBzZXQgcHJvdG90eXBlIG9mIGAkc3RhdGVgIG9iamVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Byb3RvdHlwZV9maXhlZFxcbkNhbm5vdCBzZXQgcHJvdG90eXBlIG9mIFxcYCRzdGF0ZVxcYCBvYmplY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3RvdHlwZV9maXhlZGApO1xuXHR9XG59XG5cbi8qKlxuICogUmVhZGluZyBzdGF0ZSB0aGF0IHdhcyBjcmVhdGVkIGluc2lkZSB0aGUgc2FtZSBkZXJpdmVkIGlzIGZvcmJpZGRlbi4gQ29uc2lkZXIgdXNpbmcgYHVudHJhY2tgIHRvIHJlYWQgbG9jYWxseSBjcmVhdGVkIHN0YXRlXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV91bnNhZmVfbG9jYWxfcmVhZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV91bnNhZmVfbG9jYWxfcmVhZFxcblJlYWRpbmcgc3RhdGUgdGhhdCB3YXMgY3JlYXRlZCBpbnNpZGUgdGhlIHNhbWUgZGVyaXZlZCBpcyBmb3JiaWRkZW4uIENvbnNpZGVyIHVzaW5nIFxcYHVudHJhY2tcXGAgdG8gcmVhZCBsb2NhbGx5IGNyZWF0ZWQgc3RhdGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbG9jYWxfcmVhZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFVwZGF0aW5nIHN0YXRlIGluc2lkZSBhIGRlcml2ZWQgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBgJHN0YXRlYFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfdW5zYWZlX211dGF0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Vuc2FmZV9tdXRhdGlvblxcblVwZGF0aW5nIHN0YXRlIGluc2lkZSBhIGRlcml2ZWQgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBcXGAkc3RhdGVcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbXV0YXRpb25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9tdXRhdGlvbmApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTb3VyY2UsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0Y29tcG9uZW50X2NvbnRleHQsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0bmV3X2RlcHMsXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVudHJhY2tlZF93cml0ZXMsXG5cdGdldCxcblx0aXNfcnVuZXMsXG5cdHNjaGVkdWxlX2VmZmVjdCxcblx0c2V0X3VudHJhY2tlZF93cml0ZXMsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRpbmNyZW1lbnRfdmVyc2lvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0ZGVyaXZlZF9zb3VyY2VzLFxuXHRzZXRfZGVyaXZlZF9zb3VyY2VzLFxuXHRjaGVja19kaXJ0aW5lc3MsXG5cdHNldF9pc19mbHVzaGluZ19lZmZlY3QsXG5cdGlzX2ZsdXNoaW5nX2VmZmVjdFxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVxdWFscywgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCB7XG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRESVJUWSxcblx0QlJBTkNIX0VGRkVDVCxcblx0SU5TUEVDVF9FRkZFQ1QsXG5cdFVOT1dORUQsXG5cdE1BWUJFX0RJUlRZLFxuXHRCTE9DS19FRkZFQ1Rcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcsIHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrIH0gZnJvbSAnLi4vZGV2L3RyYWNpbmcuanMnO1xuXG5leHBvcnQgbGV0IGluc3BlY3RfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1NldDxhbnk+fSB2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5zcGVjdF9lZmZlY3RzKHYpIHtcblx0aW5zcGVjdF9lZmZlY3RzID0gdjtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge0Vycm9yIHwgbnVsbH0gW3N0YWNrXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZSh2LCBzdGFjaykge1xuXHQvKiogQHR5cGUge1ZhbHVlfSAqL1xuXHR2YXIgc2lnbmFsID0ge1xuXHRcdGY6IDAsIC8vIFRPRE8gaWRlYWxseSB3ZSBjb3VsZCBza2lwIHRoaXMgYWx0b2dldGhlciwgYnV0IGl0IGNhdXNlcyB0eXBlIGVycm9yc1xuXHRcdHYsXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdGVxdWFscyxcblx0XHR2ZXJzaW9uOiAwXG5cdH07XG5cblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHNpZ25hbC5jcmVhdGVkID0gc3RhY2sgPz8gZ2V0X3N0YWNrKCdDcmVhdGVkQXQnKTtcblx0XHRzaWduYWwuZGVidWcgPSBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZSh2KSB7XG5cdHJldHVybiBwdXNoX2Rlcml2ZWRfc291cmNlKHNvdXJjZSh2KSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gaW5pdGlhbF92YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gbXV0YWJsZV9zb3VyY2UoaW5pdGlhbF92YWx1ZSwgaW1tdXRhYmxlID0gZmFsc2UpIHtcblx0Y29uc3QgcyA9IHNvdXJjZShpbml0aWFsX3ZhbHVlKTtcblx0aWYgKCFpbW11dGFibGUpIHtcblx0XHRzLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHR9XG5cblx0Ly8gYmluZCB0aGUgc2lnbmFsIHRvIHRoZSBjb21wb25lbnQgY29udGV4dCwgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdC8vIHRyYWNrIHVwZGF0ZXMgdG8gdHJpZ2dlciBiZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzXG5cdGlmIChsZWdhY3lfbW9kZV9mbGFnICYmIGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsICYmIGNvbXBvbmVudF9jb250ZXh0LmwgIT09IG51bGwpIHtcblx0XHQoY29tcG9uZW50X2NvbnRleHQubC5zID8/PSBbXSkucHVzaChzKTtcblx0fVxuXG5cdHJldHVybiBzO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXRhYmxlX3N0YXRlKHYsIGltbXV0YWJsZSA9IGZhbHNlKSB7XG5cdHJldHVybiBwdXNoX2Rlcml2ZWRfc291cmNlKG11dGFibGVfc291cmNlKHYsIGltbXV0YWJsZSkpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1NvdXJjZTxWPn0gc291cmNlXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcHVzaF9kZXJpdmVkX3NvdXJjZShzb3VyY2UpIHtcblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdGlmIChkZXJpdmVkX3NvdXJjZXMgPT09IG51bGwpIHtcblx0XHRcdHNldF9kZXJpdmVkX3NvdXJjZXMoW3NvdXJjZV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXJpdmVkX3NvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzb3VyY2U7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXV0YXRlKHNvdXJjZSwgdmFsdWUpIHtcblx0c2V0KFxuXHRcdHNvdXJjZSxcblx0XHR1bnRyYWNrKCgpID0+IGdldChzb3VyY2UpKVxuXHQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHNvdXJjZSwgdmFsdWUpIHtcblx0aWYgKFxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdGlzX3J1bmVzKCkgJiZcblx0XHQoYWN0aXZlX3JlYWN0aW9uLmYgJiAoREVSSVZFRCB8IEJMT0NLX0VGRkVDVCkpICE9PSAwICYmXG5cdFx0Ly8gSWYgdGhlIHNvdXJjZSB3YXMgY3JlYXRlZCBsb2NhbGx5IHdpdGhpbiB0aGUgY3VycmVudCBkZXJpdmVkLCB0aGVuXG5cdFx0Ly8gd2UgYWxsb3cgdGhlIG11dGF0aW9uLlxuXHRcdChkZXJpdmVkX3NvdXJjZXMgPT09IG51bGwgfHwgIWRlcml2ZWRfc291cmNlcy5pbmNsdWRlcyhzb3VyY2UpKVxuXHQpIHtcblx0XHRlLnN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpO1xuXHR9XG5cblx0cmV0dXJuIGludGVybmFsX3NldChzb3VyY2UsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5hbF9zZXQoc291cmNlLCB2YWx1ZSkge1xuXHRpZiAoIXNvdXJjZS5lcXVhbHModmFsdWUpKSB7XG5cdFx0c291cmNlLnYgPSB2YWx1ZTtcblx0XHRzb3VyY2UudmVyc2lvbiA9IGluY3JlbWVudF92ZXJzaW9uKCk7XG5cblx0XHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0XHRzb3VyY2UudXBkYXRlZCA9IGdldF9zdGFjaygnVXBkYXRlZEF0Jyk7XG5cdFx0fVxuXG5cdFx0bWFya19yZWFjdGlvbnMoc291cmNlLCBESVJUWSk7XG5cblx0XHQvLyBJZiB0aGUgY3VycmVudCBzaWduYWwgaXMgcnVubmluZyBmb3IgdGhlIGZpcnN0IHRpbWUsIGl0IHdvbid0IGhhdmUgYW55XG5cdFx0Ly8gcmVhY3Rpb25zIGFzIHdlIG9ubHkgYWxsb2NhdGUgYW5kIGFzc2lnbiB0aGUgcmVhY3Rpb25zIGFmdGVyIHRoZSBzaWduYWxcblx0XHQvLyBoYXMgZnVsbHkgZXhlY3V0ZWQuIFNvIGluIHRoZSBjYXNlIG9mIGVuc3VyaW5nIGl0IHJlZ2lzdGVycyB0aGUgcmVhY3Rpb25cblx0XHQvLyBwcm9wZXJseSBmb3IgaXRzZWxmLCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgY3VycmVudCBlZmZlY3QgYWN0dWFsbHkgZ2V0c1xuXHRcdC8vIHNjaGVkdWxlZC4gaS5lOiBgJGVmZmVjdCgoKSA9PiB4KyspYFxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiZcblx0XHRcdChhY3RpdmVfZWZmZWN0LmYgJiBDTEVBTikgIT09IDAgJiZcblx0XHRcdChhY3RpdmVfZWZmZWN0LmYgJiBCUkFOQ0hfRUZGRUNUKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0aWYgKG5ld19kZXBzICE9PSBudWxsICYmIG5ld19kZXBzLmluY2x1ZGVzKHNvdXJjZSkpIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoYWN0aXZlX2VmZmVjdCwgRElSVFkpO1xuXHRcdFx0XHRzY2hlZHVsZV9lZmZlY3QoYWN0aXZlX2VmZmVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodW50cmFja2VkX3dyaXRlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHNldF91bnRyYWNrZWRfd3JpdGVzKFtzb3VyY2VdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1bnRyYWNrZWRfd3JpdGVzLnB1c2goc291cmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChERVYgJiYgaW5zcGVjdF9lZmZlY3RzLnNpemUgPiAwKSB7XG5cdFx0XHRjb25zdCBpbnNwZWN0cyA9IEFycmF5LmZyb20oaW5zcGVjdF9lZmZlY3RzKTtcblx0XHRcdHZhciBwcmV2aW91c2x5X2ZsdXNoaW5nX2VmZmVjdCA9IGlzX2ZsdXNoaW5nX2VmZmVjdDtcblx0XHRcdHNldF9pc19mbHVzaGluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVmZmVjdCBvZiBpbnNwZWN0cykge1xuXHRcdFx0XHRcdC8vIE1hcmsgY2xlYW4gaW5zcGVjdC1lZmZlY3RzIGFzIG1heWJlIGRpcnR5IGFuZCB0aGVuIGNoZWNrIHRoZWlyIGRpcnRpbmVzc1xuXHRcdFx0XHRcdC8vIGluc3RlYWQgb2YganVzdCB1cGRhdGluZyB0aGUgZWZmZWN0cyAtIHRoaXMgd2F5IHdlIGF2b2lkIG92ZXJmaXJpbmcuXG5cdFx0XHRcdFx0aWYgKChlZmZlY3QuZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoZWZmZWN0KSkge1xuXHRcdFx0XHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdChwcmV2aW91c2x5X2ZsdXNoaW5nX2VmZmVjdCk7XG5cdFx0XHR9XG5cdFx0XHRpbnNwZWN0X2VmZmVjdHMuY2xlYXIoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzIHNob3VsZCBiZSBESVJUWSBvciBNQVlCRV9ESVJUWVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIG1hcmtfcmVhY3Rpb25zKHNpZ25hbCwgc3RhdHVzKSB7XG5cdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zID09PSBudWxsKSByZXR1cm47XG5cblx0dmFyIHJ1bmVzID0gaXNfcnVuZXMoKTtcblx0dmFyIGxlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGg7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhciByZWFjdGlvbiA9IHJlYWN0aW9uc1tpXTtcblx0XHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdFx0Ly8gU2tpcCBhbnkgZWZmZWN0cyB0aGF0IGFyZSBhbHJlYWR5IGRpcnR5XG5cdFx0aWYgKChmbGFncyAmIERJUlRZKSAhPT0gMCkgY29udGludWU7XG5cblx0XHQvLyBJbiBsZWdhY3kgbW9kZSwgc2tpcCB0aGUgY3VycmVudCBlZmZlY3QgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdGlmICghcnVuZXMgJiYgcmVhY3Rpb24gPT09IGFjdGl2ZV9lZmZlY3QpIGNvbnRpbnVlO1xuXG5cdFx0Ly8gSW5zcGVjdCBlZmZlY3RzIG5lZWQgdG8gcnVuIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHRoZSBzdGFjayB0cmFjZSBtYWtlcyBzZW5zZVxuXHRcdGlmIChERVYgJiYgKGZsYWdzICYgSU5TUEVDVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRpbnNwZWN0X2VmZmVjdHMuYWRkKHJlYWN0aW9uKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBzdGF0dXMpO1xuXG5cdFx0Ly8gSWYgdGhlIHNpZ25hbCBhKSB3YXMgcHJldmlvdXNseSBjbGVhbiBvciBiKSBpcyBhbiB1bm93bmVkIGRlcml2ZWQsIHRoZW4gbWFyayBpdFxuXHRcdGlmICgoZmxhZ3MgJiAoQ0xFQU4gfCBVTk9XTkVEKSkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0XHRtYXJrX3JlYWN0aW9ucygvKiogQHR5cGUge0Rlcml2ZWR9ICovIChyZWFjdGlvbiksIE1BWUJFX0RJUlRZKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjaGVkdWxlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG52YXIgYm9sZCA9ICdmb250LXdlaWdodDogYm9sZCc7XG52YXIgbm9ybWFsID0gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG4vKipcbiAqIEFzc2lnbm1lbnQgdG8gYCVwcm9wZXJ0eSVgIHByb3BlcnR5ICglbG9jYXRpb24lKSB3aWxsIGV2YWx1YXRlIHRvIHRoZSByaWdodC1oYW5kIHNpZGUsIG5vdCB0aGUgdmFsdWUgb2YgYCVwcm9wZXJ0eSVgIGZvbGxvd2luZyB0aGUgYXNzaWdubWVudC4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbm1lbnRfdmFsdWVfc3RhbGUocHJvcGVydHksIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYXNzaWdubWVudF92YWx1ZV9zdGFsZVxcbiVjQXNzaWdubWVudCB0byBcXGAke3Byb3BlcnR5fVxcYCBwcm9wZXJ0eSAoJHtsb2NhdGlvbn0pIHdpbGwgZXZhbHVhdGUgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSwgbm90IHRoZSB2YWx1ZSBvZiBcXGAke3Byb3BlcnR5fVxcYCBmb2xsb3dpbmcgdGhlIGFzc2lnbm1lbnQuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hc3NpZ25tZW50X3ZhbHVlX3N0YWxlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Fzc2lnbm1lbnRfdmFsdWVfc3RhbGVgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlYmluZGluZyVgICglbG9jYXRpb24lKSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZShiaW5kaW5nLCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlXFxuJWMke2xvY2F0aW9uID8gYFxcYCR7YmluZGluZ31cXGAgKCR7bG9jYXRpb259KSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5YCA6IGBcXGAke2JpbmRpbmd9XFxgIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlgfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBZb3VyIGBjb25zb2xlLiVtZXRob2QlYCBjb250YWluZWQgYCRzdGF0ZWAgcHJveGllcy4gQ29uc2lkZXIgdXNpbmcgYCRpbnNwZWN0KC4uLilgIG9yIGAkc3RhdGUuc25hcHNob3QoLi4uKWAgaW5zdGVhZFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc29sZV9sb2dfc3RhdGUobWV0aG9kKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gY29uc29sZV9sb2dfc3RhdGVcXG4lY1lvdXIgXFxgY29uc29sZS4ke21ldGhvZH1cXGAgY29udGFpbmVkIFxcYCRzdGF0ZVxcYCBwcm94aWVzLiBDb25zaWRlciB1c2luZyBcXGAkaW5zcGVjdCguLi4pXFxgIG9yIFxcYCRzdGF0ZS5zbmFwc2hvdCguLi4pXFxgIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb25zb2xlX2xvZ19zdGF0ZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb25zb2xlX2xvZ19zdGF0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogJWhhbmRsZXIlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gdG8gJXN1Z2dlc3Rpb24lP1xuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWdnZXN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmVudF9oYW5kbGVyX2ludmFsaWQoaGFuZGxlciwgc3VnZ2VzdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGV2ZW50X2hhbmRsZXJfaW52YWxpZFxcbiVjJHtoYW5kbGVyfSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBtZWFuIHRvICR7c3VnZ2VzdGlvbn0/XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZXZlbnRfaGFuZGxlcl9pbnZhbGlkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2V2ZW50X2hhbmRsZXJfaW52YWxpZGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGAlYXR0cmlidXRlJWAgYXR0cmlidXRlIG9uIGAlaHRtbCVgIGNoYW5nZWQgaXRzIHZhbHVlIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSwgYCV2YWx1ZSVgLCB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZChhdHRyaWJ1dGUsIGh0bWwsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkXFxuJWNUaGUgXFxgJHthdHRyaWJ1dGV9XFxgIGF0dHJpYnV0ZSBvbiBcXGAke2h0bWx9XFxgIGNoYW5nZWQgaXRzIHZhbHVlIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSwgXFxgJHt2YWx1ZX1cXGAsIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrICVsb2NhdGlvbiUgY2hhbmdlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9odG1sX2NoYW5nZWQobG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBoeWRyYXRpb25faHRtbF9jaGFuZ2VkXFxuJWMke2xvY2F0aW9uID8gYFRoZSB2YWx1ZSBvZiBhbiBcXGB7QGh0bWwgLi4ufVxcYCBibG9jayAke2xvY2F0aW9ufSBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVgIDogXCJUaGUgdmFsdWUgb2YgYW4gYHtAaHRtbCAuLi59YCBibG9jayBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcIn1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25faHRtbF9jaGFuZ2VkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9odG1sX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAlbG9jYXRpb24lXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9taXNtYXRjaChsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9taXNtYXRjaFxcbiVjJHtsb2NhdGlvbiA/IGBIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci4gVGhlIGVycm9yIG9jY3VycmVkIG5lYXIgJHtsb2NhdGlvbn1gIDogXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlclwifVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fbWlzbWF0Y2hgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgcmVuZGVyYCBmdW5jdGlvbiBwYXNzZWQgdG8gYGNyZWF0ZVJhd1NuaXBwZXRgIHNob3VsZCByZXR1cm4gSFRNTCBmb3IgYSBzaW5nbGUgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJcXG4lY1RoZSBcXGByZW5kZXJcXGAgZnVuY3Rpb24gcGFzc2VkIHRvIFxcYGNyZWF0ZVJhd1NuaXBwZXRcXGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJgKTtcblx0fVxufVxuXG4vKipcbiAqIERldGVjdGVkIGEgbWlncmF0ZWQgYCQ6YCByZWFjdGl2ZSBibG9jayBpbiBgJWZpbGVuYW1lJWAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBgJGVmZmVjdGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2soZmlsZW5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBsZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrXFxuJWNEZXRlY3RlZCBhIG1pZ3JhdGVkIFxcYCQ6XFxgIHJlYWN0aXZlIGJsb2NrIGluIFxcYCR7ZmlsZW5hbWV9XFxgIHRoYXQgYm90aCBhY2Nlc3NlcyBhbmQgdXBkYXRlcyB0aGUgc2FtZSByZWFjdGl2ZSB2YWx1ZS4gVGhpcyBtYXkgY2F1c2UgcmVjdXJzaXZlIHVwZGF0ZXMgd2hlbiBjb252ZXJ0ZWQgdG8gYW4gXFxgJGVmZmVjdFxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9sZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgKTtcblx0fVxufVxuXG4vKipcbiAqIFRyaWVkIHRvIHVubW91bnQgYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IG1vdW50ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBsaWZlY3ljbGVfZG91YmxlX3VubW91bnRcXG4lY1RyaWVkIHRvIHVubW91bnQgYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IG1vdW50ZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlcGFyZW50JSBwYXNzZWQgYSB2YWx1ZSB0byAlY2hpbGQlIHdpdGggYGJpbmQ6YCwgYnV0IHRoZSB2YWx1ZSBpcyBvd25lZCBieSAlb3duZXIlLiBDb25zaWRlciBjcmVhdGluZyBhIGJpbmRpbmcgYmV0d2VlbiAlb3duZXIlIGFuZCAlcGFyZW50JVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3duZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcocGFyZW50LCBjaGlsZCwgb3duZXIpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nXFxuJWMke3BhcmVudH0gcGFzc2VkIGEgdmFsdWUgdG8gJHtjaGlsZH0gd2l0aCBcXGBiaW5kOlxcYCwgYnV0IHRoZSB2YWx1ZSBpcyBvd25lZCBieSAke293bmVyfS4gQ29uc2lkZXIgY3JlYXRpbmcgYSBiaW5kaW5nIGJldHdlZW4gJHtvd25lcn0gYW5kICR7cGFyZW50fVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogJWNvbXBvbmVudCUgbXV0YXRlZCBhIHZhbHVlIG93bmVkIGJ5ICVvd25lciUuIFRoaXMgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQuIENvbnNpZGVyIHBhc3NpbmcgdmFsdWVzIHRvIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBgYmluZDpgLCBvciB1c2UgYSBjYWxsYmFjayBpbnN0ZWFkXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtjb21wb25lbnRdXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtvd25lcl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKGNvbXBvbmVudCwgb3duZXIpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvblxcbiVjJHtjb21wb25lbnQgPyBgJHtjb21wb25lbnR9IG11dGF0ZWQgYSB2YWx1ZSBvd25lZCBieSAke293bmVyfS4gVGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgcGFzc2luZyB2YWx1ZXMgdG8gY2hpbGQgY29tcG9uZW50cyB3aXRoIFxcYGJpbmQ6XFxgLCBvciB1c2UgYSBjYWxsYmFjayBpbnN0ZWFkYCA6IFwiTXV0YXRpbmcgYSB2YWx1ZSBvdXRzaWRlIHRoZSBjb21wb25lbnQgdGhhdCBjcmVhdGVkIGl0IGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBDb25zaWRlciBwYXNzaW5nIHZhbHVlcyB0byBjaGlsZCBjb21wb25lbnRzIHdpdGggYGJpbmQ6YCwgb3IgdXNlIGEgY2FsbGJhY2sgaW5zdGVhZFwifVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWFjdGl2ZSBgJHN0YXRlKC4uLilgIHByb3hpZXMgYW5kIHRoZSB2YWx1ZXMgdGhleSBwcm94eSBoYXZlIGRpZmZlcmVudCBpZGVudGl0aWVzLiBCZWNhdXNlIG9mIHRoaXMsIGNvbXBhcmlzb25zIHdpdGggYCVvcGVyYXRvciVgIHdpbGwgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2gob3BlcmF0b3IpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBzdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaFxcbiVjUmVhY3RpdmUgXFxgJHN0YXRlKC4uLilcXGAgcHJveGllcyBhbmQgdGhlIHZhbHVlcyB0aGV5IHByb3h5IGhhdmUgZGlmZmVyZW50IGlkZW50aXRpZXMuIEJlY2F1c2Ugb2YgdGhpcywgY29tcGFyaXNvbnMgd2l0aCBcXGAke29wZXJhdG9yfVxcYCB3aWxsIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hgKTtcblx0fVxufSIsIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cblxuaW1wb3J0IHtcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX0VSUk9SLFxuXHRIWURSQVRJT05fU1RBUlQsXG5cdEhZRFJBVElPTl9TVEFSVF9FTFNFXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIFVzZSB0aGlzIHZhcmlhYmxlIHRvIGd1YXJkIGV2ZXJ5dGhpbmcgcmVsYXRlZCB0byBoeWRyYXRpb24gY29kZSBzbyBpdCBjYW4gYmUgdHJlZXNoYWtlbiBvdXRcbiAqIGlmIHRoZSB1c2VyIGRvZXNuJ3QgdXNlIHRoZSBgaHlkcmF0ZWAgbWV0aG9kIGFuZCB0aGVzZSBjb2RlIHBhdGhzIGFyZSB0aGVyZWZvcmUgbm90IG5lZWRlZC5cbiAqL1xuZXhwb3J0IGxldCBoeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0aW5nKHZhbHVlKSB7XG5cdGh5ZHJhdGluZyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBub2RlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGh5ZHJhdGVkLiBUaGlzIHN0YXJ0cyBvdXQgYXMgdGhlIGZpcnN0IG5vZGUgaW5zaWRlIHRoZSBvcGVuaW5nXG4gKiA8IS0tWy0tPiBjb21tZW50LCBhbmQgdXBkYXRlcyBlYWNoIHRpbWUgYSBjb21wb25lbnQgY2FsbHMgYCQuY2hpbGQoLi4uKWAgb3IgYCQuc2libGluZyguLi4pYC5cbiAqIFdoZW4gZW50ZXJpbmcgYSBibG9jayAoZS5nLiBgeyNpZiAuLi59YCksIGBoeWRyYXRlX25vZGVgIGlzIHRoZSBibG9jayBvcGVuaW5nIGNvbW1lbnQ7IGJ5IHRoZVxuICogdGltZSB3ZSBsZWF2ZSB0aGUgYmxvY2sgaXQgaXMgdGhlIGNsb3NpbmcgY29tbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBibG9jaydzIGFuY2hvci5cbiAqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9XG4gKi9cbmV4cG9ydCBsZXQgaHlkcmF0ZV9ub2RlO1xuXG4vKiogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0ZV9ub2RlKG5vZGUpIHtcblx0aWYgKG5vZGUgPT09IG51bGwpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdHJldHVybiAoaHlkcmF0ZV9ub2RlID0gbm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX25leHQoKSB7XG5cdHJldHVybiBzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhoeWRyYXRlX25vZGUpKSk7XG59XG5cbi8qKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KG5vZGUpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHQvLyBJZiB0aGUgbm9kZSBoYXMgcmVtYWluaW5nIHNpYmxpbmdzLCBzb21ldGhpbmcgaGFzIGdvbmUgd3Jvbmdcblx0aWYgKGdldF9uZXh0X3NpYmxpbmcoaHlkcmF0ZV9ub2RlKSAhPT0gbnVsbCkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX3RlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRlbXBsYXRlTm9kZSBkb2Vzbid0IGluY2x1ZGUgRG9jdW1lbnRGcmFnbWVudCwgYnV0IGl0J3MgYWN0dWFsbHkgZmluZVxuXHRcdGh5ZHJhdGVfbm9kZSA9IHRlbXBsYXRlLmNvbnRlbnQ7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHQoY291bnQgPSAxKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHR2YXIgaSA9IGNvdW50O1xuXHRcdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0fVxuXG5cdFx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIG5vZGVzIHN0YXJ0aW5nIGF0IGBoeWRyYXRlX25vZGVgIHVwIHVudGlsIHRoZSBuZXh0IGh5ZHJhdGlvbiBlbmQgY29tbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX25vZGVzKCkge1xuXHR2YXIgZGVwdGggPSAwO1xuXHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4KSB7XG5cdFx0XHR2YXIgZGF0YSA9IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpLmRhdGE7XG5cblx0XHRcdGlmIChkYXRhID09PSBIWURSQVRJT05fRU5EKSB7XG5cdFx0XHRcdGlmIChkZXB0aCA9PT0gMCkgcmV0dXJuIG5vZGU7XG5cdFx0XHRcdGRlcHRoIC09IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVCB8fCBkYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRSkge1xuXHRcdFx0XHRkZXB0aCArPSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBuZXh0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHRub2RlLnJlbW92ZSgpO1xuXHRcdG5vZGUgPSBuZXh0O1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IFByb3h5TWV0YWRhdGEgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEB0eXBlZGVmIHt7IGZpbGU6IHN0cmluZywgbGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlciB9fSBMb2NhdGlvbiAqL1xuXG5pbXBvcnQgeyBTVEFURV9TWU1CT0xfTUVUQURBVEEgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdXNlcl9wcmVfZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZ2V0X3Byb3RvdHlwZV9vZiB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBBcnJheTx7IHN0YXJ0OiBMb2NhdGlvbiwgZW5kOiBMb2NhdGlvbiwgY29tcG9uZW50OiBGdW5jdGlvbiB9Pj59ICovXG5jb25zdCBib3VuZGFyaWVzID0ge307XG5cbmNvbnN0IGNocm9tZV9wYXR0ZXJuID0gL2F0ICg/Oi4rIFxcKCk/KC4rKTooXFxkKyk6KFxcZCspXFwpPyQvO1xuY29uc3QgZmlyZWZveF9wYXR0ZXJuID0gL0AoLispOihcXGQrKTooXFxkKykkLztcblxuZnVuY3Rpb24gZ2V0X3N0YWNrKCkge1xuXHRjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSByZXR1cm4gbnVsbDtcblxuXHRjb25zdCBlbnRyaWVzID0gW107XG5cblx0Zm9yIChjb25zdCBsaW5lIG9mIHN0YWNrLnNwbGl0KCdcXG4nKSkge1xuXHRcdGxldCBtYXRjaCA9IGNocm9tZV9wYXR0ZXJuLmV4ZWMobGluZSkgPz8gZmlyZWZveF9wYXR0ZXJuLmV4ZWMobGluZSk7XG5cblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGVudHJpZXMucHVzaCh7XG5cdFx0XHRcdGZpbGU6IG1hdGNoWzFdLFxuXHRcdFx0XHRsaW5lOiArbWF0Y2hbMl0sXG5cdFx0XHRcdGNvbHVtbjogK21hdGNoWzNdXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZW50cmllcztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIGAuc3ZlbHRlYCBjb21wb25lbnQgaXMgcmVzcG9uc2libGUgZm9yIGEgZ2l2ZW4gc3RhdGUgY2hhbmdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb24gfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2NvbXBvbmVudCgpIHtcblx0Ly8gZmlyc3QgNCBsaW5lcyBhcmUgc3ZlbHRlIGludGVybmFsczsgYWRqdXN0IHRoaXMgbnVtYmVyIGlmIHdlIGNoYW5nZSB0aGUgaW50ZXJuYWwgY2FsbCBzdGFja1xuXHRjb25zdCBzdGFjayA9IGdldF9zdGFjaygpPy5zbGljZSg0KTtcblx0aWYgKCFzdGFjaykgcmV0dXJuIG51bGw7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGVudHJ5ID0gc3RhY2tbaV07XG5cdFx0Y29uc3QgbW9kdWxlcyA9IGJvdW5kYXJpZXNbZW50cnkuZmlsZV07XG5cdFx0aWYgKCFtb2R1bGVzKSB7XG5cdFx0XHQvLyBJZiB0aGUgZmlyc3QgZW50cnkgaXMgbm90IGEgY29tcG9uZW50LCB0aGF0IG1lYW5zIHRoZSBtb2RpZmljYXRpb24gdmVyeSBsaWtlbHkgaGFwcGVuZWRcblx0XHRcdC8vIHdpdGhpbiBhIC5zdmVsdGUuanMgZmlsZSwgcG9zc2libHkgdHJpZ2dlcmVkIGJ5IGEgY29tcG9uZW50LiBTaW5jZSB0aGVzZSBmaWxlcyBhcmUgbm90IHBhcnRcblx0XHRcdC8vIG9mIHRoZSBib25kYXJpZXMvY29tcG9uZW50IGNvbnRleHQgaGV1cmlzdGljLCB3ZSBuZWVkIHRvIGJhaWwgaW4gdGhpcyBjYXNlLCBlbHNlIHdlIHdvdWxkXG5cdFx0XHQvLyBoYXZlIGZhbHNlIHBvc2l0aXZlcyB3aGVuIHRoZSAuc3ZlbHRlLnRzIGZpbGUgcHJvdmlkZXMgYSBzdGF0ZSBjcmVhdG9yIGZ1bmN0aW9uLCBlbmNhcHN1bGF0aW5nXG5cdFx0XHQvLyB0aGUgc3RhdGUgYW5kIGl0cyBtdXRhdGlvbnMsIGFuZCBpcyBiZWluZyBjYWxsZWQgZnJvbSBhIGNvbXBvbmVudCBvdGhlciB0aGFuIHRoZSBvbmUgd2hvXG5cdFx0XHQvLyBjYWxsZWQgdGhlIHN0YXRlIGNyZWF0b3IgZnVuY3Rpb24uXG5cdFx0XHRpZiAoaSA9PT0gMCkgcmV0dXJuIG51bGw7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG5cdFx0XHRpZiAobW9kdWxlLmVuZCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vZHVsZS5zdGFydC5saW5lIDwgZW50cnkubGluZSAmJiBtb2R1bGUuZW5kLmxpbmUgPiBlbnRyeS5saW5lKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuY29tcG9uZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgY29uc3QgQUREX09XTkVSID0gU3ltYm9sKCdBRERfT1dORVInKTtcblxuLyoqXG4gKiBUb2dldGhlciB3aXRoIGBtYXJrX21vZHVsZV9lbmRgLCB0aGlzIGZ1bmN0aW9uIGVzdGFibGlzaGVzIHRoZSBib3VuZGFyaWVzIG9mIGEgYC5zdmVsdGVgIGZpbGUsXG4gKiBzdWNoIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBgZ2V0X2NvbXBvbmVudGAgY2FuIHRlbGwgdXMgd2hpY2ggY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlXG4gKiBmb3IgYSBnaXZlbiBzdGF0ZSBjaGFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtfbW9kdWxlX3N0YXJ0KCkge1xuXHRjb25zdCBzdGFydCA9IGdldF9zdGFjaygpPy5bMl07XG5cblx0aWYgKHN0YXJ0KSB7XG5cdFx0KGJvdW5kYXJpZXNbc3RhcnQuZmlsZV0gPz89IFtdKS5wdXNoKHtcblx0XHRcdHN0YXJ0LFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0ZW5kOiBudWxsLFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3ZSBhZGQgdGhlIGNvbXBvbmVudCBhdCB0aGUgZW5kLCBzaW5jZSBITVIgd2lsbCBvdmVyd3JpdGUgdGhlIGZ1bmN0aW9uXG5cdFx0XHRjb21wb25lbnQ6IG51bGxcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBvbmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya19tb2R1bGVfZW5kKGNvbXBvbmVudCkge1xuXHRjb25zdCBlbmQgPSBnZXRfc3RhY2soKT8uWzJdO1xuXG5cdGlmIChlbmQpIHtcblx0XHRjb25zdCBib3VuZGFyaWVzX2ZpbGUgPSBib3VuZGFyaWVzW2VuZC5maWxlXTtcblx0XHRjb25zdCBib3VuZGFyeSA9IGJvdW5kYXJpZXNfZmlsZVtib3VuZGFyaWVzX2ZpbGUubGVuZ3RoIC0gMV07XG5cblx0XHRib3VuZGFyeS5lbmQgPSBlbmQ7XG5cdFx0Ym91bmRhcnkuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHthbnl9IG93bmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfb3duZXIob2JqZWN0LCBvd25lciwgZ2xvYmFsID0gZmFsc2UsIHNraXBfd2FybmluZyA9IGZhbHNlKSB7XG5cdGlmIChvYmplY3QgJiYgIWdsb2JhbCkge1xuXHRcdGNvbnN0IGNvbXBvbmVudCA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0XHRjb25zdCBtZXRhZGF0YSA9IG9iamVjdFtTVEFURV9TWU1CT0xfTUVUQURBVEFdO1xuXHRcdGlmIChtZXRhZGF0YSAmJiAhaGFzX293bmVyKG1ldGFkYXRhLCBjb21wb25lbnQpKSB7XG5cdFx0XHRsZXQgb3JpZ2luYWwgPSBnZXRfb3duZXIobWV0YWRhdGEpO1xuXG5cdFx0XHRpZiAob3duZXJbRklMRU5BTUVdICE9PSBjb21wb25lbnRbRklMRU5BTUVdICYmICFza2lwX3dhcm5pbmcpIHtcblx0XHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nKGNvbXBvbmVudFtGSUxFTkFNRV0sIG93bmVyW0ZJTEVOQU1FXSwgb3JpZ2luYWxbRklMRU5BTUVdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRhZGRfb3duZXJfdG9fb2JqZWN0KG9iamVjdCwgb3duZXIsIG5ldyBTZXQoKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRfb2JqZWN0XG4gKiBAcGFyYW0ge2FueX0gQ29tcG9uZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfb3duZXJfZWZmZWN0KGdldF9vYmplY3QsIENvbXBvbmVudCwgc2tpcF93YXJuaW5nID0gZmFsc2UpIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRhZGRfb3duZXIoZ2V0X29iamVjdCgpLCBDb21wb25lbnQsIGZhbHNlLCBza2lwX3dhcm5pbmcpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGEgfCBudWxsfSBmcm9tXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGF9IHRvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aWRlbl9vd25lcnNoaXAoZnJvbSwgdG8pIHtcblx0aWYgKHRvLm93bmVycyA9PT0gbnVsbCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHdoaWxlIChmcm9tKSB7XG5cdFx0aWYgKGZyb20ub3duZXJzID09PSBudWxsKSB7XG5cdFx0XHR0by5vd25lcnMgPSBudWxsO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBvd25lciBvZiBmcm9tLm93bmVycykge1xuXHRcdFx0dG8ub3duZXJzLmFkZChvd25lcik7XG5cdFx0fVxuXG5cdFx0ZnJvbSA9IGZyb20ucGFyZW50O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3duZXJcbiAqIEBwYXJhbSB7U2V0PGFueT59IHNlZW5cbiAqL1xuZnVuY3Rpb24gYWRkX293bmVyX3RvX29iamVjdChvYmplY3QsIG93bmVyLCBzZWVuKSB7XG5cdGNvbnN0IG1ldGFkYXRhID0gLyoqIEB0eXBlIHtQcm94eU1ldGFkYXRhfSAqLyAob2JqZWN0Py5bU1RBVEVfU1lNQk9MX01FVEFEQVRBXSk7XG5cblx0aWYgKG1ldGFkYXRhKSB7XG5cdFx0Ly8gdGhpcyBpcyBhIHN0YXRlIHByb3h5LCBhZGQgb3duZXIgZGlyZWN0bHksIGlmIG5vdCBnbG9iYWxseSBzaGFyZWRcblx0XHRpZiAoJ293bmVycycgaW4gbWV0YWRhdGEgJiYgbWV0YWRhdGEub3duZXJzICE9IG51bGwpIHtcblx0XHRcdG1ldGFkYXRhLm93bmVycy5hZGQob3duZXIpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoc2Vlbi5oYXMob2JqZWN0KSkgcmV0dXJuO1xuXHRcdHNlZW4uYWRkKG9iamVjdCk7XG5cdFx0aWYgKEFERF9PV05FUiBpbiBvYmplY3QgJiYgb2JqZWN0W0FERF9PV05FUl0pIHtcblx0XHRcdC8vIHRoaXMgaXMgYSBjbGFzcyB3aXRoIHN0YXRlIGZpZWxkcy4gd2UgcHV0IHRoaXMgaW4gYSByZW5kZXIgZWZmZWN0XG5cdFx0XHQvLyBzbyB0aGF0IGlmIHN0YXRlIGlzIHJlcGxhY2VkIChlLmcuIGBpbnN0YW5jZS5uYW1lID0geyBmaXJzdCwgbGFzdCB9YClcblx0XHRcdC8vIHRoZSBuZXcgc3RhdGUgaXMgYWxzbyBjby1vd25lZCBieSB0aGUgY2FsbGVyIG9mIGBnZXRDb250ZXh0YFxuXHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdG9iamVjdFtBRERfT1dORVJdKG93bmVyKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKG9iamVjdCk7XG5cblx0XHRcdGlmIChwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuXHRcdFx0XHQvLyByZWN1cnNlIHVudGlsIHdlIGZpbmQgYSBzdGF0ZSBwcm94eVxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0XHRhZGRfb3duZXJfdG9fb2JqZWN0KG9iamVjdFtrZXldLCBvd25lciwgc2Vlbik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocHJvdG8gPT09IEFycmF5LnByb3RvdHlwZSkge1xuXHRcdFx0XHQvLyByZWN1cnNlIHVudGlsIHdlIGZpbmQgYSBzdGF0ZSBwcm94eVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0W2ldLCBvd25lciwgc2Vlbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGF9IG1ldGFkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNfb3duZXIobWV0YWRhdGEsIGNvbXBvbmVudCkge1xuXHRpZiAobWV0YWRhdGEub3duZXJzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gKFxuXHRcdG1ldGFkYXRhLm93bmVycy5oYXMoY29tcG9uZW50KSB8fFxuXHRcdChtZXRhZGF0YS5wYXJlbnQgIT09IG51bGwgJiYgaGFzX293bmVyKG1ldGFkYXRhLnBhcmVudCwgY29tcG9uZW50KSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGF9IG1ldGFkYXRhXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRfb3duZXIobWV0YWRhdGEpIHtcblx0cmV0dXJuIChcblx0XHRtZXRhZGF0YT8ub3duZXJzPy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgPz9cblx0XHRnZXRfb3duZXIoLyoqIEB0eXBlIHtQcm94eU1ldGFkYXRhfSAqLyAobWV0YWRhdGEucGFyZW50KSlcblx0KTtcbn1cblxubGV0IHNraXAgPSBmYWxzZTtcblxuLyoqXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNraXBfb3duZXJzaGlwX3ZhbGlkYXRpb24oZm4pIHtcblx0c2tpcCA9IHRydWU7XG5cdGZuKCk7XG5cdHNraXAgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGF9IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19vd25lcnNoaXAobWV0YWRhdGEpIHtcblx0aWYgKHNraXApIHJldHVybjtcblxuXHRjb25zdCBjb21wb25lbnQgPSBnZXRfY29tcG9uZW50KCk7XG5cblx0aWYgKGNvbXBvbmVudCAmJiAhaGFzX293bmVyKG1ldGFkYXRhLCBjb21wb25lbnQpKSB7XG5cdFx0bGV0IG9yaWdpbmFsID0gZ2V0X293bmVyKG1ldGFkYXRhKTtcblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRpZiAob3JpZ2luYWxbRklMRU5BTUVdICE9PSBjb21wb25lbnRbRklMRU5BTUVdKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHR3Lm93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKGNvbXBvbmVudFtGSUxFTkFNRV0sIG9yaWdpbmFsW0ZJTEVOQU1FXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHcub3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24oKTtcblx0XHR9XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgUHJveHlNZXRhZGF0YSwgUHJveHlTdGF0ZU9iamVjdCwgU291cmNlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0LCBjb21wb25lbnRfY29udGV4dCwgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4vcnVudGltZS5qcyc7XG5pbXBvcnQge1xuXHRhcnJheV9wcm90b3R5cGUsXG5cdGdldF9kZXNjcmlwdG9yLFxuXHRnZXRfcHJvdG90eXBlX29mLFxuXHRpc19hcnJheSxcblx0b2JqZWN0X3Byb3RvdHlwZVxufSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY2hlY2tfb3duZXJzaGlwLCB3aWRlbl9vd25lcnNoaXAgfSBmcm9tICcuL2Rldi9vd25lcnNoaXAuanMnO1xuaW1wb3J0IHsgc291cmNlLCBzZXQgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBTVEFURV9TWU1CT0wsIFNUQVRFX1NZTUJPTF9NRVRBREFUQSB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGEgfCBudWxsfSBbcGFyZW50XVxuICogQHBhcmFtIHtTb3VyY2U8VD59IFtwcmV2XSBkZXYgbW9kZSBvbmx5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3h5KHZhbHVlLCBwYXJlbnQgPSBudWxsLCBwcmV2KSB7XG5cdC8qKiBAdHlwZSB7RXJyb3IgfCBudWxsfSAqL1xuXHR2YXIgc3RhY2sgPSBudWxsO1xuXHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0c3RhY2sgPSBnZXRfc3RhY2soJ0NyZWF0ZWRBdCcpO1xuXHR9XG5cdC8vIGlmIG5vbi1wcm94eWFibGUsIG9yIGlzIGFscmVhZHkgYSBwcm94eSwgcmV0dXJuIGB2YWx1ZWBcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwgfHwgU1RBVEVfU1lNQk9MIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gZ2V0X3Byb3RvdHlwZV9vZih2YWx1ZSk7XG5cblx0aWYgKHByb3RvdHlwZSAhPT0gb2JqZWN0X3Byb3RvdHlwZSAmJiBwcm90b3R5cGUgIT09IGFycmF5X3Byb3RvdHlwZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7TWFwPGFueSwgU291cmNlPGFueT4+fSAqL1xuXHR2YXIgc291cmNlcyA9IG5ldyBNYXAoKTtcblx0dmFyIGlzX3Byb3hpZWRfYXJyYXkgPSBpc19hcnJheSh2YWx1ZSk7XG5cdHZhciB2ZXJzaW9uID0gc291cmNlKDApO1xuXG5cdGlmIChpc19wcm94aWVkX2FycmF5KSB7XG5cdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgdGhlIGxlbmd0aCBzb3VyY2UgZWFnZXJseSB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIG11dGF0aW9ucyB0byB0aGUgYXJyYXkgYXJlIHByb3Blcmx5IHN5bmNlZCB3aXRoIG91ciBwcm94eVxuXHRcdHNvdXJjZXMuc2V0KCdsZW5ndGgnLCBzb3VyY2UoLyoqIEB0eXBlIHthbnlbXX0gKi8gKHZhbHVlKS5sZW5ndGgsIHN0YWNrKSk7XG5cdH1cblxuXHQvKiogQHR5cGUge1Byb3h5TWV0YWRhdGF9ICovXG5cdHZhciBtZXRhZGF0YTtcblxuXHRpZiAoREVWKSB7XG5cdFx0bWV0YWRhdGEgPSB7XG5cdFx0XHRwYXJlbnQsXG5cdFx0XHRvd25lcnM6IG51bGxcblx0XHR9O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdC8vIFJldXNlIG93bmVycyBmcm9tIHByZXZpb3VzIHN0YXRlOyBuZWNlc3NhcnkgYmVjYXVzZSByZWFzc2lnbm1lbnQgaXMgbm90IGd1YXJhbnRlZWQgdG8gaGF2ZSBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0LlxuXHRcdFx0Ly8gSWYgbm8gcHJldmlvdXMgcHJveHkgZXhpc3RzIHdlIHBsYXkgaXQgc2FmZSBhbmQgYXNzdW1lIG93bmVybGVzcyBzdGF0ZVxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0Y29uc3QgcHJldl9vd25lcnMgPSBwcmV2LnY/LltTVEFURV9TWU1CT0xfTUVUQURBVEFdPy5vd25lcnM7XG5cdFx0XHRtZXRhZGF0YS5vd25lcnMgPSBwcmV2X293bmVycyA/IG5ldyBTZXQocHJldl9vd25lcnMpIDogbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWV0YWRhdGEub3duZXJzID1cblx0XHRcdFx0cGFyZW50ID09PSBudWxsXG5cdFx0XHRcdFx0PyBjb21wb25lbnRfY29udGV4dCAhPT0gbnVsbFxuXHRcdFx0XHRcdFx0PyBuZXcgU2V0KFtjb21wb25lbnRfY29udGV4dC5mdW5jdGlvbl0pXG5cdFx0XHRcdFx0XHQ6IG51bGxcblx0XHRcdFx0XHQ6IG5ldyBTZXQoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb3h5KC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLCB7XG5cdFx0ZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5jb25maWd1cmFibGUgPT09IGZhbHNlIHx8XG5cdFx0XHRcdGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHQvLyB3ZSBkaXNhbGxvdyBub24tYmFzaWMgZGVzY3JpcHRvcnMsIGJlY2F1c2UgdW5sZXNzIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlXG5cdFx0XHRcdC8vIHRhcmdldCBvYmplY3Qg4oCUIHdoaWNoIHdlIGF2b2lkLCBzbyB0aGF0IHN0YXRlIGNhbiBiZSBmb3JrZWQg4oCUIHdlIHdpbGwgcnVuXG5cdFx0XHRcdC8vIGFmb3VsIG9mIHRoZSB2YXJpb3VzIGludmFyaWFudHNcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvUHJveHkvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI2ludmFyaWFudHNcblx0XHRcdFx0ZS5zdGF0ZV9kZXNjcmlwdG9yc19maXhlZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXG5cdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHMgPSBzb3VyY2UoZGVzY3JpcHRvci52YWx1ZSwgc3RhY2spO1xuXHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldChzLCBwcm94eShkZXNjcmlwdG9yLnZhbHVlLCBtZXRhZGF0YSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXG5cdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChwcm9wIGluIHRhcmdldCkge1xuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHNvdXJjZShVTklOSVRJQUxJWkVELCBzdGFjaykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXaGVuIHdvcmtpbmcgd2l0aCBhcnJheXMsIHdlIG5lZWQgdG8gYWxzbyBlbnN1cmUgd2UgdXBkYXRlIHRoZSBsZW5ndGggd2hlbiByZW1vdmluZ1xuXHRcdFx0XHQvLyBhbiBpbmRleGVkIHByb3BlcnR5XG5cdFx0XHRcdGlmIChpc19wcm94aWVkX2FycmF5ICYmIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhciBscyA9IC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovIChzb3VyY2VzLmdldCgnbGVuZ3RoJykpO1xuXHRcdFx0XHRcdHZhciBuID0gTnVtYmVyKHByb3ApO1xuXG5cdFx0XHRcdFx0aWYgKE51bWJlci5pc0ludGVnZXIobikgJiYgbiA8IGxzLnYpIHtcblx0XHRcdFx0XHRcdHNldChscywgbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNldChzLCBVTklOSVRJQUxJWkVEKTtcblx0XHRcdFx0dXBkYXRlX3ZlcnNpb24odmVyc2lvbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuXHRcdFx0aWYgKERFViAmJiBwcm9wID09PSBTVEFURV9TWU1CT0xfTUVUQURBVEEpIHtcblx0XHRcdFx0cmV0dXJuIG1ldGFkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJvcCA9PT0gU1RBVEVfU1lNQk9MKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBleGlzdHMgPSBwcm9wIGluIHRhcmdldDtcblxuXHRcdFx0Ly8gY3JlYXRlIGEgc291cmNlLCBidXQgb25seSBpZiBpdCdzIGFuIG93biBwcm9wZXJ0eSBhbmQgbm90IGEgcHJvdG90eXBlIHByb3BlcnR5XG5cdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkICYmICghZXhpc3RzIHx8IGdldF9kZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LndyaXRhYmxlKSkge1xuXHRcdFx0XHRzID0gc291cmNlKHByb3h5KGV4aXN0cyA/IHRhcmdldFtwcm9wXSA6IFVOSU5JVElBTElaRUQsIG1ldGFkYXRhKSwgc3RhY2spO1xuXHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgdiA9IGdldChzKTtcblxuXHRcdFx0XHQvLyBJbiBjYXNlIG9mIHNvbWV0aGluZyBsaWtlIGBmb28gPSBiYXIubWFwKC4uLilgLCBmb28gd291bGQgaGF2ZSBvd25lcnNoaXBcblx0XHRcdFx0Ly8gb2YgdGhlIGFycmF5IGl0c2VsZiwgd2hpbGUgdGhlIGluZGl2aWR1YWwgaXRlbXMgd291bGQgaGF2ZSBvd25lcnNoaXBcblx0XHRcdFx0Ly8gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNyZWF0ZWQgYmFyLiBUaGF0IG1lYW5zIGlmIHdlIGxhdGVyIGRvIGBmb29bMF0uYmF6ID0gNDJgLFxuXHRcdFx0XHQvLyB3ZSBjb3VsZCBnZXQgYSBmYWxzZS1wb3NpdGl2ZSBvd25lcnNoaXAgdmlvbGF0aW9uLCBzaW5jZSB0aGUgdHdvIHByb3hpZXNcblx0XHRcdFx0Ly8gYXJlIG5vdCBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciB2aWEgdGhlIHBhcmVudCBtZXRhZGF0YSByZWxhdGlvbnNoaXAuXG5cdFx0XHRcdC8vIEZvciB0aGlzIHJlYXNvbiwgd2UgbmVlZCB0byB3aWRlbiB0aGUgb3duZXJzaGlwIG9mIHRoZSBjaGlsZHJlblxuXHRcdFx0XHQvLyB1cG9uIGFjY2VzcyB3aGVuIHdlIGRldGVjdCB0aGV5IGFyZSBub3QgY29ubmVjdGVkLlxuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtQcm94eU1ldGFkYXRhIHwgdW5kZWZpbmVkfSAqL1xuXHRcdFx0XHRcdHZhciBwcm9wX21ldGFkYXRhID0gdj8uW1NUQVRFX1NZTUJPTF9NRVRBREFUQV07XG5cdFx0XHRcdFx0aWYgKHByb3BfbWV0YWRhdGEgJiYgcHJvcF9tZXRhZGF0YT8ucGFyZW50ICE9PSBtZXRhZGF0YSkge1xuXHRcdFx0XHRcdFx0d2lkZW5fb3duZXJzaGlwKG1ldGFkYXRhLCBwcm9wX21ldGFkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdiA9PT0gVU5JTklUSUFMSVpFRCA/IHVuZGVmaW5lZCA6IHY7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcblx0XHR9LFxuXG5cdFx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApO1xuXG5cdFx0XHRpZiAoZGVzY3JpcHRvciAmJiAndmFsdWUnIGluIGRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdFx0aWYgKHMpIGRlc2NyaXB0b3IudmFsdWUgPSBnZXQocyk7XG5cdFx0XHR9IGVsc2UgaWYgKGRlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgc291cmNlID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHNvdXJjZT8udjtcblxuXHRcdFx0XHRpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IFVOSU5JVElBTElaRUQpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkZXNjcmlwdG9yO1xuXHRcdH0sXG5cblx0XHRoYXModGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHRpZiAoREVWICYmIHByb3AgPT09IFNUQVRFX1NZTUJPTF9NRVRBREFUQSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHByb3AgPT09IFNUQVRFX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBoYXMgPSAocyAhPT0gdW5kZWZpbmVkICYmIHMudiAhPT0gVU5JTklUSUFMSVpFRCkgfHwgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzICE9PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzID0gc291cmNlKGhhcyA/IHByb3h5KHRhcmdldFtwcm9wXSwgbWV0YWRhdGEpIDogVU5JTklUSUFMSVpFRCwgc3RhY2spO1xuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHZhbHVlID0gZ2V0KHMpO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IFVOSU5JVElBTElaRUQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhcztcblx0XHR9LFxuXG5cdFx0c2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGhhcyA9IHByb3AgaW4gdGFyZ2V0O1xuXG5cdFx0XHQvLyB2YXJpYWJsZS5sZW5ndGggPSB2YWx1ZSAtPiBjbGVhciBhbGwgc2lnbmFscyB3aXRoIGluZGV4ID49IHZhbHVlXG5cdFx0XHRpZiAoaXNfcHJveGllZF9hcnJheSAmJiBwcm9wID09PSAnbGVuZ3RoJykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gdmFsdWU7IGkgPCAvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAocykudjsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dmFyIG90aGVyX3MgPSBzb3VyY2VzLmdldChpICsgJycpO1xuXHRcdFx0XHRcdGlmIChvdGhlcl9zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNldChvdGhlcl9zLCBVTklOSVRJQUxJWkVEKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgaXRlbSBleGlzdHMgaW4gdGhlIG9yaWdpbmFsLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHVuaW5pdGlhbGl6ZWQgc291cmNlLFxuXHRcdFx0XHRcdFx0Ly8gZWxzZSBhIGxhdGVyIHJlYWQgb2YgdGhlIHByb3BlcnR5IHdvdWxkIHJlc3VsdCBpbiBhIHNvdXJjZSBiZWluZyBjcmVhdGVkIHdpdGhcblx0XHRcdFx0XHRcdC8vIHRoZSB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgaXRlbSBhdCB0aGF0IGluZGV4LlxuXHRcdFx0XHRcdFx0b3RoZXJfcyA9IHNvdXJjZShVTklOSVRJQUxJWkVELCBzdGFjayk7XG5cdFx0XHRcdFx0XHRzb3VyY2VzLnNldChpICsgJycsIG90aGVyX3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlbid0IHlldCBjcmVhdGVkIGEgc291cmNlIGZvciB0aGlzIHByb3BlcnR5LCB3ZSBuZWVkIHRvIGVuc3VyZVxuXHRcdFx0Ly8gd2UgZG8gc28gb3RoZXJ3aXNlIGlmIHdlIHJlYWQgaXQgbGF0ZXIsIHRoZW4gdGhlIHdyaXRlIHdvbid0IGJlIHRyYWNrZWQgYW5kXG5cdFx0XHQvLyB0aGUgaGV1cmlzdGljcyBvZiBlZmZlY3RzIHdpbGwgYmUgZGlmZmVyZW50IHZzIGlmIHdlIGhhZCByZWFkIHRoZSBwcm94aWVkXG5cdFx0XHQvLyBvYmplY3QgcHJvcGVydHkgYmVmb3JlIHdyaXRpbmcgdG8gdGhhdCBwcm9wZXJ0eS5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpIHtcblx0XHRcdFx0XHRzID0gc291cmNlKHVuZGVmaW5lZCwgc3RhY2spO1xuXHRcdFx0XHRcdHNldChzLCBwcm94eSh2YWx1ZSwgbWV0YWRhdGEpKTtcblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFzID0gcy52ICE9PSBVTklOSVRJQUxJWkVEO1xuXHRcdFx0XHRzZXQocywgcHJveHkodmFsdWUsIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtQcm94eU1ldGFkYXRhIHwgdW5kZWZpbmVkfSAqL1xuXHRcdFx0XHR2YXIgcHJvcF9tZXRhZGF0YSA9IHZhbHVlPy5bU1RBVEVfU1lNQk9MX01FVEFEQVRBXTtcblx0XHRcdFx0aWYgKHByb3BfbWV0YWRhdGEgJiYgcHJvcF9tZXRhZGF0YT8ucGFyZW50ICE9PSBtZXRhZGF0YSkge1xuXHRcdFx0XHRcdHdpZGVuX293bmVyc2hpcChtZXRhZGF0YSwgcHJvcF9tZXRhZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hlY2tfb3duZXJzaGlwKG1ldGFkYXRhKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIG5ldyB2YWx1ZSBiZWZvcmUgdXBkYXRpbmcgYW55IHNpZ25hbHMgc28gdGhhdCBhbnkgbGlzdGVuZXJzIGdldCB0aGUgbmV3IHZhbHVlXG5cdFx0XHRpZiAoZGVzY3JpcHRvcj8uc2V0KSB7XG5cdFx0XHRcdGRlc2NyaXB0b3Iuc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFoYXMpIHtcblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtdXRhdGVkIGFuIGFycmF5IGRpcmVjdGx5LCB3ZSBtaWdodCBuZWVkIHRvXG5cdFx0XHRcdC8vIHNpZ25hbCB0aGF0IGxlbmd0aCBoYXMgYWxzbyBjaGFuZ2VkLiBEbyBpdCBiZWZvcmUgdXBkYXRpbmcgbWV0YWRhdGFcblx0XHRcdFx0Ly8gdG8gZW5zdXJlIHRoYXQgaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IGFzIGEgcmVzdWx0IG9mIGEgbWV0YWRhdGEgdXBkYXRlXG5cdFx0XHRcdC8vIHdpbGwgbm90IGNhdXNlIHRoZSBsZW5ndGggdG8gYmUgb3V0IG9mIHN5bmMuXG5cdFx0XHRcdGlmIChpc19wcm94aWVkX2FycmF5ICYmIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhciBscyA9IC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovIChzb3VyY2VzLmdldCgnbGVuZ3RoJykpO1xuXHRcdFx0XHRcdHZhciBuID0gTnVtYmVyKHByb3ApO1xuXG5cdFx0XHRcdFx0aWYgKE51bWJlci5pc0ludGVnZXIobikgJiYgbiA+PSBscy52KSB7XG5cdFx0XHRcdFx0XHRzZXQobHMsIG4gKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1cGRhdGVfdmVyc2lvbih2ZXJzaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdG93bktleXModGFyZ2V0KSB7XG5cdFx0XHRnZXQodmVyc2lvbik7XG5cblx0XHRcdHZhciBvd25fa2V5cyA9IFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZpbHRlcigoa2V5KSA9PiB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzLmdldChrZXkpO1xuXHRcdFx0XHRyZXR1cm4gc291cmNlID09PSB1bmRlZmluZWQgfHwgc291cmNlLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yICh2YXIgW2tleSwgc291cmNlXSBvZiBzb3VyY2VzKSB7XG5cdFx0XHRcdGlmIChzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRCAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG5cdFx0XHRcdFx0b3duX2tleXMucHVzaChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvd25fa2V5cztcblx0XHR9LFxuXG5cdFx0c2V0UHJvdG90eXBlT2YoKSB7XG5cdFx0XHRlLnN0YXRlX3Byb3RvdHlwZV9maXhlZCgpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTb3VyY2U8bnVtYmVyPn0gc2lnbmFsXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZV92ZXJzaW9uKHNpZ25hbCwgZCA9IDEpIHtcblx0c2V0KHNpZ25hbCwgc2lnbmFsLnYgKyBkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9wcm94aWVkX3ZhbHVlKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZVtTVEFURV9TWU1CT0xdO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoYSwgYikge1xuXHRyZXR1cm4gT2JqZWN0LmlzKGdldF9wcm94aWVkX3ZhbHVlKGEpLCBnZXRfcHJveGllZF92YWx1ZShiKSk7XG59XG4iLCJpbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9wcm94aWVkX3ZhbHVlIH0gZnJvbSAnLi4vcHJveHkuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9hcnJheV9wcm90b3R5cGVfd2FybmluZ3MoKSB7XG5cdGNvbnN0IGFycmF5X3Byb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblx0Ly8gVGhlIFJFUEwgZW5kcyB1cCBoZXJlIG92ZXIgYW5kIG92ZXIsIGFuZCB0aGlzIHByZXZlbnRzIGl0IGZyb20gYWRkaW5nIG1vcmUgYW5kIG1vcmUgcGF0Y2hlc1xuXHQvLyBvZiB0aGUgc2FtZSBraW5kIHRvIHRoZSBwcm90b3R5cGUsIHdoaWNoIHdvdWxkIHNsb3cgZG93biBldmVyeXRoaW5nIG92ZXIgdGltZS5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBjbGVhbnVwID0gQXJyYXkuX19zdmVsdGVfY2xlYW51cDtcblx0aWYgKGNsZWFudXApIHtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjb25zdCB7IGluZGV4T2YsIGxhc3RJbmRleE9mLCBpbmNsdWRlcyB9ID0gYXJyYXlfcHJvdG90eXBlO1xuXG5cdGFycmF5X3Byb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHRjb25zdCBpbmRleCA9IGluZGV4T2YuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4KTtcblxuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGZvciAobGV0IGkgPSBmcm9tX2luZGV4ID8/IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5LmluZGV4T2YoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGFycmF5X3Byb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Ly8gd2UgbmVlZCB0byBzcGVjaWZ5IHRoaXMubGVuZ3RoIC0gMSBiZWNhdXNlIGl0J3MgcHJvYmFibHkgdXNpbmcgc29tZXRoaW5nIGxpa2Vcblx0XHQvLyBgYXJndW1lbnRzYCBpbnNpZGUgc28gcGFzc2luZyB1bmRlZmluZWQgaXMgZGlmZmVyZW50IGZyb20gbm90IHBhc3NpbmcgYW55dGhpbmdcblx0XHRjb25zdCBpbmRleCA9IGxhc3RJbmRleE9mLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCA/PyB0aGlzLmxlbmd0aCAtIDEpO1xuXG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gKGZyb21faW5kZXggPz8gdGhpcy5sZW5ndGggLSAxKTsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5Lmxhc3RJbmRleE9mKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fTtcblxuXHRhcnJheV9wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdGNvbnN0IGhhcyA9IGluY2x1ZGVzLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCk7XG5cblx0XHRpZiAoIWhhcykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5LmluY2x1ZGVzKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBoYXM7XG5cdH07XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRBcnJheS5fX3N2ZWx0ZV9jbGVhbnVwID0gKCkgPT4ge1xuXHRcdGFycmF5X3Byb3RvdHlwZS5pbmRleE9mID0gaW5kZXhPZjtcblx0XHRhcnJheV9wcm90b3R5cGUubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcblx0XHRhcnJheV9wcm90b3R5cGUuaW5jbHVkZXMgPSBpbmNsdWRlcztcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXF1YWxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaWN0X2VxdWFscyhhLCBiLCBlcXVhbCA9IHRydWUpIHtcblx0Ly8gdHJ5LWNhdGNoIG5lZWRlZCBiZWNhdXNlIHRoaXMgdHJpZXMgdG8gcmVhZCBwcm9wZXJ0aWVzIG9mIGBhYCBhbmQgYGJgLFxuXHQvLyB3aGljaCBjb3VsZCBiZSBkaXNhbGxvd2VkIGZvciBleGFtcGxlIGluIGEgc2VjdXJlIGNvbnRleHRcblx0dHJ5IHtcblx0XHRpZiAoKGEgPT09IGIpICE9PSAoZ2V0X3Byb3hpZWRfdmFsdWUoYSkgPT09IGdldF9wcm94aWVkX3ZhbHVlKGIpKSkge1xuXHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChlcXVhbCA/ICc9PT0nIDogJyE9PScpO1xuXHRcdH1cblx0fSBjYXRjaCB7fVxuXG5cdHJldHVybiAoYSA9PT0gYikgPT09IGVxdWFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtib29sZWFufSBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgZXF1YWwgPSB0cnVlKSB7XG5cdGlmICgoYSA9PSBiKSAhPT0gKGdldF9wcm94aWVkX3ZhbHVlKGEpID09IGdldF9wcm94aWVkX3ZhbHVlKGIpKSkge1xuXHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goZXF1YWwgPyAnPT0nIDogJyE9Jyk7XG5cdH1cblxuXHRyZXR1cm4gKGEgPT0gYikgPT09IGVxdWFsO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzIH0gZnJvbSAnLi4vZGV2L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLy8gZXhwb3J0IHRoZXNlIGZvciByZWZlcmVuY2UgaW4gdGhlIGNvbXBpbGVkIGNvZGUsIG1ha2luZyBnbG9iYWwgbmFtZSBkZWR1cGxpY2F0aW9uIHVubmVjZXNzYXJ5XG4vKiogQHR5cGUge1dpbmRvd30gKi9cbmV4cG9ydCB2YXIgJHdpbmRvdztcblxuLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbmV4cG9ydCB2YXIgJGRvY3VtZW50O1xuXG4vKiogQHR5cGUgeygpID0+IE5vZGUgfCBudWxsfSAqL1xudmFyIGZpcnN0X2NoaWxkX2dldHRlcjtcbi8qKiBAdHlwZSB7KCkgPT4gTm9kZSB8IG51bGx9ICovXG52YXIgbmV4dF9zaWJsaW5nX2dldHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZXNlIGxhemlseSB0byBhdm9pZCBpc3N1ZXMgd2hlbiB1c2luZyB0aGUgcnVudGltZSBpbiBhIHNlcnZlciBjb250ZXh0XG4gKiB3aGVyZSB0aGVzZSBnbG9iYWxzIGFyZSBub3QgYXZhaWxhYmxlIHdoaWxlIGF2b2lkaW5nIGEgc2VwYXJhdGUgc2VydmVyIGVudHJ5IHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X29wZXJhdGlvbnMoKSB7XG5cdGlmICgkd2luZG93ICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQkd2luZG93ID0gd2luZG93O1xuXHQkZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuXHR2YXIgZWxlbWVudF9wcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcblx0dmFyIG5vZGVfcHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGU7XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRmaXJzdF9jaGlsZF9nZXR0ZXIgPSBnZXRfZGVzY3JpcHRvcihub2RlX3Byb3RvdHlwZSwgJ2ZpcnN0Q2hpbGQnKS5nZXQ7XG5cdC8vIEB0cy1pZ25vcmVcblx0bmV4dF9zaWJsaW5nX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKS5nZXQ7XG5cblx0Ly8gdGhlIGZvbGxvd2luZyBhc3NpZ25tZW50cyBpbXByb3ZlIHBlcmYgb2YgbG9va3VwcyBvbiBET00gbm9kZXNcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsaWNrID0gdW5kZWZpbmVkO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnRfcHJvdG90eXBlLl9fY2xhc3NOYW1lID0gJyc7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudF9wcm90b3R5cGUuX19hdHRyaWJ1dGVzID0gbnVsbDtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX3N0eWxlcyA9IG51bGw7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudF9wcm90b3R5cGUuX19lID0gdW5kZWZpbmVkO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0VGV4dC5wcm90b3R5cGUuX190ID0gdW5kZWZpbmVkO1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdmVsdGVfbWV0YSA9IG51bGw7XG5cblx0XHRpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV90ZXh0KHZhbHVlID0gJycpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZmlyc3RfY2hpbGQobm9kZSkge1xuXHRyZXR1cm4gZmlyc3RfY2hpbGRfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuLypAX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X25leHRfc2libGluZyhub2RlKSB7XG5cdHJldHVybiBuZXh0X3NpYmxpbmdfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGQobm9kZSwgaXNfdGV4dCkge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBnZXRfZmlyc3RfY2hpbGQobm9kZSk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChoeWRyYXRlX25vZGUpKTtcblxuXHQvLyBDaGlsZCBjYW4gYmUgbnVsbCBpZiB3ZSBoYXZlIGFuIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSBjaGlsZCwgbGlrZSBgPHA+e3RleHR9PC9wPmAsIHdoZXJlIGB0ZXh0YCBpcyBlbXB0eVxuXHRpZiAoY2hpbGQgPT09IG51bGwpIHtcblx0XHRjaGlsZCA9IGh5ZHJhdGVfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fSBlbHNlIGlmIChpc190ZXh0ICYmIGNoaWxkLm5vZGVUeXBlICE9PSAzKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdGNoaWxkPy5iZWZvcmUodGV4dCk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHNldF9oeWRyYXRlX25vZGUoY2hpbGQpO1xuXHRyZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgVGVtcGxhdGVOb2RlW119IGZyYWdtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3RleHRcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0X2NoaWxkKGZyYWdtZW50LCBpc190ZXh0KSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0Ly8gd2hlbiBub3QgaHlkcmF0aW5nLCBgZnJhZ21lbnRgIGlzIGEgYERvY3VtZW50RnJhZ21lbnRgICh0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYG9wZW5fZnJhZ2ApXG5cdFx0dmFyIGZpcnN0ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGZyYWdtZW50KSkpO1xuXG5cdFx0Ly8gVE9ETyBwcmV2ZW50IHVzZXIgY29tbWVudHMgd2l0aCB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gcHJlc2VydmVDb21tZW50cyBpcyB0cnVlXG5cdFx0aWYgKGZpcnN0IGluc3RhbmNlb2YgQ29tbWVudCAmJiBmaXJzdC5kYXRhID09PSAnJykgcmV0dXJuIGdldF9uZXh0X3NpYmxpbmcoZmlyc3QpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9XG5cblx0Ly8gaWYgYW4ge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHRoZXJlIG1pZ2h0IGJlIG5vXG5cdC8vIHRleHQgbm9kZSB0byBoeWRyYXRlIOKAlCB3ZSBtdXN0IHRoZXJlZm9yZSBjcmVhdGUgb25lXG5cdGlmIChpc190ZXh0ICYmIGh5ZHJhdGVfbm9kZT8ubm9kZVR5cGUgIT09IDMpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cblx0XHRoeWRyYXRlX25vZGU/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3RleHRcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpYmxpbmcobm9kZSwgY291bnQgPSAxLCBpc190ZXh0ID0gZmFsc2UpIHtcblx0bGV0IG5leHRfc2libGluZyA9IGh5ZHJhdGluZyA/IGh5ZHJhdGVfbm9kZSA6IG5vZGU7XG5cdHZhciBsYXN0X3NpYmxpbmc7XG5cblx0d2hpbGUgKGNvdW50LS0pIHtcblx0XHRsYXN0X3NpYmxpbmcgPSBuZXh0X3NpYmxpbmc7XG5cdFx0bmV4dF9zaWJsaW5nID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5leHRfc2libGluZykpO1xuXHR9XG5cblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHRyZXR1cm4gbmV4dF9zaWJsaW5nO1xuXHR9XG5cblx0dmFyIHR5cGUgPSBuZXh0X3NpYmxpbmc/Lm5vZGVUeXBlO1xuXG5cdC8vIGlmIGEgc2libGluZyB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUg4oCUIHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgdHlwZSAhPT0gMykge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblx0XHQvLyBJZiB0aGUgbmV4dCBzaWJsaW5nIGlzIGBudWxsYCBhbmQgd2UncmUgaGFuZGxpbmcgdGV4dCB0aGVuIGl0J3MgYmVjYXVzZVxuXHRcdC8vIHRoZSBTU1IgY29udGVudCB3YXMgZW1wdHkgZm9yIHRoZSB0ZXh0LCBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgbmV3IHRleHRcblx0XHQvLyBub2RlIGFuZCBpbnNlcnQgaXQgYWZ0ZXIgdGhlIGxhc3Qgc2libGluZ1xuXHRcdGlmIChuZXh0X3NpYmxpbmcgPT09IG51bGwpIHtcblx0XHRcdGxhc3Rfc2libGluZz8uYWZ0ZXIodGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5leHRfc2libGluZy5iZWZvcmUodGV4dCk7XG5cdFx0fVxuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRzZXRfaHlkcmF0ZV9ub2RlKG5leHRfc2libGluZyk7XG5cdHJldHVybiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHRfc2libGluZyk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfdGV4dF9jb250ZW50KG5vZGUpIHtcblx0bm9kZS50ZXh0Q29udGVudCA9ICcnO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRDTEVBTixcblx0REVSSVZFRCxcblx0REVTVFJPWUVELFxuXHRESVJUWSxcblx0RUZGRUNUX0hBU19ERVJJVkVELFxuXHRNQVlCRV9ESVJUWSxcblx0VU5PV05FRFxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRhY3RpdmVfZWZmZWN0LFxuXHRyZW1vdmVfcmVhY3Rpb25zLFxuXHRzZXRfc2lnbmFsX3N0YXR1cyxcblx0c2tpcF9yZWFjdGlvbixcblx0dXBkYXRlX3JlYWN0aW9uLFxuXHRpbmNyZW1lbnRfdmVyc2lvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdGNvbXBvbmVudF9jb250ZXh0XG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZXF1YWxzLCBzYWZlX2VxdWFscyB9IGZyb20gJy4vZXF1YWxpdHkuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgZGVzdHJveV9lZmZlY3QgfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaW5zcGVjdF9lZmZlY3RzLCBzZXRfaW5zcGVjdF9lZmZlY3RzIH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGdldF9zdGFjayB9IGZyb20gJy4uL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGZuXG4gKiBAcmV0dXJucyB7RGVyaXZlZDxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChmbikge1xuXHR2YXIgZmxhZ3MgPSBERVJJVkVEIHwgRElSVFk7XG5cblx0aWYgKGFjdGl2ZV9lZmZlY3QgPT09IG51bGwpIHtcblx0XHRmbGFncyB8PSBVTk9XTkVEO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFNpbmNlIGRlcml2ZWRzIGFyZSBldmFsdWF0ZWQgbGF6aWx5LCBhbnkgZWZmZWN0cyBjcmVhdGVkIGluc2lkZSB0aGVtIGFyZVxuXHRcdC8vIGNyZWF0ZWQgdG9vIGxhdGUgdG8gZW5zdXJlIHRoYXQgdGhlIHBhcmVudCBlZmZlY3QgaXMgYWRkZWQgdG8gdGhlIHRyZWVcblx0XHRhY3RpdmVfZWZmZWN0LmYgfD0gRUZGRUNUX0hBU19ERVJJVkVEO1xuXHR9XG5cblx0dmFyIHBhcmVudF9kZXJpdmVkID1cblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDBcblx0XHRcdD8gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKVxuXHRcdFx0OiBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RGVyaXZlZDxWPn0gKi9cblx0Y29uc3Qgc2lnbmFsID0ge1xuXHRcdGNoaWxkcmVuOiBudWxsLFxuXHRcdGN0eDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0ZGVwczogbnVsbCxcblx0XHRlcXVhbHMsXG5cdFx0ZjogZmxhZ3MsXG5cdFx0Zm4sXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdHY6IC8qKiBAdHlwZSB7Vn0gKi8gKG51bGwpLFxuXHRcdHZlcnNpb246IDAsXG5cdFx0cGFyZW50OiBwYXJlbnRfZGVyaXZlZCA/PyBhY3RpdmVfZWZmZWN0XG5cdH07XG5cblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHNpZ25hbC5jcmVhdGVkID0gZ2V0X3N0YWNrKCdDcmVhdGVkQXQnKTtcblx0fVxuXG5cdGlmIChwYXJlbnRfZGVyaXZlZCAhPT0gbnVsbCkge1xuXHRcdChwYXJlbnRfZGVyaXZlZC5jaGlsZHJlbiA/Pz0gW10pLnB1c2goc2lnbmFsKTtcblx0fVxuXG5cdHJldHVybiBzaWduYWw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkX3NhZmVfZXF1YWwoZm4pIHtcblx0Y29uc3Qgc2lnbmFsID0gZGVyaXZlZChmbik7XG5cdHNpZ25hbC5lcXVhbHMgPSBzYWZlX2VxdWFscztcblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZXN0cm95X2Rlcml2ZWRfY2hpbGRyZW4oZGVyaXZlZCkge1xuXHR2YXIgY2hpbGRyZW4gPSBkZXJpdmVkLmNoaWxkcmVuO1xuXG5cdGlmIChjaGlsZHJlbiAhPT0gbnVsbCkge1xuXHRcdGRlcml2ZWQuY2hpbGRyZW4gPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoKGNoaWxkLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0XHRkZXN0cm95X2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoY2hpbGQpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoY2hpbGQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IHVwZGF0aW5nIGRlcml2ZWRzLCB1c2VkIHRvIGRldGVjdCBpbmZpbml0ZSByZWN1cnNpb25cbiAqIGluIGRldiBtb2RlIGFuZCBwcm92aWRlIGEgbmljZXIgZXJyb3IgdGhhbiAndG9vIG11Y2ggcmVjdXJzaW9uJ1xuICogQHR5cGUge0Rlcml2ZWRbXX1cbiAqL1xubGV0IHN0YWNrID0gW107XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7RWZmZWN0IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSB7XG5cdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmICgocGFyZW50LmYgJiBERVJJVkVEKSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocGFyZW50KTtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZTtcblx0dmFyIHByZXZfYWN0aXZlX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0c2V0X2FjdGl2ZV9lZmZlY3QoZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSk7XG5cblx0aWYgKERFVikge1xuXHRcdGxldCBwcmV2X2luc3BlY3RfZWZmZWN0cyA9IGluc3BlY3RfZWZmZWN0cztcblx0XHRzZXRfaW5zcGVjdF9lZmZlY3RzKG5ldyBTZXQoKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzdGFjay5pbmNsdWRlcyhkZXJpdmVkKSkge1xuXHRcdFx0XHRlLmRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YWNrLnB1c2goZGVyaXZlZCk7XG5cblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9jaGlsZHJlbihkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdFx0c2V0X2luc3BlY3RfZWZmZWN0cyhwcmV2X2luc3BlY3RfZWZmZWN0cyk7XG5cdFx0XHRzdGFjay5wb3AoKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9jaGlsZHJlbihkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2Rlcml2ZWQoZGVyaXZlZCkge1xuXHR2YXIgdmFsdWUgPSBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCk7XG5cdHZhciBzdGF0dXMgPVxuXHRcdChza2lwX3JlYWN0aW9uIHx8IChkZXJpdmVkLmYgJiBVTk9XTkVEKSAhPT0gMCkgJiYgZGVyaXZlZC5kZXBzICE9PSBudWxsID8gTUFZQkVfRElSVFkgOiBDTEVBTjtcblxuXHRzZXRfc2lnbmFsX3N0YXR1cyhkZXJpdmVkLCBzdGF0dXMpO1xuXG5cdGlmICghZGVyaXZlZC5lcXVhbHModmFsdWUpKSB7XG5cdFx0ZGVyaXZlZC52ID0gdmFsdWU7XG5cdFx0ZGVyaXZlZC52ZXJzaW9uID0gaW5jcmVtZW50X3ZlcnNpb24oKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Rlcml2ZWQoZGVyaXZlZCkge1xuXHRkZXN0cm95X2Rlcml2ZWRfY2hpbGRyZW4oZGVyaXZlZCk7XG5cdHJlbW92ZV9yZWFjdGlvbnMoZGVyaXZlZCwgMCk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGRlcml2ZWQsIERFU1RST1lFRCk7XG5cblx0ZGVyaXZlZC52ID0gZGVyaXZlZC5jaGlsZHJlbiA9IGRlcml2ZWQuZGVwcyA9IGRlcml2ZWQuY3R4ID0gZGVyaXZlZC5yZWFjdGlvbnMgPSBudWxsO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBDb21wb25lbnRDb250ZXh0TGVnYWN5LCBEZXJpdmVkLCBFZmZlY3QsIFRlbXBsYXRlTm9kZSwgVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHtcblx0Y2hlY2tfZGlydGluZXNzLFxuXHRjb21wb25lbnRfY29udGV4dCxcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24sXG5cdHVwZGF0ZV9lZmZlY3QsXG5cdGdldCxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdGlzX2ZsdXNoaW5nX2VmZmVjdCxcblx0cmVtb3ZlX3JlYWN0aW9ucyxcblx0c2NoZWR1bGVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHNldF9pc19mbHVzaGluZ19lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRza2lwX3JlYWN0aW9uXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0RElSVFksXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFJFTkRFUl9FRkZFQ1QsXG5cdEVGRkVDVCxcblx0REVTVFJPWUVELFxuXHRJTkVSVCxcblx0RUZGRUNUX1JBTixcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0RUZGRUNUX1RSQU5TUEFSRU5ULFxuXHRERVJJVkVELFxuXHRVTk9XTkVELFxuXHRDTEVBTixcblx0SU5TUEVDVF9FRkZFQ1QsXG5cdEhFQURfRUZGRUNULFxuXHRNQVlCRV9ESVJUWSxcblx0RUZGRUNUX0hBU19ERVJJVkVEXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGRlc3Ryb3lfZGVyaXZlZCB9IGZyb20gJy4vZGVyaXZlZHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7JyRlZmZlY3QnIHwgJyRlZmZlY3QucHJlJyB8ICckaW5zcGVjdCd9IHJ1bmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VmZmVjdChydW5lKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsICYmIGFjdGl2ZV9yZWFjdGlvbiA9PT0gbnVsbCkge1xuXHRcdGUuZWZmZWN0X29ycGhhbihydW5lKTtcblx0fVxuXG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgVU5PV05FRCkgIT09IDApIHtcblx0XHRlLmVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWQoKTtcblx0fVxuXG5cdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdGUuZWZmZWN0X2luX3RlYXJkb3duKHJ1bmUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtFZmZlY3R9IHBhcmVudF9lZmZlY3RcbiAqL1xuZnVuY3Rpb24gcHVzaF9lZmZlY3QoZWZmZWN0LCBwYXJlbnRfZWZmZWN0KSB7XG5cdHZhciBwYXJlbnRfbGFzdCA9IHBhcmVudF9lZmZlY3QubGFzdDtcblx0aWYgKHBhcmVudF9sYXN0ID09PSBudWxsKSB7XG5cdFx0cGFyZW50X2VmZmVjdC5sYXN0ID0gcGFyZW50X2VmZmVjdC5maXJzdCA9IGVmZmVjdDtcblx0fSBlbHNlIHtcblx0XHRwYXJlbnRfbGFzdC5uZXh0ID0gZWZmZWN0O1xuXHRcdGVmZmVjdC5wcmV2ID0gcGFyZW50X2xhc3Q7XG5cdFx0cGFyZW50X2VmZmVjdC5sYXN0ID0gZWZmZWN0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7bnVsbCB8ICgoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpKX0gZm5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHBhcmFtIHtib29sZWFufSBwdXNoXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfZWZmZWN0KHR5cGUsIGZuLCBzeW5jLCBwdXNoID0gdHJ1ZSkge1xuXHR2YXIgaXNfcm9vdCA9ICh0eXBlICYgUk9PVF9FRkZFQ1QpICE9PSAwO1xuXHR2YXIgcGFyZW50X2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIEVuc3VyZSB0aGUgcGFyZW50IGlzIG5ldmVyIGFuIGluc3BlY3QgZWZmZWN0XG5cdFx0d2hpbGUgKHBhcmVudF9lZmZlY3QgIT09IG51bGwgJiYgKHBhcmVudF9lZmZlY3QuZiAmIElOU1BFQ1RfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0cGFyZW50X2VmZmVjdCA9IHBhcmVudF9lZmZlY3QucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWZmZWN0ID0ge1xuXHRcdGN0eDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0ZGVwczogbnVsbCxcblx0XHRkZXJpdmVkczogbnVsbCxcblx0XHRub2Rlc19zdGFydDogbnVsbCxcblx0XHRub2Rlc19lbmQ6IG51bGwsXG5cdFx0ZjogdHlwZSB8IERJUlRZLFxuXHRcdGZpcnN0OiBudWxsLFxuXHRcdGZuLFxuXHRcdGxhc3Q6IG51bGwsXG5cdFx0bmV4dDogbnVsbCxcblx0XHRwYXJlbnQ6IGlzX3Jvb3QgPyBudWxsIDogcGFyZW50X2VmZmVjdCxcblx0XHRwcmV2OiBudWxsLFxuXHRcdHRlYXJkb3duOiBudWxsLFxuXHRcdHRyYW5zaXRpb25zOiBudWxsLFxuXHRcdHZlcnNpb246IDBcblx0fTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0fVxuXG5cdGlmIChzeW5jKSB7XG5cdFx0dmFyIHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0ID0gaXNfZmx1c2hpbmdfZWZmZWN0O1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNldF9pc19mbHVzaGluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QuZiB8PSBFRkZFQ1RfUkFOO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0KTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoZm4gIT09IG51bGwpIHtcblx0XHRzY2hlZHVsZV9lZmZlY3QoZWZmZWN0KTtcblx0fVxuXG5cdC8vIGlmIGFuIGVmZmVjdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBubyBET00gYW5kIG5vIHRlYXJkb3duIGZ1bmN0aW9uLFxuXHQvLyBkb24ndCBib3RoZXIgYWRkaW5nIGl0IHRvIHRoZSBlZmZlY3QgdHJlZVxuXHR2YXIgaW5lcnQgPVxuXHRcdHN5bmMgJiZcblx0XHRlZmZlY3QuZGVwcyA9PT0gbnVsbCAmJlxuXHRcdGVmZmVjdC5maXJzdCA9PT0gbnVsbCAmJlxuXHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCAmJlxuXHRcdGVmZmVjdC50ZWFyZG93biA9PT0gbnVsbCAmJlxuXHRcdChlZmZlY3QuZiAmIEVGRkVDVF9IQVNfREVSSVZFRCkgPT09IDA7XG5cblx0aWYgKCFpbmVydCAmJiAhaXNfcm9vdCAmJiBwdXNoKSB7XG5cdFx0aWYgKHBhcmVudF9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdHB1c2hfZWZmZWN0KGVmZmVjdCwgcGFyZW50X2VmZmVjdCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UncmUgaW4gYSBkZXJpdmVkLCBhZGQgdGhlIGVmZmVjdCB0aGVyZSB0b29cblx0XHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmIChhY3RpdmVfcmVhY3Rpb24uZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHR2YXIgZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGFjdGl2ZV9yZWFjdGlvbik7XG5cdFx0XHQoZGVyaXZlZC5jaGlsZHJlbiA/Pz0gW10pLnB1c2goZWZmZWN0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnRyYWNraW5nKClgXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF90cmFja2luZygpIHtcblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElmIGl0J3Mgc2tpcHBlZCwgdGhhdCdzIGJlY2F1c2Ugd2UncmUgaW5zaWRlIGFuIHVub3duZWRcblx0Ly8gdGhhdCBpcyBub3QgYmVpbmcgdHJhY2tlZCBieSBhbm90aGVyIHJlYWN0aW9uXG5cdHJldHVybiAhc2tpcF9yZWFjdGlvbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZWFyZG93bihmbikge1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QsIG51bGwsIGZhbHNlKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBDTEVBTik7XG5cdGVmZmVjdC50ZWFyZG93biA9IGZuO1xuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0KC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX2VmZmVjdChmbikge1xuXHR2YWxpZGF0ZV9lZmZlY3QoJyRlZmZlY3QnKTtcblxuXHQvLyBOb24tbmVzdGVkIGAkZWZmZWN0KC4uLilgIGluIGEgY29tcG9uZW50IHNob3VsZCBiZSBkZWZlcnJlZFxuXHQvLyB1bnRpbCB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWRcblx0dmFyIGRlZmVyID1cblx0XHRhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmXG5cdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwICYmXG5cdFx0Y29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiZcblx0XHQhY29tcG9uZW50X2NvbnRleHQubTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnJGVmZmVjdCdcblx0XHR9KTtcblx0fVxuXG5cdGlmIChkZWZlcikge1xuXHRcdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdChjb250ZXh0LmUgPz89IFtdKS5wdXNoKHtcblx0XHRcdGZuLFxuXHRcdFx0ZWZmZWN0OiBhY3RpdmVfZWZmZWN0LFxuXHRcdFx0cmVhY3Rpb246IGFjdGl2ZV9yZWFjdGlvblxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzaWduYWwgPSBlZmZlY3QoZm4pO1xuXHRcdHJldHVybiBzaWduYWw7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC5wcmUoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX3ByZV9lZmZlY3QoZm4pIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckZWZmZWN0LnByZScpO1xuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnJGVmZmVjdC5wcmUnXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHJlbmRlcl9lZmZlY3QoZm4pO1xufVxuXG4vKiogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3RfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KElOU1BFQ1RfRUZGRUNULCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3Qucm9vdCguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3Rfcm9vdChmbikge1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJPT1RfRUZGRUNULCBmbiwgdHJ1ZSk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHR9O1xufVxuXG4vKipcbiAqIEFuIGVmZmVjdCByb290IHdob3NlIGNoaWxkcmVuIGNhbiB0cmFuc2l0aW9uIG91dFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhvcHRpb25zPzogeyBvdXRybz86IGJvb2xlYW4gfSkgPT4gUHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9yb290KGZuKSB7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUk9PVF9FRkZFQ1QsIGZuLCB0cnVlKTtcblxuXHRyZXR1cm4gKG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsKSA9PiB7XG5cdFx0XHRpZiAob3B0aW9ucy5vdXRybykge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0XHRmdWxmaWwodW5kZWZpbmVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRmdWxmaWwodW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEVGRkVDVCwgZm4sIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJDogLi5gXG4gKiBAcGFyYW0geygpID0+IGFueX0gZGVwc1xuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3ByZV9lZmZlY3QoZGVwcywgZm4pIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0LyoqIEB0eXBlIHt7IGVmZmVjdDogbnVsbCB8IEVmZmVjdCwgcmFuOiBib29sZWFuIH19ICovXG5cdHZhciB0b2tlbiA9IHsgZWZmZWN0OiBudWxsLCByYW46IGZhbHNlIH07XG5cdGNvbnRleHQubC5yMS5wdXNoKHRva2VuKTtcblxuXHR0b2tlbi5lZmZlY3QgPSByZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRkZXBzKCk7XG5cblx0XHQvLyBJZiB0aGlzIGxlZ2FjeSBwcmUgZWZmZWN0IGhhcyBhbHJlYWR5IHJ1biBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgcmVzZXQsIHRoZW5cblx0XHQvLyBiYWlsIG91dCB0byBlbXVsYXRlIHRoZSBzYW1lIGJlaGF2aW9yLlxuXHRcdGlmICh0b2tlbi5yYW4pIHJldHVybjtcblxuXHRcdHRva2VuLnJhbiA9IHRydWU7XG5cdFx0c2V0KGNvbnRleHQubC5yMiwgdHJ1ZSk7XG5cdFx0dW50cmFjayhmbik7XG5cdH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3ByZV9lZmZlY3RfcmVzZXQoKSB7XG5cdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmICghZ2V0KGNvbnRleHQubC5yMikpIHJldHVybjtcblxuXHRcdC8vIFJ1biBkaXJ0eSBgJDpgIHN0YXRlbWVudHNcblx0XHRmb3IgKHZhciB0b2tlbiBvZiBjb250ZXh0LmwucjEpIHtcblx0XHRcdHZhciBlZmZlY3QgPSB0b2tlbi5lZmZlY3Q7XG5cblx0XHRcdC8vIElmIHRoZSBlZmZlY3QgaXMgQ0xFQU4sIHRoZW4gbWFrZSBpdCBNQVlCRV9ESVJUWS4gVGhpcyBlbnN1cmVzIHdlIHRyYXZlcnNlIHRocm91Z2hcblx0XHRcdC8vIHRoZSBlZmZlY3RzIGRlcGVuZGVuY2llcyBhbmQgY29ycmVjdGx5IGVuc3VyZSBlYWNoIGRlcGVuZGVuY3kgaXMgdXAtdG8tZGF0ZS5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoZWZmZWN0KSkge1xuXHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRva2VuLnJhbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnRleHQubC5yMi52ID0gZmFsc2U7IC8vIHNldCBkaXJlY3RseSB0byBhdm9pZCByZXJ1bm5pbmcgdGhpcyBlZmZlY3Rcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcl9lZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZV9lZmZlY3QoZm4pIHtcblx0aWYgKERFVikge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJ3tleHByZXNzaW9ufSdcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gYmxvY2soZm4pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibG9jayhmbiwgZmxhZ3MgPSAwKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QgfCBCTE9DS19FRkZFQ1QgfCBmbGFncywgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBbcHVzaF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaChmbiwgcHVzaCA9IHRydWUpIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IEJSQU5DSF9FRkZFQ1QsIGZuLCB0cnVlLCBwdXNoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpIHtcblx0dmFyIHRlYXJkb3duID0gZWZmZWN0LnRlYXJkb3duO1xuXHRpZiAodGVhcmRvd24gIT09IG51bGwpIHtcblx0XHRjb25zdCBwcmV2aW91c2x5X2Rlc3Ryb3lpbmdfZWZmZWN0ID0gaXNfZGVzdHJveWluZ19lZmZlY3Q7XG5cdFx0Y29uc3QgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHRydWUpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0dHJ5IHtcblx0XHRcdHRlYXJkb3duLmNhbGwobnVsbCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdChwcmV2aW91c2x5X2Rlc3Ryb3lpbmdfZWZmZWN0KTtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lZmZlY3RfZGVyaXZlZHMoc2lnbmFsKSB7XG5cdHZhciBkZXJpdmVkcyA9IHNpZ25hbC5kZXJpdmVkcztcblxuXHRpZiAoZGVyaXZlZHMgIT09IG51bGwpIHtcblx0XHRzaWduYWwuZGVyaXZlZHMgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXJpdmVkcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0ZGVzdHJveV9kZXJpdmVkKGRlcml2ZWRzW2ldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbW92ZV9kb21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4oc2lnbmFsLCByZW1vdmVfZG9tID0gZmFsc2UpIHtcblx0dmFyIGVmZmVjdCA9IHNpZ25hbC5maXJzdDtcblx0c2lnbmFsLmZpcnN0ID0gc2lnbmFsLmxhc3QgPSBudWxsO1xuXG5cdHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcblx0XHR2YXIgbmV4dCA9IGVmZmVjdC5uZXh0O1xuXHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCwgcmVtb3ZlX2RvbSk7XG5cdFx0ZWZmZWN0ID0gbmV4dDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4oc2lnbmFsKSB7XG5cdHZhciBlZmZlY3QgPSBzaWduYWwuZmlyc3Q7XG5cblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cdFx0aWYgKChlZmZlY3QuZiAmIEJSQU5DSF9FRkZFQ1QpID09PSAwKSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdH1cblx0XHRlZmZlY3QgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlX2RvbV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lZmZlY3QoZWZmZWN0LCByZW1vdmVfZG9tID0gdHJ1ZSkge1xuXHR2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXG5cdGlmICgocmVtb3ZlX2RvbSB8fCAoZWZmZWN0LmYgJiBIRUFEX0VGRkVDVCkgIT09IDApICYmIGVmZmVjdC5ub2Rlc19zdGFydCAhPT0gbnVsbCkge1xuXHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0XHR2YXIgbm9kZSA9IGVmZmVjdC5ub2Rlc19zdGFydDtcblx0XHR2YXIgZW5kID0gZWZmZWN0Lm5vZGVzX2VuZDtcblxuXHRcdHdoaWxlIChub2RlICE9PSBudWxsKSB7XG5cdFx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZSB8IG51bGx9ICovXG5cdFx0XHR2YXIgbmV4dCA9IG5vZGUgPT09IGVuZCA/IG51bGwgOiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXG5cdFx0XHRub2RlLnJlbW92ZSgpO1xuXHRcdFx0bm9kZSA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlZCA9IHRydWU7XG5cdH1cblxuXHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihlZmZlY3QsIHJlbW92ZV9kb20gJiYgIXJlbW92ZWQpO1xuXHRkZXN0cm95X2VmZmVjdF9kZXJpdmVkcyhlZmZlY3QpO1xuXHRyZW1vdmVfcmVhY3Rpb25zKGVmZmVjdCwgMCk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgREVTVFJPWUVEKTtcblxuXHR2YXIgdHJhbnNpdGlvbnMgPSBlZmZlY3QudHJhbnNpdGlvbnM7XG5cblx0aWYgKHRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLnN0b3AoKTtcblx0XHR9XG5cdH1cblxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpO1xuXG5cdHZhciBwYXJlbnQgPSBlZmZlY3QucGFyZW50O1xuXG5cdC8vIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiBza2lwIHRoaXMgd29yayBhbHRvZ2V0aGVyXG5cdGlmIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmZpcnN0ICE9PSBudWxsKSB7XG5cdFx0dW5saW5rX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdGVmZmVjdC5jb21wb25lbnRfZnVuY3Rpb24gPSBudWxsO1xuXHR9XG5cblx0Ly8gYGZpcnN0YCBhbmQgYGNoaWxkYCBhcmUgbnVsbGVkIG91dCBpbiBkZXN0cm95X2VmZmVjdF9jaGlsZHJlblxuXHQvLyB3ZSBkb24ndCBudWxsIG91dCBgcGFyZW50YCBzbyB0aGF0IGVycm9yIHByb3BhZ2F0aW9uIGNhbiB3b3JrIGNvcnJlY3RseVxuXHRlZmZlY3QubmV4dCA9XG5cdFx0ZWZmZWN0LnByZXYgPVxuXHRcdGVmZmVjdC50ZWFyZG93biA9XG5cdFx0ZWZmZWN0LmN0eCA9XG5cdFx0ZWZmZWN0LmRlcHMgPVxuXHRcdGVmZmVjdC5mbiA9XG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID1cblx0XHRlZmZlY3Qubm9kZXNfZW5kID1cblx0XHRcdG51bGw7XG59XG5cbi8qKlxuICogRGV0YWNoIGFuIGVmZmVjdCBmcm9tIHRoZSBlZmZlY3QgdHJlZSwgZnJlZWluZyB1cCBtZW1vcnkgYW5kXG4gKiByZWR1Y2luZyB0aGUgYW1vdW50IG9mIHdvcmsgdGhhdCBoYXBwZW5zIG9uIHN1YnNlcXVlbnQgdHJhdmVyc2Fsc1xuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saW5rX2VmZmVjdChlZmZlY3QpIHtcblx0dmFyIHBhcmVudCA9IGVmZmVjdC5wYXJlbnQ7XG5cdHZhciBwcmV2ID0gZWZmZWN0LnByZXY7XG5cdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cblx0aWYgKHByZXYgIT09IG51bGwpIHByZXYubmV4dCA9IG5leHQ7XG5cdGlmIChuZXh0ICE9PSBudWxsKSBuZXh0LnByZXYgPSBwcmV2O1xuXG5cdGlmIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRpZiAocGFyZW50LmZpcnN0ID09PSBlZmZlY3QpIHBhcmVudC5maXJzdCA9IG5leHQ7XG5cdFx0aWYgKHBhcmVudC5sYXN0ID09PSBlZmZlY3QpIHBhcmVudC5sYXN0ID0gcHJldjtcblx0fVxufVxuXG4vKipcbiAqIFdoZW4gYSBibG9jayBlZmZlY3QgaXMgcmVtb3ZlZCwgd2UgZG9uJ3QgaW1tZWRpYXRlbHkgZGVzdHJveSBpdCBvciB5YW5rIGl0XG4gKiBvdXQgb2YgdGhlIERPTSwgYmVjYXVzZSBpdCBtaWdodCBoYXZlIHRyYW5zaXRpb25zLiBJbnN0ZWFkLCB3ZSAncGF1c2UnIGl0LlxuICogSXQgc3RheXMgYXJvdW5kIChpbiBtZW1vcnksIGFuZCBpbiB0aGUgRE9NKSB1bnRpbCBvdXRybyB0cmFuc2l0aW9ucyBoYXZlXG4gKiBjb21wbGV0ZWQsIGFuZCBpZiB0aGUgc3RhdGUgY2hhbmdlIGlzIHJldmVyc2VkIHRoZW4gd2UgX3Jlc3VtZV8gaXQuXG4gKiBBIHBhdXNlZCBlZmZlY3QgZG9lcyBub3QgdXBkYXRlLCBhbmQgdGhlIERPTSBzdWJ0cmVlIGJlY29tZXMgaW5lcnQuXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdXNlX2VmZmVjdChlZmZlY3QsIGNhbGxiYWNrKSB7XG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gKi9cblx0dmFyIHRyYW5zaXRpb25zID0gW107XG5cblx0cGF1c2VfY2hpbGRyZW4oZWZmZWN0LCB0cmFuc2l0aW9ucywgdHJ1ZSk7XG5cblx0cnVuX291dF90cmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgKCkgPT4ge1xuXHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25NYW5hZ2VyW119IHRyYW5zaXRpb25zXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCBmbikge1xuXHR2YXIgcmVtYWluaW5nID0gdHJhbnNpdGlvbnMubGVuZ3RoO1xuXHRpZiAocmVtYWluaW5nID4gMCkge1xuXHRcdHZhciBjaGVjayA9ICgpID0+IC0tcmVtYWluaW5nIHx8IGZuKCk7XG5cdFx0Zm9yICh2YXIgdHJhbnNpdGlvbiBvZiB0cmFuc2l0aW9ucykge1xuXHRcdFx0dHJhbnNpdGlvbi5vdXQoY2hlY2spO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmbigpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtUcmFuc2l0aW9uTWFuYWdlcltdfSB0cmFuc2l0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF1c2VfY2hpbGRyZW4oZWZmZWN0LCB0cmFuc2l0aW9ucywgbG9jYWwpIHtcblx0aWYgKChlZmZlY3QuZiAmIElORVJUKSAhPT0gMCkgcmV0dXJuO1xuXHRlZmZlY3QuZiBePSBJTkVSVDtcblxuXHRpZiAoZWZmZWN0LnRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIGVmZmVjdC50cmFuc2l0aW9ucykge1xuXHRcdFx0aWYgKHRyYW5zaXRpb24uaXNfZ2xvYmFsIHx8IGxvY2FsKSB7XG5cdFx0XHRcdHRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGNoaWxkID0gZWZmZWN0LmZpcnN0O1xuXG5cdHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdHZhciBzaWJsaW5nID0gY2hpbGQubmV4dDtcblx0XHR2YXIgdHJhbnNwYXJlbnQgPSAoY2hpbGQuZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDAgfHwgKGNoaWxkLmYgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMDtcblx0XHQvLyBUT0RPIHdlIGRvbid0IG5lZWQgdG8gY2FsbCBwYXVzZV9jaGlsZHJlbiByZWN1cnNpdmVseSB3aXRoIGEgbGlua2VkIGxpc3QgaW4gcGxhY2Vcblx0XHQvLyBpdCdzIHNsaWdodGx5IG1vcmUgaW52b2x2ZWQgdGhvdWdoIGFzIHdlIGhhdmUgdG8gYWNjb3VudCBmb3IgYHRyYW5zcGFyZW50YCBjaGFuZ2luZ1xuXHRcdC8vIHRocm91Z2ggdGhlIHRyZWUuXG5cdFx0cGF1c2VfY2hpbGRyZW4oY2hpbGQsIHRyYW5zaXRpb25zLCB0cmFuc3BhcmVudCA/IGxvY2FsIDogZmFsc2UpO1xuXHRcdGNoaWxkID0gc2libGluZztcblx0fVxufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgcGF1c2VfZWZmZWN0YC4gV2UgY2FsbCB0aGlzIGlmIChmb3IgZXhhbXBsZSlcbiAqIGB4YCBiZWNvbWVzIGZhbHN5IHRoZW4gdHJ1dGh5OiBgeyNpZiB4fS4uLnsvaWZ9YFxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdW1lX2VmZmVjdChlZmZlY3QpIHtcblx0cmVzdW1lX2NoaWxkcmVuKGVmZmVjdCwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICovXG5mdW5jdGlvbiByZXN1bWVfY2hpbGRyZW4oZWZmZWN0LCBsb2NhbCkge1xuXHRpZiAoKGVmZmVjdC5mICYgSU5FUlQpID09PSAwKSByZXR1cm47XG5cblx0Ly8gSWYgYSBkZXBlbmRlbmN5IG9mIHRoaXMgZWZmZWN0IGNoYW5nZWQgd2hpbGUgaXQgd2FzIHBhdXNlZCxcblx0Ly8gYXBwbHkgdGhlIGNoYW5nZSBub3dcblx0aWYgKGNoZWNrX2RpcnRpbmVzcyhlZmZlY3QpKSB7XG5cdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0Ly8gRW5zdXJlIHdlIHRvZ2dsZSB0aGUgZmxhZyBhZnRlciBwb3NzaWJseSB1cGRhdGluZyB0aGUgZWZmZWN0IHNvIHRoYXRcblx0Ly8gZWFjaCBibG9jayBsb2dpYyBjYW4gY29ycmVjdGx5IG9wZXJhdGUgb24gaW5lcnQgaXRlbXNcblx0ZWZmZWN0LmYgXj0gSU5FUlQ7XG5cblx0dmFyIGNoaWxkID0gZWZmZWN0LmZpcnN0O1xuXG5cdHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdHZhciBzaWJsaW5nID0gY2hpbGQubmV4dDtcblx0XHR2YXIgdHJhbnNwYXJlbnQgPSAoY2hpbGQuZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDAgfHwgKGNoaWxkLmYgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMDtcblx0XHQvLyBUT0RPIHdlIGRvbid0IG5lZWQgdG8gY2FsbCByZXN1bWVfY2hpbGRyZW4gcmVjdXJzaXZlbHkgd2l0aCBhIGxpbmtlZCBsaXN0IGluIHBsYWNlXG5cdFx0Ly8gaXQncyBzbGlnaHRseSBtb3JlIGludm9sdmVkIHRob3VnaCBhcyB3ZSBoYXZlIHRvIGFjY291bnQgZm9yIGB0cmFuc3BhcmVudGAgY2hhbmdpbmdcblx0XHQvLyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRcdHJlc3VtZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNwYXJlbnQgPyBsb2NhbCA6IGZhbHNlKTtcblx0XHRjaGlsZCA9IHNpYmxpbmc7XG5cdH1cblxuXHRpZiAoZWZmZWN0LnRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIGVmZmVjdC50cmFuc2l0aW9ucykge1xuXHRcdFx0aWYgKHRyYW5zaXRpb24uaXNfZ2xvYmFsIHx8IGxvY2FsKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24uaW4oKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vLyBGYWxsYmFjayBmb3Igd2hlbiByZXF1ZXN0SWRsZUNhbGxiYWNrIGlzIG5vdCBhdmFpbGFibGVcbmV4cG9ydCBjb25zdCByZXF1ZXN0X2lkbGVfY2FsbGJhY2sgPVxuXHR0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCdcblx0XHQ/ICgvKiogQHR5cGUgeygpID0+IHZvaWR9ICovIGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAxKVxuXHRcdDogcmVxdWVzdElkbGVDYWxsYmFjaztcblxubGV0IGlzX21pY3JvX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5sZXQgaXNfaWRsZV90YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXG4vKiogQHR5cGUge0FycmF5PCgpID0+IHZvaWQ+fSAqL1xubGV0IGN1cnJlbnRfcXVldWVkX21pY3JvX3Rhc2tzID0gW107XG4vKiogQHR5cGUge0FycmF5PCgpID0+IHZvaWQ+fSAqL1xubGV0IGN1cnJlbnRfcXVldWVkX2lkbGVfdGFza3MgPSBbXTtcblxuZnVuY3Rpb24gcHJvY2Vzc19taWNyb190YXNrcygpIHtcblx0aXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcblx0Y29uc3QgdGFza3MgPSBjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcy5zbGljZSgpO1xuXHRjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcyA9IFtdO1xuXHRydW5fYWxsKHRhc2tzKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pZGxlX3Rhc2tzKCkge1xuXHRpc19pZGxlX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cdGNvbnN0IHRhc2tzID0gY3VycmVudF9xdWV1ZWRfaWRsZV90YXNrcy5zbGljZSgpO1xuXHRjdXJyZW50X3F1ZXVlZF9pZGxlX3Rhc2tzID0gW107XG5cdHJ1bl9hbGwodGFza3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXVlX21pY3JvX3Rhc2soZm4pIHtcblx0aWYgKCFpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gdHJ1ZTtcblx0XHRxdWV1ZU1pY3JvdGFzayhwcm9jZXNzX21pY3JvX3Rhc2tzKTtcblx0fVxuXHRjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcy5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWV1ZV9pZGxlX3Rhc2soZm4pIHtcblx0aWYgKCFpc19pZGxlX3Rhc2tfcXVldWVkKSB7XG5cdFx0aXNfaWRsZV90YXNrX3F1ZXVlZCA9IHRydWU7XG5cdFx0cmVxdWVzdF9pZGxlX2NhbGxiYWNrKHByb2Nlc3NfaWRsZV90YXNrcyk7XG5cdH1cblx0Y3VycmVudF9xdWV1ZWRfaWRsZV90YXNrcy5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHJ1biBhbnkgcXVldWVkIHRhc2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfdGFza3MoKSB7XG5cdGlmIChpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdHByb2Nlc3NfbWljcm9fdGFza3MoKTtcblx0fVxuXHRpZiAoaXNfaWRsZV90YXNrX3F1ZXVlZCkge1xuXHRcdHByb2Nlc3NfaWRsZV90YXNrcygpO1xuXHR9XG59XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIENhbm5vdCB1c2UgYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9YCBpZiB0aGUgcGFyZW50IGNvbXBvbmVudCB1c2VzIGBsZXQ6YCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9kZWZhdWx0X3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRcXG5DYW5ub3QgdXNlIFxcYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9XFxgIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgXFxgbGV0OlxcYCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX2RlZmF1bHRfc25pcHBldGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJSguLi4pYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudFxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJWAgaXMgbm90IGEgc3RvcmUgd2l0aCBhIGBzdWJzY3JpYmVgIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0b3JlX2ludmFsaWRfc2hhcGVcXG5cXGAke25hbWV9XFxgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBcXGBzdWJzY3JpYmVcXGAgbWV0aG9kXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGB0aGlzYCBwcm9wIG9uIGA8c3ZlbHRlOmVsZW1lbnQ+YCBtdXN0IGJlIGEgc3RyaW5nLCBpZiBkZWZpbmVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWUoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlXFxuVGhlIFxcYHRoaXNcXGAgcHJvcCBvbiBcXGA8c3ZlbHRlOmVsZW1lbnQ+XFxgIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZWApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTaWduYWwsIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHksIGdldF9kZXNjcmlwdG9ycywgZ2V0X3Byb3RvdHlwZV9vZiB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbixcblx0ZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4sXG5cdGRlc3Ryb3lfZWZmZWN0X2Rlcml2ZWRzLFxuXHRlZmZlY3QsXG5cdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duLFxuXHR1bmxpbmtfZWZmZWN0XG59IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdEVGRkVDVCxcblx0UkVOREVSX0VGRkVDVCxcblx0RElSVFksXG5cdE1BWUJFX0RJUlRZLFxuXHRDTEVBTixcblx0REVSSVZFRCxcblx0VU5PV05FRCxcblx0REVTVFJPWUVELFxuXHRJTkVSVCxcblx0QlJBTkNIX0VGRkVDVCxcblx0U1RBVEVfU1lNQk9MLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRMRUdBQ1lfREVSSVZFRF9QUk9QLFxuXHRESVNDT05ORUNURUQsXG5cdEJPVU5EQVJZX0VGRkVDVFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBmbHVzaF90YXNrcyB9IGZyb20gJy4vZG9tL3Rhc2suanMnO1xuaW1wb3J0IHsgYWRkX293bmVyIH0gZnJvbSAnLi9kZXYvb3duZXJzaGlwLmpzJztcbmltcG9ydCB7IGludGVybmFsX3NldCwgc2V0LCBzb3VyY2UgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBkZXN0cm95X2Rlcml2ZWQsIGV4ZWN1dGVfZGVyaXZlZCwgdXBkYXRlX2Rlcml2ZWQgfSBmcm9tICcuL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQgfSBmcm9tICcuLi9zaGFyZWQvZXJyb3JzLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcsIHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgdHJhY2luZ19leHByZXNzaW9ucywgZ2V0X3N0YWNrIH0gZnJvbSAnLi9kZXYvdHJhY2luZy5qcyc7XG5cbmNvbnN0IEZMVVNIX01JQ1JPVEFTSyA9IDA7XG5jb25zdCBGTFVTSF9TWU5DID0gMTtcbi8vIFVzZWQgZm9yIERFViB0aW1lIGVycm9yIGhhbmRsaW5nXG4vKiogQHBhcmFtIHtXZWFrU2V0PEVycm9yPn0gdmFsdWUgKi9cbmNvbnN0IGhhbmRsZWRfZXJyb3JzID0gbmV3IFdlYWtTZXQoKTtcbmV4cG9ydCBsZXQgaXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcblxuLy8gVXNlZCBmb3IgY29udHJvbGxpbmcgdGhlIGZsdXNoIG9mIGVmZmVjdHMuXG5sZXQgc2NoZWR1bGVyX21vZGUgPSBGTFVTSF9NSUNST1RBU0s7XG4vLyBVc2VkIGZvciBoYW5kbGluZyBzY2hlZHVsaW5nXG5sZXQgaXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcblxuLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xubGV0IGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cbmV4cG9ydCBsZXQgaXNfZmx1c2hpbmdfZWZmZWN0ID0gZmFsc2U7XG5leHBvcnQgbGV0IGlzX2Rlc3Ryb3lpbmdfZWZmZWN0ID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc19mbHVzaGluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodmFsdWUpIHtcblx0aXNfZGVzdHJveWluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuLy8gSGFuZGxlIGVmZmVjdCBxdWV1ZXNcblxuLyoqIEB0eXBlIHtFZmZlY3RbXX0gKi9cbmxldCBxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cbmxldCBmbHVzaF9jb3VudCA9IDA7XG4vKiogQHR5cGUge0VmZmVjdFtdfSBTdGFjayBvZiBlZmZlY3RzLCBkZXYgb25seSAqL1xubGV0IGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcbi8vIEhhbmRsZSBzaWduYWwgcmVhY3Rpdml0eSB0cmVlIGRlcGVuZGVuY2llcyBhbmQgcmVhY3Rpb25zXG5cbi8qKiBAdHlwZSB7bnVsbCB8IFJlYWN0aW9ufSAqL1xuZXhwb3J0IGxldCBhY3RpdmVfcmVhY3Rpb24gPSBudWxsO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgUmVhY3Rpb259IHJlYWN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2FjdGl2ZV9yZWFjdGlvbihyZWFjdGlvbikge1xuXHRhY3RpdmVfcmVhY3Rpb24gPSByZWFjdGlvbjtcbn1cblxuLyoqIEB0eXBlIHtudWxsIHwgRWZmZWN0fSAqL1xuZXhwb3J0IGxldCBhY3RpdmVfZWZmZWN0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IEVmZmVjdH0gZWZmZWN0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2FjdGl2ZV9lZmZlY3QoZWZmZWN0KSB7XG5cdGFjdGl2ZV9lZmZlY3QgPSBlZmZlY3Q7XG59XG5cbi8qKlxuICogV2hlbiBzb3VyY2VzIGFyZSBjcmVhdGVkIHdpdGhpbiBhIGRlcml2ZWQsIHdlIHJlY29yZCB0aGVtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBhbGxvd1xuICogbG9jYWwgbXV0YXRpb25zIHRvIHRoZXNlIHNvdXJjZXMgd2l0aG91dCB0aGUgc2lkZS1lZmZlY3QgZXJyb3IgYmVpbmcgaW52b2tlZCB1bm5lY2Vzc2FyaWx5LlxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCBkZXJpdmVkX3NvdXJjZXMgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7U291cmNlW10gfCBudWxsfSBzb3VyY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVyaXZlZF9zb3VyY2VzKHNvdXJjZXMpIHtcblx0ZGVyaXZlZF9zb3VyY2VzID0gc291cmNlcztcbn1cblxuLyoqXG4gKiBUaGUgZGVwZW5kZW5jaWVzIG9mIHRoZSByZWFjdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBleGVjdXRlZC4gSW4gbWFueSBjYXNlcyxcbiAqIHRoZSBkZXBlbmRlbmNpZXMgYXJlIHVuY2hhbmdlZCBiZXR3ZWVuIHJ1bnMsIGFuZCBzbyB0aGlzIHdpbGwgYmUgYG51bGxgIHVubGVzc1xuICogYW5kIHVudGlsIGEgbmV3IGRlcGVuZGVuY3kgaXMgYWNjZXNzZWQg4oCUIHdlIHRyYWNrIHRoaXMgdmlhIGBza2lwcGVkX2RlcHNgXG4gKiBAdHlwZSB7bnVsbCB8IFZhbHVlW119XG4gKi9cbmV4cG9ydCBsZXQgbmV3X2RlcHMgPSBudWxsO1xuXG5sZXQgc2tpcHBlZF9kZXBzID0gMDtcblxuLyoqXG4gKiBUcmFja3Mgd3JpdGVzIHRoYXQgdGhlIGVmZmVjdCBpdCdzIGV4ZWN1dGVkIGluIGRvZXNuJ3QgbGlzdGVuIHRvIHlldCxcbiAqIHNvIHRoYXQgdGhlIGRlcGVuZGVuY3kgY2FuIGJlIGFkZGVkIHRvIHRoZSBlZmZlY3QgbGF0ZXIgb24gaWYgaXQgdGhlbiByZWFkcyBpdFxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCB1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IFNvdXJjZVtdfSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF91bnRyYWNrZWRfd3JpdGVzKHZhbHVlKSB7XG5cdHVudHJhY2tlZF93cml0ZXMgPSB2YWx1ZTtcbn1cblxuLyoqIEB0eXBlIHtudW1iZXJ9IFVzZWQgYnkgc291cmNlcyBhbmQgZGVyaXZlZHMgZm9yIGhhbmRsaW5nIHVwZGF0ZXMgdG8gdW5vd25lZCBkZXJpdmVkcyBpdCBzdGFydHMgZnJvbSAxIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBhIGNyZWF0ZWQgZWZmZWN0IGFuZCBhIHJ1biBvbmUgZm9yIHRyYWNpbmcgKi9cbmxldCBjdXJyZW50X3ZlcnNpb24gPSAxO1xuXG4vLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZ2V0KCkgY2hhaW4gdGhhdCBoYXMgbm8gYWN0aXZlIGNvbnRhaW5lcixcbi8vIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLCB3ZSBza2lwIGFkZGluZyB0aGUgcmVhY3Rpb24uXG5leHBvcnQgbGV0IHNraXBfcmVhY3Rpb24gPSBmYWxzZTtcbi8vIEhhbmRsZSBjb2xsZWN0aW5nIGFsbCBzaWduYWxzIHdoaWNoIGFyZSByZWFkIGR1cmluZyBhIHNwZWNpZmljIHRpbWUgZnJhbWVcbi8qKiBAdHlwZSB7U2V0PFZhbHVlPiB8IG51bGx9ICovXG5leHBvcnQgbGV0IGNhcHR1cmVkX3NpZ25hbHMgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtTZXQ8VmFsdWU+IHwgbnVsbH0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2FwdHVyZWRfc2lnbmFscyh2YWx1ZSkge1xuXHRjYXB0dXJlZF9zaWduYWxzID0gdmFsdWU7XG59XG5cbi8vIEhhbmRsaW5nIHJ1bnRpbWUgY29tcG9uZW50IGNvbnRleHRcbi8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dCB8IG51bGx9ICovXG5leHBvcnQgbGV0IGNvbXBvbmVudF9jb250ZXh0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dCB8IG51bGx9IGNvbnRleHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY29tcG9uZW50X2NvbnRleHQoY29udGV4dCkge1xuXHRjb21wb25lbnRfY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgY29tcG9uZW50IGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBjdXJyZW50IGNvbXBvbmVudCBjb250ZXh0OlxuICogYGBgaHRtbFxuICogPCEtLSBBcHAuc3ZlbHRlIC0tPlxuICogPEZvbz5cbiAqICAgPEJhciAvPiA8IS0tIGNvbnRleHQgPT0gRm9vLnN2ZWx0ZSwgZnVuY3Rpb24gPT0gQXBwLnN2ZWx0ZSAtLT5cbiAqIDwvRm9vPlxuICogYGBgXG4gKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dFsnZnVuY3Rpb24nXX1cbiAqL1xuZXhwb3J0IGxldCBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oZm4pIHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnRfdmVyc2lvbigpIHtcblx0cmV0dXJuICsrY3VycmVudF92ZXJzaW9uO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZXMoKSB7XG5cdHJldHVybiAhbGVnYWN5X21vZGVfZmxhZyB8fCAoY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZGVyaXZlZCBvciBlZmZlY3QgaXMgZGlydHkuXG4gKiBJZiBpdCBpcyBNQVlCRV9ESVJUWSwgd2lsbCBzZXQgdGhlIHN0YXR1cyB0byBDTEVBTlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfZGlydGluZXNzKHJlYWN0aW9uKSB7XG5cdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0aWYgKChmbGFncyAmIERJUlRZKSAhPT0gMCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKChmbGFncyAmIE1BWUJFX0RJUlRZKSAhPT0gMCkge1xuXHRcdHZhciBkZXBlbmRlbmNpZXMgPSByZWFjdGlvbi5kZXBzO1xuXHRcdHZhciBpc191bm93bmVkID0gKGZsYWdzICYgVU5PV05FRCkgIT09IDA7XG5cblx0XHRpZiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKChmbGFncyAmIERJU0NPTk5FQ1RFRCkgIT09IDApIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdChkZXBlbmRlbmNpZXNbaV0ucmVhY3Rpb25zID8/PSBbXSkucHVzaChyZWFjdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZWFjdGlvbi5mIF49IERJU0NPTk5FQ1RFRDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcblxuXHRcdFx0XHRpZiAoY2hlY2tfZGlydGluZXNzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcGVuZGVuY3kpKSkge1xuXHRcdFx0XHRcdHVwZGF0ZV9kZXJpdmVkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcGVuZGVuY3kpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHdlIGFyZSB3b3JraW5nIHdpdGggYW4gdW5vd25lZCBzaWduYWwgYXMgcGFydCBvZiBhbiBlZmZlY3QgKGR1ZSB0byAhc2tpcF9yZWFjdGlvbilcblx0XHRcdFx0Ly8gYW5kIHRoZSB2ZXJzaW9uIGhhc24ndCBjaGFuZ2VkLCB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoYXQgdGhpcyByZWFjdGlvblxuXHRcdFx0XHQvLyBpcyBsaW5rZWQgdG8gdGhlIGRlcGVuZGVuY3kgc291cmNlIOKAkyBvdGhlcndpc2UgZnV0dXJlIHVwZGF0ZXMgd2lsbCBub3QgYmUgY2F1Z2h0LlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0aXNfdW5vd25lZCAmJlxuXHRcdFx0XHRcdGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiZcblx0XHRcdFx0XHQhc2tpcF9yZWFjdGlvbiAmJlxuXHRcdFx0XHRcdCFkZXBlbmRlbmN5Py5yZWFjdGlvbnM/LmluY2x1ZGVzKHJlYWN0aW9uKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQoZGVwZW5kZW5jeS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKHJlYWN0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkZXBlbmRlbmN5LnZlcnNpb24gPiByZWFjdGlvbi52ZXJzaW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBVbm93bmVkIHNpZ25hbHMgc2hvdWxkIG5ldmVyIGJlIG1hcmtlZCBhcyBjbGVhbiB1bmxlc3MgdGhleVxuXHRcdC8vIGFyZSB1c2VkIHdpdGhpbiBhbiBhY3RpdmVfZWZmZWN0IHdpdGhvdXQgc2tpcF9yZWFjdGlvblxuXHRcdGlmICghaXNfdW5vd25lZCB8fCAoYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAhc2tpcF9yZWFjdGlvbikpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBDTEVBTik7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZnVuY3Rpb24gcHJvcGFnYXRlX2Vycm9yKGVycm9yLCBlZmZlY3QpIHtcblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgY3VycmVudCA9IGVmZmVjdDtcblxuXHR3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuXHRcdGlmICgoY3VycmVudC5mICYgQk9VTkRBUllfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRjdXJyZW50LmZuKGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdC8vIFJlbW92ZSBib3VuZGFyeSBmbGFnIGZyb20gZWZmZWN0XG5cdFx0XHRcdGN1cnJlbnQuZiBePSBCT1VOREFSWV9FRkZFQ1Q7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuXHR9XG5cblx0aXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcblx0dGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5mdW5jdGlvbiBzaG91bGRfcmV0aHJvd19lcnJvcihlZmZlY3QpIHtcblx0cmV0dXJuIChcblx0XHQoZWZmZWN0LmYgJiBERVNUUk9ZRUQpID09PSAwICYmXG5cdFx0KGVmZmVjdC5wYXJlbnQgPT09IG51bGwgfHwgKGVmZmVjdC5wYXJlbnQuZiAmIEJPVU5EQVJZX0VGRkVDVCkgPT09IDApXG5cdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldF9pc190aHJvd2luZ19lcnJvcigpIHtcblx0aXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdCB8IG51bGx9IHByZXZpb3VzX2VmZmVjdFxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29tcG9uZW50X2NvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9lcnJvcihlcnJvciwgZWZmZWN0LCBwcmV2aW91c19lZmZlY3QsIGNvbXBvbmVudF9jb250ZXh0KSB7XG5cdGlmIChpc190aHJvd2luZ19lcnJvcikge1xuXHRcdGlmIChwcmV2aW91c19lZmZlY3QgPT09IG51bGwpIHtcblx0XHRcdGlzX3Rocm93aW5nX2Vycm9yID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3VsZF9yZXRocm93X2Vycm9yKGVmZmVjdCkpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChwcmV2aW91c19lZmZlY3QgIT09IG51bGwpIHtcblx0XHRpc190aHJvd2luZ19lcnJvciA9IHRydWU7XG5cdH1cblxuXHRpZiAoXG5cdFx0IURFViB8fFxuXHRcdGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsIHx8XG5cdFx0IShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB8fFxuXHRcdGhhbmRsZWRfZXJyb3JzLmhhcyhlcnJvcilcblx0KSB7XG5cdFx0cHJvcGFnYXRlX2Vycm9yKGVycm9yLCBlZmZlY3QpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGhhbmRsZWRfZXJyb3JzLmFkZChlcnJvcik7XG5cblx0Y29uc3QgY29tcG9uZW50X3N0YWNrID0gW107XG5cblx0Y29uc3QgZWZmZWN0X25hbWUgPSBlZmZlY3QuZm4/Lm5hbWU7XG5cblx0aWYgKGVmZmVjdF9uYW1lKSB7XG5cdFx0Y29tcG9uZW50X3N0YWNrLnB1c2goZWZmZWN0X25hbWUpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cblx0bGV0IGN1cnJlbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXG5cdHdoaWxlIChjdXJyZW50X2NvbnRleHQgIT09IG51bGwpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0XHRcdHZhciBmaWxlbmFtZSA9IGN1cnJlbnRfY29udGV4dC5mdW5jdGlvbj8uW0ZJTEVOQU1FXTtcblxuXHRcdFx0aWYgKGZpbGVuYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSBmaWxlbmFtZS5zcGxpdCgnLycpLnBvcCgpO1xuXHRcdFx0XHRjb21wb25lbnRfc3RhY2sucHVzaChmaWxlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdXJyZW50X2NvbnRleHQgPSBjdXJyZW50X2NvbnRleHQucDtcblx0fVxuXG5cdGNvbnN0IGluZGVudCA9IC9GaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID8gJyAgJyA6ICdcXHQnO1xuXHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdtZXNzYWdlJywge1xuXHRcdHZhbHVlOiBlcnJvci5tZXNzYWdlICsgYFxcbiR7Y29tcG9uZW50X3N0YWNrLm1hcCgobmFtZSkgPT4gYFxcbiR7aW5kZW50fWluICR7bmFtZX1gKS5qb2luKCcnKX1cXG5gXG5cdH0pO1xuXHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdjb21wb25lbnRfc3RhY2snLCB7XG5cdFx0dmFsdWU6IGNvbXBvbmVudF9zdGFja1xuXHR9KTtcblxuXHRjb25zdCBzdGFjayA9IGVycm9yLnN0YWNrO1xuXG5cdC8vIEZpbHRlciBvdXQgaW50ZXJuYWwgZmlsZXMgZnJvbSBjYWxsc3RhY2tcblx0aWYgKHN0YWNrKSB7XG5cdFx0Y29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG5cdFx0Y29uc3QgbmV3X2xpbmVzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0aWYgKGxpbmUuaW5jbHVkZXMoJ3N2ZWx0ZS9zcmMvaW50ZXJuYWwnKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdG5ld19saW5lcy5wdXNoKGxpbmUpO1xuXHRcdH1cblx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcblx0XHRcdHZhbHVlOiBuZXdfbGluZXMuam9pbignXFxuJylcblx0XHR9KTtcblx0fVxuXG5cdHByb3BhZ2F0ZV9lcnJvcihlcnJvciwgZWZmZWN0KTtcblxuXHRpZiAoc2hvdWxkX3JldGhyb3dfZXJyb3IoZWZmZWN0KSkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9yZWFjdGlvbihyZWFjdGlvbikge1xuXHR2YXIgcHJldmlvdXNfZGVwcyA9IG5ld19kZXBzO1xuXHR2YXIgcHJldmlvdXNfc2tpcHBlZF9kZXBzID0gc2tpcHBlZF9kZXBzO1xuXHR2YXIgcHJldmlvdXNfdW50cmFja2VkX3dyaXRlcyA9IHVudHJhY2tlZF93cml0ZXM7XG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX3NraXBfcmVhY3Rpb24gPSBza2lwX3JlYWN0aW9uO1xuXHR2YXIgcHJldl9kZXJpdmVkX3NvdXJjZXMgPSBkZXJpdmVkX3NvdXJjZXM7XG5cdHZhciBwcmV2aW91c19jb21wb25lbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdG5ld19kZXBzID0gLyoqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX0gKi8gKG51bGwpO1xuXHRza2lwcGVkX2RlcHMgPSAwO1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblx0YWN0aXZlX3JlYWN0aW9uID0gKGZsYWdzICYgKEJSQU5DSF9FRkZFQ1QgfCBST09UX0VGRkVDVCkpID09PSAwID8gcmVhY3Rpb24gOiBudWxsO1xuXHRza2lwX3JlYWN0aW9uID0gIWlzX2ZsdXNoaW5nX2VmZmVjdCAmJiAoZmxhZ3MgJiBVTk9XTkVEKSAhPT0gMDtcblx0ZGVyaXZlZF9zb3VyY2VzID0gbnVsbDtcblx0Y29tcG9uZW50X2NvbnRleHQgPSByZWFjdGlvbi5jdHg7XG5cblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKDAsIHJlYWN0aW9uLmZuKSgpO1xuXHRcdHZhciBkZXBzID0gcmVhY3Rpb24uZGVwcztcblxuXHRcdGlmIChuZXdfZGVwcyAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdHJlbW92ZV9yZWFjdGlvbnMocmVhY3Rpb24sIHNraXBwZWRfZGVwcyk7XG5cblx0XHRcdGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA+IDApIHtcblx0XHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHMgKyBuZXdfZGVwcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBuZXdfZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRlcHNbc2tpcHBlZF9kZXBzICsgaV0gPSBuZXdfZGVwc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVhY3Rpb24uZGVwcyA9IGRlcHMgPSBuZXdfZGVwcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFza2lwX3JlYWN0aW9uKSB7XG5cdFx0XHRcdGZvciAoaSA9IHNraXBwZWRfZGVwczsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHQoZGVwc1tpXS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKHJlYWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZGVwcyAhPT0gbnVsbCAmJiBza2lwcGVkX2RlcHMgPCBkZXBzLmxlbmd0aCkge1xuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblx0XHRcdGRlcHMubGVuZ3RoID0gc2tpcHBlZF9kZXBzO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0gZmluYWxseSB7XG5cdFx0bmV3X2RlcHMgPSBwcmV2aW91c19kZXBzO1xuXHRcdHNraXBwZWRfZGVwcyA9IHByZXZpb3VzX3NraXBwZWRfZGVwcztcblx0XHR1bnRyYWNrZWRfd3JpdGVzID0gcHJldmlvdXNfdW50cmFja2VkX3dyaXRlcztcblx0XHRhY3RpdmVfcmVhY3Rpb24gPSBwcmV2aW91c19yZWFjdGlvbjtcblx0XHRza2lwX3JlYWN0aW9uID0gcHJldmlvdXNfc2tpcF9yZWFjdGlvbjtcblx0XHRkZXJpdmVkX3NvdXJjZXMgPSBwcmV2X2Rlcml2ZWRfc291cmNlcztcblx0XHRjb21wb25lbnRfY29udGV4dCA9IHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtWYWx1ZTxWPn0gZGVwZW5kZW5jeVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbihzaWduYWwsIGRlcGVuZGVuY3kpIHtcblx0bGV0IHJlYWN0aW9ucyA9IGRlcGVuZGVuY3kucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zICE9PSBudWxsKSB7XG5cdFx0dmFyIGluZGV4ID0gcmVhY3Rpb25zLmluZGV4T2Yoc2lnbmFsKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR2YXIgbmV3X2xlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGggLSAxO1xuXHRcdFx0aWYgKG5ld19sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3dhcCB3aXRoIGxhc3QgZWxlbWVudCBhbmQgdGhlbiByZW1vdmUuXG5cdFx0XHRcdHJlYWN0aW9uc1tpbmRleF0gPSByZWFjdGlvbnNbbmV3X2xlbmd0aF07XG5cdFx0XHRcdHJlYWN0aW9ucy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gSWYgdGhlIGRlcml2ZWQgaGFzIG5vIHJlYWN0aW9ucywgdGhlbiB3ZSBjYW4gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSBncmFwaCxcblx0Ly8gYWxsb3dpbmcgaXQgdG8gZWl0aGVyIHJlY29ubmVjdCBpbiB0aGUgZnV0dXJlLCBvciBiZSBHQydkIGJ5IHRoZSBWTS5cblx0aWYgKFxuXHRcdHJlYWN0aW9ucyA9PT0gbnVsbCAmJlxuXHRcdChkZXBlbmRlbmN5LmYgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdC8vIERlc3Ryb3lpbmcgYSBjaGlsZCBlZmZlY3Qgd2hpbGUgdXBkYXRpbmcgYSBwYXJlbnQgZWZmZWN0IGNhbiBjYXVzZSBhIGRlcGVuZGVuY3kgdG8gYXBwZWFyXG5cdFx0Ly8gdG8gYmUgdW51c2VkLCB3aGVuIGluIGZhY3QgaXQgaXMgdXNlZCBieSB0aGUgY3VycmVudGx5LXVwZGF0aW5nIHBhcmVudC4gQ2hlY2tpbmcgYG5ld19kZXBzYFxuXHRcdC8vIGFsbG93cyB1cyB0byBza2lwIHRoZSBleHBlbnNpdmUgd29yayBvZiBkaXNjb25uZWN0aW5nIGFuZCBpbW1lZGlhdGVseSByZWNvbm5lY3RpbmcgaXRcblx0XHQobmV3X2RlcHMgPT09IG51bGwgfHwgIW5ld19kZXBzLmluY2x1ZGVzKGRlcGVuZGVuY3kpKVxuXHQpIHtcblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhkZXBlbmRlbmN5LCBNQVlCRV9ESVJUWSk7XG5cdFx0Ly8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIGRlcml2ZWQgdGhhdCBpcyBvd25lZCBieSBhbiBlZmZlY3QsIHRoZW4gbWFyayBpdCBhcyBiZWluZ1xuXHRcdC8vIGRpc2Nvbm5lY3RlZC5cblx0XHRpZiAoKGRlcGVuZGVuY3kuZiAmIChVTk9XTkVEIHwgRElTQ09OTkVDVEVEKSkgPT09IDApIHtcblx0XHRcdGRlcGVuZGVuY3kuZiBePSBESVNDT05ORUNURUQ7XG5cdFx0fVxuXHRcdHJlbW92ZV9yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqKi8gKGRlcGVuZGVuY3kpLCAwKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2luZGV4XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbnMoc2lnbmFsLCBzdGFydF9pbmRleCkge1xuXHR2YXIgZGVwZW5kZW5jaWVzID0gc2lnbmFsLmRlcHM7XG5cdGlmIChkZXBlbmRlbmNpZXMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gc3RhcnRfaW5kZXg7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZW1vdmVfcmVhY3Rpb24oc2lnbmFsLCBkZXBlbmRlbmNpZXNbaV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRpZiAoKGZsYWdzICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblxuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xuXG5cdGlmIChERVYpIHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2ZuID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IGVmZmVjdC5jb21wb25lbnRfZnVuY3Rpb247XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICgoZmxhZ3MgJiBCTE9DS19FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihlZmZlY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihlZmZlY3QpO1xuXHRcdH1cblx0XHRkZXN0cm95X2VmZmVjdF9kZXJpdmVkcyhlZmZlY3QpO1xuXG5cdFx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KTtcblx0XHR2YXIgdGVhcmRvd24gPSB1cGRhdGVfcmVhY3Rpb24oZWZmZWN0KTtcblx0XHRlZmZlY3QudGVhcmRvd24gPSB0eXBlb2YgdGVhcmRvd24gPT09ICdmdW5jdGlvbicgPyB0ZWFyZG93biA6IG51bGw7XG5cdFx0ZWZmZWN0LnZlcnNpb24gPSBjdXJyZW50X3ZlcnNpb247XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRkZXZfZWZmZWN0X3N0YWNrLnB1c2goZWZmZWN0KTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBlZmZlY3QsIHByZXZpb3VzX2VmZmVjdCwgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgfHwgZWZmZWN0LmN0eCk7XG5cdH0gZmluYWxseSB7XG5cdFx0YWN0aXZlX2VmZmVjdCA9IHByZXZpb3VzX2VmZmVjdDtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IHByZXZpb3VzX2NvbXBvbmVudF9mbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbG9nX2VmZmVjdF9zdGFjaygpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5lcnJvcihcblx0XHQnTGFzdCB0ZW4gZWZmZWN0cyB3ZXJlOiAnLFxuXHRcdGRldl9lZmZlY3Rfc3RhY2suc2xpY2UoLTEwKS5tYXAoKGQpID0+IGQuZm4pXG5cdCk7XG5cdGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcbn1cblxuZnVuY3Rpb24gaW5maW5pdGVfbG9vcF9ndWFyZCgpIHtcblx0aWYgKGZsdXNoX2NvdW50ID4gMTAwMCkge1xuXHRcdGZsdXNoX2NvdW50ID0gMDtcblx0XHR0cnkge1xuXHRcdFx0ZS5lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkKCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0Ly8gc3RhY2sgaXMgZ2FyYmFnZSwgaWdub3JlLiBJbnN0ZWFkIGFkZCBhIGNvbnNvbGUuZXJyb3IgbWVzc2FnZS5cblx0XHRcdFx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnc3RhY2snLCB7XG5cdFx0XHRcdFx0dmFsdWU6ICcnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVHJ5IGFuZCBoYW5kbGUgdGhlIGVycm9yIHNvIGl0IGNhbiBiZSBjYXVnaHQgYXQgYSBib3VuZGFyeSwgdGhhdCdzXG5cdFx0XHQvLyBpZiB0aGVyZSdzIGFuIGVmZmVjdCBhdmFpbGFibGUgZnJvbSB3aGVuIGl0IHdhcyBsYXN0IHNjaGVkdWxlZFxuXHRcdFx0aWYgKGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGhhbmRsZV9lcnJvcihlcnJvciwgbGFzdF9zY2hlZHVsZWRfZWZmZWN0LCBudWxsLCBudWxsKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHQvLyBPbmx5IGxvZyB0aGUgZWZmZWN0IHN0YWNrIGlmIHRoZSBlcnJvciBpcyByZS10aHJvd25cblx0XHRcdFx0XHRcdGxvZ19lZmZlY3Rfc3RhY2soKTtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhhbmRsZV9lcnJvcihlcnJvciwgbGFzdF9zY2hlZHVsZWRfZWZmZWN0LCBudWxsLCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdGxvZ19lZmZlY3Rfc3RhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Zmx1c2hfY291bnQrKztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEVmZmVjdD59IHJvb3RfZWZmZWN0c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3F1ZXVlZF9yb290X2VmZmVjdHMocm9vdF9lZmZlY3RzKSB7XG5cdHZhciBsZW5ndGggPSByb290X2VmZmVjdHMubGVuZ3RoO1xuXHRpZiAobGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGluZmluaXRlX2xvb3BfZ3VhcmQoKTtcblxuXHR2YXIgcHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QgPSBpc19mbHVzaGluZ19lZmZlY3Q7XG5cdGlzX2ZsdXNoaW5nX2VmZmVjdCA9IHRydWU7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWZmZWN0ID0gcm9vdF9lZmZlY3RzW2ldO1xuXG5cdFx0XHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pID09PSAwKSB7XG5cdFx0XHRcdGVmZmVjdC5mIF49IENMRUFOO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiogQHR5cGUge0VmZmVjdFtdfSAqL1xuXHRcdFx0dmFyIGNvbGxlY3RlZF9lZmZlY3RzID0gW107XG5cblx0XHRcdHByb2Nlc3NfZWZmZWN0cyhlZmZlY3QsIGNvbGxlY3RlZF9lZmZlY3RzKTtcblx0XHRcdGZsdXNoX3F1ZXVlZF9lZmZlY3RzKGNvbGxlY3RlZF9lZmZlY3RzKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfZmx1c2hpbmdfZWZmZWN0ID0gcHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3Q7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEVmZmVjdD59IGVmZmVjdHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmbHVzaF9xdWV1ZWRfZWZmZWN0cyhlZmZlY3RzKSB7XG5cdHZhciBsZW5ndGggPSBlZmZlY3RzLmxlbmd0aDtcblx0aWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZWZmZWN0ID0gZWZmZWN0c1tpXTtcblxuXHRcdGlmICgoZWZmZWN0LmYgJiAoREVTVFJPWUVEIHwgSU5FUlQpKSA9PT0gMCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhlZmZlY3QpKSB7XG5cdFx0XHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXG5cdFx0XHRcdFx0Ly8gRWZmZWN0cyB3aXRoIG5vIGRlcGVuZGVuY2llcyBvciB0ZWFyZG93biBkbyBub3QgZ2V0IGFkZGVkIHRvIHRoZSBlZmZlY3QgdHJlZS5cblx0XHRcdFx0XHQvLyBEZWZlcnJlZCBlZmZlY3RzIChlLmcuIGAkZWZmZWN0KC4uLilgKSBfYXJlXyBhZGRlZCB0byB0aGUgdHJlZSBiZWNhdXNlIHdlXG5cdFx0XHRcdFx0Ly8gZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1bnRpbCB0aGV5IGFyZSBleGVjdXRlZC4gRG9pbmcgdGhlIGNoZWNrXG5cdFx0XHRcdFx0Ly8gaGVyZSAocmF0aGVyIHRoYW4gaW4gYHVwZGF0ZV9lZmZlY3RgKSBhbGxvd3MgdXMgdG8gc2tpcCB0aGUgd29yayBmb3Jcblx0XHRcdFx0XHQvLyBpbW1lZGlhdGUgZWZmZWN0cy5cblx0XHRcdFx0XHRpZiAoZWZmZWN0LmRlcHMgPT09IG51bGwgJiYgZWZmZWN0LmZpcnN0ID09PSBudWxsICYmIGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKGVmZmVjdC50ZWFyZG93biA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHQvLyByZW1vdmUgdGhpcyBlZmZlY3QgZnJvbSB0aGUgZ3JhcGhcblx0XHRcdFx0XHRcdFx0dW5saW5rX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8ga2VlcCB0aGUgZWZmZWN0IGluIHRoZSBncmFwaCwgYnV0IGZyZWUgdXAgc29tZSBtZW1vcnlcblx0XHRcdFx0XHRcdFx0ZWZmZWN0LmZuID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGhhbmRsZV9lcnJvcihlcnJvciwgZWZmZWN0LCBudWxsLCBlZmZlY3QuY3R4KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19kZWZlcnJlZCgpIHtcblx0aXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcblx0aWYgKGZsdXNoX2NvdW50ID4gMTAwMSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBwcmV2aW91c19xdWV1ZWRfcm9vdF9lZmZlY3RzID0gcXVldWVkX3Jvb3RfZWZmZWN0cztcblx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IFtdO1xuXHRmbHVzaF9xdWV1ZWRfcm9vdF9lZmZlY3RzKHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMpO1xuXG5cdGlmICghaXNfbWljcm9fdGFza19xdWV1ZWQpIHtcblx0XHRmbHVzaF9jb3VudCA9IDA7XG5cdFx0bGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gbnVsbDtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRkZXZfZWZmZWN0X3N0YWNrID0gW107XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZV9lZmZlY3Qoc2lnbmFsKSB7XG5cdGlmIChzY2hlZHVsZXJfbW9kZSA9PT0gRkxVU0hfTUlDUk9UQVNLKSB7XG5cdFx0aWYgKCFpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdFx0aXNfbWljcm9fdGFza19xdWV1ZWQgPSB0cnVlO1xuXHRcdFx0cXVldWVNaWNyb3Rhc2socHJvY2Vzc19kZWZlcnJlZCk7XG5cdFx0fVxuXHR9XG5cblx0bGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gc2lnbmFsO1xuXG5cdHZhciBlZmZlY3QgPSBzaWduYWw7XG5cblx0d2hpbGUgKGVmZmVjdC5wYXJlbnQgIT09IG51bGwpIHtcblx0XHRlZmZlY3QgPSBlZmZlY3QucGFyZW50O1xuXHRcdHZhciBmbGFncyA9IGVmZmVjdC5mO1xuXG5cdFx0aWYgKChmbGFncyAmIChST09UX0VGRkVDVCB8IEJSQU5DSF9FRkZFQ1QpKSAhPT0gMCkge1xuXHRcdFx0aWYgKChmbGFncyAmIENMRUFOKSA9PT0gMCkgcmV0dXJuO1xuXHRcdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0fVxuXHR9XG5cblx0cXVldWVkX3Jvb3RfZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG59XG5cbi8qKlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYm90aCBydW5zIHJlbmRlciBlZmZlY3RzIGFuZCBjb2xsZWN0cyB1c2VyIGVmZmVjdHMgaW4gdG9wb2xvZ2ljYWwgb3JkZXJcbiAqIGZyb20gdGhlIHN0YXJ0aW5nIGVmZmVjdCBwYXNzZWQgaW4uIEVmZmVjdHMgd2lsbCBiZSBjb2xsZWN0ZWQgd2hlbiB0aGV5IG1hdGNoIHRoZSBmaWx0ZXJlZFxuICogYml0d2lzZSBmbGFnIHBhc3NlZCBpbiBvbmx5LiBUaGUgY29sbGVjdGVkIGVmZmVjdHMgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBhbGwgdGhlIHVzZXJcbiAqIGVmZmVjdHMgdG8gYmUgZmx1c2hlZC5cbiAqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdFtdfSBjb2xsZWN0ZWRfZWZmZWN0c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NfZWZmZWN0cyhlZmZlY3QsIGNvbGxlY3RlZF9lZmZlY3RzKSB7XG5cdHZhciBjdXJyZW50X2VmZmVjdCA9IGVmZmVjdC5maXJzdDtcblx0dmFyIGVmZmVjdHMgPSBbXTtcblxuXHRtYWluX2xvb3A6IHdoaWxlIChjdXJyZW50X2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdHZhciBmbGFncyA9IGN1cnJlbnRfZWZmZWN0LmY7XG5cdFx0dmFyIGlzX2JyYW5jaCA9IChmbGFncyAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdHZhciBpc19za2lwcGFibGVfYnJhbmNoID0gaXNfYnJhbmNoICYmIChmbGFncyAmIENMRUFOKSAhPT0gMDtcblx0XHR2YXIgc2libGluZyA9IGN1cnJlbnRfZWZmZWN0Lm5leHQ7XG5cblx0XHRpZiAoIWlzX3NraXBwYWJsZV9icmFuY2ggJiYgKGZsYWdzICYgSU5FUlQpID09PSAwKSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgUkVOREVSX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdFx0aWYgKGlzX2JyYW5jaCkge1xuXHRcdFx0XHRcdGN1cnJlbnRfZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoY3VycmVudF9lZmZlY3QpKSB7XG5cdFx0XHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoY3VycmVudF9lZmZlY3QpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGN1cnJlbnRfZWZmZWN0LCBudWxsLCBjdXJyZW50X2VmZmVjdC5jdHgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjaGlsZCA9IGN1cnJlbnRfZWZmZWN0LmZpcnN0O1xuXG5cdFx0XHRcdGlmIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGN1cnJlbnRfZWZmZWN0ID0gY2hpbGQ7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoKGZsYWdzICYgRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0XHRlZmZlY3RzLnB1c2goY3VycmVudF9lZmZlY3QpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzaWJsaW5nID09PSBudWxsKSB7XG5cdFx0XHRsZXQgcGFyZW50ID0gY3VycmVudF9lZmZlY3QucGFyZW50O1xuXG5cdFx0XHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChlZmZlY3QgPT09IHBhcmVudCkge1xuXHRcdFx0XHRcdGJyZWFrIG1haW5fbG9vcDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcGFyZW50X3NpYmxpbmcgPSBwYXJlbnQubmV4dDtcblx0XHRcdFx0aWYgKHBhcmVudF9zaWJsaW5nICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VycmVudF9lZmZlY3QgPSBwYXJlbnRfc2libGluZztcblx0XHRcdFx0XHRjb250aW51ZSBtYWluX2xvb3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdXJyZW50X2VmZmVjdCA9IHNpYmxpbmc7XG5cdH1cblxuXHQvLyBXZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggbWFueSBlZmZlY3RzIGhlcmUsIGZhciBtb3JlIHRoYW4gY2FuIGJlIHNwcmVhZCBpbnRvXG5cdC8vIGFuIGFycmF5IHB1c2ggY2FsbCAoY2FsbHN0YWNrIG92ZXJmbG93KS4gU28gbGV0J3MgZGVhbCB3aXRoIGVhY2ggZWZmZWN0IGluIGEgbG9vcC5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGQgPSBlZmZlY3RzW2ldO1xuXHRcdGNvbGxlY3RlZF9lZmZlY3RzLnB1c2goY2hpbGQpO1xuXHRcdHByb2Nlc3NfZWZmZWN0cyhjaGlsZCwgY29sbGVjdGVkX2VmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgdmVyc2lvbiBvZiBgZmx1c2hTeW5jYCB3aXRoIHRoZSBvcHRpb24gdG8gbm90IGZsdXNoIHByZXZpb3VzIGVmZmVjdHMuXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHBhc3NlZCBmdW5jdGlvbiwgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0geygpID0+IGFueX0gW2ZuXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3N5bmMoZm4pIHtcblx0dmFyIHByZXZpb3VzX3NjaGVkdWxlcl9tb2RlID0gc2NoZWR1bGVyX21vZGU7XG5cdHZhciBwcmV2aW91c19xdWV1ZWRfcm9vdF9lZmZlY3RzID0gcXVldWVkX3Jvb3RfZWZmZWN0cztcblxuXHR0cnkge1xuXHRcdGluZmluaXRlX2xvb3BfZ3VhcmQoKTtcblxuXHRcdC8qKiBAdHlwZSB7RWZmZWN0W119ICovXG5cdFx0Y29uc3Qgcm9vdF9lZmZlY3RzID0gW107XG5cblx0XHRzY2hlZHVsZXJfbW9kZSA9IEZMVVNIX1NZTkM7XG5cdFx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IHJvb3RfZWZmZWN0cztcblx0XHRpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXG5cdFx0Zmx1c2hfcXVldWVkX3Jvb3RfZWZmZWN0cyhwcmV2aW91c19xdWV1ZWRfcm9vdF9lZmZlY3RzKTtcblxuXHRcdHZhciByZXN1bHQgPSBmbj8uKCk7XG5cblx0XHRmbHVzaF90YXNrcygpO1xuXHRcdGlmIChxdWV1ZWRfcm9vdF9lZmZlY3RzLmxlbmd0aCA+IDAgfHwgcm9vdF9lZmZlY3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdGZsdXNoX3N5bmMoKTtcblx0XHR9XG5cblx0XHRmbHVzaF9jb3VudCA9IDA7XG5cdFx0bGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gbnVsbDtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRkZXZfZWZmZWN0X3N0YWNrID0gW107XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBmaW5hbGx5IHtcblx0XHRzY2hlZHVsZXJfbW9kZSA9IHByZXZpb3VzX3NjaGVkdWxlcl9tb2RlO1xuXHRcdHF1ZXVlZF9yb290X2VmZmVjdHMgPSBwcmV2aW91c19xdWV1ZWRfcm9vdF9lZmZlY3RzO1xuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRpY2soKSB7XG5cdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXHQvLyBCeSBjYWxsaW5nIGZsdXNoX3N5bmMgd2UgZ3VhcmFudGVlIHRoYXQgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBhcmUgYXBwbGllZCBhZnRlciBvbmUgdGljay5cblx0Ly8gVE9ETyBsb29rIGludG8gd2hldGhlciB3ZSBjYW4gbWFrZSBmbHVzaGluZyBzdWJzZXF1ZW50IHVwZGF0ZXMgc3luY2hyb25vdXNseSBpbiB0aGUgZnV0dXJlLlxuXHRmbHVzaF9zeW5jKCk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj59IHNpZ25hbFxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoc2lnbmFsKSB7XG5cdHZhciBmbGFncyA9IHNpZ25hbC5mO1xuXHR2YXIgaXNfZGVyaXZlZCA9IChmbGFncyAmIERFUklWRUQpICE9PSAwO1xuXG5cdC8vIElmIHRoZSBkZXJpdmVkIGlzIGRlc3Ryb3llZCwganVzdCBleGVjdXRlIGl0IGFnYWluIHdpdGhvdXQgcmV0YWluaW5nXG5cdC8vIGl0cyBtZW1vaXNhdGlvbiBwcm9wZXJ0aWVzIGFzIHRoZSBkZXJpdmVkIGlzIHN0YWxlXG5cdGlmIChpc19kZXJpdmVkICYmIChmbGFncyAmIERFU1RST1lFRCkgIT09IDApIHtcblx0XHR2YXIgdmFsdWUgPSBleGVjdXRlX2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKSk7XG5cdFx0Ly8gRW5zdXJlIHRoZSBkZXJpdmVkIHJlbWFpbnMgZGVzdHJveWVkXG5cdFx0ZGVzdHJveV9kZXJpdmVkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCkpO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGlmIChjYXB0dXJlZF9zaWduYWxzICE9PSBudWxsKSB7XG5cdFx0Y2FwdHVyZWRfc2lnbmFscy5hZGQoc2lnbmFsKTtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBkZXBlbmRlbmN5IG9uIHRoZSBjdXJyZW50IHJlYWN0aW9uIHNpZ25hbC5cblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCkge1xuXHRcdGlmIChkZXJpdmVkX3NvdXJjZXMgIT09IG51bGwgJiYgZGVyaXZlZF9zb3VyY2VzLmluY2x1ZGVzKHNpZ25hbCkpIHtcblx0XHRcdGUuc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWQoKTtcblx0XHR9XG5cdFx0dmFyIGRlcHMgPSBhY3RpdmVfcmVhY3Rpb24uZGVwcztcblxuXHRcdC8vIElmIHRoZSBzaWduYWwgaXMgYWNjZXNzaW5nIHRoZSBzYW1lIGRlcGVuZGVuY2llcyBpbiB0aGUgc2FtZVxuXHRcdC8vIG9yZGVyIGFzIGl0IGRpZCBsYXN0IHRpbWUsIGluY3JlbWVudCBgc2tpcHBlZF9kZXBzYFxuXHRcdC8vIHJhdGhlciB0aGFuIHVwZGF0aW5nIGBuZXdfZGVwc2AsIHdoaWNoIGNyZWF0ZXMgR0MgY29zdFxuXHRcdGlmIChuZXdfZGVwcyA9PT0gbnVsbCAmJiBkZXBzICE9PSBudWxsICYmIGRlcHNbc2tpcHBlZF9kZXBzXSA9PT0gc2lnbmFsKSB7XG5cdFx0XHRza2lwcGVkX2RlcHMrKztcblx0XHR9IGVsc2UgaWYgKG5ld19kZXBzID09PSBudWxsKSB7XG5cdFx0XHRuZXdfZGVwcyA9IFtzaWduYWxdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdfZGVwcy5wdXNoKHNpZ25hbCk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0dW50cmFja2VkX3dyaXRlcyAhPT0gbnVsbCAmJlxuXHRcdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIENMRUFOKSAhPT0gMCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIEJSQU5DSF9FRkZFQ1QpID09PSAwICYmXG5cdFx0XHR1bnRyYWNrZWRfd3JpdGVzLmluY2x1ZGVzKHNpZ25hbClcblx0XHQpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGFjdGl2ZV9lZmZlY3QsIERJUlRZKTtcblx0XHRcdHNjaGVkdWxlX2VmZmVjdChhY3RpdmVfZWZmZWN0KTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoaXNfZGVyaXZlZCAmJiAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmRlcHMgPT09IG51bGwpIHtcblx0XHR2YXIgZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCk7XG5cdFx0dmFyIHBhcmVudCA9IGRlcml2ZWQucGFyZW50O1xuXHRcdHZhciB0YXJnZXQgPSBkZXJpdmVkO1xuXG5cdFx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gQXR0YWNoIHRoZSBkZXJpdmVkIHRvIHRoZSBuZWFyZXN0IHBhcmVudCBlZmZlY3QsIGlmIHRoZXJlIGFyZSBkZXJpdmVkc1xuXHRcdFx0Ly8gaW4gYmV0d2VlbiB0aGVuIHdlIGFsc28gbmVlZCB0byBhdHRhY2ggdGhlbSB0b29cblx0XHRcdGlmICgocGFyZW50LmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0XHR2YXIgcGFyZW50X2Rlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChwYXJlbnQpO1xuXG5cdFx0XHRcdHRhcmdldCA9IHBhcmVudF9kZXJpdmVkO1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnRfZGVyaXZlZC5wYXJlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcGFyZW50X2VmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocGFyZW50KTtcblxuXHRcdFx0XHRpZiAoIXBhcmVudF9lZmZlY3QuZGVyaXZlZHM/LmluY2x1ZGVzKHRhcmdldCkpIHtcblx0XHRcdFx0XHQocGFyZW50X2VmZmVjdC5kZXJpdmVkcyA/Pz0gW10pLnB1c2godGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfZGVyaXZlZCkge1xuXHRcdGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXG5cdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhkZXJpdmVkKSkge1xuXHRcdFx0dXBkYXRlX2Rlcml2ZWQoZGVyaXZlZCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKFxuXHRcdERFViAmJlxuXHRcdHRyYWNpbmdfbW9kZV9mbGFnICYmXG5cdFx0dHJhY2luZ19leHByZXNzaW9ucyAhPT0gbnVsbCAmJlxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMucmVhY3Rpb24gPT09IGFjdGl2ZV9yZWFjdGlvblxuXHQpIHtcblx0XHQvLyBVc2VkIHdoZW4gbWFwcGluZyBzdGF0ZSBiZXR3ZWVuIHNwZWNpYWwgYmxvY2tzIGxpa2UgYGVhY2hgXG5cdFx0aWYgKHNpZ25hbC5kZWJ1Zykge1xuXHRcdFx0c2lnbmFsLmRlYnVnKCk7XG5cdFx0fSBlbHNlIGlmIChzaWduYWwuY3JlYXRlZCkge1xuXHRcdFx0dmFyIGVudHJ5ID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLmdldChzaWduYWwpO1xuXG5cdFx0XHRpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRlbnRyeSA9IHsgcmVhZDogW10gfTtcblx0XHRcdFx0dHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLnNldChzaWduYWwsIGVudHJ5KTtcblx0XHRcdH1cblxuXHRcdFx0ZW50cnkucmVhZC5wdXNoKGdldF9zdGFjaygnVHJhY2VkQXQnKSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNpZ25hbC52O1xufVxuXG4vKipcbiAqIExpa2UgYGdldGAsIGJ1dCBjaGVja3MgZm9yIGB1bmRlZmluZWRgLiBVc2VkIGZvciBgdmFyYCBkZWNsYXJhdGlvbnMgYmVjYXVzZSB0aGV5IGNhbiBiZSBhY2Nlc3NlZCBiZWZvcmUgYmVpbmcgZGVjbGFyZWRcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+IHwgdW5kZWZpbmVkfSBzaWduYWxcbiAqIEByZXR1cm5zIHtWIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9nZXQoc2lnbmFsKSB7XG5cdHJldHVybiBzaWduYWwgJiYgZ2V0KHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ2FwdHVyZSBhbiBhcnJheSBvZiBhbGwgdGhlIHNpZ25hbHMgdGhhdCBhcmUgcmVhZCB3aGVuIGBmbmAgaXMgY2FsbGVkXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZV9zaWduYWxzKGZuKSB7XG5cdHZhciBwcmV2aW91c19jYXB0dXJlZF9zaWduYWxzID0gY2FwdHVyZWRfc2lnbmFscztcblx0Y2FwdHVyZWRfc2lnbmFscyA9IG5ldyBTZXQoKTtcblxuXHR2YXIgY2FwdHVyZWQgPSBjYXB0dXJlZF9zaWduYWxzO1xuXHR2YXIgc2lnbmFsO1xuXG5cdHRyeSB7XG5cdFx0dW50cmFjayhmbik7XG5cdFx0aWYgKHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMgIT09IG51bGwpIHtcblx0XHRcdGZvciAoc2lnbmFsIG9mIGNhcHR1cmVkX3NpZ25hbHMpIHtcblx0XHRcdFx0cHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscy5hZGQoc2lnbmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Y2FwdHVyZWRfc2lnbmFscyA9IHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHM7XG5cdH1cblxuXHRyZXR1cm4gY2FwdHVyZWQ7XG59XG5cbi8qKlxuICogSW52b2tlcyBhIGZ1bmN0aW9uIGFuZCBjYXB0dXJlcyBhbGwgc2lnbmFscyB0aGF0IGFyZSByZWFkIGR1cmluZyB0aGUgaW52b2NhdGlvbixcbiAqIHRoZW4gaW52YWxpZGF0ZXMgdGhlbS5cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzKGZuKSB7XG5cdHZhciBjYXB0dXJlZCA9IGNhcHR1cmVfc2lnbmFscygoKSA9PiB1bnRyYWNrKGZuKSk7XG5cblx0Zm9yICh2YXIgc2lnbmFsIG9mIGNhcHR1cmVkKSB7XG5cdFx0Ly8gR28gb25lIGxldmVsIHVwIGJlY2F1c2UgZGVyaXZlZCBzaWduYWxzIGNyZWF0ZWQgYXMgcGFydCBvZiBwcm9wcyBpbiBsZWdhY3kgbW9kZVxuXHRcdGlmICgoc2lnbmFsLmYgJiBMRUdBQ1lfREVSSVZFRF9QUk9QKSAhPT0gMCkge1xuXHRcdFx0Zm9yIChjb25zdCBkZXAgb2YgLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKS5kZXBzIHx8IFtdKSB7XG5cdFx0XHRcdGlmICgoZGVwLmYgJiBERVJJVkVEKSA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIFVzZSBpbnRlcm5hbF9zZXQgaW5zdGVhZCBvZiBzZXQgaGVyZSBhbmQgYmVsb3cgdG8gYXZvaWQgbXV0YXRpb24gdmFsaWRhdGlvblxuXHRcdFx0XHRcdGludGVybmFsX3NldChkZXAsIGRlcC52KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCBzaWduYWwudik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogV2hlbiB1c2VkIGluc2lkZSBhIFtgJGRlcml2ZWRgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtgJGVmZmVjdGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSxcbiAqIGFueSBzdGF0ZSByZWFkIGluc2lkZSBgZm5gIHdpbGwgbm90IGJlIHRyZWF0ZWQgYXMgYSBkZXBlbmRlbmN5LlxuICpcbiAqIGBgYHRzXG4gKiAkZWZmZWN0KCgpID0+IHtcbiAqICAgLy8gdGhpcyB3aWxsIHJ1biB3aGVuIGBkYXRhYCBjaGFuZ2VzLCBidXQgbm90IHdoZW4gYHRpbWVgIGNoYW5nZXNcbiAqICAgc2F2ZShkYXRhLCB7XG4gKiAgICAgdGltZXN0YW1wOiB1bnRyYWNrKCgpID0+IHRpbWUpXG4gKiAgIH0pO1xuICogfSk7XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2soZm4pIHtcblx0Y29uc3QgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHRyeSB7XG5cdFx0YWN0aXZlX3JlYWN0aW9uID0gbnVsbDtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHRhY3RpdmVfcmVhY3Rpb24gPSBwcmV2aW91c19yZWFjdGlvbjtcblx0fVxufVxuXG5jb25zdCBTVEFUVVNfTUFTSyA9IH4oRElSVFkgfCBNQVlCRV9ESVJUWSB8IENMRUFOKTtcblxuLyoqXG4gKiBAcGFyYW0ge1NpZ25hbH0gc2lnbmFsXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zaWduYWxfc3RhdHVzKHNpZ25hbCwgc3RhdHVzKSB7XG5cdHNpZ25hbC5mID0gKHNpZ25hbC5mICYgU1RBVFVTX01BU0spIHwgc3RhdHVzO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ2dldENvbnRleHQnKTtcblx0Y29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXAuZ2V0KGtleSkpO1xuXG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBmbiA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KS5mdW5jdGlvbjtcblx0XHRpZiAoZm4pIHtcblx0XHRcdGFkZF9vd25lcihyZXN1bHQsIGZuLCB0cnVlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdzZXRDb250ZXh0Jyk7XG5cdGNvbnRleHRfbWFwLnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnaGFzQ29udGV4dCcpO1xuXHRyZXR1cm4gY29udGV4dF9tYXAuaGFzKGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRBbGxDb250ZXh0cycpO1xuXG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBmbiA9IGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbjtcblx0XHRpZiAoZm4pIHtcblx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgY29udGV4dF9tYXAudmFsdWVzKCkpIHtcblx0XHRcdFx0YWRkX293bmVyKHZhbHVlLCBmbiwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIC8qKiBAdHlwZSB7VH0gKi8gKGNvbnRleHRfbWFwKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge01hcDx1bmtub3duLCB1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gZ2V0X29yX2luaXRfY29udGV4dF9tYXAobmFtZSkge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gKGNvbXBvbmVudF9jb250ZXh0LmMgPz89IG5ldyBNYXAoZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB8fCB1bmRlZmluZWQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHR9IGNvbXBvbmVudF9jb250ZXh0XG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB7XG5cdGxldCBwYXJlbnQgPSBjb21wb25lbnRfY29udGV4dC5wO1xuXHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgY29udGV4dF9tYXAgPSBwYXJlbnQuYztcblx0XHRpZiAoY29udGV4dF9tYXAgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBjb250ZXh0X21hcDtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnA7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtudW1iZXIgfCBiaWdpbnR9IFRcbiAqIEBwYXJhbSB7VmFsdWU8VD59IHNpZ25hbFxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoc2lnbmFsLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc2lnbmFsKTtcblx0dmFyIHJlc3VsdCA9IGQgPT09IDEgPyB2YWx1ZSsrIDogdmFsdWUtLTtcblxuXHRzZXQoc2lnbmFsLCB2YWx1ZSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyIHwgYmlnaW50fSBUXG4gKiBAcGFyYW0ge1ZhbHVlPFQ+fSBzaWduYWxcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3ByZShzaWduYWwsIGQgPSAxKSB7XG5cdHZhciB2YWx1ZSA9IGdldChzaWduYWwpO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHNldChzaWduYWwsIGQgPT09IDEgPyArK3ZhbHVlIDogLS12YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlX2Zyb21fb2JqZWN0KG9iaiwga2V5cykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuXHR2YXIgcmVzdWx0ID0ge307XG5cblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IG9ialtrZXldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7YW55fSBydW5lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoKHByb3BzLCBydW5lcyA9IGZhbHNlLCBmbikge1xuXHRjb21wb25lbnRfY29udGV4dCA9IHtcblx0XHRwOiBjb21wb25lbnRfY29udGV4dCxcblx0XHRjOiBudWxsLFxuXHRcdGU6IG51bGwsXG5cdFx0bTogZmFsc2UsXG5cdFx0czogcHJvcHMsXG5cdFx0eDogbnVsbCxcblx0XHRsOiBudWxsXG5cdH07XG5cblx0aWYgKGxlZ2FjeV9tb2RlX2ZsYWcgJiYgIXJ1bmVzKSB7XG5cdFx0Y29tcG9uZW50X2NvbnRleHQubCA9IHtcblx0XHRcdHM6IG51bGwsXG5cdFx0XHR1OiBudWxsLFxuXHRcdFx0cjE6IFtdLFxuXHRcdFx0cjI6IHNvdXJjZShmYWxzZSlcblx0XHR9O1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdC8vIGNvbXBvbmVudCBmdW5jdGlvblxuXHRcdGNvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uID0gZm47XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFRcbiAqIEBwYXJhbSB7VH0gW2NvbXBvbmVudF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wKGNvbXBvbmVudCkge1xuXHRjb25zdCBjb250ZXh0X3N0YWNrX2l0ZW0gPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGNvbnRleHRfc3RhY2tfaXRlbSAhPT0gbnVsbCkge1xuXHRcdGlmIChjb21wb25lbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29udGV4dF9zdGFja19pdGVtLnggPSBjb21wb25lbnQ7XG5cdFx0fVxuXHRcdGNvbnN0IGNvbXBvbmVudF9lZmZlY3RzID0gY29udGV4dF9zdGFja19pdGVtLmU7XG5cdFx0aWYgKGNvbXBvbmVudF9lZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0XHRcdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRcdGNvbnRleHRfc3RhY2tfaXRlbS5lID0gbnVsbDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50X2VmZmVjdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY29tcG9uZW50X2VmZmVjdCA9IGNvbXBvbmVudF9lZmZlY3RzW2ldO1xuXHRcdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KGNvbXBvbmVudF9lZmZlY3QuZWZmZWN0KTtcblx0XHRcdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKGNvbXBvbmVudF9lZmZlY3QucmVhY3Rpb24pO1xuXHRcdFx0XHRcdGVmZmVjdChjb21wb25lbnRfZWZmZWN0LmZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dF9zdGFja19pdGVtLnA7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gY29udGV4dF9zdGFja19pdGVtLnA/LmZ1bmN0aW9uID8/IG51bGw7XG5cdFx0fVxuXHRcdGNvbnRleHRfc3RhY2tfaXRlbS5tID0gdHJ1ZTtcblx0fVxuXHQvLyBNaWNyby1vcHRpbWl6YXRpb246IERvbid0IHNldCAuYSBhYm92ZSB0byB0aGUgZW1wdHkgb2JqZWN0XG5cdC8vIHNvIGl0IGNhbiBiZSBnYXJiYWdlLWNvbGxlY3RlZCB3aGVuIHRoZSByZXR1cm4gaGVyZSBpcyB1bnVzZWRcblx0cmV0dXJuIGNvbXBvbmVudCB8fCAvKiogQHR5cGUge1R9ICovICh7fSk7XG59XG5cbi8qKlxuICogUG9zc2libHkgdHJhdmVyc2UgYW4gb2JqZWN0IGFuZCByZWFkIGFsbCBpdHMgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkncmUgYWxsIHJlYWN0aXZlIGluIGNhc2UgdGhpcyBpcyBgJHN0YXRlYC5cbiAqIERvZXMgb25seSBjaGVjayBmaXJzdCBsZXZlbCBvZiBhbiBvYmplY3QgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKGhldXJpc3RpYyBzaG91bGQgYmUgZ29vZCBmb3IgOTklIG9mIGFsbCBjYXNlcykuXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkX3N0YXRlKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8ICF2YWx1ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdGRlZXBfcmVhZCh2YWx1ZSk7XG5cdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRjb25zdCBwcm9wID0gdmFsdWVba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAmJiBTVEFURV9TWU1CT0wgaW4gcHJvcCkge1xuXHRcdFx0XHRkZWVwX3JlYWQocHJvcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRGVlcGx5IHRyYXZlcnNlIGFuIG9iamVjdCBhbmQgcmVhZCBhbGwgaXRzIHByb3BlcnRpZXNcbiAqIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVhY3RpdmUgaW4gY2FzZSB0aGlzIGlzIGAkc3RhdGVgXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZpc2l0ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkKHZhbHVlLCB2aXNpdGVkID0gbmV3IFNldCgpKSB7XG5cdGlmIChcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlIERPTSBlbGVtZW50c1xuXHRcdCEodmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkgJiZcblx0XHQhdmlzaXRlZC5oYXModmFsdWUpXG5cdCkge1xuXHRcdHZpc2l0ZWQuYWRkKHZhbHVlKTtcblx0XHQvLyBXaGVuIHdvcmtpbmcgd2l0aCBhIHBvc3NpYmxlIFN2ZWx0ZURhdGUsIHRoaXNcblx0XHQvLyB3aWxsIGVuc3VyZSB3ZSBjYXB0dXJlIGNoYW5nZXMgdG8gaXQuXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0dmFsdWUuZ2V0VGltZSgpO1xuXHRcdH1cblx0XHRmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlZXBfcmVhZCh2YWx1ZVtrZXldLCB2aXNpdGVkKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblx0XHRpZiAoXG5cdFx0XHRwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IEFycmF5LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IE1hcC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBTZXQucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gRGF0ZS5wcm90b3R5cGVcblx0XHQpIHtcblx0XHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblx0XHRcdGZvciAobGV0IGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0XHRjb25zdCBnZXQgPSBkZXNjcmlwdG9yc1trZXldLmdldDtcblx0XHRcdFx0aWYgKGdldCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRnZXQuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuaWYgKERFVikge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcblx0ICovXG5cdGZ1bmN0aW9uIHRocm93X3J1bmVfZXJyb3IocnVuZSkge1xuXHRcdGlmICghKHJ1bmUgaW4gZ2xvYmFsVGhpcykpIHtcblx0XHRcdC8vIFRPRE8gaWYgcGVvcGxlIHN0YXJ0IGFkanVzdGluZyB0aGUgXCJ0aGlzIGNhbiBjb250YWluIHJ1bmVzXCIgY29uZmlnIHRocm91Z2ggdi1wLXMgbW9yZSwgYWRqdXN0IHRoaXMgbWVzc2FnZVxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWU7IC8vIGxldCdzIGhvcGUgbm9vbmUgbW9kaWZpZXMgdGhpcyBnbG9iYWwsIGJ1dCBiZWx0cyBhbmQgYnJhY2VzXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgcnVuZSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZS5ydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6ICh2KSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvd19ydW5lX2Vycm9yKCckc3RhdGUnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGVmZmVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckZGVyaXZlZCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckaW5zcGVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckcHJvcHMnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGJpbmRhYmxlJyk7XG59XG4iLCIvKiogQGltcG9ydCB7IFNvdXJjZUxvY2F0aW9uIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9TVEFSVCwgSFlEUkFUSU9OX1NUQVJUX0VMU0UgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGZuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U291cmNlTG9jYXRpb25bXX0gbG9jYXRpb25zXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xvY2F0aW9ucyhmbiwgZmlsZW5hbWUsIGxvY2F0aW9ucykge1xuXHRyZXR1cm4gKC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHRjb25zdCBkb20gPSBmbiguLi5hcmdzKTtcblxuXHRcdHZhciBub2RlID0gaHlkcmF0aW5nID8gZG9tIDogZG9tLm5vZGVUeXBlID09PSAxMSA/IGRvbS5maXJzdENoaWxkIDogZG9tO1xuXHRcdGFzc2lnbl9sb2NhdGlvbnMobm9kZSwgZmlsZW5hbWUsIGxvY2F0aW9ucyk7XG5cblx0XHRyZXR1cm4gZG9tO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1NvdXJjZUxvY2F0aW9ufSBsb2NhdGlvblxuICovXG5mdW5jdGlvbiBhc3NpZ25fbG9jYXRpb24oZWxlbWVudCwgZmlsZW5hbWUsIGxvY2F0aW9uKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdGxvYzogeyBmaWxlOiBmaWxlbmFtZSwgbGluZTogbG9jYXRpb25bMF0sIGNvbHVtbjogbG9jYXRpb25bMV0gfVxuXHR9O1xuXG5cdGlmIChsb2NhdGlvblsyXSkge1xuXHRcdGFzc2lnbl9sb2NhdGlvbnMoZWxlbWVudC5maXJzdENoaWxkLCBmaWxlbmFtZSwgbG9jYXRpb25bMl0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlIHwgbnVsbH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1NvdXJjZUxvY2F0aW9uW119IGxvY2F0aW9uc1xuICovXG5mdW5jdGlvbiBhc3NpZ25fbG9jYXRpb25zKG5vZGUsIGZpbGVuYW1lLCBsb2NhdGlvbnMpIHtcblx0dmFyIGkgPSAwO1xuXHR2YXIgZGVwdGggPSAwO1xuXG5cdHdoaWxlIChub2RlICYmIGkgPCBsb2NhdGlvbnMubGVuZ3RoKSB7XG5cdFx0aWYgKGh5ZHJhdGluZyAmJiBub2RlLm5vZGVUeXBlID09PSA4KSB7XG5cdFx0XHR2YXIgY29tbWVudCA9IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpO1xuXHRcdFx0aWYgKGNvbW1lbnQuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGNvbW1lbnQuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0UpIGRlcHRoICs9IDE7XG5cdFx0XHRlbHNlIGlmIChjb21tZW50LmRhdGFbMF0gPT09IEhZRFJBVElPTl9FTkQpIGRlcHRoIC09IDE7XG5cdFx0fVxuXG5cdFx0aWYgKGRlcHRoID09PSAwICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdGFzc2lnbl9sb2NhdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKSwgZmlsZW5hbWUsIGxvY2F0aW9uc1tpKytdKTtcblx0XHR9XG5cblx0XHRub2RlID0gbm9kZS5uZXh0U2libGluZztcblx0fVxufVxuIiwiaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNsZWFyX3RleHRfY29udGVudCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9mb2N1cyhkb20sIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSkge1xuXHRcdGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHRcdGRvbS5hdXRvZm9jdXMgPSB0cnVlO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gYm9keSkge1xuXHRcdFx0XHRkb20uZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBjaGlsZCBvZiBhIHRleHRhcmVhIGFjdHVhbGx5IGNvcnJlc3BvbmRzIHRvIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHksIHNvIHdlIG5lZWRcbiAqIHRvIHJlbW92ZSBpdCB1cG9uIGh5ZHJhdGlvbiB0byBhdm9pZCBhIGJ1ZyB3aGVuIHNvbWVvbmUgcmVzZXRzIHRoZSBmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtIVE1MVGV4dEFyZWFFbGVtZW50fSBkb21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX3RleHRhcmVhX2NoaWxkKGRvbSkge1xuXHRpZiAoaHlkcmF0aW5nICYmIGdldF9maXJzdF9jaGlsZChkb20pICE9PSBudWxsKSB7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KGRvbSk7XG5cdH1cbn1cblxubGV0IGxpc3RlbmluZ190b19mb3JtX3Jlc2V0ID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRfZm9ybV9yZXNldF9saXN0ZW5lcigpIHtcblx0aWYgKCFsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCkge1xuXHRcdGxpc3RlbmluZ190b19mb3JtX3Jlc2V0ID0gdHJ1ZTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0J3Jlc2V0Jyxcblx0XHRcdChldnQpID0+IHtcblx0XHRcdFx0Ly8gTmVlZHMgdG8gaGFwcGVuIG9uZSB0aWNrIGxhdGVyIG9yIGVsc2UgdGhlIGRvbSBwcm9wZXJ0aWVzIG9mIHRoZSBmb3JtXG5cdFx0XHRcdC8vIGVsZW1lbnRzIGhhdmUgbm90IHVwZGF0ZWQgdG8gdGhlaXIgcmVzZXQgdmFsdWVzIHlldFxuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoIWV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGUgb2YgLyoqQHR5cGUge0hUTUxGb3JtRWxlbWVudH0gKi8gKGV2dC50YXJnZXQpLmVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdFx0ZS5fX29uX3I/LigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSW4gdGhlIGNhcHR1cmUgcGhhc2UgdG8gZ3VhcmFudGVlIHdlIGdldCBub3RpY2VkIG9mIGl0IChubyBwb3NzaWJsaXR5IG9mIHN0b3BQcm9wYWdhdGlvbilcblx0XHRcdHsgY2FwdHVyZTogdHJ1ZSB9XG5cdFx0KTtcblx0fVxufVxuIiwiaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5cbi8qKlxuICogRmlyZXMgdGhlIGhhbmRsZXIgb25jZSBpbW1lZGlhdGVseSAodW5sZXNzIGNvcnJlc3BvbmRpbmcgYXJnIGlzIHNldCB0byBgZmFsc2VgKSxcbiAqIHRoZW4gbGlzdGVucyB0byB0aGUgZ2l2ZW4gZXZlbnRzIHVudGlsIHRoZSByZW5kZXIgZWZmZWN0IGNvbnRleHQgaXMgZGVzdHJveWVkXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0geyhldmVudD86IEV2ZW50KSA9PiB2b2lkfSBoYW5kbGVyXG4gKiBAcGFyYW0ge2FueX0gY2FsbF9oYW5kbGVyX2ltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudHMsIGhhbmRsZXIsIGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSA9IHRydWUpIHtcblx0aWYgKGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSkge1xuXHRcdGhhbmRsZXIoKTtcblx0fVxuXG5cdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG5cdH1cblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Zm9yICh2YXIgbmFtZSBvZiBldmVudHMpIHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dChmbikge1xuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogTGlzdGVuIHRvIHRoZSBnaXZlbiBldmVudCwgYW5kIHRoZW4gaW5zdGFudGlhdGUgYSBnbG9iYWwgZm9ybSByZXNldCBsaXN0ZW5lciBpZiBub3QgYWxyZWFkeSBkb25lLFxuICogdG8gbm90aWZ5IGFsbCBiaW5kaW5ncyB3aGVuIHRoZSBmb3JtIGlzIHJlc2V0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHsoaXNfcmVzZXQ/OiB0cnVlKSA9PiB2b2lkfSBbb25fcmVzZXRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBvbl9yZXNldCA9IGhhbmRsZXIpIHtcblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoKSA9PiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoaGFuZGxlcikpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IHByZXYgPSBlbGVtZW50Ll9fb25fcjtcblx0aWYgKHByZXYpIHtcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGNoZWNrYm94IHRoYXQgY2FuIGhhdmUgbXVsdGlwbGUgYmluZHMgKGdyb3VwICYgY2hlY2tlZClcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiB7XG5cdFx0XHRwcmV2KCk7XG5cdFx0XHRvbl9yZXNldCh0cnVlKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50Ll9fb25fciA9ICgpID0+IG9uX3Jlc2V0KHRydWUpO1xuXHR9XG5cblx0YWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdsb2NhdGUtY2hhcmFjdGVyJyAqL1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG4vKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuZXhwb3J0IGNvbnN0IGFsbF9yZWdpc3RlcmVkX2V2ZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtTZXQ8KGV2ZW50czogQXJyYXk8c3RyaW5nPikgPT4gdm9pZD59ICovXG5leHBvcnQgY29uc3Qgcm9vdF9ldmVudF9oYW5kbGVzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIFNTUiBhZGRzIG9ubG9hZCBhbmQgb25lcnJvciBhdHRyaWJ1dGVzIHRvIGNhdGNoIHRob3NlIGV2ZW50cyBiZWZvcmUgdGhlIGh5ZHJhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB0aG9zZSBjYXNlcywgcmVtb3ZlcyB0aGUgYXR0cmlidXRlcyBhbmQgcmVwbGF5cyB0aGUgZXZlbnRzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlfZXZlbnRzKGRvbSkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdGlmIChkb20ub25sb2FkKSB7XG5cdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25sb2FkJyk7XG5cdH1cblx0aWYgKGRvbS5vbmVycm9yKSB7XG5cdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25lcnJvcicpO1xuXHR9XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgZXZlbnQgPSBkb20uX19lO1xuXHRpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRkb20uX19lID0gdW5kZWZpbmVkO1xuXHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdGlmIChkb20uaXNDb25uZWN0ZWQpIHtcblx0XHRcdFx0ZG9tLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGRvbVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBvcHRpb25zKSB7XG5cdC8qKlxuXHQgKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRmdW5jdGlvbiB0YXJnZXRfaGFuZGxlcigvKiogQHR5cGUge0V2ZW50fSAqLyBldmVudCkge1xuXHRcdGlmICghb3B0aW9ucy5jYXB0dXJlKSB7XG5cdFx0XHQvLyBPbmx5IGNhbGwgaW4gdGhlIGJ1YmJsZSBwaGFzZSwgZWxzZSBkZWxlZ2F0ZWQgZXZlbnRzIHdvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNhcHR1cmluZyBldmVudHNcblx0XHRcdGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbi5jYWxsKGRvbSwgZXZlbnQpO1xuXHRcdH1cblx0XHRpZiAoIWV2ZW50LmNhbmNlbEJ1YmJsZSkge1xuXHRcdFx0cmV0dXJuIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hyb21lIGhhcyBhIGJ1ZyB3aGVyZSBwb2ludGVyIGV2ZW50cyBkb24ndCB3b3JrIHdoZW4gYXR0YWNoZWQgdG8gYSBET00gZWxlbWVudCB0aGF0IGhhcyBiZWVuIGNsb25lZFxuXHQvLyB3aXRoIGNsb25lTm9kZSgpIGFuZCB0aGUgRE9NIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50LiBUbyBlbnN1cmUgdGhlIGV2ZW50IHdvcmtzLCB3ZVxuXHQvLyBkZWZlciB0aGUgYXR0YWNobWVudCB0aWxsIGFmdGVyIGl0J3MgYmVlbiBhcHBlbmRlZCB0byB0aGUgZG9jdW1lbnQuIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIGZpeGVzXG5cdC8vIHRoaXMgYnVnLiBUaGUgc2FtZSBhcHBsaWVzIHRvIHdoZWVsIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuXHRpZiAoXG5cdFx0ZXZlbnRfbmFtZS5zdGFydHNXaXRoKCdwb2ludGVyJykgfHxcblx0XHRldmVudF9uYW1lLnN0YXJ0c1dpdGgoJ3RvdWNoJykgfHxcblx0XHRldmVudF9uYW1lID09PSAnd2hlZWwnXG5cdCkge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXRfaGFuZGxlcjtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGhhbmRsZXIuIFVzaW5nIHRoaXNcbiAqIHJhdGhlciB0aGFuIGBhZGRFdmVudExpc3RlbmVyYCB3aWxsIHByZXNlcnZlIHRoZSBjb3JyZWN0IG9yZGVyIHJlbGF0aXZlIHRvIGhhbmRsZXJzIGFkZGVkIGRlY2xhcmF0aXZlbHlcbiAqICh3aXRoIGF0dHJpYnV0ZXMgbGlrZSBgb25jbGlja2ApLCB3aGljaCB1c2UgZXZlbnQgZGVsZWdhdGlvbiBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudCh0eXBlLCBlbGVtZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FwdHVyZVxuICogQHBhcmFtIHtib29sZWFufSBbcGFzc2l2ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlKSB7XG5cdHZhciBvcHRpb25zID0geyBjYXB0dXJlLCBwYXNzaXZlIH07XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0aWYgKGRvbSA9PT0gZG9jdW1lbnQuYm9keSB8fCBkb20gPT09IHdpbmRvdyB8fCBkb20gPT09IGRvY3VtZW50KSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZWdhdGUoZXZlbnRzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudHNbaV0pO1xuXHR9XG5cblx0Zm9yICh2YXIgZm4gb2Ygcm9vdF9ldmVudF9oYW5kbGVzKSB7XG5cdFx0Zm4oZXZlbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbihldmVudCkge1xuXHR2YXIgaGFuZGxlcl9lbGVtZW50ID0gdGhpcztcblx0dmFyIG93bmVyX2RvY3VtZW50ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoaGFuZGxlcl9lbGVtZW50KS5vd25lckRvY3VtZW50O1xuXHR2YXIgZXZlbnRfbmFtZSA9IGV2ZW50LnR5cGU7XG5cdHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoPy4oKSB8fCBbXTtcblx0dmFyIGN1cnJlbnRfdGFyZ2V0ID0gLyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi8gKHBhdGhbMF0gfHwgZXZlbnQudGFyZ2V0KTtcblxuXHQvLyBjb21wb3NlZFBhdGggY29udGFpbnMgbGlzdCBvZiBub2RlcyB0aGUgZXZlbnQgaGFzIHByb3BhZ2F0ZWQgdGhyb3VnaC5cblx0Ly8gV2UgY2hlY2sgX19yb290IHRvIHNraXAgYWxsIG5vZGVzIGJlbG93IGl0IGluIGNhc2UgdGhpcyBpcyBhXG5cdC8vIHBhcmVudCBvZiB0aGUgX19yb290IG5vZGUsIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZXJlJ3MgbmVzdGVkXG5cdC8vIG1vdW50ZWQgYXBwcy4gSW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudHMgbXVsdGlwbGUgdGltZXMuXG5cdHZhciBwYXRoX2lkeCA9IDA7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyBhZGRlZCBiZWxvd1xuXHR2YXIgaGFuZGxlZF9hdCA9IGV2ZW50Ll9fcm9vdDtcblxuXHRpZiAoaGFuZGxlZF9hdCkge1xuXHRcdHZhciBhdF9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlZF9hdCk7XG5cdFx0aWYgKFxuXHRcdFx0YXRfaWR4ICE9PSAtMSAmJlxuXHRcdFx0KGhhbmRsZXJfZWxlbWVudCA9PT0gZG9jdW1lbnQgfHwgaGFuZGxlcl9lbGVtZW50ID09PSAvKiogQHR5cGUge2FueX0gKi8gKHdpbmRvdykpXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBvciBhIHdpbmRvdyBsaXN0ZW5lciwgYnV0IHRoZSBldmVudCB3YXMgYWxyZWFkeSBoYW5kbGVkXG5cdFx0XHQvLyAtPiBpZ25vcmUsIGJ1dCBzZXQgaGFuZGxlX2F0IHRvIGRvY3VtZW50L3dpbmRvdyBzbyB0aGF0IHdlJ3JlIHJlc2V0dGluZyB0aGUgZXZlbnRcblx0XHRcdC8vIGNoYWluIGluIGNhc2Ugc29tZW9uZSBtYW51YWxseSBkaXNwYXRjaGVzIHRoZSBzYW1lIGV2ZW50IG9iamVjdCBhZ2Fpbi5cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHNraXBwaW5nIGlmIHRoZSBpbmRleCBpcyBoaWdoZXIsIGJlY2F1c2Vcblx0XHQvLyBzb21lb25lIGNvdWxkIGNyZWF0ZSBhbiBldmVudCBwcm9ncmFtbWF0aWNhbGx5IGFuZCBlbWl0IGl0IG11bHRpcGxlIHRpbWVzLFxuXHRcdC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgdGhlIHdob2xlIHByb3BhZ2F0aW9uIGNoYWluIHByb3Blcmx5IGVhY2ggdGltZS5cblx0XHQvLyAodGhpcyB3aWxsIG9ubHkgYmUgYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtdWx0aXBsZSB0aW1lcyBhbmRcblx0XHQvLyB0aGUgZmFsbGJhY2sgZG9jdW1lbnQgbGlzdGVuZXIgaXNuJ3QgcmVhY2hlZCBpbiBiZXR3ZWVuLCBidXQgdGhhdCdzIHN1cGVyIHJhcmUpXG5cdFx0dmFyIGhhbmRsZXJfaWR4ID0gcGF0aC5pbmRleE9mKGhhbmRsZXJfZWxlbWVudCk7XG5cdFx0aWYgKGhhbmRsZXJfaWR4ID09PSAtMSkge1xuXHRcdFx0Ly8gaGFuZGxlX2lkeCBjYW4gdGhlb3JldGljYWxseSBiZSAtMSAoaGFwcGVuZWQgaW4gc29tZSBKU0RPTSB0ZXN0aW5nIHNjZW5hcmlvcyB3aXRoIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgb2JqZWN0KVxuXHRcdFx0Ly8gc28gZ3VhcmQgYWdhaW5zdCB0aGF0LCB0b28sIGFuZCBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIHdhcyBoYW5kbGVkIGF0IHRoaXMgcG9pbnQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGF0X2lkeCA8PSBoYW5kbGVyX2lkeCkge1xuXHRcdFx0cGF0aF9pZHggPSBhdF9pZHg7XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChwYXRoW3BhdGhfaWR4XSB8fCBldmVudC50YXJnZXQpO1xuXHQvLyB0aGVyZSBjYW4gb25seSBiZSBvbmUgZGVsZWdhdGVkIGV2ZW50IHBlciBlbGVtZW50LCBhbmQgd2UgZWl0aGVyIGFscmVhZHkgaGFuZGxlZCB0aGUgY3VycmVudCB0YXJnZXQsXG5cdC8vIG9yIHRoaXMgaXMgdGhlIHZlcnkgZmlyc3QgdGFyZ2V0IGluIHRoZSBjaGFpbiB3aGljaCBoYXMgYSBub24tZGVsZWdhdGVkIGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGl0J3Mgc2FmZVxuXHQvLyB0byBoYW5kbGUgYSBwb3NzaWJsZSBkZWxlZ2F0ZWQgZXZlbnQgb24gaXQgbGF0ZXIgKHRocm91Z2ggdGhlIHJvb3QgZGVsZWdhdGlvbiBsaXN0ZW5lciBmb3IgZXhhbXBsZSkuXG5cdGlmIChjdXJyZW50X3RhcmdldCA9PT0gaGFuZGxlcl9lbGVtZW50KSByZXR1cm47XG5cblx0Ly8gUHJveHkgY3VycmVudFRhcmdldCB0byBjb3JyZWN0IHRhcmdldFxuXHRkZWZpbmVfcHJvcGVydHkoZXZlbnQsICdjdXJyZW50VGFyZ2V0Jywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudF90YXJnZXQgfHwgb3duZXJfZG9jdW1lbnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGlzIHN0YXJ0ZWQgYmVjYXVzZSBvZiBDaHJvbWl1bSBpc3N1ZSBodHRwczovL2Nocm9tZXN0YXR1cy5jb20vZmVhdHVyZS81MTI4Njk2ODIzNTQ1ODU2LFxuXHQvLyB3aGVyZSByZW1vdmFsIG9yIG1vdmluZyBvZiBvZiB0aGUgRE9NIGNhbiBjYXVzZSBzeW5jIGBibHVyYCBldmVudHMgdG8gZmlyZSwgd2hpY2ggY2FuIGNhdXNlIGxvZ2ljXG5cdC8vIHRvIHJ1biBpbnNpZGUgdGhlIGN1cnJlbnQgYGFjdGl2ZV9yZWFjdGlvbmAsIHdoaWNoIGlzbid0IHdoYXQgd2Ugd2FudCBhdCBhbGwuIEhvd2V2ZXIsIG9uIHJlZmxlY3Rpb24sXG5cdC8vIGl0J3MgcHJvYmFibHkgYmVzdCB0aGF0IGFsbCBldmVudCBoYW5kbGVkIGJ5IFN2ZWx0ZSBoYXZlIHRoaXMgYmVoYXZpb3VyLCBhcyB3ZSBkb24ndCByZWFsbHkgd2FudFxuXHQvLyBhbiBldmVudCBoYW5kbGVyIHRvIHJ1biBpbiB0aGUgY29udGV4dCBvZiBhbm90aGVyIHJlYWN0aW9uIG9yIGVmZmVjdC5cblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cblx0dHJ5IHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bn1cblx0XHQgKi9cblx0XHR2YXIgdGhyb3dfZXJyb3I7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3Vua25vd25bXX1cblx0XHQgKi9cblx0XHR2YXIgb3RoZXJfZXJyb3JzID0gW107XG5cblx0XHR3aGlsZSAoY3VycmVudF90YXJnZXQgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdFx0XHR2YXIgcGFyZW50X2VsZW1lbnQgPVxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5hc3NpZ25lZFNsb3QgfHxcblx0XHRcdFx0Y3VycmVudF90YXJnZXQucGFyZW50Tm9kZSB8fFxuXHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5ob3N0IHx8XG5cdFx0XHRcdG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0dmFyIGRlbGVnYXRlZCA9IGN1cnJlbnRfdGFyZ2V0WydfXycgKyBldmVudF9uYW1lXTtcblxuXHRcdFx0XHRpZiAoZGVsZWdhdGVkICE9PSB1bmRlZmluZWQgJiYgISgvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5kaXNhYmxlZCkpIHtcblx0XHRcdFx0XHRpZiAoaXNfYXJyYXkoZGVsZWdhdGVkKSkge1xuXHRcdFx0XHRcdFx0dmFyIFtmbiwgLi4uZGF0YV0gPSBkZWxlZ2F0ZWQ7XG5cdFx0XHRcdFx0XHRmbi5hcHBseShjdXJyZW50X3RhcmdldCwgW2V2ZW50LCAuLi5kYXRhXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRlbGVnYXRlZC5jYWxsKGN1cnJlbnRfdGFyZ2V0LCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdFx0XHRvdGhlcl9lcnJvcnMucHVzaChlcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3dfZXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSB8fCBwYXJlbnRfZWxlbWVudCA9PT0gaGFuZGxlcl9lbGVtZW50IHx8IHBhcmVudF9lbGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudF90YXJnZXQgPSBwYXJlbnRfZWxlbWVudDtcblx0XHR9XG5cblx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdGZvciAobGV0IGVycm9yIG9mIG90aGVyX2Vycm9ycykge1xuXHRcdFx0XHQvLyBUaHJvdyB0aGUgcmVzdCBvZiB0aGUgZXJyb3JzLCBvbmUtYnktb25lIG9uIGEgbWljcm90YXNrXG5cdFx0XHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyB0aHJvd19lcnJvcjtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyB1c2VkIGFib3ZlXG5cdFx0ZXZlbnQuX19yb290ID0gaGFuZGxlcl9lbGVtZW50O1xuXHRcdC8vIEB0cy1pZ25vcmUgcmVtb3ZlIHByb3h5IG9uIGN1cnJlbnRUYXJnZXRcblx0XHRkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2LCB3YXJuIGlmIGFuIGV2ZW50IGhhbmRsZXIgaXMgbm90IGEgZnVuY3Rpb24sIGFzIGl0IG1lYW5zIHRoZVxuICogdXNlciBwcm9iYWJseSBjYWxsZWQgdGhlIGhhbmRsZXIgb3IgZm9yZ290IHRvIGFkZCBhIGAoKSA9PmBcbiAqIEBwYXJhbSB7KCkgPT4gKGV2ZW50OiBFdmVudCwgLi4uYXJnczogYW55KSA9PiB2b2lkfSB0aHVua1xuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtbRXZlbnQsIC4uLmFueV19IGFyZ3NcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gW2xvY11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZV9wYXJlbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseShcblx0dGh1bmssXG5cdGVsZW1lbnQsXG5cdGFyZ3MsXG5cdGNvbXBvbmVudCxcblx0bG9jLFxuXHRoYXNfc2lkZV9lZmZlY3RzID0gZmFsc2UsXG5cdHJlbW92ZV9wYXJlbnMgPSBmYWxzZVxuKSB7XG5cdGxldCBoYW5kbGVyO1xuXHRsZXQgZXJyb3I7XG5cblx0dHJ5IHtcblx0XHRoYW5kbGVyID0gdGh1bmsoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGVycm9yID0gZTtcblx0fVxuXG5cdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhhbmRsZXIuYXBwbHkoZWxlbWVudCwgYXJncyk7XG5cdH0gZWxzZSBpZiAoaGFzX3NpZGVfZWZmZWN0cyB8fCBoYW5kbGVyICE9IG51bGwgfHwgZXJyb3IpIHtcblx0XHRjb25zdCBmaWxlbmFtZSA9IGNvbXBvbmVudD8uW0ZJTEVOQU1FXTtcblx0XHRjb25zdCBsb2NhdGlvbiA9IGxvYyA/IGAgYXQgJHtmaWxlbmFtZX06JHtsb2NbMF19OiR7bG9jWzFdfWAgOiBgIGluICR7ZmlsZW5hbWV9YDtcblxuXHRcdGNvbnN0IGV2ZW50X25hbWUgPSBhcmdzWzBdLnR5cGU7XG5cdFx0Y29uc3QgZGVzY3JpcHRpb24gPSBgXFxgJHtldmVudF9uYW1lfVxcYCBoYW5kbGVyJHtsb2NhdGlvbn1gO1xuXHRcdGNvbnN0IHN1Z2dlc3Rpb24gPSByZW1vdmVfcGFyZW5zID8gJ3JlbW92ZSB0aGUgdHJhaWxpbmcgYCgpYCcgOiAnYWRkIGEgbGVhZGluZyBgKCkgPT5gJztcblxuXHRcdHcuZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGRlc2NyaXB0aW9uLCBzdWdnZXN0aW9uKTtcblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59XG4iLCIvKiogQHBhcmFtIHtzdHJpbmd9IGh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpIHtcblx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRlbGVtLmlubmVySFRNTCA9IGh0bWw7XG5cdHJldHVybiBlbGVtLmNvbnRlbnQ7XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgVEVNUExBVEVfRlJBR01FTlQsIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZSB8IG51bGx9IGVuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpIHtcblx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cdGlmIChlZmZlY3Qubm9kZXNfc3RhcnQgPT09IG51bGwpIHtcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBzdGFydDtcblx0XHRlZmZlY3Qubm9kZXNfZW5kID0gZW5kO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHVzZV9pbXBvcnRfbm9kZSA9IChmbGFncyAmIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHtOb2RlfSAqL1xuXHR2YXIgbm9kZTtcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChoYXNfc3RhcnQgPyBjb250ZW50IDogJzwhPicgKyBjb250ZW50KTtcblx0XHRcdGlmICghaXNfZnJhZ21lbnQpIG5vZGUgPSAvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHR1c2VfaW1wb3J0X25vZGUgPyBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpIDogbm9kZS5jbG9uZU5vZGUodHJ1ZSlcblx0XHQpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlX3dpdGhfc2NyaXB0KGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBmbiA9IHRlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKTtcblx0cmV0dXJuICgpID0+IHJ1bl9zY3JpcHRzKC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovIChmbigpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsnc3ZnJyB8ICdtYXRoJ30gbnNcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBuc190ZW1wbGF0ZShjb250ZW50LCBmbGFncywgbnMgPSAnc3ZnJykge1xuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB3cmFwcGVkID0gYDwke25zfT4ke2hhc19zdGFydCA/IGNvbnRlbnQgOiAnPCE+JyArIGNvbnRlbnR9PC8ke25zfT5gO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovXG5cdHZhciBub2RlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmICghbm9kZSkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCh3cmFwcGVkKSk7XG5cdFx0XHR2YXIgcm9vdCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChyb290KSkge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHN2Z190ZW1wbGF0ZV93aXRoX3NjcmlwdChjb250ZW50LCBmbGFncykge1xuXHR2YXIgZm4gPSBuc190ZW1wbGF0ZShjb250ZW50LCBmbGFncyk7XG5cdHJldHVybiAoKSA9PiBydW5fc2NyaXB0cygvKiogQHR5cGUge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSAqLyAoZm4oKSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRobWxfdGVtcGxhdGUoY29udGVudCwgZmxhZ3MpIHtcblx0cmV0dXJuIG5zX3RlbXBsYXRlKGNvbnRlbnQsIGZsYWdzLCAnbWF0aCcpO1xufVxuXG4vKipcbiAqIENyZWF0aW5nIGEgZG9jdW1lbnQgZnJhZ21lbnQgZnJvbSBIVE1MIHRoYXQgY29udGFpbnMgc2NyaXB0IHRhZ3Mgd2lsbCBub3QgZXhlY3V0ZVxuICogdGhlIHNjcmlwdHMuIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgc2NyaXB0IHRhZ3Mgd2l0aCBuZXcgb25lcyBzbyB0aGF0IHRoZXkgYXJlIGV4ZWN1dGVkLlxuICogQHBhcmFtIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBOb2RlW119XG4gKi9cbmZ1bmN0aW9uIHJ1bl9zY3JpcHRzKG5vZGUpIHtcblx0Ly8gc2NyaXB0cyB3ZXJlIFNTUidkLCBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBydW5cblx0aWYgKGh5ZHJhdGluZykgcmV0dXJuIG5vZGU7XG5cblx0Y29uc3QgaXNfZnJhZ21lbnQgPSBub2RlLm5vZGVUeXBlID09PSAxMTtcblx0Y29uc3Qgc2NyaXB0cyA9XG5cdFx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLnRhZ05hbWUgPT09ICdTQ1JJUFQnXG5cdFx0XHQ/IFsvKiogQHR5cGUge0hUTUxTY3JpcHRFbGVtZW50fSAqLyAobm9kZSldXG5cdFx0XHQ6IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0Jyk7XG5cdGNvbnN0IGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0Zm9yIChjb25zdCBzY3JpcHQgb2Ygc2NyaXB0cykge1xuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0Zm9yICh2YXIgYXR0cmlidXRlIG9mIHNjcmlwdC5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRjbG9uZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUudGV4dENvbnRlbnQgPSBzY3JpcHQudGV4dENvbnRlbnQ7XG5cblx0XHQvLyBUaGUgc2NyaXB0IGhhcyBjaGFuZ2VkIC0gaWYgaXQncyBhdCB0aGUgZWRnZXMsIHRoZSBlZmZlY3Qgbm93IHBvaW50cyBhdCBkZWFkIG5vZGVzXG5cdFx0aWYgKGlzX2ZyYWdtZW50ID8gbm9kZS5maXJzdENoaWxkID09PSBzY3JpcHQgOiBub2RlID09PSBzY3JpcHQpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IGNsb25lO1xuXHRcdH1cblx0XHRpZiAoaXNfZnJhZ21lbnQgPyBub2RlLmxhc3RDaGlsZCA9PT0gc2NyaXB0IDogbm9kZSA9PT0gc2NyaXB0KSB7XG5cdFx0XHRlZmZlY3Qubm9kZXNfZW5kID0gY2xvbmU7XG5cdFx0fVxuXG5cdFx0c2NyaXB0LnJlcGxhY2VXaXRoKGNsb25lKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQodmFsdWUgPSAnJykge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHZhciB0ID0gY3JlYXRlX3RleHQodmFsdWUgKyAnJyk7XG5cdFx0YXNzaWduX25vZGVzKHQsIHQpO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDMpIHtcblx0XHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgd2UgbmVlZCB0byBpbnNlcnQgYW4gZW1wdHkgdGV4dCBub2RlXG5cdFx0bm9kZS5iZWZvcmUoKG5vZGUgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShub2RlKTtcblx0fVxuXG5cdGFzc2lnbl9ub2Rlcyhub2RlLCBub2RlKTtcblx0cmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KCkge1xuXHQvLyB3ZSdyZSBub3QgZGVsZWdhdGluZyB0byBgdGVtcGxhdGVgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdH1cblxuXHR2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0dmFyIHN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG5cdHZhciBhbmNob3IgPSBjcmVhdGVfdGV4dCgpO1xuXHRmcmFnLmFwcGVuZChzdGFydCwgYW5jaG9yKTtcblxuXHRhc3NpZ25fbm9kZXMoc3RhcnQsIGFuY2hvcik7XG5cblx0cmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQXNzaWduIHRoZSBjcmVhdGVkIChvciBpbiBoeWRyYXRpb24gbW9kZSwgdHJhdmVyc2VkKSBkb20gZWxlbWVudHMgdG8gdGhlIGN1cnJlbnQgYmxvY2tcbiAqIGFuZCBpbnNlcnQgdGhlIGVsZW1lbnRzIGludG8gdGhlIGRvbSAoaW4gY2xpZW50IG1vZGUpLlxuICogQHBhcmFtIHtUZXh0IHwgQ29tbWVudCB8IEVsZW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoYW5jaG9yLCBkb20pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gaHlkcmF0ZV9ub2RlO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChhbmNob3IgPT09IG51bGwpIHtcblx0XHQvLyBlZGdlIGNhc2Ug4oCUIHZvaWQgYDxzdmVsdGU6ZWxlbWVudD5gIHdpdGggY29udGVudFxuXHRcdHJldHVybjtcblx0fVxuXG5cdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZG9tKSk7XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIE1vdW50T3B0aW9ucyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRjbGVhcl90ZXh0X2NvbnRlbnQsXG5cdGNyZWF0ZV90ZXh0LFxuXHRnZXRfZmlyc3RfY2hpbGQsXG5cdGdldF9uZXh0X3NpYmxpbmcsXG5cdGluaXRfb3BlcmF0aW9uc1xufSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9FUlJPUiwgSFlEUkFUSU9OX1NUQVJUIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHB1c2gsIHBvcCwgY29tcG9uZW50X2NvbnRleHQsIGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X3Jvb3QsIGJyYW5jaCB9IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGFycmF5X2Zyb20gfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLFxuXHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sXG5cdHJvb3RfZXZlbnRfaGFuZGxlc1xufSBmcm9tICcuL2RvbS9lbGVtZW50cy9ldmVudHMuanMnO1xuaW1wb3J0IHsgcmVzZXRfaGVhZF9hbmNob3IgfSBmcm9tICcuL2RvbS9ibG9ja3Mvc3ZlbHRlLWhlYWQuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi9kb20vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgaXNfcGFzc2l2ZV9ldmVudCB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIG5vcm1hbGx5IHRydWUg4oCUIGJsb2NrIGVmZmVjdHMgc2hvdWxkIHJ1biB0aGVpciBpbnRybyB0cmFuc2l0aW9ucyDigJRcbiAqIGJ1dCBpcyBmYWxzZSBkdXJpbmcgaHlkcmF0aW9uICh1bmxlc3MgYG9wdGlvbnMuaW50cm9gIGlzIGB0cnVlYCkgYW5kXG4gKiB3aGVuIGNyZWF0aW5nIHRoZSBjaGlsZHJlbiBvZiBhIGA8c3ZlbHRlOmVsZW1lbnQ+YCB0aGF0IGp1c3QgY2hhbmdlZCB0YWdcbiAqL1xuZXhwb3J0IGxldCBzaG91bGRfaW50cm8gPSB0cnVlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zaG91bGRfaW50cm8odmFsdWUpIHtcblx0c2hvdWxkX2ludHJvID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3RleHQodGV4dCwgdmFsdWUpIHtcblx0Ly8gRm9yIG9iamVjdHMsIHdlIGFwcGx5IHN0cmluZyBjb2VyY2lvbiAod2hpY2ggbWlnaHQgbWFrZSB0aGluZ3MgbGlrZSAkc3RhdGUgYXJyYXkgcmVmZXJlbmNlcyBpbiB0aGUgdGVtcGxhdGUgcmVhY3RpdmUpIGJlZm9yZSBkaWZmaW5nXG5cdHZhciBzdHIgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgKyAnJyA6IHZhbHVlO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlmIChzdHIgIT09ICh0ZXh0Ll9fdCA/Pz0gdGV4dC5ub2RlVmFsdWUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHQuX190ID0gc3RyO1xuXHRcdHRleHQubm9kZVZhbHVlID0gc3RyID09IG51bGwgPyAnJyA6IHN0ciArICcnO1xuXHR9XG59XG5cbi8qKlxuICogTW91bnRzIGEgY29tcG9uZW50IHRvIHRoZSBnaXZlbiB0YXJnZXQgYW5kIHJldHVybnMgdGhlIGV4cG9ydHMgYW5kIHBvdGVudGlhbGx5IHRoZSBwcm9wcyAoaWYgY29tcGlsZWQgd2l0aCBgYWNjZXNzb3JzOiB0cnVlYCkgb2YgdGhlIGNvbXBvbmVudC5cbiAqIFRyYW5zaXRpb25zIHdpbGwgcGxheSBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIHVubGVzcyB0aGUgYGludHJvYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHtNb3VudE9wdGlvbnM8UHJvcHM+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRyZXR1cm4gX21vdW50KGNvbXBvbmVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSHlkcmF0ZXMgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIHRhcmdldCBhbmQgcmV0dXJucyB0aGUgZXhwb3J0cyBhbmQgcG90ZW50aWFsbHkgdGhlIHByb3BzIChpZiBjb21waWxlZCB3aXRoIGBhY2Nlc3NvcnM6IHRydWVgKSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7fSBleHRlbmRzIFByb3BzID8ge1xuICogXHRcdHRhcmdldDogRG9jdW1lbnQgfCBFbGVtZW50IHwgU2hhZG93Um9vdDtcbiAqIFx0XHRwcm9wcz86IFByb3BzO1xuICogXHRcdGV2ZW50cz86IFJlY29yZDxzdHJpbmcsIChlOiBhbnkpID0+IGFueT47XG4gKiAgXHRjb250ZXh0PzogTWFwPGFueSwgYW55PjtcbiAqIFx0XHRpbnRybz86IGJvb2xlYW47XG4gKiBcdFx0cmVjb3Zlcj86IGJvb2xlYW47XG4gKiBcdH0gOiB7XG4gKiBcdFx0dGFyZ2V0OiBEb2N1bWVudCB8IEVsZW1lbnQgfCBTaGFkb3dSb290O1xuICogXHRcdHByb3BzOiBQcm9wcztcbiAqIFx0XHRldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCAoZTogYW55KSA9PiBhbnk+O1xuICogIFx0Y29udGV4dD86IE1hcDxhbnksIGFueT47XG4gKiBcdFx0aW50cm8/OiBib29sZWFuO1xuICogXHRcdHJlY292ZXI/OiBib29sZWFuO1xuICogXHR9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdGluaXRfb3BlcmF0aW9ucygpO1xuXHRvcHRpb25zLmludHJvID0gb3B0aW9ucy5pbnRybyA/PyBmYWxzZTtcblx0Y29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cdGNvbnN0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGNvbnN0IHByZXZpb3VzX2h5ZHJhdGVfbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR0cnkge1xuXHRcdHZhciBhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZCh0YXJnZXQpKTtcblx0XHR3aGlsZSAoXG5cdFx0XHRhbmNob3IgJiZcblx0XHRcdChhbmNob3Iubm9kZVR5cGUgIT09IDggfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhICE9PSBIWURSQVRJT05fU1RBUlQpXG5cdFx0KSB7XG5cdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoYW5jaG9yKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFhbmNob3IpIHtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKSk7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cblx0XHRjb25zdCBpbnN0YW5jZSA9IF9tb3VudChjb21wb25lbnQsIHsgLi4ub3B0aW9ucywgYW5jaG9yIH0pO1xuXG5cdFx0aWYgKFxuXHRcdFx0aHlkcmF0ZV9ub2RlID09PSBudWxsIHx8XG5cdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgIT09IDggfHxcblx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSAhPT0gSFlEUkFUSU9OX0VORFxuXHRcdCkge1xuXHRcdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblxuXHRcdHJldHVybiAvKiogIEB0eXBlIHtFeHBvcnRzfSAqLyAoaW5zdGFuY2UpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChlcnJvciA9PT0gSFlEUkFUSU9OX0VSUk9SKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5yZWNvdmVyID09PSBmYWxzZSkge1xuXHRcdFx0XHRlLmh5ZHJhdGlvbl9mYWlsZWQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYW4gZXJyb3Igb2NjdXJlZCBhYm92ZSwgdGhlIG9wZXJhdGlvbnMgbWlnaHQgbm90IHlldCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0XHRpbml0X29wZXJhdGlvbnMoKTtcblx0XHRcdGNsZWFyX3RleHRfY29udGVudCh0YXJnZXQpO1xuXG5cdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdHJldHVybiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9oeWRyYXRpbmcod2FzX2h5ZHJhdGluZyk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShwcmV2aW91c19oeWRyYXRlX25vZGUpO1xuXHRcdHJlc2V0X2hlYWRfYW5jaG9yKCk7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZG9jdW1lbnRfbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxhbnk+PiB8IENvbXBvbmVudDxhbnk+fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZnVuY3Rpb24gX21vdW50KENvbXBvbmVudCwgeyB0YXJnZXQsIGFuY2hvciwgcHJvcHMgPSB7fSwgZXZlbnRzLCBjb250ZXh0LCBpbnRybyA9IHRydWUgfSkge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblxuXHR2YXIgcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cblx0LyoqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzICovXG5cdHZhciBldmVudF9oYW5kbGUgPSAoZXZlbnRzKSA9PiB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBldmVudF9uYW1lID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRpZiAocmVnaXN0ZXJlZF9ldmVudHMuaGFzKGV2ZW50X25hbWUpKSBjb250aW51ZTtcblx0XHRcdHJlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudF9uYW1lKTtcblxuXHRcdFx0dmFyIHBhc3NpdmUgPSBpc19wYXNzaXZlX2V2ZW50KGV2ZW50X25hbWUpO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJvdGggdGhlIGNvbnRhaW5lciBhbmQgdGhlIGRvY3VtZW50LlxuXHRcdFx0Ly8gVGhlIGNvbnRhaW5lciBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyBmcm9tIHdpdGhpbiBpbiBjYXNlXG5cdFx0XHQvLyB0aGUgb3V0ZXIgY29udGVudCBzdG9wcyBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblxuXHRcdFx0dmFyIG4gPSBkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpO1xuXG5cdFx0XHRpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFRoZSBkb2N1bWVudCBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZSBmcm9tIGVsZW1lbnRzIHRoYXQgd2VyZVxuXHRcdFx0XHQvLyBtYW51YWxseSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBjb250YWluZXIgKGUuZy4gdmlhIG1hbnVhbCBwb3J0YWxzKS5cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbiArIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRldmVudF9oYW5kbGUoYXJyYXlfZnJvbShhbGxfcmVnaXN0ZXJlZF9ldmVudHMpKTtcblx0cm9vdF9ldmVudF9oYW5kbGVzLmFkZChldmVudF9oYW5kbGUpO1xuXG5cdC8qKiBAdHlwZSB7RXhwb3J0c30gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3aWxsIGJlIGRlZmluZWQgYmVjYXVzZSB0aGUgcmVuZGVyIGVmZmVjdCBydW5zIHN5bmNocm9ub3VzbHlcblx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgdW5tb3VudCA9IGNvbXBvbmVudF9yb290KCgpID0+IHtcblx0XHR2YXIgYW5jaG9yX25vZGUgPSBhbmNob3IgPz8gdGFyZ2V0LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXG5cdFx0YnJhbmNoKCgpID0+IHtcblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHB1c2goe30pO1xuXHRcdFx0XHR2YXIgY3R4ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdFx0XHRjdHguYyA9IGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0Ly8gV2UgY2FuJ3Qgc3ByZWFkIHRoZSBvYmplY3Qgb3IgZWxzZSB3ZSdkIGxvc2UgdGhlIHN0YXRlIHByb3h5IHN0dWZmLCBpZiBpdCBpcyBvbmVcblx0XHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChwcm9wcykuJCRldmVudHMgPSBldmVudHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0YXNzaWduX25vZGVzKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoYW5jaG9yX25vZGUpLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0c2hvdWxkX2ludHJvID0gaW50cm87XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBwdWJsaWMgdHlwaW5ncyBhcmUgbm90IHdoYXQgdGhlIGFjdHVhbCBmdW5jdGlvbiBsb29rcyBsaWtlXG5cdFx0XHRjb21wb25lbnQgPSBDb21wb25lbnQoYW5jaG9yX25vZGUsIHByb3BzKSB8fCB7fTtcblx0XHRcdHNob3VsZF9pbnRybyA9IHRydWU7XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHBvcCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAodmFyIGV2ZW50X25hbWUgb2YgcmVnaXN0ZXJlZF9ldmVudHMpIHtcblx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblxuXHRcdFx0XHR2YXIgbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZG9jdW1lbnRfbGlzdGVuZXJzLmdldChldmVudF9uYW1lKSk7XG5cblx0XHRcdFx0aWYgKC0tbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblx0XHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuZGVsZXRlKGV2ZW50X25hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cm9vdF9ldmVudF9oYW5kbGVzLmRlbGV0ZShldmVudF9oYW5kbGUpO1xuXG5cdFx0XHRpZiAoYW5jaG9yX25vZGUgIT09IGFuY2hvcikge1xuXHRcdFx0XHRhbmNob3Jfbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChhbmNob3Jfbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0bW91bnRlZF9jb21wb25lbnRzLnNldChjb21wb25lbnQsIHVubW91bnQpO1xuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG1vdW50ZWQgb3IgaHlkcmF0ZWQuXG4gKiBVc2VzIGEgYFdlYWtNYXBgIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAqL1xubGV0IG1vdW50ZWRfY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VudGVkIHVzaW5nIGBtb3VudGAgb3IgYGh5ZHJhdGVgLlxuICpcbiAqIFNpbmNlIDUuMTMuMCwgaWYgYG9wdGlvbnMub3V0cm9gIGlzIGB0cnVlYCwgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgd2lsbCBwbGF5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBhZnRlciB0cmFuc2l0aW9ucyBoYXZlIGNvbXBsZXRlZCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgdHJ1ZSwgb3IgaW1tZWRpYXRlbHkgb3RoZXJ3aXNlIChwcmlvciB0byA1LjEzLjAsIHJldHVybnMgYHZvaWRgKS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbW91bnQsIHVubW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICogaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zdmVsdGUnO1xuICpcbiAqIGNvbnN0IGFwcCA9IG1vdW50KEFwcCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSk7XG4gKlxuICogLy8gbGF0ZXIuLi5cbiAqIHVubW91bnQoYXBwLCB7IG91dHJvOiB0cnVlIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7IG91dHJvPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0Y29uc3QgZm4gPSBtb3VudGVkX2NvbXBvbmVudHMuZ2V0KGNvbXBvbmVudCk7XG5cblx0aWYgKGZuKSB7XG5cdFx0bW91bnRlZF9jb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuXHRcdHJldHVybiBmbihvcHRpb25zKTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHR3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpO1xuXHR9XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuIiwiaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldF9jb21wb25lbnQgfSBmcm9tICcuL293bmVyc2hpcC5qcyc7XG5cbi8qKiBAcGFyYW0ge0Z1bmN0aW9uICYgeyBbRklMRU5BTUVdOiBzdHJpbmcgfX0gdGFyZ2V0ICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfdGFyZ2V0KHRhcmdldCkge1xuXHRpZiAodGFyZ2V0KSB7XG5cdFx0ZS5jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3KHRhcmdldFtGSUxFTkFNRV0gPz8gJ2EgY29tcG9uZW50JywgdGFyZ2V0Lm5hbWUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfYXBpKCkge1xuXHRjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRfY29udGV4dD8uZnVuY3Rpb247XG5cblx0LyoqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgKi9cblx0ZnVuY3Rpb24gZXJyb3IobWV0aG9kKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGNvbnN0IHBhcmVudCA9IGdldF9jb21wb25lbnQoKT8uW0ZJTEVOQU1FXSA/PyAnU29tZXRoaW5nJztcblx0XHRlLmNvbXBvbmVudF9hcGlfY2hhbmdlZChwYXJlbnQsIG1ldGhvZCwgY29tcG9uZW50W0ZJTEVOQU1FXSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdCRkZXN0cm95OiAoKSA9PiBlcnJvcignJGRlc3Ryb3koKScpLFxuXHRcdCRvbjogKCkgPT4gZXJyb3IoJyRvbiguLi4pJyksXG5cdFx0JHNldDogKCkgPT4gZXJyb3IoJyRzZXQoLi4uKScpXG5cdH07XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRyZW1vdmVfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIHBhdXNlX2VmZmVjdCwgcmVzdW1lX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlRfRUxTRSwgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KGJyYW5jaDogKGZuOiAoYW5jaG9yOiBOb2RlKSA9PiB2b2lkLCBmbGFnPzogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZH0gZm5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Vsc2VpZl0gVHJ1ZSBpZiB0aGlzIGlzIGFuIGB7OmVsc2UgaWYgLi4ufWAgYmxvY2sgcmF0aGVyIHRoYW4gYW4gYHsjaWYgLi4ufWAsIGFzIHRoYXQgYWZmZWN0cyB3aGljaCB0cmFuc2l0aW9ucyBhcmUgY29uc2lkZXJlZCAnbG9jYWwnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlmX2Jsb2NrKG5vZGUsIGZuLCBlbHNlaWYgPSBmYWxzZSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBjb25zZXF1ZW50X2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgYWx0ZXJuYXRlX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtVTklOSVRJQUxJWkVEIHwgYm9vbGVhbiB8IG51bGx9ICovXG5cdHZhciBjb25kaXRpb24gPSBVTklOSVRJQUxJWkVEO1xuXG5cdHZhciBmbGFncyA9IGVsc2VpZiA/IEVGRkVDVF9UUkFOU1BBUkVOVCA6IDA7XG5cblx0dmFyIGhhc19icmFuY2ggPSBmYWxzZTtcblxuXHRjb25zdCBzZXRfYnJhbmNoID0gKC8qKiBAdHlwZSB7KGFuY2hvcjogTm9kZSkgPT4gdm9pZH0gKi8gZm4sIGZsYWcgPSB0cnVlKSA9PiB7XG5cdFx0aGFzX2JyYW5jaCA9IHRydWU7XG5cdFx0dXBkYXRlX2JyYW5jaChmbGFnLCBmbik7XG5cdH07XG5cblx0Y29uc3QgdXBkYXRlX2JyYW5jaCA9IChcblx0XHQvKiogQHR5cGUge2Jvb2xlYW4gfCBudWxsfSAqLyBuZXdfY29uZGl0aW9uLFxuXHRcdC8qKiBAdHlwZSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gKi8gZm5cblx0KSA9PiB7XG5cdFx0aWYgKGNvbmRpdGlvbiA9PT0gKGNvbmRpdGlvbiA9IG5ld19jb25kaXRpb24pKSByZXR1cm47XG5cblx0XHQvKiogV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGEgaHlkcmF0aW9uIG1pc21hdGNoLiBOZWVkcyB0byBiZSBhIGBsZXRgIG9yIGVsc2UgaXQgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgKi9cblx0XHRsZXQgbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGNvbnN0IGlzX2Vsc2UgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoISFjb25kaXRpb24gPT09IGlzX2Vsc2UpIHtcblx0XHRcdFx0Ly8gSHlkcmF0aW9uIG1pc21hdGNoOiByZW1vdmUgZXZlcnl0aGluZyBpbnNpZGUgdGhlIGFuY2hvciBhbmQgc3RhcnQgZnJlc2guXG5cdFx0XHRcdC8vIFRoaXMgY291bGQgaGFwcGVuIHdpdGggYHsjaWYgYnJvd3Nlcn0uLi57L2lmfWAsIGZvciBleGFtcGxlXG5cdFx0XHRcdGFuY2hvciA9IHJlbW92ZV9ub2RlcygpO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY29uZGl0aW9uKSB7XG5cdFx0XHRpZiAoY29uc2VxdWVudF9lZmZlY3QpIHtcblx0XHRcdFx0cmVzdW1lX2VmZmVjdChjb25zZXF1ZW50X2VmZmVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGZuKSB7XG5cdFx0XHRcdGNvbnNlcXVlbnRfZWZmZWN0ID0gYnJhbmNoKCgpID0+IGZuKGFuY2hvcikpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWx0ZXJuYXRlX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoYWx0ZXJuYXRlX2VmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdGFsdGVybmF0ZV9lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFsdGVybmF0ZV9lZmZlY3QpIHtcblx0XHRcdFx0cmVzdW1lX2VmZmVjdChhbHRlcm5hdGVfZWZmZWN0KTtcblx0XHRcdH0gZWxzZSBpZiAoZm4pIHtcblx0XHRcdFx0YWx0ZXJuYXRlX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBmbihhbmNob3IpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvbnNlcXVlbnRfZWZmZWN0KSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChjb25zZXF1ZW50X2VmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnNlcXVlbnRfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBjb250aW51ZSBpbiBoeWRyYXRpb24gbW9kZVxuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGhhc19icmFuY2ggPSBmYWxzZTtcblx0XHRmbihzZXRfYnJhbmNoKTtcblx0XHRpZiAoIWhhc19icmFuY2gpIHtcblx0XHRcdHVwZGF0ZV9icmFuY2gobnVsbCwgbnVsbCk7XG5cdFx0fVxuXHR9LCBmbGFncyk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIHBhdXNlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBub3RfZXF1YWwsIHNhZmVfbm90X2VxdWFsIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgeyBpc19ydW5lcyB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IFZ9IGdldF9rZXlcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSkgPT4gVGVtcGxhdGVOb2RlIHwgdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtleV9ibG9jayhub2RlLCBnZXRfa2V5LCByZW5kZXJfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtWIHwgdHlwZW9mIFVOSU5JVElBTElaRUR9ICovXG5cdHZhciBrZXkgPSBVTklOSVRJQUxJWkVEO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdHZhciBjaGFuZ2VkID0gaXNfcnVuZXMoKSA/IG5vdF9lcXVhbCA6IHNhZmVfbm90X2VxdWFsO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoY2hhbmdlZChrZXksIChrZXkgPSBnZXRfa2V5KCkpKSkge1xuXHRcdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0ZWZmZWN0ID0gYnJhbmNoKCgpID0+IHJlbmRlcl9mbihhbmNob3IpKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWFjaEl0ZW0sIEVhY2hTdGF0ZSwgRWZmZWN0LCBNYXliZVNvdXJjZSwgU291cmNlLCBUZW1wbGF0ZU5vZGUsIFRyYW5zaXRpb25NYW5hZ2VyLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRFQUNIX0lOREVYX1JFQUNUSVZFLFxuXHRFQUNIX0lTX0FOSU1BVEVELFxuXHRFQUNIX0lTX0NPTlRST0xMRUQsXG5cdEVBQ0hfSVRFTV9JTU1VVEFCTEUsXG5cdEVBQ0hfSVRFTV9SRUFDVElWRSxcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX1NUQVJUX0VMU0Vcbn0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHJlbW92ZV9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nXG59IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnMsXG5cdHBhdXNlX2NoaWxkcmVuLFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgbXV0YWJsZV9zb3VyY2UsIGludGVybmFsX3NldCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tLCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBJTkVSVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24gfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIFRoZSByb3cgb2YgYSBrZXllZCBlYWNoIGJsb2NrIHRoYXQgaXMgY3VycmVudGx5IHVwZGF0aW5nLiBXZSB0cmFjayB0aGlzXG4gKiBzbyB0aGF0IGBhbmltYXRlOmAgZGlyZWN0aXZlcyBoYXZlIHNvbWV0aGluZyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0b1xuICogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2VhY2hfaXRlbSA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gaXRlbSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2VhY2hfaXRlbShpdGVtKSB7XG5cdGN1cnJlbnRfZWFjaF9pdGVtID0gaXRlbTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gX1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KF8sIGkpIHtcblx0cmV0dXJuIGk7XG59XG5cbi8qKlxuICogUGF1c2UgbXVsdGlwbGUgZWZmZWN0cyBzaW11bHRhbmVvdXNseSwgYW5kIGNvb3JkaW5hdGUgdGhlaXJcbiAqIHN1YnNlcXVlbnQgZGVzdHJ1Y3Rpb24uIFVzZWQgaW4gZWFjaCBibG9ja3NcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbVtdfSBpdGVtc1xuICogQHBhcmFtIHtudWxsIHwgTm9kZX0gY29udHJvbGxlZF9hbmNob3JcbiAqIEBwYXJhbSB7TWFwPGFueSwgRWFjaEl0ZW0+fSBpdGVtc19tYXBcbiAqL1xuZnVuY3Rpb24gcGF1c2VfZWZmZWN0cyhzdGF0ZSwgaXRlbXMsIGNvbnRyb2xsZWRfYW5jaG9yLCBpdGVtc19tYXApIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0cGF1c2VfY2hpbGRyZW4oaXRlbXNbaV0uZSwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXHR9XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSBsZW5ndGggPiAwICYmIHRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCAmJiBjb250cm9sbGVkX2FuY2hvciAhPT0gbnVsbDtcblx0Ly8gSWYgd2UgaGF2ZSBhIGNvbnRyb2xsZWQgYW5jaG9yLCBpdCBtZWFucyB0aGF0IHRoZSBlYWNoIGJsb2NrIGlzIGluc2lkZSBhIHNpbmdsZVxuXHQvLyBET00gZWxlbWVudCwgc28gd2UgY2FuIGFwcGx5IGEgZmFzdC1wYXRoIGZvciBjbGVhcmluZyB0aGUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoXG5cdFx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovIChjb250cm9sbGVkX2FuY2hvcikucGFyZW50Tm9kZVxuXHRcdCk7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KHBhcmVudF9ub2RlKTtcblx0XHRwYXJlbnRfbm9kZS5hcHBlbmQoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoY29udHJvbGxlZF9hbmNob3IpKTtcblx0XHRpdGVtc19tYXAuY2xlYXIoKTtcblx0XHRsaW5rKHN0YXRlLCBpdGVtc1swXS5wcmV2LCBpdGVtc1tsZW5ndGggLSAxXS5uZXh0KTtcblx0fVxuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKCFpc19jb250cm9sbGVkKSB7XG5cdFx0XHRcdGl0ZW1zX21hcC5kZWxldGUoaXRlbS5rKTtcblx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0fVxuXHRcdFx0ZGVzdHJveV9lZmZlY3QoaXRlbS5lLCAhaXNfY29udHJvbGxlZCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudH0gbm9kZSBUaGUgbmV4dCBzaWJsaW5nIG5vZGUsIG9yIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGlzIGlzIGEgJ2NvbnRyb2xsZWQnIGJsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IE1heWJlU291cmNlPG51bWJlcj4pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG5vZGUsIGZsYWdzLCBnZXRfY29sbGVjdGlvbiwgZ2V0X2tleSwgcmVuZGVyX2ZuLCBmYWxsYmFja19mbiA9IG51bGwpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoU3RhdGV9ICovXG5cdHZhciBzdGF0ZSA9IHsgZmxhZ3MsIGl0ZW1zOiBuZXcgTWFwKCksIGZpcnN0OiBudWxsIH07XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwO1xuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSk7XG5cblx0XHRhbmNob3IgPSBoeWRyYXRpbmdcblx0XHRcdD8gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge0NvbW1lbnQgfCBUZXh0fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHBhcmVudF9ub2RlKSkpXG5cdFx0XHQ6IHBhcmVudF9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZmFsbGJhY2sgPSBudWxsO1xuXG5cdHZhciB3YXNfZW1wdHkgPSBmYWxzZTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSBnZXRfY29sbGVjdGlvbigpO1xuXG5cdFx0dmFyIGFycmF5ID0gaXNfYXJyYXkoY29sbGVjdGlvbilcblx0XHRcdD8gY29sbGVjdGlvblxuXHRcdFx0OiBjb2xsZWN0aW9uID09IG51bGxcblx0XHRcdFx0PyBbXVxuXHRcdFx0XHQ6IGFycmF5X2Zyb20oY29sbGVjdGlvbik7XG5cblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0aWYgKHdhc19lbXB0eSAmJiBsZW5ndGggPT09IDApIHtcblx0XHRcdC8vIGlnbm9yZSB1cGRhdGVzIGlmIHRoZSBhcnJheSBpcyBlbXB0eSxcblx0XHRcdC8vIGFuZCBpdCBhbHJlYWR5IHdhcyBlbXB0eSBvbiBwcmV2aW91cyBydW5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0d2FzX2VtcHR5ID0gbGVuZ3RoID09PSAwO1xuXG5cdFx0LyoqIGB0cnVlYCBpZiB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdGxldCBtaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0dmFyIGlzX2Vsc2UgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoaXNfZWxzZSAhPT0gKGxlbmd0aCA9PT0gMCkpIHtcblx0XHRcdFx0Ly8gaHlkcmF0aW9uIG1pc21hdGNoIOKAlCByZW1vdmUgdGhlIHNlcnZlci1yZW5kZXJlZCBET00gYW5kIHN0YXJ0IG92ZXJcblx0XHRcdFx0YW5jaG9yID0gcmVtb3ZlX25vZGVzKCk7XG5cblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0bWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoaXMgaXMgc2VwYXJhdGUgdG8gdGhlIHByZXZpb3VzIGJsb2NrIGJlY2F1c2UgYGh5ZHJhdGluZ2AgbWlnaHQgY2hhbmdlXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdFx0XHR2YXIgcHJldiA9IG51bGw7XG5cblx0XHRcdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdFx0XHR2YXIgaXRlbTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLm5vZGVUeXBlID09PSA4ICYmXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhID09PSBIWURSQVRJT05fRU5EXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIFRoZSBzZXJ2ZXIgcmVuZGVyZWQgZmV3ZXIgaXRlbXMgdGhhbiBleHBlY3RlZCxcblx0XHRcdFx0XHQvLyBzbyBicmVhayBvdXQgYW5kIGNvbnRpbnVlIGFwcGVuZGluZyBub24taHlkcmF0ZWQgaXRlbXNcblx0XHRcdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0XHR2YXIga2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRcdGl0ZW0gPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRoeWRyYXRlX25vZGUsXG5cdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0cHJldixcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdHJlbmRlcl9mbixcblx0XHRcdFx0XHRmbGFncyxcblx0XHRcdFx0XHRnZXRfY29sbGVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0XHRzdGF0ZS5pdGVtcy5zZXQoa2V5LCBpdGVtKTtcblxuXHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGV4Y2VzcyBub2Rlc1xuXHRcdFx0aWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShyZW1vdmVfbm9kZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHRcdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9yZWFjdGlvbik7XG5cdFx0XHRyZWNvbmNpbGUoXG5cdFx0XHRcdGFycmF5LFxuXHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0YW5jaG9yLFxuXHRcdFx0XHRyZW5kZXJfZm4sXG5cdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHQoZWZmZWN0LmYgJiBJTkVSVCkgIT09IDAsXG5cdFx0XHRcdGdldF9rZXksXG5cdFx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoZmFsbGJhY2spIHtcblx0XHRcdFx0XHRyZXN1bWVfZWZmZWN0KGZhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IGJyYW5jaCgoKSA9PiBmYWxsYmFja19mbihhbmNob3IpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZmFsbGJhY2ssICgpID0+IHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB3ZSBtb3VudCB0aGUgZWFjaCBibG9jayBmb3IgdGhlIGZpcnN0IHRpbWUsIHRoZSBjb2xsZWN0aW9uIHdvbid0IGJlXG5cdFx0Ly8gY29ubmVjdGVkIHRvIHRoaXMgZWZmZWN0IGFzIHRoZSBlZmZlY3QgaGFzbid0IGZpbmlzaGVkIHJ1bm5pbmcgeWV0IGFuZCBpdHMgZGVwc1xuXHRcdC8vIHdvbid0IGJlIGFzc2lnbmVkLiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgd2hlbiByZWNvbmNpbGluZyB0aGUgZWFjaCBibG9ja1xuXHRcdC8vIHRoYXQgYSBtdXRhdGlvbiBvY2N1cnJlZCBhbmQgaXQncyBtYWRlIHRoZSBjb2xsZWN0aW9uIE1BWUJFX0RJUlRZLCBzbyByZWFkaW5nIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gYWdhaW4gY2FuIHByb3ZpZGUgY29uc2lzdGVuY3kgdG8gdGhlIHJlYWN0aXZlIGdyYXBoIGFnYWluIGFzIHRoZSBkZXJpdmVkc1xuXHRcdC8vIHdpbGwgbm93IGJlIGBDTEVBTmAuXG5cdFx0Z2V0X2NvbGxlY3Rpb24oKTtcblx0fSk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEFkZCwgcmVtb3ZlLCBvciByZW9yZGVyIGl0ZW1zIG91dHB1dCBieSBhbiBlYWNoIGJsb2NrIGFzIGl0cyBpbnB1dCBjaGFuZ2VzXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtBcnJheTxWPn0gYXJyYXlcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudCB8IFRleHR9IGFuY2hvclxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFNvdXJjZTxudW1iZXI+KSA9PiB2b2lkfSByZW5kZXJfZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtib29sZWFufSBpc19pbmVydFxuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHBhcmFtIHsoKSA9PiBWW119IGdldF9jb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVjb25jaWxlKGFycmF5LCBzdGF0ZSwgYW5jaG9yLCByZW5kZXJfZm4sIGZsYWdzLCBpc19pbmVydCwgZ2V0X2tleSwgZ2V0X2NvbGxlY3Rpb24pIHtcblx0dmFyIGlzX2FuaW1hdGVkID0gKGZsYWdzICYgRUFDSF9JU19BTklNQVRFRCkgIT09IDA7XG5cdHZhciBzaG91bGRfdXBkYXRlID0gKGZsYWdzICYgKEVBQ0hfSVRFTV9SRUFDVElWRSB8IEVBQ0hfSU5ERVhfUkVBQ1RJVkUpKSAhPT0gMDtcblxuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR2YXIgaXRlbXMgPSBzdGF0ZS5pdGVtcztcblx0dmFyIGZpcnN0ID0gc3RhdGUuZmlyc3Q7XG5cdHZhciBjdXJyZW50ID0gZmlyc3Q7XG5cblx0LyoqIEB0eXBlIHt1bmRlZmluZWQgfCBTZXQ8RWFjaEl0ZW0+fSAqL1xuXHR2YXIgc2VlbjtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH0gKi9cblx0dmFyIHByZXYgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHRvX2FuaW1hdGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbVtdfSAqL1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIHN0YXNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge1Z9ICovXG5cdHZhciB2YWx1ZTtcblxuXHQvKiogQHR5cGUge2FueX0gKi9cblx0dmFyIGtleTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaXRlbTtcblxuXHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0dmFyIGk7XG5cblx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0a2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRpdGVtID0gaXRlbXMuZ2V0KGtleSk7XG5cblx0XHRcdGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aXRlbS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdCh0b19hbmltYXRlID8/PSBuZXcgU2V0KCkpLmFkZChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdGl0ZW0gPSBpdGVtcy5nZXQoa2V5KTtcblxuXHRcdGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSBjdXJyZW50ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjdXJyZW50LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdFx0XHRwcmV2ID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdGNoaWxkX2FuY2hvcixcblx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdHByZXYsXG5cdFx0XHRcdHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0aSxcblx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRmbGFncyxcblx0XHRcdFx0Z2V0X2NvbGxlY3Rpb25cblx0XHRcdCk7XG5cblx0XHRcdGl0ZW1zLnNldChrZXksIHByZXYpO1xuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdGN1cnJlbnQgPSBwcmV2Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkX3VwZGF0ZSkge1xuXHRcdFx0dXBkYXRlX2l0ZW0oaXRlbSwgdmFsdWUsIGksIGZsYWdzKTtcblx0XHR9XG5cblx0XHRpZiAoKGl0ZW0uZS5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0XHRyZXN1bWVfZWZmZWN0KGl0ZW0uZSk7XG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0aXRlbS5hPy51bmZpeCgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5kZWxldGUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gIT09IGN1cnJlbnQpIHtcblx0XHRcdGlmIChzZWVuICE9PSB1bmRlZmluZWQgJiYgc2Vlbi5oYXMoaXRlbSkpIHtcblx0XHRcdFx0aWYgKG1hdGNoZWQubGVuZ3RoIDwgc3Rhc2hlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGxhdGVyIGl0ZW1zIHRvIHRoZSBmcm9udFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHN0YXNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGo7XG5cblx0XHRcdFx0XHRwcmV2ID0gc3RhcnQucHJldjtcblxuXHRcdFx0XHRcdHZhciBhID0gbWF0Y2hlZFswXTtcblx0XHRcdFx0XHR2YXIgYiA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRtb3ZlKG1hdGNoZWRbal0sIHN0YXJ0LCBhbmNob3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzdGFzaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRzZWVuLmRlbGV0ZShzdGFzaGVkW2pdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBhLnByZXYsIGIubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgYSk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYiwgc3RhcnQpO1xuXG5cdFx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHByZXYgPSBiO1xuXHRcdFx0XHRcdGkgLT0gMTtcblxuXHRcdFx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdFx0XHRzdGFzaGVkID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBlYXJsaWVyIGl0ZW1zIHRvIHRoZSBiYWNrXG5cdFx0XHRcdFx0c2Vlbi5kZWxldGUoaXRlbSk7XG5cdFx0XHRcdFx0bW92ZShpdGVtLCBjdXJyZW50LCBhbmNob3IpO1xuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0sIHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuayAhPT0ga2V5KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0IGFuZCBhbiBpdGVtIGhhcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGluZXJ0LFxuXHRcdFx0XHQvLyBza2lwIG92ZXIgYWRkaW5nIGl0IHRvIG91ciBzZWVuIFNldCBhcyB0aGUgaXRlbSBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcblx0XHRcdFx0aWYgKGlzX2luZXJ0IHx8IChjdXJyZW50LmUuZiAmIElORVJUKSA9PT0gMCkge1xuXHRcdFx0XHRcdChzZWVuID8/PSBuZXcgU2V0KCkpLmFkZChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFzaGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtID0gY3VycmVudDtcblx0XHR9XG5cblx0XHRtYXRjaGVkLnB1c2goaXRlbSk7XG5cdFx0cHJldiA9IGl0ZW07XG5cdFx0Y3VycmVudCA9IGl0ZW0ubmV4dDtcblx0fVxuXG5cdGlmIChjdXJyZW50ICE9PSBudWxsIHx8IHNlZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciB0b19kZXN0cm95ID0gc2VlbiA9PT0gdW5kZWZpbmVkID8gW10gOiBhcnJheV9mcm9tKHNlZW4pO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0LCB0aGVuIGluZXJ0IGVmZmVjdHMgYXJlIGN1cnJlbnRseSBvdXRyb2luZyBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWRcblx0XHRcdGlmIChpc19pbmVydCB8fCAoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0dG9fZGVzdHJveS5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdHJveV9sZW5ndGggPSB0b19kZXN0cm95Lmxlbmd0aDtcblxuXHRcdGlmIChkZXN0cm95X2xlbmd0aCA+IDApIHtcblx0XHRcdHZhciBjb250cm9sbGVkX2FuY2hvciA9IChmbGFncyAmIEVBQ0hfSVNfQ09OVFJPTExFRCkgIT09IDAgJiYgbGVuZ3RoID09PSAwID8gYW5jaG9yIDogbnVsbDtcblxuXHRcdFx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZXN0cm95X2xlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dG9fZGVzdHJveVtpXS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8uZml4KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGF1c2VfZWZmZWN0cyhzdGF0ZSwgdG9fZGVzdHJveSwgY29udHJvbGxlZF9hbmNob3IsIGl0ZW1zKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmICh0b19hbmltYXRlID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGZvciAoaXRlbSBvZiB0b19hbmltYXRlKSB7XG5cdFx0XHRcdGl0ZW0uYT8uYXBwbHkoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZmlyc3QgPSBzdGF0ZS5maXJzdCAmJiBzdGF0ZS5maXJzdC5lO1xuXHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmxhc3QgPSBwcmV2ICYmIHByZXYuZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VhY2hJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVfaXRlbShpdGVtLCB2YWx1ZSwgaW5kZXgsIHR5cGUpIHtcblx0aWYgKCh0eXBlICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMCkge1xuXHRcdGludGVybmFsX3NldChpdGVtLnYsIHZhbHVlKTtcblx0fVxuXG5cdGlmICgodHlwZSAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpICE9PSAwKSB7XG5cdFx0aW50ZXJuYWxfc2V0KC8qKiBAdHlwZSB7VmFsdWU8bnVtYmVyPn0gKi8gKGl0ZW0uaSksIGluZGV4KTtcblx0fSBlbHNlIHtcblx0XHRpdGVtLmkgPSBpbmRleDtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge05vZGV9IGFuY2hvclxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7dW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogViB8IFNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFZhbHVlPG51bWJlcj4pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtFYWNoSXRlbX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2l0ZW0oXG5cdGFuY2hvcixcblx0c3RhdGUsXG5cdHByZXYsXG5cdG5leHQsXG5cdHZhbHVlLFxuXHRrZXksXG5cdGluZGV4LFxuXHRyZW5kZXJfZm4sXG5cdGZsYWdzLFxuXHRnZXRfY29sbGVjdGlvblxuKSB7XG5cdHZhciBwcmV2aW91c19lYWNoX2l0ZW0gPSBjdXJyZW50X2VhY2hfaXRlbTtcblx0dmFyIHJlYWN0aXZlID0gKGZsYWdzICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMDtcblx0dmFyIG11dGFibGUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fSU1NVVRBQkxFKSA9PT0gMDtcblxuXHR2YXIgdiA9IHJlYWN0aXZlID8gKG11dGFibGUgPyBtdXRhYmxlX3NvdXJjZSh2YWx1ZSkgOiBzb3VyY2UodmFsdWUpKSA6IHZhbHVlO1xuXHR2YXIgaSA9IChmbGFncyAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpID09PSAwID8gaW5kZXggOiBzb3VyY2UoaW5kZXgpO1xuXG5cdGlmIChERVYgJiYgcmVhY3RpdmUpIHtcblx0XHQvLyBGb3IgdHJhY2luZyBwdXJwb3Nlcywgd2UgbmVlZCB0byBsaW5rIHRoZSBzb3VyY2Ugc2lnbmFsIHdlIGNyZWF0ZSB3aXRoIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gKyBpbmRleCBzbyB0aGF0IHRyYWNpbmcgd29ya3MgYXMgaW50ZW5kZWRcblx0XHQvKiogQHR5cGUge1ZhbHVlfSAqLyAodikuZGVidWcgPSAoKSA9PiB7XG5cdFx0XHR2YXIgY29sbGVjdGlvbl9pbmRleCA9IHR5cGVvZiBpID09PSAnbnVtYmVyJyA/IGluZGV4IDogaS52O1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdGdldF9jb2xsZWN0aW9uKClbY29sbGVjdGlvbl9pbmRleF07XG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdHZhciBpdGVtID0ge1xuXHRcdGksXG5cdFx0dixcblx0XHRrOiBrZXksXG5cdFx0YTogbnVsbCxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZTogbnVsbCxcblx0XHRwcmV2LFxuXHRcdG5leHRcblx0fTtcblxuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG5cblx0dHJ5IHtcblx0XHRpdGVtLmUgPSBicmFuY2goKCkgPT4gcmVuZGVyX2ZuKGFuY2hvciwgdiwgaSksIGh5ZHJhdGluZyk7XG5cblx0XHRpdGVtLmUucHJldiA9IHByZXYgJiYgcHJldi5lO1xuXHRcdGl0ZW0uZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cblx0XHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdFx0c3RhdGUuZmlyc3QgPSBpdGVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBpdGVtO1xuXHRcdFx0cHJldi5lLm5leHQgPSBpdGVtLmU7XG5cdFx0fVxuXG5cdFx0aWYgKG5leHQgIT09IG51bGwpIHtcblx0XHRcdG5leHQucHJldiA9IGl0ZW07XG5cdFx0XHRuZXh0LmUucHJldiA9IGl0ZW0uZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fSBmaW5hbGx5IHtcblx0XHRjdXJyZW50X2VhY2hfaXRlbSA9IHByZXZpb3VzX2VhY2hfaXRlbTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaEl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKiBAcGFyYW0ge1RleHQgfCBFbGVtZW50IHwgQ29tbWVudH0gYW5jaG9yXG4gKi9cbmZ1bmN0aW9uIG1vdmUoaXRlbSwgbmV4dCwgYW5jaG9yKSB7XG5cdHZhciBlbmQgPSBpdGVtLm5leHQgPyAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGl0ZW0ubmV4dC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblxuXHR2YXIgZGVzdCA9IG5leHQgPyAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHQuZS5ub2Rlc19zdGFydCkgOiBhbmNob3I7XG5cdHZhciBub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChpdGVtLmUubm9kZXNfc3RhcnQpO1xuXG5cdHdoaWxlIChub2RlICE9PSBlbmQpIHtcblx0XHR2YXIgbmV4dF9ub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHRkZXN0LmJlZm9yZShub2RlKTtcblx0XHRub2RlID0gbmV4dF9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqL1xuZnVuY3Rpb24gbGluayhzdGF0ZSwgcHJldiwgbmV4dCkge1xuXHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdHN0YXRlLmZpcnN0ID0gbmV4dDtcblx0fSBlbHNlIHtcblx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdHByZXYuZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cdH1cblxuXHRpZiAobmV4dCAhPT0gbnVsbCkge1xuXHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0bmV4dC5lLnByZXYgPSBwcmV2ICYmIHByZXYuZTtcblx0fVxufVxuIiwiaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29tbWVudH0gYW5jaG9yXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBzbG90X3Byb3BzXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogQ29tbWVudCkgPT4gdm9pZCl9IGZhbGxiYWNrX2ZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbG90KGFuY2hvciwgJCRwcm9wcywgbmFtZSwgc2xvdF9wcm9wcywgZmFsbGJhY2tfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIHNsb3RfZm4gPSAkJHByb3BzLiQkc2xvdHM/LltuYW1lXTtcblx0Ly8gSW50ZXJvcDogQ2FuIHVzZSBzbmlwcGV0cyB0byBmaWxsIHNsb3RzXG5cdHZhciBpc19pbnRlcm9wID0gZmFsc2U7XG5cdGlmIChzbG90X2ZuID09PSB0cnVlKSB7XG5cdFx0c2xvdF9mbiA9ICQkcHJvcHNbbmFtZSA9PT0gJ2RlZmF1bHQnID8gJ2NoaWxkcmVuJyA6IG5hbWVdO1xuXHRcdGlzX2ludGVyb3AgPSB0cnVlO1xuXHR9XG5cblx0aWYgKHNsb3RfZm4gPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0ZmFsbGJhY2tfZm4oYW5jaG9yKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c2xvdF9mbihhbmNob3IsIGlzX2ludGVyb3AgPyAoKSA9PiBzbG90X3Byb3BzIDogc2xvdF9wcm9wcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZV9zbG90cyhwcm9wcykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuXHRjb25zdCBzYW5pdGl6ZWQgPSB7fTtcblx0aWYgKHByb3BzLmNoaWxkcmVuKSBzYW5pdGl6ZWQuZGVmYXVsdCA9IHRydWU7XG5cdGZvciAoY29uc3Qga2V5IGluIHByb3BzLiQkc2xvdHMpIHtcblx0XHRzYW5pdGl6ZWRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHNhbml0aXplZDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZScgKi9cbi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBicmFuY2gsIGJsb2NrLCBkZXN0cm95X2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgeyhub2RlOiBUZW1wbGF0ZU5vZGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBTbmlwcGV0Rm5cbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IFNuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9IGdldF9zbmlwcGV0XG4gKiBAcGFyYW0geygoKSA9PiBhbnkpW119IGFyZ3NcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25pcHBldChub2RlLCBnZXRfc25pcHBldCwgLi4uYXJncykge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge1NuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0dmFyIHNuaXBwZXQgPSBub29wO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIHNuaXBwZXRfZWZmZWN0O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoc25pcHBldCA9PT0gKHNuaXBwZXQgPSBnZXRfc25pcHBldCgpKSkgcmV0dXJuO1xuXG5cdFx0aWYgKHNuaXBwZXRfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChzbmlwcGV0X2VmZmVjdCk7XG5cdFx0XHRzbmlwcGV0X2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKERFViAmJiBzbmlwcGV0ID09IG51bGwpIHtcblx0XHRcdGUuaW52YWxpZF9zbmlwcGV0KCk7XG5cdFx0fVxuXG5cdFx0c25pcHBldF9lZmZlY3QgPSBicmFuY2goKCkgPT4gLyoqIEB0eXBlIHtTbmlwcGV0Rm59ICovIChzbmlwcGV0KShhbmNob3IsIC4uLmFyZ3MpKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2ZWxvcG1lbnQsIHdyYXAgdGhlIHNuaXBwZXQgZnVuY3Rpb24gc28gdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbiwgYW5kIHNvIHRoYXQgdGhlXG4gKiBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0IGlzIHNldCBmb3Igb3duZXJzaGlwIGNoZWNrc1xuICogQHBhcmFtIHthbnl9IGNvbXBvbmVudFxuICogQHBhcmFtIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBfc25pcHBldChjb21wb25lbnQsIGZuKSB7XG5cdHJldHVybiAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIG5vZGUsIC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oY29tcG9uZW50KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4obm9kZSwgLi4uYXJncyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24ocHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc25pcHBldCBwcm9ncmFtbWF0aWNhbGx5XG4gKiBAdGVtcGxhdGUge3Vua25vd25bXX0gUGFyYW1zXG4gKiBAcGFyYW0geyguLi5wYXJhbXM6IEdldHRlcnM8UGFyYW1zPikgPT4ge1xuICogICByZW5kZXI6ICgpID0+IHN0cmluZ1xuICogICBzZXR1cD86IChlbGVtZW50OiBFbGVtZW50KSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpXG4gKiB9fSBmblxuICogQHJldHVybnMge1NuaXBwZXQ8UGFyYW1zPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhd1NuaXBwZXQoZm4pIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZXMgYXJlIGEgbGllXG5cdHJldHVybiAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIGFuY2hvciwgLyoqIEB0eXBlIHtHZXR0ZXJzPFBhcmFtcz59ICovIC4uLnBhcmFtcykgPT4ge1xuXHRcdHZhciBzbmlwcGV0ID0gZm4oLi4ucGFyYW1zKTtcblxuXHRcdC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cblx0XHR2YXIgZWxlbWVudDtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBodG1sID0gc25pcHBldC5yZW5kZXIoKS50cmltKCk7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpO1xuXHRcdFx0ZWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoREVWICYmIChnZXRfbmV4dF9zaWJsaW5nKGVsZW1lbnQpICE9PSBudWxsIHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpKSB7XG5cdFx0XHRcdHcuaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSBzbmlwcGV0LnNldHVwPy4oZWxlbWVudCk7XG5cdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRlYXJkb3duKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUsIERvbSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBwYXVzZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFBcbiAqIEB0ZW1wbGF0ZSB7KHByb3BzOiBQKSA9PiB2b2lkfSBDXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBDfSBnZXRfY29tcG9uZW50XG4gKiBAcGFyYW0geyhhbmNob3I6IFRlbXBsYXRlTm9kZSwgY29tcG9uZW50OiBDKSA9PiBEb20gfCB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50KG5vZGUsIGdldF9jb21wb25lbnQsIHJlbmRlcl9mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0N9ICovXG5cdHZhciBjb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoY29tcG9uZW50ID09PSAoY29tcG9uZW50ID0gZ2V0X2NvbXBvbmVudCgpKSkgcmV0dXJuO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChjb21wb25lbnQpIHtcblx0XHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiByZW5kZXJfZm4oYW5jaG9yLCBjb21wb25lbnQpKTtcblx0XHR9XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgTkFNRVNQQUNFX1NWRyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQge1xuXHRibG9jayxcblx0YnJhbmNoLFxuXHRkZXN0cm95X2VmZmVjdCxcblx0cGF1c2VfZWZmZWN0LFxuXHRyZXN1bWVfZWZmZWN0XG59IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzZXRfc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfZWFjaF9pdGVtLCBzZXRfY3VycmVudF9lYWNoX2l0ZW0gfSBmcm9tICcuL2VhY2guanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGlzX3Jhd190ZXh0X2VsZW1lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtDb21tZW50IHwgRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF90YWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoZWxlbWVudDogRWxlbWVudCwgYW5jaG9yOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCl9IHJlbmRlcl9mbixcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgKCgpID0+IHN0cmluZyl9IGdldF9uYW1lc3BhY2VcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgW251bWJlciwgbnVtYmVyXX0gbG9jYXRpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChub2RlLCBnZXRfdGFnLCBpc19zdmcsIHJlbmRlcl9mbiwgZ2V0X25hbWVzcGFjZSwgbG9jYXRpb24pIHtcblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGZpbGVuYW1lID0gREVWICYmIGxvY2F0aW9uICYmIGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbltGSUxFTkFNRV07XG5cblx0LyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuXHR2YXIgdGFnO1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cblx0dmFyIGN1cnJlbnRfdGFnO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdHZhciBlbGVtZW50ID0gbnVsbDtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZSk7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdC8qKlxuXHQgKiBUaGUga2V5ZWQgYHsjZWFjaCAuLi59YCBpdGVtIGJsb2NrLCBpZiBhbnksIHRoYXQgdGhpcyBlbGVtZW50IGlzIGluc2lkZS5cblx0ICogV2UgdHJhY2sgdGhpcyBzbyB3ZSBjYW4gc2V0IGl0IHdoZW4gY2hhbmdpbmcgdGhlIGVsZW1lbnQsIGFsbG93aW5nIGFueVxuXHQgKiBgYW5pbWF0ZTpgIGRpcmVjdGl2ZSB0byBiaW5kIGl0c2VsZiB0byB0aGUgY29ycmVjdCBibG9ja1xuXHQgKi9cblx0dmFyIGVhY2hfaXRlbV9ibG9jayA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRjb25zdCBuZXh0X3RhZyA9IGdldF90YWcoKSB8fCBudWxsO1xuXHRcdHZhciBucyA9IGdldF9uYW1lc3BhY2UgPyBnZXRfbmFtZXNwYWNlKCkgOiBpc19zdmcgfHwgbmV4dF90YWcgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG51bGw7XG5cblx0XHQvLyBBc3N1bXB0aW9uOiBOb29uZSBjaGFuZ2VzIHRoZSBuYW1lc3BhY2UgYnV0IG5vdCB0aGUgdGFnICh3aGF0IHdvdWxkIHRoYXQgZXZlbiBtZWFuPylcblx0XHRpZiAobmV4dF90YWcgPT09IHRhZykgcmV0dXJuO1xuXG5cdFx0Ly8gU2VlIGV4cGxhbmF0aW9uIG9mIGBlYWNoX2l0ZW1fYmxvY2tgIGFib3ZlXG5cdFx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShlYWNoX2l0ZW1fYmxvY2spO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0aWYgKG5leHRfdGFnID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIHN0YXJ0IG91dHJvXG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRfdGFnID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKG5leHRfdGFnID09PSBjdXJyZW50X3RhZykge1xuXHRcdFx0XHQvLyBzYW1lIHRhZyBhcyBpcyBjdXJyZW50bHkgcmVuZGVyZWQg4oCUIGFib3J0IG91dHJvXG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRhZyBpcyBjaGFuZ2luZyDigJQgZGVzdHJveSBpbW1lZGlhdGVseSwgcmVuZGVyIGNvbnRlbnRzIHdpdGhvdXQgaW50cm8gdHJhbnNpdGlvbnNcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0c2V0X3Nob3VsZF9pbnRybyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRfdGFnICYmIG5leHRfdGFnICE9PSBjdXJyZW50X3RhZykge1xuXHRcdFx0ZWZmZWN0ID0gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0ZWxlbWVudCA9IGh5ZHJhdGluZ1xuXHRcdFx0XHRcdD8gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZWxlbWVudClcblx0XHRcdFx0XHQ6IG5zXG5cdFx0XHRcdFx0XHQ/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgbmV4dF90YWcpXG5cdFx0XHRcdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dF90YWcpO1xuXG5cdFx0XHRcdGlmIChERVYgJiYgbG9jYXRpb24pIHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdFx0XHRcdFx0bG9jOiB7XG5cdFx0XHRcdFx0XHRcdGZpbGU6IGZpbGVuYW1lLFxuXHRcdFx0XHRcdFx0XHRsaW5lOiBsb2NhdGlvblswXSxcblx0XHRcdFx0XHRcdFx0Y29sdW1uOiBsb2NhdGlvblsxXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ25fbm9kZXMoZWxlbWVudCwgZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKHJlbmRlcl9mbikge1xuXHRcdFx0XHRcdGlmIChoeWRyYXRpbmcgJiYgaXNfcmF3X3RleHRfZWxlbWVudChuZXh0X3RhZykpIHtcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgaHlkcmF0aW9uIGdsaXRjaGVzXG5cdFx0XHRcdFx0XHRlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgaHlkcmF0aW5nLCB1c2UgdGhlIGV4aXN0aW5nIHNzciBjb21tZW50IGFzIHRoZSBhbmNob3Igc28gdGhhdCB0aGVcblx0XHRcdFx0XHQvLyBpbm5lciBvcGVuIGFuZCBjbG9zZSBtZXRob2RzIGNhbiBwaWNrIHVwIHRoZSBleGlzdGluZyBub2RlcyBjb3JyZWN0bHlcblx0XHRcdFx0XHR2YXIgY2hpbGRfYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdFx0XHRcdGh5ZHJhdGluZyA/IGdldF9maXJzdF9jaGlsZChlbGVtZW50KSA6IGVsZW1lbnQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkX2FuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBgY2hpbGRfYW5jaG9yYCBpcyB1bmRlZmluZWQgaWYgdGhpcyBpcyBhIHZvaWQgZWxlbWVudCwgYnV0IHdlIHN0aWxsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjYWxsIGByZW5kZXJfZm5gIGluIG9yZGVyIHRvIHJ1biBhY3Rpb25zIGV0Yy4gSWYgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyBjb250YWlucyBjaGlsZHJlbiwgaXQncyBhIHVzZXIgZXJyb3IgKHdoaWNoIGlzIHdhcm5lZCBvbiBlbHNld2hlcmUpXG5cdFx0XHRcdFx0Ly8gYW5kIHRoZSBET00gd2lsbCBiZSBzaWxlbnRseSBkaXNjYXJkZWRcblx0XHRcdFx0XHRyZW5kZXJfZm4oZWxlbWVudCwgY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHdlIGRvIHRoaXMgYWZ0ZXIgY2FsbGluZyBgcmVuZGVyX2ZuYCBzbyB0aGF0IGNoaWxkIGVmZmVjdHMgZG9uJ3Qgb3ZlcnJpZGUgYG5vZGVzLmVuZGBcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBlbGVtZW50O1xuXG5cdFx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0YWcgPSBuZXh0X3RhZztcblx0XHRpZiAodGFnKSBjdXJyZW50X3RhZyA9IHRhZztcblx0XHRzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXG5cdFx0c2V0X2N1cnJlbnRfZWFjaF9pdGVtKHByZXZpb3VzX2VhY2hfaXRlbSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0fVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBvPWUubGVuZ3RoO2Zvcih0PTA7dDxvO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zil9ZWxzZSBmb3IoZiBpbiBlKWVbZl0mJihuJiYobis9XCIgXCIpLG4rPWYpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIixvPWFyZ3VtZW50cy5sZW5ndGg7ZjxvO2YrKykoZT1hcmd1bWVudHNbZl0pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgeyBlc2NhcGVfaHRtbCB9IGZyb20gJy4uLy4uL2VzY2FwaW5nLmpzJztcbmltcG9ydCB7IGNsc3ggYXMgX2Nsc3ggfSBmcm9tICdjbHN4JztcblxuLyoqXG4gKiBgPGRpdiB0cmFuc2xhdGU9e2ZhbHNlfT5gIHNob3VsZCBiZSByZW5kZXJlZCBhcyBgPGRpdiB0cmFuc2xhdGU9XCJub1wiPmAgYW5kIF9ub3RfXG4gKiBgPGRpdiB0cmFuc2xhdGU9XCJmYWxzZVwiPmAsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYDxkaXYgdHJhbnNsYXRlPVwieWVzXCI+YC4gVGhlcmVcbiAqIG1heSBiZSBvdGhlciBvZGQgY2FzZXMgdGhhdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoaXMgbGlzdCBpbiBmdXR1cmVcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBNYXA8YW55LCBzdHJpbmc+Pn1cbiAqL1xuY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuXHR0cmFuc2xhdGU6IG5ldyBNYXAoW1xuXHRcdFt0cnVlLCAneWVzJ10sXG5cdFx0W2ZhbHNlLCAnbm8nXVxuXHRdKVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX2Jvb2xlYW5dXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSwgaXNfYm9vbGVhbiA9IGZhbHNlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8ICghdmFsdWUgJiYgaXNfYm9vbGVhbikgfHwgKHZhbHVlID09PSAnJyAmJiBuYW1lID09PSAnY2xhc3MnKSkgcmV0dXJuICcnO1xuXHRjb25zdCBub3JtYWxpemVkID0gKG5hbWUgaW4gcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1tuYW1lXS5nZXQodmFsdWUpKSB8fCB2YWx1ZTtcblx0Y29uc3QgYXNzaWdubWVudCA9IGlzX2Jvb2xlYW4gPyAnJyA6IGA9XCIke2VzY2FwZV9odG1sKG5vcm1hbGl6ZWQsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKipcbiAqIFNtYWxsIHdyYXBwZXIgYXJvdW5kIGNsc3ggdG8gcHJlc2VydmUgU3ZlbHRlJ3MgKHdlaXJkKSBoYW5kbGluZyBvZiBmYWxzeSB2YWx1ZXMuXG4gKiBUT0RPIFN2ZWx0ZSA2IHJldmlzaXQgdGhpcywgYW5kIGxpa2VseSB0dXJuIGFsbCBmYWxzeSB2YWx1ZXMgaW50byB0aGUgZW1wdHkgc3RyaW5nICh3aGF0IGNsc3ggYWxzbyBkb2VzKVxuICogQHBhcmFtICB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xzeCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBfY2xzeCh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlID8/ICcnO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvcnMsIGdldF9wcm90b3R5cGVfb2YgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlX2V2ZW50LCBkZWxlZ2F0ZSB9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyLCBhdXRvZm9jdXMgfSBmcm9tICcuL21pc2MuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBMT0FESU5HX0FUVFJfU1lNQk9MIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHF1ZXVlX2lkbGVfdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgaXNfY2FwdHVyZV9ldmVudCwgaXNfZGVsZWdhdGVkLCBub3JtYWxpemVfYXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNsc3ggfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5cbi8qKlxuICogVGhlIHZhbHVlL2NoZWNrZWQgYXR0cmlidXRlIGluIHRoZSB0ZW1wbGF0ZSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX2lucHV0X2RlZmF1bHRzKGlucHV0KSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0dmFyIGFscmVhZHlfcmVtb3ZlZCA9IGZhbHNlO1xuXG5cdC8vIFdlIHRyeSBhbmQgcmVtb3ZlIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXMgbGF0ZXIsIHJhdGhlciB0aGFuIHN5bmMgZHVyaW5nIGh5ZHJhdGlvbi5cblx0Ly8gRG9pbmcgaXQgc3luYyBkdXJpbmcgaHlkcmF0aW9uIGhhcyBhIG5lZ2F0aXZlIGltcGFjdCBvbiBwZXJmb3JtYW5jZSwgYnV0IGRlZmVycmluZyB0aGVcblx0Ly8gd29yayBpbiBhbiBpZGxlIHRhc2sgYWxsZXZpYXRlcyB0aGlzIGdyZWF0bHkuIElmIGEgZm9ybSByZXNldCBldmVudCBjb21lcyBpbiBiZWZvcmVcblx0Ly8gdGhlIGlkbGUgY2FsbGJhY2ssIHRoZW4gd2UgZW5zdXJlIHRoZSBpbnB1dCBkZWZhdWx0cyBhcmUgY2xlYXJlZCBqdXN0IGJlZm9yZS5cblx0dmFyIHJlbW92ZV9kZWZhdWx0cyA9ICgpID0+IHtcblx0XHRpZiAoYWxyZWFkeV9yZW1vdmVkKSByZXR1cm47XG5cdFx0YWxyZWFkeV9yZW1vdmVkID0gdHJ1ZTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlcyBidXQgcHJlc2VydmUgdGhlIHZhbHVlc1xuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ3ZhbHVlJywgbnVsbCk7XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuXHRcdFx0dmFyIGNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ2NoZWNrZWQnLCBudWxsKTtcblx0XHRcdGlucHV0LmNoZWNrZWQgPSBjaGVja2VkO1xuXHRcdH1cblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlucHV0Ll9fb25fciA9IHJlbW92ZV9kZWZhdWx0cztcblx0cXVldWVfaWRsZV90YXNrKHJlbW92ZV9kZWZhdWx0cyk7XG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMudmFsdWUgPT09XG5cdFx0XHQoYXR0cmlidXRlcy52YWx1ZSA9XG5cdFx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdFx0dmFsdWUgPz8gdW5kZWZpbmVkKSB8fFxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHQvLyBgcHJvZ3Jlc3NgIGVsZW1lbnRzIGFsd2F5cyBuZWVkIHRoZWlyIHZhbHVlIHNldCB3aGVuIGl0cyBgMGBcblx0XHQoZWxlbWVudC52YWx1ZSA9PT0gdmFsdWUgJiYgKHZhbHVlICE9PSAwIHx8IGVsZW1lbnQubm9kZU5hbWUgIT09ICdQUk9HUkVTUycpKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2NoZWNrZWQoZWxlbWVudCwgY2hlY2tlZCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMuY2hlY2tlZCA9PT1cblx0XHQoYXR0cmlidXRlcy5jaGVja2VkID1cblx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdGNoZWNrZWQgPz8gdW5kZWZpbmVkKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgb24gYW4gYG9wdGlvbmAgZWxlbWVudC5cbiAqIE5vdCBzZXQgdGhyb3VnaCB0aGUgcHJvcGVydHkgYmVjYXVzZSB0aGF0IGRvZXNuJ3QgcmVmbGVjdCB0byB0aGUgRE9NLFxuICogd2hpY2ggbWVhbnMgaXQgd291bGRuJ3QgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gYSBmb3JtIGlzIHJlc2V0LlxuICogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NlbGVjdGVkKGVsZW1lbnQsIHNlbGVjdGVkKSB7XG5cdGlmIChzZWxlY3RlZCkge1xuXHRcdC8vIFRoZSBzZWxlY3RlZCBvcHRpb24gY291bGQndmUgY2hhbmdlZCB2aWEgdXNlciBzZWxlY3Rpb24sIGFuZFxuXHRcdC8vIHNldHRpbmcgdGhlIHZhbHVlIHdpdGhvdXQgdGhpcyBjaGVjayB3b3VsZCBzZXQgaXQgYmFjay5cblx0XHRpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnJyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZGVmYXVsdCBjaGVja2VkIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgY2hlY2tlZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVmYXVsdF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG5cdGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuXHRlbGVtZW50LmNoZWNrZWQgPSBleGlzdGluZ192YWx1ZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IHZhbHVlIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgdmFsdWUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X3ZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG5cdGNvbnN0IGV4aXN0aW5nX3ZhbHVlID0gZWxlbWVudC52YWx1ZTtcblx0ZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcblx0ZWxlbWVudC52YWx1ZSA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlLCBza2lwX3dhcm5pbmcpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgYXR0cmlidXRlcyA9IChlbGVtZW50Ll9fYXR0cmlidXRlcyA/Pz0ge30pO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXG5cdFx0aWYgKFxuXHRcdFx0YXR0cmlidXRlID09PSAnc3JjJyB8fFxuXHRcdFx0YXR0cmlidXRlID09PSAnc3Jjc2V0JyB8fFxuXHRcdFx0KGF0dHJpYnV0ZSA9PT0gJ2hyZWYnICYmIGVsZW1lbnQubm9kZU5hbWUgPT09ICdMSU5LJylcblx0XHQpIHtcblx0XHRcdGlmICghc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdGNoZWNrX3NyY19pbl9kZXZfaHlkcmF0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUgPz8gJycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSByZXNldCB0aGVzZSBhdHRyaWJ1dGVzLCB0aGV5IHdvdWxkIHJlc3VsdCBpbiBhbm90aGVyIG5ldHdvcmsgcmVxdWVzdCwgd2hpY2ggd2Ugd2FudCB0byBhdm9pZC5cblx0XHRcdC8vIFdlIGFzc3VtZSB0aGV5IGFyZSB0aGUgc2FtZSBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyIGFzIGNoZWNraW5nIGlmIHRoZXkgYXJlIGVxdWFsIGlzIGV4cGVuc2l2ZVxuXHRcdFx0Ly8gKHdlIGNhbid0IGp1c3QgY29tcGFyZSB0aGUgc3RyaW5ncyBhcyB0aGV5IGNhbiBiZSBkaWZmZXJlbnQgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBidXQgcmVzdWx0IGluIHRoZVxuXHRcdFx0Ly8gc2FtZSB1cmwsIHNvIHdlIHdvdWxkIG5lZWQgdG8gY3JlYXRlIGhpZGRlbiBhbmNob3IgZWxlbWVudHMgdG8gY29tcGFyZSB0aGVtKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPT09IChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZSkpIHJldHVybjtcblxuXHRpZiAoYXR0cmlidXRlID09PSAnc3R5bGUnICYmICdfX3N0eWxlcycgaW4gZWxlbWVudCkge1xuXHRcdC8vIHJlc2V0IHN0eWxlcyB0byBmb3JjZSBzdHlsZTogZGlyZWN0aXZlIHRvIHVwZGF0ZVxuXHRcdGVsZW1lbnQuX19zdHlsZXMgPSB7fTtcblx0fVxuXG5cdGlmIChhdHRyaWJ1dGUgPT09ICdsb2FkaW5nJykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50W0xPQURJTkdfQVRUUl9TWU1CT0xdID0gdmFsdWU7XG5cdH1cblxuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiBnZXRfc2V0dGVycyhlbGVtZW50KS5pbmNsdWRlcyhhdHRyaWJ1dGUpKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGVsZW1lbnRbYXR0cmlidXRlXSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3hsaW5rX2F0dHJpYnV0ZShkb20sIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0ZG9tLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcblx0Ly8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCBzZXR0aW5nIGN1c3RvbSBlbGVtZW50IHByb3BzLCB3aGljaCBjYW5cblx0Ly8gaW52b2tlIGxpZmVjeWNsZSBtZXRob2RzIG9uIG90aGVyIGN1c3RvbSBlbGVtZW50cywgZG9lcyBub3QgYWxzb1xuXHQvLyBhc3NvY2lhdGUgdGhvc2UgbGlmZWN5Y2xlIG1ldGhvZHMgd2l0aCB0aGUgY3VycmVudCBhY3RpdmUgcmVhY3Rpb25cblx0Ly8gb3IgZWZmZWN0XG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHRyeSB7XG5cdFx0aWYgKFxuXHRcdFx0Ly8gRG9uJ3QgY29tcHV0ZSBzZXR0ZXJzIGZvciBjdXN0b20gZWxlbWVudHMgd2hpbGUgdGhleSBhcmVuJ3QgcmVnaXN0ZXJlZCB5ZXQsXG5cdFx0XHQvLyBiZWNhdXNlIGR1cmluZyB0aGVpciB1cGdyYWRlL2luc3RhbnRpYXRpb24gdGhleSBtaWdodCBhZGQgbW9yZSBzZXR0ZXJzLlxuXHRcdFx0Ly8gSW5zdGVhZCwgZmFsbCBiYWNrIHRvIGEgc2ltcGxlIFwiYW4gb2JqZWN0LCB0aGVuIHNldCBhcyBwcm9wZXJ0eVwiIGhldXJpc3RpYy5cblx0XHRcdHNldHRlcnNfY2FjaGUuaGFzKG5vZGUubm9kZU5hbWUpIHx8IGN1c3RvbUVsZW1lbnRzLmdldChub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0PyBnZXRfc2V0dGVycyhub2RlKS5pbmNsdWRlcyhwcm9wKVxuXHRcdFx0XHQ6IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdG5vZGVbcHJvcF0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gV2UgZGlkIGdldHRlcnMgZXRjIGNoZWNrcyBhbHJlYWR5LCBzdHJpbmdpZnkgYmVmb3JlIHBhc3NpbmcgdG8gc2V0X2F0dHJpYnV0ZVxuXHRcdFx0Ly8gdG8gZW5zdXJlIGl0IGRvZXNuJ3QgaW52b2tlIHRoZSBzYW1lIGxvZ2ljIGFnYWluLCBhbmQgcG90ZW50aWFsbHkgcG9wdWxhdGluZ1xuXHRcdFx0Ly8gdGhlIHNldHRlcnMgY2FjaGUgdG9vIGVhcmx5LlxuXHRcdFx0c2V0X2F0dHJpYnV0ZShub2RlLCBwcm9wLCB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIFNwcmVhZHMgYXR0cmlidXRlcyBvbnRvIGEgRE9NIGVsZW1lbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnRseSBzZXQgYXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWR9IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gbmV4dCBOZXcgYXR0cmlidXRlcyAtIHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlXVxuICogQHBhcmFtIHtib29sZWFufSBbaXNfY3VzdG9tX2VsZW1lbnRdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKFxuXHRlbGVtZW50LFxuXHRwcmV2LFxuXHRuZXh0LFxuXHRjc3NfaGFzaCxcblx0cHJlc2VydmVfYXR0cmlidXRlX2Nhc2UgPSBmYWxzZSxcblx0aXNfY3VzdG9tX2VsZW1lbnQgPSBmYWxzZSxcblx0c2tpcF93YXJuaW5nID0gZmFsc2Vcbikge1xuXHR2YXIgY3VycmVudCA9IHByZXYgfHwge307XG5cdHZhciBpc19vcHRpb25fZWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09QVElPTic7XG5cblx0Zm9yICh2YXIga2V5IGluIHByZXYpIHtcblx0XHRpZiAoIShrZXkgaW4gbmV4dCkpIHtcblx0XHRcdG5leHRba2V5XSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5leHQuY2xhc3MpIHtcblx0XHRuZXh0LmNsYXNzID0gY2xzeChuZXh0LmNsYXNzKTtcblx0fVxuXG5cdGlmIChjc3NfaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bmV4dC5jbGFzcyA9IG5leHQuY2xhc3MgPyBuZXh0LmNsYXNzICsgJyAnICsgY3NzX2hhc2ggOiBjc3NfaGFzaDtcblx0fVxuXG5cdHZhciBzZXR0ZXJzID0gZ2V0X3NldHRlcnMoZWxlbWVudCk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgYXR0cmlidXRlcyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICoqLyAoZWxlbWVudC5fX2F0dHJpYnV0ZXMgPz89IHt9KTtcblxuXHQvLyBzaW5jZSBrZXkgaXMgY2FwdHVyZWQgd2UgdXNlIGNvbnN0XG5cdGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcblx0XHQvLyBsZXQgaW5zdGVhZCBvZiB2YXIgYmVjYXVzZSByZWZlcmVuY2VkIGluIGEgY2xvc3VyZVxuXHRcdGxldCB2YWx1ZSA9IG5leHRba2V5XTtcblxuXHRcdC8vIFVwIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvIGRvIHRoaXMgZm9yIHRoZSBpbml0aWFsIHZhbHVlLCB0b28sIGV2ZW4gaWYgaXQncyB1bmRlZmluZWQsXG5cdFx0Ly8gYW5kIHRoaXMgd291bGRuJ3QgYmUgcmVhY2hlZCBpbiBjYXNlIG9mIHVuZGVmaW5lZCBiZWNhdXNlIG9mIHRoZSBlcXVhbGl0eSBjaGVjayBiZWxvd1xuXHRcdGlmIChpc19vcHRpb25fZWxlbWVudCAmJiBrZXkgPT09ICd2YWx1ZScgJiYgdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0Ly8gVGhlIDxvcHRpb24+IGVsZW1lbnQgaXMgYSBzcGVjaWFsIGNhc2UgYmVjYXVzZSByZW1vdmluZyB0aGUgdmFsdWUgYXR0cmlidXRlIG1lYW5zXG5cdFx0XHQvLyB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG9wdGlvbiBlbGVtZW50LCBhbmQgc2V0dGluZyB0aGUgdmFsdWVcblx0XHRcdC8vIHRvIG51bGwgb3IgdW5kZWZpbmVkIG1lYW5zIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHN0cmluZyBcIm51bGxcIiBvciBcInVuZGVmaW5lZFwiLlxuXHRcdFx0Ly8gVG8gYWxpZ24gd2l0aCBob3cgd2UgaGFuZGxlIHRoaXMgY2FzZSBpbiBub24tc3ByZWFkLXNjZW5hcmlvcywgdGhpcyBsb2dpYyBpcyBuZWVkZWQuXG5cdFx0XHQvLyBUaGVyZSdzIGEgc3VwZXItZWRnZS1jYXNlIGJ1ZyBoZXJlIHRoYXQgaXMgbGVmdCBpbiBpbiBmYXZvciBvZiBzbWFsbGVyIGNvZGUgc2l6ZTpcblx0XHRcdC8vIEJlY2F1c2Ugb2YgdGhlIFwic2V0IG1pc3NpbmcgcHJvcHMgdG8gbnVsbFwiIGxvZ2ljIGFib3ZlLCB3ZSBjYW4ndCBkaWZmZXJlbnRpYXRlXG5cdFx0XHQvLyBiZXR3ZWVuIGEgbWlzc2luZyB2YWx1ZSBhbmQgYW4gZXhwbGljaXRseSBzZXQgdmFsdWUgb2YgbnVsbCBvciB1bmRlZmluZWQuIFRoYXQgbWVhbnNcblx0XHRcdC8vIHRoYXQgb25jZSBzZXQsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgb2YgYW4gPG9wdGlvbj4gZWxlbWVudCBjYW4ndCBiZSByZW1vdmVkLiBUaGlzIGlzXG5cdFx0XHQvLyBhIHZlcnkgcmFyZSBlZGdlIGNhc2UsIGFuZCByZW1vdmluZyB0aGUgYXR0cmlidXRlIGFsdG9nZXRoZXIgaXNuJ3QgcG9zc2libGUgZWl0aGVyXG5cdFx0XHQvLyBmb3IgdGhlIDxvcHRpb24gdmFsdWU9e3VuZGVmaW5lZH0+IGNhc2UsIHNvIHdlJ3JlIG5vdCBsb3NpbmcgYW55IGZ1bmN0aW9uYWxpdHkgaGVyZS5cblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGVsZW1lbnQudmFsdWUgPSBlbGVtZW50Ll9fdmFsdWUgPSAnJztcblx0XHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFyIHByZXZfdmFsdWUgPSBjdXJyZW50W2tleV07XG5cdFx0aWYgKHZhbHVlID09PSBwcmV2X3ZhbHVlKSBjb250aW51ZTtcblxuXHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXG5cdFx0dmFyIHByZWZpeCA9IGtleVswXSArIGtleVsxXTsgLy8gdGhpcyBpcyBmYXN0ZXIgdGhhbiBrZXkuc2xpY2UoMCwgMilcblx0XHRpZiAocHJlZml4ID09PSAnJCQnKSBjb250aW51ZTtcblxuXHRcdGlmIChwcmVmaXggPT09ICdvbicpIHtcblx0XHRcdC8qKiBAdHlwZSB7eyBjYXB0dXJlPzogdHJ1ZSB9fSAqL1xuXHRcdFx0Y29uc3Qgb3B0cyA9IHt9O1xuXHRcdFx0Y29uc3QgZXZlbnRfaGFuZGxlX2tleSA9ICckJCcgKyBrZXk7XG5cdFx0XHRsZXQgZXZlbnRfbmFtZSA9IGtleS5zbGljZSgyKTtcblx0XHRcdHZhciBkZWxlZ2F0ZWQgPSBpc19kZWxlZ2F0ZWQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChpc19jYXB0dXJlX2V2ZW50KGV2ZW50X25hbWUpKSB7XG5cdFx0XHRcdGV2ZW50X25hbWUgPSBldmVudF9uYW1lLnNsaWNlKDAsIC03KTtcblx0XHRcdFx0b3B0cy5jYXB0dXJlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZWxlZ2F0ZWQgJiYgcHJldl92YWx1ZSkge1xuXHRcdFx0XHQvLyBMaXN0ZW5pbmcgdG8gc2FtZSBldmVudCBidXQgZGlmZmVyZW50IGhhbmRsZXIgLT4gb3VyIGhhbmRsZSBmdW5jdGlvbiBiZWxvdyB0YWtlcyBjYXJlIG9mIHRoaXNcblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSB0byByZW1vdmUgYW5kIGFkZCBsaXN0ZW5lcnMgaW4gdGhpcyBjYXNlLCBpdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgZXZlbnQgaXMgXCJzd2FsbG93ZWRcIlxuXHRcdFx0XHQvLyAodGhlIGJyb3dzZXIgc2VlbXMgdG8gbm90IGtub3cgeWV0IHRoYXQgYSBuZXcgb25lIGV4aXN0cyBub3cpIGFuZCBkb2Vzbid0IHJlYWNoIHRoZSBoYW5kbGVyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzExOTAzXG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgY3VycmVudFtldmVudF9oYW5kbGVfa2V5XSwgb3B0cyk7XG5cdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIWRlbGVnYXRlZCkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIEB0aGlzIHthbnl9XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKGV2dCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFtrZXldLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGVsZW1lbnQsIGhhbmRsZSwgb3B0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVsZWdhdGUoW2V2ZW50X25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W2BfXyR7ZXZlbnRfbmFtZX1gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRlbGVtZW50LnN0eWxlLmNzc1RleHQgPSB2YWx1ZSArICcnO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnYXV0b2ZvY3VzJykge1xuXHRcdFx0YXV0b2ZvY3VzKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChlbGVtZW50KSwgQm9vbGVhbih2YWx1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScgfHwgKGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSAhPSBudWxsKSkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnRba2V5XSA9IGVsZW1lbnQuX192YWx1ZSA9IHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2VsZWN0ZWQnICYmIGlzX29wdGlvbl9lbGVtZW50KSB7XG5cdFx0XHRzZXRfc2VsZWN0ZWQoLyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudH0gKi8gKGVsZW1lbnQpLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuYW1lID0ga2V5O1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZSkge1xuXHRcdFx0XHRuYW1lID0gbm9ybWFsaXplX2F0dHJpYnV0ZShuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlzX2RlZmF1bHQgPSBuYW1lID09PSAnZGVmYXVsdFZhbHVlJyB8fCBuYW1lID09PSAnZGVmYXVsdENoZWNrZWQnO1xuXG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaXNfY3VzdG9tX2VsZW1lbnQgJiYgIWlzX2RlZmF1bHQpIHtcblx0XHRcdFx0YXR0cmlidXRlc1trZXldID0gbnVsbDtcblxuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnY2hlY2tlZCcpIHtcblx0XHRcdFx0XHQvLyByZW1vdmluZyB2YWx1ZS9jaGVja2VkIGFsc28gcmVtb3ZlcyBkZWZhdWx0VmFsdWUvZGVmYXVsdENoZWNrZWQg4oCUIHByZXNlcnZlXG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqLyAoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHRcdFx0bGV0IHByZXYgPSBpbnB1dC5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0VmFsdWUgPSBwcmV2O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsZXQgcHJldiA9IGlucHV0LmRlZmF1bHRDaGVja2VkO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBwcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRpc19kZWZhdWx0IHx8XG5cdFx0XHRcdChzZXR0ZXJzLmluY2x1ZGVzKG5hbWUpICYmIChpc19jdXN0b21fZWxlbWVudCB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSlcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGVsZW1lbnRbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmIChoeWRyYXRpbmcgJiYgKG5hbWUgPT09ICdzcmMnIHx8IG5hbWUgPT09ICdocmVmJyB8fCBuYW1lID09PSAnc3Jjc2V0JykpIHtcblx0XHRcdFx0XHRpZiAoIXNraXBfd2FybmluZykgY2hlY2tfc3JjX2luX2Rldl9oeWRyYXRpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUgPz8gJycpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldF9hdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChrZXkgPT09ICdzdHlsZScgJiYgJ19fc3R5bGVzJyBpbiBlbGVtZW50KSB7XG5cdFx0XHQvLyByZXNldCBzdHlsZXMgdG8gZm9yY2Ugc3R5bGU6IGRpcmVjdGl2ZSB0byB1cGRhdGVcblx0XHRcdGVsZW1lbnQuX19zdHlsZXMgPSB7fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudDtcbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBzdHJpbmdbXT59ICovXG52YXIgc2V0dGVyc19jYWNoZSA9IG5ldyBNYXAoKTtcblxuLyoqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAqL1xuZnVuY3Rpb24gZ2V0X3NldHRlcnMoZWxlbWVudCkge1xuXHR2YXIgc2V0dGVycyA9IHNldHRlcnNfY2FjaGUuZ2V0KGVsZW1lbnQubm9kZU5hbWUpO1xuXHRpZiAoc2V0dGVycykgcmV0dXJuIHNldHRlcnM7XG5cdHNldHRlcnNfY2FjaGUuc2V0KGVsZW1lbnQubm9kZU5hbWUsIChzZXR0ZXJzID0gW10pKTtcblxuXHR2YXIgZGVzY3JpcHRvcnM7XG5cdHZhciBwcm90byA9IGVsZW1lbnQ7IC8vIEluIHRoZSBjYXNlIG9mIGN1c3RvbSBlbGVtZW50cyB0aGVyZSBtaWdodCBiZSBzZXR0ZXJzIG9uIHRoZSBpbnN0YW5jZVxuXHR2YXIgZWxlbWVudF9wcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG5cdC8vIFN0b3AgYXQgRWxlbWVudCwgZnJvbSB0aGVyZSBvbiB0aGVyZSdzIG9ubHkgdW5uZWNlc3Nhcnkgc2V0dGVycyB3ZSdyZSBub3QgaW50ZXJlc3RlZCBpblxuXHQvLyBEbyBub3QgdXNlIGNvbnRydWN0b3IubmFtZSBoZXJlIGFzIHRoYXQncyB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlciBlbnZpcm9ubWVudHNcblx0d2hpbGUgKGVsZW1lbnRfcHJvdG8gIT09IHByb3RvKSB7XG5cdFx0ZGVzY3JpcHRvcnMgPSBnZXRfZGVzY3JpcHRvcnMocHJvdG8pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGRlc2NyaXB0b3JzKSB7XG5cdFx0XHRpZiAoZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcblx0XHRcdFx0c2V0dGVycy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHByb3RvKTtcblx0fVxuXG5cdHJldHVybiBzZXR0ZXJzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tfc3JjX2luX2Rldl9oeWRyYXRpb24oZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRpZiAoIURFVikgcmV0dXJuO1xuXHRpZiAoYXR0cmlidXRlID09PSAnc3Jjc2V0JyAmJiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnQsIHZhbHVlKSkgcmV0dXJuO1xuXHRpZiAoc3JjX3VybF9lcXVhbChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpID8/ICcnLCB2YWx1ZSkpIHJldHVybjtcblxuXHR3Lmh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZChcblx0XHRhdHRyaWJ1dGUsXG5cdFx0ZWxlbWVudC5vdXRlckhUTUwucmVwbGFjZShlbGVtZW50LmlubmVySFRNTCwgZWxlbWVudC5pbm5lckhUTUwgJiYgJy4uLicpLFxuXHRcdFN0cmluZyh2YWx1ZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcblx0aWYgKGVsZW1lbnRfc3JjID09PSB1cmwpIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gbmV3IFVSTChlbGVtZW50X3NyYywgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZiA9PT0gbmV3IFVSTCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWY7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0ICovXG5mdW5jdGlvbiBzcGxpdF9zcmNzZXQoc3Jjc2V0KSB7XG5cdHJldHVybiBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYykgPT4gc3JjLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU291cmNlRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnQsIHNyY3NldCkge1xuXHR2YXIgZWxlbWVudF91cmxzID0gc3BsaXRfc3Jjc2V0KGVsZW1lbnQuc3Jjc2V0KTtcblx0dmFyIHVybHMgPSBzcGxpdF9zcmNzZXQoc3Jjc2V0KTtcblxuXHRyZXR1cm4gKFxuXHRcdHVybHMubGVuZ3RoID09PSBlbGVtZW50X3VybHMubGVuZ3RoICYmXG5cdFx0dXJscy5ldmVyeShcblx0XHRcdChbdXJsLCB3aWR0aF0sIGkpID0+XG5cdFx0XHRcdHdpZHRoID09PSBlbGVtZW50X3VybHNbaV1bMV0gJiZcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGJvdGggd2F5cyBiZWNhdXNlIFZpdGUgd2lsbCBjcmVhdGUgYW4gYSBmdWxsIFVSTCB3aXRoXG5cdFx0XHRcdC8vIGBuZXcgVVJMKGFzc2V0LCBpbXBvcnQubWV0YS51cmwpLmhyZWZgIGZvciB0aGUgY2xpZW50IHdoZW4gYGJhc2U6ICcuLydgLCBhbmQgdGhlXG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTHMgaW5zaWRlIHNyY3NldCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgVVJMcyBieVxuXHRcdFx0XHQvLyBicm93c2VycyAoaW4gY29udHJhc3QgdG8gaW1nLnNyYykuIFRoaXMgbWVhbnMgYm90aCBTU1IgYW5kIERPTSBjb2RlIGNvdWxkXG5cdFx0XHRcdC8vIGNvbnRhaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMcy5cblx0XHRcdFx0KHNyY191cmxfZXF1YWwoZWxlbWVudF91cmxzW2ldWzBdLCB1cmwpIHx8IHNyY191cmxfZXF1YWwodXJsLCBlbGVtZW50X3VybHNbaV1bMF0pKVxuXHRcdClcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX2xhenlfaW1nKGVsZW1lbnQpIHtcblx0Ly8gSWYgd2UncmUgdXNpbmcgYW4gaW1hZ2UgdGhhdCBoYXMgYSBsYXp5IGxvYWRpbmcgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIGFwcGx5XG5cdC8vIHRoZSBsb2FkaW5nIGFuZCBzcmMgYWZ0ZXIgdGhlIGltZyBlbGVtZW50IGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudC5cblx0Ly8gT3RoZXJ3aXNlIHRoZSBsYXp5IGJlaGF2aW91ciB3aWxsIG5vdCB3b3JrIGR1ZSB0byBvdXIgY2xvbmVOb2RlIGhldXJpc3RpYyBmb3Jcblx0Ly8gdGVtcGxhdGVzLlxuXHRpZiAoIWh5ZHJhdGluZyAmJiBlbGVtZW50LmxvYWRpbmcgPT09ICdsYXp5Jykge1xuXHRcdHZhciBzcmMgPSBlbGVtZW50LnNyYztcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudFtMT0FESU5HX0FUVFJfU1lNQk9MXSA9IG51bGw7XG5cdFx0ZWxlbWVudC5sb2FkaW5nID0gJ2VhZ2VyJztcblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGlmIChlbGVtZW50W0xPQURJTkdfQVRUUl9TWU1CT0xdICE9PSAnZWFnZXInKSB7XG5cdFx0XHRcdGVsZW1lbnQubG9hZGluZyA9ICdsYXp5Jztcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQuc3JjID0gc3JjO1xuXHRcdH0pO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT09ICcnKSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWF0aE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X21hdGhtbF9jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT09ICcnKSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5jbGFzc05hbWUgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uY2xhc3NOYW1lICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdC8vIFJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgd2hlbiB0aGUgdmFsdWUgaXMgb25seSBhbiBlbXB0eSBzdHJpbmcgY2F1c2VzXG5cdFx0Ly8gcGVmb3JtYW5jZSBpc3N1ZXMgdnMgc2ltcGx5IG1ha2luZyB0aGUgY2xhc3NOYW1lIGFuIGVtcHR5IHN0cmluZy4gU29cblx0XHQvLyB3ZSBzaG91bGQgb25seSByZW1vdmUgdGhlIGNsYXNzIGlmIHRoZSB0aGUgdmFsdWUgaXMgbnVsbGlzaC5cblx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaGFzaCkge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLmNsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0XHR9XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBWfVxuICovXG5mdW5jdGlvbiB0b19jbGFzcyh2YWx1ZSwgaGFzaCkge1xuXHRyZXR1cm4gKHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKSArIChoYXNoID8gJyAnICsgaGFzaCA6ICcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzX25hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGRvbSwgY2xhc3NfbmFtZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlKSB7XG5cdFx0aWYgKGRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NfbmFtZSkpIHJldHVybjtcblx0XHRkb20uY2xhc3NMaXN0LmFkZChjbGFzc19uYW1lKTtcblx0fSBlbHNlIHtcblx0XHRpZiAoIWRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NfbmFtZSkpIHJldHVybjtcblx0XHRkb20uY2xhc3NMaXN0LnJlbW92ZShjbGFzc19uYW1lKTtcblx0fVxufVxuIiwiaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyByZW5kZXJfZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50IH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi8uLi8uLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi8uLi8uLi9wcm94eS5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi8uLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgaXNfcnVuZXMsIHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3ZhbHVlKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgcnVuZXMgPSBpc19ydW5lcygpO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdpbnB1dCcsIChpc19yZXNldCkgPT4ge1xuXHRcdGlmIChERVYgJiYgaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLmJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdC8qKiBAdHlwZSB7YW55fSAqL1xuXHRcdHZhciB2YWx1ZSA9IGlzX3Jlc2V0ID8gaW5wdXQuZGVmYXVsdFZhbHVlIDogaW5wdXQudmFsdWU7XG5cdFx0dmFsdWUgPSBpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSA/IHRvX251bWJlcih2YWx1ZSkgOiB2YWx1ZTtcblx0XHRzZXQodmFsdWUpO1xuXG5cdFx0Ly8gSW4gcnVuZXMgbW9kZSwgcmVzcGVjdCBhbnkgdmFsaWRhdGlvbiBpbiBhY2Nlc3NvcnMgKGRvZXNuJ3QgYXBwbHkgaW4gbGVnYWN5IG1vZGUsXG5cdFx0Ly8gYmVjYXVzZSB3ZSB1c2UgbXV0YWJsZSBzdGF0ZSB3aGljaCBlbnN1cmVzIHRoZSByZW5kZXIgZWZmZWN0IGFsd2F5cyBydW5zKVxuXHRcdGlmIChydW5lcyAmJiB2YWx1ZSAhPT0gKHZhbHVlID0gZ2V0KCkpKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcblx0XHRcdHZhciBlbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG5cblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBjb2VyY2VkIG9uIGFzc2lnbm1lbnRcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWUgPz8gJyc7XG5cblx0XHRcdC8vIFJlc3RvcmUgc2VsZWN0aW9uXG5cdFx0XHRpZiAoZW5kICE9PSBudWxsKSB7XG5cdFx0XHRcdGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHQoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRWYWx1ZSAhPT0gaW5wdXQudmFsdWUpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdFZhbHVlIGlzIHNldCwgdGhlbiB2YWx1ZSA9PSBkZWZhdWx0VmFsdWVcblx0XHQvLyBUT0RPIFN2ZWx0ZSA2OiByZW1vdmUgaW5wdXQudmFsdWUgY2hlY2sgYW5kIHNldCB0byBlbXB0eSBzdHJpbmc/XG5cdFx0KHVudHJhY2soZ2V0KSA9PSBudWxsICYmIGlucHV0LnZhbHVlKVxuXHQpIHtcblx0XHRzZXQoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIoaW5wdXQudmFsdWUpIDogaW5wdXQudmFsdWUpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKERFViAmJiBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHRpZiAoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgJiYgdmFsdWUgPT09IHRvX251bWJlcihpbnB1dC52YWx1ZSkpIHtcblx0XHRcdC8vIGhhbmRsZXMgMCB2cyAwMCBjYXNlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvOTk1OSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoaW5wdXQudHlwZSA9PT0gJ2RhdGUnICYmICF2YWx1ZSAmJiAhaW5wdXQudmFsdWUpIHtcblx0XHRcdC8vIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSB0ZW1wb3JhcmlseSBpbnZhbGlkIGRhdGUgaXMgc2V0ICh3aGlsZSB0eXBpbmcsIGZvciBleGFtcGxlIHdpdGggYSBsZWFkaW5nIDAgZm9yIHRoZSBkYXkpXG5cdFx0XHQvLyBhbmQgcHJldmVudHMgdGhpcyBzdGF0ZSBmcm9tIGNsZWFyaW5nIHRoZSBvdGhlciBwYXJ0cyBvZiB0aGUgZGF0ZSBpbnB1dCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzc4OTcpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3Qgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaWYgaXQncyB0aGUgc2FtZSB0byBhbGxvd1xuXHRcdC8vIG1pbmxlbmd0aCB0byB3b3JrIHByb3Blcmx5XG5cdFx0aWYgKHZhbHVlICE9PSBpbnB1dC52YWx1ZSkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdmFsdWUgaXMgY29lcmNlZCBvbiBhc3NpZ25tZW50XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlID8/ICcnO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKiBAdHlwZSB7U2V0PEhUTUxJbnB1dEVsZW1lbnRbXT59ICovXG5jb25zdCBwZW5kaW5nID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudFtdfSBpbnB1dHNcbiAqIEBwYXJhbSB7bnVsbCB8IFtudW1iZXJdfSBncm91cF9pbmRleFxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ncm91cChpbnB1dHMsIGdyb3VwX2luZGV4LCBpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGlzX2NoZWNrYm94ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdjaGVja2JveCc7XG5cdHZhciBiaW5kaW5nX2dyb3VwID0gaW5wdXRzO1xuXG5cdC8vIG5lZWRzIHRvIGJlIGxldCBvciByZWxhdGVkIGNvZGUgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgaWYgaXQncyBhbHdheXMgZmFsc2Vcblx0bGV0IGh5ZHJhdGlvbl9taXNtYXRjaCA9IGZhbHNlO1xuXG5cdGlmIChncm91cF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGluZGV4IG9mIGdyb3VwX2luZGV4KSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRiaW5kaW5nX2dyb3VwID0gYmluZGluZ19ncm91cFtpbmRleF0gPz89IFtdO1xuXHRcdH1cblx0fVxuXG5cdGJpbmRpbmdfZ3JvdXAucHVzaChpbnB1dCk7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChcblx0XHRpbnB1dCxcblx0XHQnY2hhbmdlJyxcblx0XHQoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC5fX3ZhbHVlO1xuXG5cdFx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfYmluZGluZ19ncm91cF92YWx1ZShiaW5kaW5nX2dyb3VwLCB2YWx1ZSwgaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHR9XG5cblx0XHRcdHNldCh2YWx1ZSk7XG5cdFx0fSxcblx0XHQvLyBUT0RPIGJldHRlciBkZWZhdWx0IHZhbHVlIGhhbmRsaW5nXG5cdFx0KCkgPT4gc2V0KGlzX2NoZWNrYm94ID8gW10gOiBudWxsKVxuXHQpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLCB0aGVuIHVzZSB0aGUgdXBkYXRlIHZhbHVlXG5cdFx0Ly8gZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHRpZiAoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRDaGVja2VkICE9PSBpbnB1dC5jaGVja2VkKSB7XG5cdFx0XHRoeWRyYXRpb25fbWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBbXTtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGlucHV0LmNoZWNrZWQgPSB2YWx1ZS5pbmNsdWRlcyhpbnB1dC5fX3ZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IGlzKGlucHV0Ll9fdmFsdWUsIHZhbHVlKTtcblx0XHR9XG5cdH0pO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHR2YXIgaW5kZXggPSBiaW5kaW5nX2dyb3VwLmluZGV4T2YoaW5wdXQpO1xuXG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0YmluZGluZ19ncm91cC5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKCFwZW5kaW5nLmhhcyhiaW5kaW5nX2dyb3VwKSkge1xuXHRcdHBlbmRpbmcuYWRkKGJpbmRpbmdfZ3JvdXApO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHQvLyBuZWNlc3NhcnkgdG8gbWFpbnRhaW4gYmluZGluZyBncm91cCBvcmRlciBpbiBhbGwgaW5zZXJ0aW9uIHNjZW5hcmlvc1xuXHRcdFx0YmluZGluZ19ncm91cC5zb3J0KChhLCBiKSA9PiAoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA9PT0gNCA/IC0xIDogMSkpO1xuXHRcdFx0cGVuZGluZy5kZWxldGUoYmluZGluZ19ncm91cCk7XG5cdFx0fSk7XG5cdH1cblxuXHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW9uX21pc21hdGNoKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cblx0XHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGJpbmRpbmdfZ3JvdXAsIHZhbHVlLCBpbnB1dC5jaGVja2VkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoeWRyYXRpb25faW5wdXQgPSBiaW5kaW5nX2dyb3VwLmZpbmQoKGlucHV0KSA9PiBpbnB1dC5jaGVja2VkKTtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHR2YWx1ZSA9IGh5ZHJhdGlvbl9pbnB1dD8uX192YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0c2V0KHZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfY2hlY2tlZChpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2NoYW5nZScsIChpc19yZXNldCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGlzX3Jlc2V0ID8gaW5wdXQuZGVmYXVsdENoZWNrZWQgOiBpbnB1dC5jaGVja2VkO1xuXHRcdHNldCh2YWx1ZSk7XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdENoZWNrZWQgIT09IGlucHV0LmNoZWNrZWQpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdENoZWNrZWQgaXMgc2V0LCB0aGVuIGNoZWNrZWQgPT0gZGVmYXVsdENoZWNrZWRcblx0XHR1bnRyYWNrKGdldCkgPT0gbnVsbFxuXHQpIHtcblx0XHRzZXQoaW5wdXQuY2hlY2tlZCk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblx0XHRpbnB1dC5jaGVja2VkID0gQm9vbGVhbih2YWx1ZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0FycmF5PEhUTUxJbnB1dEVsZW1lbnQ+fSBncm91cFxuICogQHBhcmFtIHtWfSBfX3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqIEByZXR1cm5zIHtWW119XG4gKi9cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG5cdHZhciB2YWx1ZSA9IG5ldyBTZXQoKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSB7XG5cdHZhciB0eXBlID0gaW5wdXQudHlwZTtcblx0cmV0dXJuIHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IEZpbGVMaXN0IHwgbnVsbH0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogRmlsZUxpc3QgfCBudWxsKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZmlsZXMoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0c2V0KGlucHV0LmZpbGVzKTtcblx0fSk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aW5wdXQuZmlsZXMgPSBnZXQoKTtcblx0fSk7XG59XG4iLCJpbXBvcnQgeyBTVEFURV9TWU1CT0wgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZWZmZWN0LCByZW5kZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi8uLi90YXNrLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYm91bmRfdmFsdWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudF9vcl9jb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc19ib3VuZF90aGlzKGJvdW5kX3ZhbHVlLCBlbGVtZW50X29yX2NvbXBvbmVudCkge1xuXHRyZXR1cm4gKFxuXHRcdGJvdW5kX3ZhbHVlID09PSBlbGVtZW50X29yX2NvbXBvbmVudCB8fCBib3VuZF92YWx1ZT8uW1NUQVRFX1NZTUJPTF0gPT09IGVsZW1lbnRfb3JfY29tcG9uZW50XG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGVsZW1lbnRfb3JfY29tcG9uZW50XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93biwgLi4ucGFydHM6IHVua25vd25bXSkgPT4gdm9pZH0gdXBkYXRlXG4gKiBAcGFyYW0geyguLi5wYXJ0czogdW5rbm93bltdKSA9PiB1bmtub3dufSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bltdfSBbZ2V0X3BhcnRzXSBTZXQgaWYgdGhlIHRoaXMgYmluZGluZyBpcyB1c2VkIGluc2lkZSBhbiBlYWNoIGJsb2NrLFxuICogXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5zIGFsbCB0aGUgcGFydHMgb2YgdGhlIGVhY2ggYmxvY2sgY29udGV4dCB0aGF0IGFyZSB1c2VkIGluIHRoZSBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfdGhpcyhlbGVtZW50X29yX2NvbXBvbmVudCA9IHt9LCB1cGRhdGUsIGdldF92YWx1ZSwgZ2V0X3BhcnRzKSB7XG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0LyoqIEB0eXBlIHt1bmtub3duW119ICovXG5cdFx0dmFyIG9sZF9wYXJ0cztcblxuXHRcdC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuXHRcdHZhciBwYXJ0cztcblxuXHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0b2xkX3BhcnRzID0gcGFydHM7XG5cdFx0XHQvLyBXZSBvbmx5IHRyYWNrIGNoYW5nZXMgdG8gdGhlIHBhcnRzLCBub3QgdGhlIHZhbHVlIGl0c2VsZiB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZXJ1bnMuXG5cdFx0XHRwYXJ0cyA9IGdldF9wYXJ0cz8uKCkgfHwgW107XG5cblx0XHRcdHVudHJhY2soKCkgPT4ge1xuXHRcdFx0XHRpZiAoZWxlbWVudF9vcl9jb21wb25lbnQgIT09IGdldF92YWx1ZSguLi5wYXJ0cykpIHtcblx0XHRcdFx0XHR1cGRhdGUoZWxlbWVudF9vcl9jb21wb25lbnQsIC4uLnBhcnRzKTtcblx0XHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGVmZmVjdCByZXJ1biAoY2F1c2U6IGVhY2ggYmxvY2sgY29udGV4dCBjaGFuZ2VzKSwgdGhlbiBudWxsZml5IHRoZSBiaW5kaW5nIGF0XG5cdFx0XHRcdFx0Ly8gdGhlIHByZXZpb3VzIHBvc2l0aW9uIGlmIGl0IGlzbid0IGFscmVhZHkgdGFrZW4gb3ZlciBieSBhIGRpZmZlcmVudCBlZmZlY3QuXG5cdFx0XHRcdFx0aWYgKG9sZF9wYXJ0cyAmJiBpc19ib3VuZF90aGlzKGdldF92YWx1ZSguLi5vbGRfcGFydHMpLCBlbGVtZW50X29yX2NvbXBvbmVudCkpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShudWxsLCAuLi5vbGRfcGFydHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Ly8gV2UgY2Fubm90IHVzZSBlZmZlY3RzIGluIHRoZSB0ZWFyZG93biBwaGFzZSwgd2Ugd2UgdXNlIGEgbWljcm90YXNrIGluc3RlYWQuXG5cdFx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdFx0aWYgKHBhcnRzICYmIGlzX2JvdW5kX3RoaXMoZ2V0X3ZhbHVlKC4uLnBhcnRzKSwgZWxlbWVudF9vcl9jb21wb25lbnQpKSB7XG5cdFx0XHRcdFx0dXBkYXRlKG51bGwsIC4uLnBhcnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRfb3JfY29tcG9uZW50O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0TGVnYWN5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJ1biwgcnVuX2FsbCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgeyB1c2VyX3ByZV9lZmZlY3QsIHVzZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBkZWVwX3JlYWRfc3RhdGUsIGdldCwgdW50cmFjayB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIExlZ2FjeS1tb2RlIG9ubHk6IENhbGwgYG9uTW91bnRgIGNhbGxiYWNrcyBhbmQgc2V0IHVwIGBiZWZvcmVVcGRhdGVgL2BhZnRlclVwZGF0ZWAgZWZmZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChpbW11dGFibGUgPSBmYWxzZSkge1xuXHRjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbnRleHQubC51O1xuXHRpZiAoIWNhbGxiYWNrcykgcmV0dXJuO1xuXG5cdGxldCBwcm9wcyA9ICgpID0+IGRlZXBfcmVhZF9zdGF0ZShjb250ZXh0LnMpO1xuXG5cdGlmIChpbW11dGFibGUpIHtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0bGV0IHByZXYgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cblx0XHQvLyBJbiBsZWdhY3kgaW1tdXRhYmxlIG1vZGUsIGJlZm9yZS9hZnRlclVwZGF0ZSBvbmx5IGZpcmUgaWYgdGhlIG9iamVjdCBpZGVudGl0eSBvZiBhIHByb3AgY2hhbmdlc1xuXHRcdGNvbnN0IGQgPSBkZXJpdmVkKCgpID0+IHtcblx0XHRcdGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGNvbnRleHQucztcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wc1trZXldICE9PSBwcmV2W2tleV0pIHtcblx0XHRcdFx0XHRwcmV2W2tleV0gPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hhbmdlZCkgdmVyc2lvbisrO1xuXHRcdFx0cmV0dXJuIHZlcnNpb247XG5cdFx0fSk7XG5cblx0XHRwcm9wcyA9ICgpID0+IGdldChkKTtcblx0fVxuXG5cdC8vIGJlZm9yZVVwZGF0ZVxuXHRpZiAoY2FsbGJhY2tzLmIubGVuZ3RoKSB7XG5cdFx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmIpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gb25Nb3VudCAobXVzdCBydW4gYmVmb3JlIGFmdGVyVXBkYXRlKVxuXHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgZm5zID0gdW50cmFjaygoKSA9PiBjYWxsYmFja3MubS5tYXAocnVuKSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gYWZ0ZXJVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5hLmxlbmd0aCkge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmEpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogSW52b2tlIHRoZSBnZXR0ZXIgb2YgYWxsIHNpZ25hbHMgYXNzb2NpYXRlZCB3aXRoIGEgY29tcG9uZW50XG4gKiBzbyB0aGV5IGNhbiBiZSByZWdpc3RlcmVkIHRvIHRoZSBlZmZlY3QgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4uXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRMZWdhY3l9IGNvbnRleHRcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBwcm9wc1xuICovXG5mdW5jdGlvbiBvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcykge1xuXHRpZiAoY29udGV4dC5sLnMpIHtcblx0XHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBjb250ZXh0LmwucykgZ2V0KHNpZ25hbCk7XG5cdH1cblxuXHRwcm9wcygpO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBDb21wb25lbnRDb250ZXh0TGVnYWN5IH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9pbmRleC5qcycgKi9cbi8qKiBAaW1wb3J0IHsgTm90RnVuY3Rpb24gfSBmcm9tICcuL2ludGVybmFsL3R5cGVzLmpzJyAqL1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGZsdXNoX3N5bmMsIHVudHJhY2sgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9ydW50aW1lLmpzJztcbmltcG9ydCB7IGlzX2FycmF5IH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgdXNlcl9lZmZlY3QgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQgfSBmcm9tICcuL2ludGVybmFsL3NoYXJlZC9lcnJvcnMuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4vaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRzXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvc3ZlbHRlLXNlcnZlciNyZW5kZXIpLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IE5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxOb3RGdW5jdGlvbjxUPj4gfCAoKCkgPT4gYW55KX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Nb3VudChmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uTW91bnQnKTtcblx0fVxuXG5cdGlmIChsZWdhY3lfbW9kZV9mbGFnICYmIGNvbXBvbmVudF9jb250ZXh0LmwgIT09IG51bGwpIHtcblx0XHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLm0ucHVzaChmbik7XG5cdH0gZWxzZSB7XG5cdFx0dXNlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2xlYW51cCA9IHVudHJhY2soZm4pO1xuXHRcdFx0aWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSByZXR1cm4gLyoqIEB0eXBlIHsoKSA9PiB2b2lkfSAqLyAoY2xlYW51cCk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uRGVzdHJveScpO1xuXHR9XG5cblx0b25Nb3VudCgoKSA9PiAoKSA9PiB1bnRyYWNrKGZuKSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge2FueX1wYXJhbXNfMFxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL2xlZ2FjeS1vbiNDb21wb25lbnQtZXZlbnRzKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBuZXZlcjsgLy8gZG9lcyBub3QgdGFrZSBhIGRldGFpbCBhcmd1bWVudFxuICogIGNoYW5nZTogc3RyaW5nOyAvLyB0YWtlcyBhIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZywgd2hpY2ggaXMgcmVxdWlyZWRcbiAqICBvcHRpb25hbDogbnVtYmVyIHwgbnVsbDsgLy8gdGFrZXMgYW4gb3B0aW9uYWwgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgbnVtYmVyXG4gKiB9PigpO1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGNhbGxiYWNrIHByb3BzIGFuZC9vciB0aGUgYCRob3N0KClgIHJ1bmUgaW5zdGVhZCDigJQgc2VlIFttaWdyYXRpb24gZ3VpZGVdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS92NS1taWdyYXRpb24tZ3VpZGUjRXZlbnQtY2hhbmdlcy1Db21wb25lbnQtZXZlbnRzKVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRNYXAgPSBhbnldXG4gKiBAcmV0dXJucyB7RXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdGlmIChhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2NyZWF0ZUV2ZW50RGlzcGF0Y2hlcicpO1xuXHR9XG5cblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpID0+IHtcblx0XHRjb25zdCBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uIHwgRnVuY3Rpb25bXT59ICovIChcblx0XHRcdGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC5zLiQkZXZlbnRzXG5cdFx0KT8uWy8qKiBAdHlwZSB7YW55fSAqLyAodHlwZSldO1xuXG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogW2V2ZW50c107XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGNyZWF0ZV9jdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCBvcHRpb25zKTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLy8gVE9ETyBtYXJrIGJlZm9yZVVwZGF0ZSBhbmQgYWZ0ZXJVcGRhdGUgYXMgZGVwcmVjYXRlZCBpbiBTdmVsdGUgNlxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0LnByZWAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0LnByZWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0IyRlZmZlY3QucHJlKSBpbnN0ZWFkXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2JlZm9yZVVwZGF0ZScpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9sZWdhY3lfb25seSgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmIucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YC5cbiAqXG4gKiBJbiBydW5lcyBtb2RlIHVzZSBgJGVmZmVjdGAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpIGluc3RlYWRcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdhZnRlclVwZGF0ZScpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9sZWdhY3lfb25seSgnYWZ0ZXJVcGRhdGUnKTtcblx0fVxuXG5cdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkuYS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBMZWdhY3ktbW9kZTogSW5pdCBjYWxsYmFja3Mgb2JqZWN0IGZvciBvbk1vdW50L2JlZm9yZVVwZGF0ZS9hZnRlclVwZGF0ZVxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb250ZXh0KSB7XG5cdHZhciBsID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29udGV4dCkubDtcblx0cmV0dXJuIChsLnUgPz89IHsgYTogW10sIGI6IFtdLCBtOiBbXSB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGZsdXNoZXMgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBhbmQgdGhvc2UgdGhhdCByZXN1bHQgZnJvbSBpdC5cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2ZuXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcblx0Zmx1c2hfc3luYyhmbik7XG59XG5cbmV4cG9ydCB7IGh5ZHJhdGUsIG1vdW50LCB1bm1vdW50IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzJztcblxuZXhwb3J0IHtcblx0Z2V0Q29udGV4dCxcblx0Z2V0QWxsQ29udGV4dHMsXG5cdGhhc0NvbnRleHQsXG5cdHNldENvbnRleHQsXG5cdHRpY2ssXG5cdHVudHJhY2tcbn0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5cbmV4cG9ydCB7IGNyZWF0ZVJhd1NuaXBwZXQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3NuaXBwZXQuanMnO1xuIiwiLyoqIEBpbXBvcnQgeyBTdG9yZVJlZmVyZW5jZXNDb250YWluZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBTdG9yZSB9IGZyb20gJyNzaGFyZWQnICovXG5pbXBvcnQgeyBzdWJzY3JpYmVfdG9fc3RvcmUgfSBmcm9tICcuLi8uLi8uLi9zdG9yZS91dGlscy5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbXV0YWJsZV9zb3VyY2UsIHNldCB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHByb3AgY3VycmVudGx5IGJlaW5nIHJlYWQgaXMgYSBzdG9yZSBiaW5kaW5nLCBhcyBpblxuICogYDxDaGlsZCBiaW5kOng9eyR5fSAvPmAuIElmIGl0IGlzLCB3ZSB0cmVhdCB0aGUgcHJvcCBhcyBtdXRhYmxlIGV2ZW4gaW5cbiAqIHJ1bmVzIG1vZGUsIGFuZCBza2lwIGBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAgdmFsaWRhdGlvblxuICovXG5sZXQgaXNfc3RvcmVfYmluZGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdG9yZS4gSWYgdGhlIHN0b3JlIGlzbid0IHN1YnNjcmliZWQgdG8geWV0LCBpdCB3aWxsIGNyZWF0ZSBhIHByb3h5XG4gKiBzaWduYWwgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGUgc3RvcmUgaXMuIFRoZSBzdG9yZSByZWZlcmVuY2VzIGNvbnRhaW5lciBpcyBuZWVkZWQgdG9cbiAqIHRyYWNrIHJlYXNzaWdubWVudHMgdG8gc3RvcmVzIGFuZCB0byB0cmFjayB0aGUgY29ycmVjdCBjb21wb25lbnQgY29udGV4dC5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2dldChzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdGNvbnN0IGVudHJ5ID0gKHN0b3Jlc1tzdG9yZV9uYW1lXSA/Pz0ge1xuXHRcdHN0b3JlOiBudWxsLFxuXHRcdHNvdXJjZTogbXV0YWJsZV9zb3VyY2UodW5kZWZpbmVkKSxcblx0XHR1bnN1YnNjcmliZTogbm9vcFxuXHR9KTtcblxuXHRpZiAoZW50cnkuc3RvcmUgIT09IHN0b3JlKSB7XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS5zdG9yZSA9IHN0b3JlID8/IG51bGw7XG5cblx0XHRpZiAoc3RvcmUgPT0gbnVsbCkge1xuXHRcdFx0ZW50cnkuc291cmNlLnYgPSB1bmRlZmluZWQ7IC8vIHNlZSBzeW5jaHJvbm91cyBjYWxsYmFjayBjb21tZW50IGJlbG93XG5cdFx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBpc19zeW5jaHJvbm91c19jYWxsYmFjayA9IHRydWU7XG5cblx0XHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAodikgPT4ge1xuXHRcdFx0XHRpZiAoaXNfc3luY2hyb25vdXNfY2FsbGJhY2spIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgZmlyc3QgdXBkYXRlcyB0byB0aGUgc3RvcmUgdmFsdWUgKHBvc3NpYmx5IG11bHRpcGxlIG9mIHRoZW0pIGFyZSBzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0Ly8gaW5zaWRlIGEgZGVyaXZlZCwgd2Ugd2lsbCBoaXQgdGhlIGBzdGF0ZV91bnNhZmVfbXV0YXRpb25gIGVycm9yIGlmIHdlIGBzZXRgIHRoZSB2YWx1ZVxuXHRcdFx0XHRcdGVudHJ5LnNvdXJjZS52ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXQoZW50cnkuc291cmNlLCB2KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGdldChlbnRyeS5zb3VyY2UpO1xufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBpZiBpdCdzIG5vdCB0aGUgc2FtZSBhcyB0aGUgb25lIGluIHRoZSBzdG9yZSByZWZlcmVuY2VzIGNvbnRhaW5lci5cbiAqIFdlIG5lZWQgdGhpcyBpbiBhZGRpdGlvbiB0byBgc3RvcmVfZ2V0YCBiZWNhdXNlIHNvbWVvbmUgY291bGQgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGJ1dFxuICogdGhlbiBuZXZlciBzdWJzY3JpYmUgdG8gdGhlIG5ldyBvbmUgKGlmIGFueSksIGNhdXNpbmcgdGhlIHN1YnNjcmlwdGlvbiB0byBzdGF5IG9wZW4gd3JvbmdmdWxseS5cbiAqIEBwYXJhbSB7U3RvcmU8YW55PiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9IHN0b3Jlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfdW5zdWIoc3RvcmUsIHN0b3JlX25hbWUsIHN0b3Jlcykge1xuXHQvKiogQHR5cGUge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lclsnJ10gfCB1bmRlZmluZWR9ICovXG5cdGxldCBlbnRyeSA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblxuXHRpZiAoZW50cnkgJiYgZW50cnkuc3RvcmUgIT09IHN0b3JlKSB7XG5cdFx0Ly8gRG9uJ3QgcmVzZXQgc3RvcmUgeWV0LCBzbyB0aGF0IHN0b3JlX2dldCBhYm92ZSBjYW4gcmVzdWJzY3JpYmUgdG8gbmV3IHN0b3JlIGlmIG5lY2Vzc2FyeVxuXHRcdGVudHJ5LnVuc3Vic2NyaWJlKCk7XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUgPSBub29wO1xuXHR9XG5cblx0cmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG5ldyB2YWx1ZSBvZiBhIHN0b3JlIGFuZCByZXR1cm5zIHRoYXQgdmFsdWUuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTdG9yZTxWPn0gc3RvcmVcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfc2V0KHN0b3JlLCB2YWx1ZSkge1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9IHN0b3Jlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVfc3RvcmUoc3RvcmVzLCBzdG9yZV9uYW1lKSB7XG5cdHZhciBlbnRyeSA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblx0aWYgKGVudHJ5LnN0b3JlICE9PSBudWxsKSB7XG5cdFx0c3RvcmVfc2V0KGVudHJ5LnN0b3JlLCBlbnRyeS5zb3VyY2Uudik7XG5cdH1cbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZXMgZnJvbSBhbGwgYXV0by1zdWJzY3JpYmVkIHN0b3JlcyBvbiBkZXN0cm95XG4gKiBAcmV0dXJucyB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBfc3RvcmVzKCkge1xuXHQvKiogQHR5cGUge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gKi9cblx0Y29uc3Qgc3RvcmVzID0ge307XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdGZvciAodmFyIHN0b3JlX25hbWUgaW4gc3RvcmVzKSB7XG5cdFx0XHRjb25zdCByZWYgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cdFx0XHRyZWYudW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBzdG9yZXM7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHN0b3JlIHdpdGggYSBuZXcgdmFsdWUuXG4gKiBAcGFyYW0ge1N0b3JlPFY+fSBzdG9yZSAgdGhlIHN0b3JlIHRvIHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IGV4cHJlc3Npb24gIHRoZSBleHByZXNzaW9uIHRoYXQgbXV0YXRlcyB0aGUgc3RvcmVcbiAqIEBwYXJhbSB7Vn0gbmV3X3ZhbHVlICB0aGUgbmV3IHN0b3JlIHZhbHVlXG4gKiBAdGVtcGxhdGUgVlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfbXV0YXRlKHN0b3JlLCBleHByZXNzaW9uLCBuZXdfdmFsdWUpIHtcblx0c3RvcmUuc2V0KG5ld192YWx1ZSk7XG5cdHJldHVybiBleHByZXNzaW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmU8bnVtYmVyPn0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdG9yZV92YWx1ZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zdG9yZShzdG9yZSwgc3RvcmVfdmFsdWUsIGQgPSAxKSB7XG5cdHN0b3JlLnNldChzdG9yZV92YWx1ZSArIGQpO1xuXHRyZXR1cm4gc3RvcmVfdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0b3JlX3ZhbHVlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3ByZV9zdG9yZShzdG9yZSwgc3RvcmVfdmFsdWUsIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gc3RvcmVfdmFsdWUgKyBkO1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBwcm9wIGdldHRlcnMgdG8gY29tbXVuaWNhdGUgdGhhdCB0aGUgcHJvcCBpcyBhIHN0b3JlIGJpbmRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtfc3RvcmVfYmluZGluZygpIHtcblx0aXNfc3RvcmVfYmluZGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHR1cGxlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYGZuKClgIHJlYWRzIGEgcHJvcCB0aGF0IGlzIGEgc3RvcmUgYmluZGluZy5cbiAqIFVzZWQgdG8gcHJldmVudCBgYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgIHZhbGlkYXRpb24gZmFsc2UgcG9zaXRpdmVzIGFuZFxuICogZW5zdXJlIHRoYXQgdGhlc2UgcHJvcHMgYXJlIHRyZWF0ZWQgYXMgbXV0YWJsZSBldmVuIGluIHJ1bmVzIG1vZGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7W1QsIGJvb2xlYW5dfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZV9zdG9yZV9iaW5kaW5nKGZuKSB7XG5cdHZhciBwcmV2aW91c19pc19zdG9yZV9iaW5kaW5nID0gaXNfc3RvcmVfYmluZGluZztcblxuXHR0cnkge1xuXHRcdGlzX3N0b3JlX2JpbmRpbmcgPSBmYWxzZTtcblx0XHRyZXR1cm4gW2ZuKCksIGlzX3N0b3JlX2JpbmRpbmddO1xuXHR9IGZpbmFsbHkge1xuXHRcdGlzX3N0b3JlX2JpbmRpbmcgPSBwcmV2aW91c19pc19zdG9yZV9iaW5kaW5nO1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4vdHlwZXMuanMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdFBST1BTX0lTX0JJTkRBQkxFLFxuXHRQUk9QU19JU19JTU1VVEFCTEUsXG5cdFBST1BTX0lTX0xBWllfSU5JVElBTCxcblx0UFJPUFNfSVNfUlVORVMsXG5cdFBST1BTX0lTX1VQREFURURcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yLCBpc19mdW5jdGlvbiB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBtdXRhYmxlX3NvdXJjZSwgc2V0LCBzb3VyY2UgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCwgZGVyaXZlZF9zYWZlX2VxdWFsIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRnZXQsXG5cdGNhcHR1cmVkX3NpZ25hbHMsXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHR1bnRyYWNrLFxuXHR1cGRhdGVcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBzYWZlX2VxdWFscyB9IGZyb20gJy4vZXF1YWxpdHkuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHtcblx0QlJBTkNIX0VGRkVDVCxcblx0TEVHQUNZX0RFUklWRURfUFJPUCxcblx0TEVHQUNZX1BST1BTLFxuXHRST09UX0VGRkVDVCxcblx0U1RBVEVfU1lNQk9MXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBwcm94eSB9IGZyb20gJy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGNhcHR1cmVfc3RvcmVfYmluZGluZyB9IGZyb20gJy4vc3RvcmUuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygodmFsdWU/OiBudW1iZXIpID0+IG51bWJlcil9IGZuXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKTtcblx0Zm4odmFsdWUgKyBkKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKSArIGQ7XG5cdGZuKHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciByZXN0IHByb3BzIChpLmUuIGBjb25zdCB7IHgsIC4uLnJlc3QgfSA9ICRwcm9wcygpYCkuXG4gKiBJcyBwYXNzZWQgdGhlIGZ1bGwgYCQkcHJvcHNgIG9iamVjdCBhbmQgZXhjbHVkZXMgdGhlIG5hbWVkIHByb3BzLlxuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgbmFtZT86IHN0cmluZyB9Pn19XG4gKi9cbmNvbnN0IHJlc3RfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5wcm9wc19yZXN0X3JlYWRvbmx5KGAke3RhcmdldC5uYW1lfS4ke1N0cmluZyhrZXkpfWApO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUsIG5hbWUpIHtcblx0cmV0dXJuIG5ldyBQcm94eShcblx0XHRERVYgPyB7IHByb3BzLCBleGNsdWRlLCBuYW1lLCBvdGhlcjoge30sIHRvX3Byb3h5OiBbXSB9IDogeyBwcm9wcywgZXhjbHVkZSB9LFxuXHRcdHJlc3RfcHJvcHNfaGFuZGxlclxuXHQpO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciBsZWdhY3kgJCRyZXN0UHJvcHMgYW5kICQkcHJvcHNcbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4sIGV4Y2x1ZGU6IEFycmF5PHN0cmluZyB8IHN5bWJvbD4sIHNwZWNpYWw6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj4sIHZlcnNpb246IFNvdXJjZTxudW1iZXI+IH0+fX1cbiAqL1xuY29uc3QgbGVnYWN5X3Jlc3RfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRnZXQodGFyZ2V0LnZlcnNpb24pO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnNwZWNpYWwgPyB0YXJnZXQuc3BlY2lhbFtrZXldKCkgOiB0YXJnZXQucHJvcHNba2V5XTtcblx0fSxcblx0c2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuXHRcdGlmICghKGtleSBpbiB0YXJnZXQuc3BlY2lhbCkpIHtcblx0XHRcdC8vIEhhbmRsZSBwcm9wcyB0aGF0IGNhbiB0ZW1wb3JhcmlseSBnZXQgb3V0IG9mIHN5bmMgd2l0aCB0aGUgcGFyZW50XG5cdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj59ICovXG5cdFx0XHR0YXJnZXQuc3BlY2lhbFtrZXldID0gcHJvcChcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGdldCBba2V5XSgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0YXJnZXQucHJvcHNba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoa2V5KSxcblx0XHRcdFx0UFJPUFNfSVNfVVBEQVRFRFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0YXJnZXQuc3BlY2lhbFtrZXldKHZhbHVlKTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pOyAvLyAkJHByb3BzIGlzIGNvYXJzZS1ncmFpbmVkOiB3aGVuICQkcHJvcHMueCBpcyB1cGRhdGVkLCB1c2FnZXMgb2YgJCRwcm9wcy55IGV0YyBhcmUgYWxzbyByZXJ1blxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG5cdFx0Ly8gU3ZlbHRlIDQgYWxsb3dlZCBmb3IgZGVsZXRpb25zIG9uICQkcmVzdFByb3BzXG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiB0cnVlO1xuXHRcdHRhcmdldC5leGNsdWRlLnB1c2goa2V5KTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KHsgcHJvcHMsIGV4Y2x1ZGUsIHNwZWNpYWw6IHt9LCB2ZXJzaW9uOiBzb3VyY2UoMCkgfSwgbGVnYWN5X3Jlc3RfcHJvcHNfaGFuZGxlcik7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHNwcmVhZCBwcm9wcy4gSGFuZGxlcyB0aGUgaW5jb21pbmcgYXJyYXkgb2YgcHJvcHNcbiAqIHRoYXQgbG9va3MgbGlrZSBgKCkgPT4geyBkeW5hbWljOiBwcm9wcyB9LCB7IHN0YXRpYzogcHJvcCB9LCAuLmAgYW5kIHdyYXBzXG4gKiB0aGVtIHNvIHRoYXQgdGhlIHdob2xlIHRoaW5nIGlzIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGFzIHRoZSBgJCRwcm9wc2AgYXJndW1lbnQuXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+fSBUXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IEFycmF5PFQgfCAoKCkgPT4gVCk+IH0+fX1cbiAqL1xuY29uc3Qgc3ByZWFkX3Byb3BzX2hhbmRsZXIgPSB7XG5cdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmICh0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCAmJiBrZXkgaW4gcCkgcmV0dXJuIHBba2V5XTtcblx0XHR9XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRjb25zdCBkZXNjID0gZ2V0X2Rlc2NyaXB0b3IocCwga2V5KTtcblx0XHRcdGlmIChkZXNjICYmIGRlc2Muc2V0KSB7XG5cdFx0XHRcdGRlc2Muc2V0KHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsICYmIGtleSBpbiBwKSB7XG5cdFx0XHRcdGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRfZGVzY3JpcHRvcihwLCBrZXkpO1xuXHRcdFx0XHRpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHQvLyBQcmV2ZW50IGEgXCJOb24tY29uZmlndXJhYmlsaXR5IFJlcG9ydCBFcnJvclwiOiBUaGUgdGFyZ2V0IGlzIGFuIGFycmF5LCBpdCBkb2VzXG5cdFx0XHRcdFx0Ly8gbm90IGFjdHVhbGx5IGNvbnRhaW4gdGhpcyBwcm9wZXJ0eS4gSWYgaXQgaXMgbm93IGRlc2NyaWJlZCBhcyBub24tY29uZmlndXJhYmxlLFxuXHRcdFx0XHRcdC8vIHRoZSBwcm94eSB0aHJvd3MgYSB2YWxpZGF0aW9uIGVycm9yLiBTZXR0aW5nIGl0IHRvIHRydWUgYXZvaWRzIHRoYXQuXG5cdFx0XHRcdFx0ZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkZXNjcmlwdG9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzKHRhcmdldCwga2V5KSB7XG5cdFx0Ly8gVG8gcHJldmVudCBhIGZhbHNlIHBvc2l0aXZlIGBpc19lbnRyeV9wcm9wc2AgaW4gdGhlIGBwcm9wYCBmdW5jdGlvblxuXHRcdGlmIChrZXkgPT09IFNUQVRFX1NZTUJPTCB8fCBrZXkgPT09IExFR0FDWV9QUk9QUykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Zm9yIChsZXQgcCBvZiB0YXJnZXQucHJvcHMpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmIChwICE9IG51bGwgJiYga2V5IGluIHApIHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHQvKiogQHR5cGUge0FycmF5PHN0cmluZyB8IHN5bWJvbD59ICovXG5cdFx0Y29uc3Qga2V5cyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgcCBvZiB0YXJnZXQucHJvcHMpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHApIHtcblx0XHRcdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBrZXlzO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCAoKCkgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPn0gcHJvcHNcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWRfcHJvcHMoLi4ucHJvcHMpIHtcblx0cmV0dXJuIG5ldyBQcm94eSh7IHByb3BzIH0sIHNwcmVhZF9wcm9wc19oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIHdpdGhfcGFyZW50X2JyYW5jaChmbikge1xuXHR2YXIgZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCAmJiAoZWZmZWN0LmYgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDApIHtcblx0XHRlZmZlY3QgPSBlZmZlY3QucGFyZW50O1xuXHR9XG5cdHRyeSB7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3Igc3luY2hyb25pemluZyBhIHBvc3NpYmx5IGJvdW5kIHByb3Agd2l0aCB0aGUgaW5uZXIgY29tcG9uZW50IHN0YXRlLlxuICogSXQgaXMgdXNlZCB3aGVuZXZlciB0aGUgY29tcGlsZXIgc2VlcyB0aGF0IHRoZSBjb21wb25lbnQgd3JpdGVzIHRvIHRoZSBwcm9wLCBvciB3aGVuIGl0IGhhcyBhIGRlZmF1bHQgcHJvcF92YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0ge1YgfCAoKCkgPT4gVil9IFtmYWxsYmFja11cbiAqIEByZXR1cm5zIHsoKCkgPT4gViB8ICgoYXJnOiBWKSA9PiBWKSB8ICgoYXJnOiBWLCBtdXRhdGlvbjogYm9vbGVhbikgPT4gVikpfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcChwcm9wcywga2V5LCBmbGFncywgZmFsbGJhY2spIHtcblx0dmFyIGltbXV0YWJsZSA9IChmbGFncyAmIFBST1BTX0lTX0lNTVVUQUJMRSkgIT09IDA7XG5cdHZhciBydW5lcyA9ICFsZWdhY3lfbW9kZV9mbGFnIHx8IChmbGFncyAmIFBST1BTX0lTX1JVTkVTKSAhPT0gMDtcblx0dmFyIGJpbmRhYmxlID0gKGZsYWdzICYgUFJPUFNfSVNfQklOREFCTEUpICE9PSAwO1xuXHR2YXIgbGF6eSA9IChmbGFncyAmIFBST1BTX0lTX0xBWllfSU5JVElBTCkgIT09IDA7XG5cdHZhciBpc19zdG9yZV9zdWIgPSBmYWxzZTtcblx0dmFyIHByb3BfdmFsdWU7XG5cblx0aWYgKGJpbmRhYmxlKSB7XG5cdFx0W3Byb3BfdmFsdWUsIGlzX3N0b3JlX3N1Yl0gPSBjYXB0dXJlX3N0b3JlX2JpbmRpbmcoKCkgPT4gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSkpO1xuXHR9IGVsc2Uge1xuXHRcdHByb3BfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblx0fVxuXG5cdC8vIENhbiBiZSB0aGUgY2FzZSB3aGVuIHNvbWVvbmUgZG9lcyBgbW91bnQoQ29tcG9uZW50LCBwcm9wcylgIHdpdGggYGxldCBwcm9wcyA9ICRzdGF0ZSh7Li4ufSlgXG5cdC8vIG9yIGBjcmVhdGVDbGFzc0NvbXBvbmVudChDb21wb25lbnQsIHByb3BzKWBcblx0dmFyIGlzX2VudHJ5X3Byb3BzID0gU1RBVEVfU1lNQk9MIGluIHByb3BzIHx8IExFR0FDWV9QUk9QUyBpbiBwcm9wcztcblxuXHR2YXIgc2V0dGVyID1cblx0XHRnZXRfZGVzY3JpcHRvcihwcm9wcywga2V5KT8uc2V0ID8/XG5cdFx0KGlzX2VudHJ5X3Byb3BzICYmIGJpbmRhYmxlICYmIGtleSBpbiBwcm9wcyA/ICh2KSA9PiAocHJvcHNba2V5XSA9IHYpIDogdW5kZWZpbmVkKTtcblxuXHR2YXIgZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjayk7XG5cdHZhciBmYWxsYmFja19kaXJ0eSA9IHRydWU7XG5cdHZhciBmYWxsYmFja191c2VkID0gZmFsc2U7XG5cblx0dmFyIGdldF9mYWxsYmFjayA9ICgpID0+IHtcblx0XHRmYWxsYmFja191c2VkID0gdHJ1ZTtcblx0XHRpZiAoZmFsbGJhY2tfZGlydHkpIHtcblx0XHRcdGZhbGxiYWNrX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRpZiAobGF6eSkge1xuXHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IHVudHJhY2soLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoZmFsbGJhY2spKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxsYmFja192YWx1ZTtcblx0fTtcblxuXHRpZiAocHJvcF92YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoc2V0dGVyICYmIHJ1bmVzKSB7XG5cdFx0XHRlLnByb3BzX2ludmFsaWRfdmFsdWUoa2V5KTtcblx0XHR9XG5cblx0XHRwcm9wX3ZhbHVlID0gZ2V0X2ZhbGxiYWNrKCk7XG5cdFx0aWYgKHNldHRlcikgc2V0dGVyKHByb3BfdmFsdWUpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHsoKSA9PiBWfSAqL1xuXHR2YXIgZ2V0dGVyO1xuXHRpZiAocnVuZXMpIHtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0X2ZhbGxiYWNrKCk7XG5cdFx0XHRmYWxsYmFja19kaXJ0eSA9IHRydWU7XG5cdFx0XHRmYWxsYmFja191c2VkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdmVsdGUgNCBkaWQgbm90IHRyaWdnZXIgdXBkYXRlcyB3aGVuIGEgcHJpbWl0aXZlIHZhbHVlIHdhcyB1cGRhdGVkIHRvIHRoZSBzYW1lIHZhbHVlLlxuXHRcdC8vIFJlcGxpY2F0ZSB0aGF0IGJlaGF2aW9yIHRocm91Z2ggdXNpbmcgYSBkZXJpdmVkXG5cdFx0dmFyIGRlcml2ZWRfZ2V0dGVyID0gd2l0aF9wYXJlbnRfYnJhbmNoKCgpID0+XG5cdFx0XHQoaW1tdXRhYmxlID8gZGVyaXZlZCA6IGRlcml2ZWRfc2FmZV9lcXVhbCkoKCkgPT4gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSkpXG5cdFx0KTtcblx0XHRkZXJpdmVkX2dldHRlci5mIHw9IExFR0FDWV9ERVJJVkVEX1BST1A7XG5cdFx0Z2V0dGVyID0gKCkgPT4ge1xuXHRcdFx0dmFyIHZhbHVlID0gZ2V0KGRlcml2ZWRfZ2V0dGVyKTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSBmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHVuZGVmaW5lZCk7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGZhbGxiYWNrX3ZhbHVlIDogdmFsdWU7XG5cdFx0fTtcblx0fVxuXG5cdC8vIGVhc3kgbW9kZSDigJQgcHJvcCBpcyBuZXZlciB3cml0dGVuIHRvXG5cdGlmICgoZmxhZ3MgJiBQUk9QU19JU19VUERBVEVEKSA9PT0gMCkge1xuXHRcdHJldHVybiBnZXR0ZXI7XG5cdH1cblxuXHQvLyBpbnRlcm1lZGlhdGUgbW9kZSDigJQgcHJvcCBpcyB3cml0dGVuIHRvLCBidXQgdGhlIHBhcmVudCBjb21wb25lbnQgaGFkXG5cdC8vIGBiaW5kOmZvb2Agd2hpY2ggbWVhbnMgd2UgY2FuIGp1c3QgY2FsbCBgJCRwcm9wcy5mb28gPSB2YWx1ZWAgZGlyZWN0bHlcblx0aWYgKHNldHRlcikge1xuXHRcdHZhciBsZWdhY3lfcGFyZW50ID0gcHJvcHMuJCRsZWdhY3k7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgvKiogQHR5cGUge2FueX0gKi8gdmFsdWUsIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gbXV0YXRpb24pIHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBXZSBkb24ndCB3YW50IHRvIG5vdGlmeSBpZiB0aGUgdmFsdWUgd2FzIG11dGF0ZWQgYW5kIHRoZSBwYXJlbnQgaXMgaW4gcnVuZXMgbW9kZS5cblx0XHRcdFx0Ly8gSW4gdGhhdCBjYXNlIHRoZSBzdGF0ZSBwcm94eSAoaWYgaXQgZXhpc3RzKSBzaG91bGQgdGFrZSBjYXJlIG9mIHRoZSBub3RpZmljYXRpb24uXG5cdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgaXMgbm90IGluIHJ1bmVzIG1vZGUsIHdlIG5lZWQgdG8gbm90aWZ5IG9uIG11dGF0aW9uLCB0b28sIHRoYXQgdGhlIHByb3Bcblx0XHRcdFx0Ly8gaGFzIGNoYW5nZWQgYmVjYXVzZSB0aGUgcGFyZW50IHdpbGwgbm90IGJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjaGFuZ2Ugb3RoZXJ3aXNlLlxuXHRcdFx0XHRpZiAoIXJ1bmVzIHx8ICFtdXRhdGlvbiB8fCBsZWdhY3lfcGFyZW50IHx8IGlzX3N0b3JlX3N1Yikge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChzZXR0ZXIpKG11dGF0aW9uID8gZ2V0dGVyKCkgOiB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGdldHRlcigpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBoYXJkIG1vZGUuIHRoaXMgaXMgd2hlcmUgaXQgZ2V0cyB1Z2x5IOKAlCB0aGUgdmFsdWUgaW4gdGhlIGNoaWxkIHNob3VsZFxuXHQvLyBzeW5jaHJvbml6ZSB3aXRoIHRoZSBwYXJlbnQsIGJ1dCBpdCBzaG91bGQgYWxzbyBiZSBwb3NzaWJsZSB0byB0ZW1wb3JhcmlseVxuXHQvLyBzZXQgdGhlIHZhbHVlIHRvIHNvbWV0aGluZyBlbHNlIGxvY2FsbHkuXG5cdHZhciBmcm9tX2NoaWxkID0gZmFsc2U7XG5cdHZhciB3YXNfZnJvbV9jaGlsZCA9IGZhbHNlO1xuXG5cdC8vIFRoZSBkZXJpdmVkIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUuIFRoZSB1bmRlcmx5aW5nIG11dGFibGVcblx0Ly8gc291cmNlIGlzIHdyaXR0ZW4gdG8gZnJvbSB2YXJpb3VzIHBsYWNlcyB0byBwZXJzaXN0IHRoaXMgdmFsdWUuXG5cdHZhciBpbm5lcl9jdXJyZW50X3ZhbHVlID0gbXV0YWJsZV9zb3VyY2UocHJvcF92YWx1ZSk7XG5cdHZhciBjdXJyZW50X3ZhbHVlID0gd2l0aF9wYXJlbnRfYnJhbmNoKCgpID0+XG5cdFx0ZGVyaXZlZCgoKSA9PiB7XG5cdFx0XHR2YXIgcGFyZW50X3ZhbHVlID0gZ2V0dGVyKCk7XG5cdFx0XHR2YXIgY2hpbGRfdmFsdWUgPSBnZXQoaW5uZXJfY3VycmVudF92YWx1ZSk7XG5cblx0XHRcdGlmIChmcm9tX2NoaWxkKSB7XG5cdFx0XHRcdGZyb21fY2hpbGQgPSBmYWxzZTtcblx0XHRcdFx0d2FzX2Zyb21fY2hpbGQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gY2hpbGRfdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHdhc19mcm9tX2NoaWxkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gKGlubmVyX2N1cnJlbnRfdmFsdWUudiA9IHBhcmVudF92YWx1ZSk7XG5cdFx0fSlcblx0KTtcblxuXHRpZiAoIWltbXV0YWJsZSkgY3VycmVudF92YWx1ZS5lcXVhbHMgPSBzYWZlX2VxdWFscztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKC8qKiBAdHlwZSB7YW55fSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdC8vIGxlZ2FjeSBub25zZW5zZSDigJQgbmVlZCB0byBlbnN1cmUgdGhlIHNvdXJjZSBpcyBpbnZhbGlkYXRlZCB3aGVuIG5lY2Vzc2FyeVxuXHRcdC8vIGFsc28gbmVlZGVkIGZvciB3aGVuIGhhbmRsaW5nIGluc3BlY3QgbG9naWMgc28gd2UgY2FuIGluc3BlY3QgdGhlIGNvcnJlY3Qgc291cmNlIHNpZ25hbFxuXHRcdGlmIChjYXB0dXJlZF9zaWduYWxzICE9PSBudWxsKSB7XG5cdFx0XHQvLyBzZXQgdGhpcyBzbyB0aGF0IHdlIGRvbid0IHJlc2V0IHRvIHRoZSBwYXJlbnQgdmFsdWUgaWYgYGRgXG5cdFx0XHQvLyBpcyBpbnZhbGlkYXRlZCBiZWNhdXNlIG9mIGBpbnZhbGlkYXRlX2lubmVyX3NpZ25hbHNgIChyYXRoZXJcblx0XHRcdC8vIHRoYW4gYmVjYXVzZSB0aGUgcGFyZW50IG9yIGNoaWxkIHZhbHVlIGNoYW5nZWQpXG5cdFx0XHRmcm9tX2NoaWxkID0gd2FzX2Zyb21fY2hpbGQ7XG5cdFx0XHQvLyBpbnZva2UgZ2V0dGVycyBzbyB0aGF0IHNpZ25hbHMgYXJlIHBpY2tlZCB1cCBieSBgaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzYFxuXHRcdFx0Z2V0dGVyKCk7XG5cdFx0XHRnZXQoaW5uZXJfY3VycmVudF92YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBuZXdfdmFsdWUgPSBtdXRhdGlvbiA/IGdldChjdXJyZW50X3ZhbHVlKSA6IHJ1bmVzICYmIGJpbmRhYmxlID8gcHJveHkodmFsdWUpIDogdmFsdWU7XG5cblx0XHRcdGlmICghY3VycmVudF92YWx1ZS5lcXVhbHMobmV3X3ZhbHVlKSkge1xuXHRcdFx0XHRmcm9tX2NoaWxkID0gdHJ1ZTtcblx0XHRcdFx0c2V0KGlubmVyX2N1cnJlbnRfdmFsdWUsIG5ld192YWx1ZSk7XG5cdFx0XHRcdC8vIFRvIGVuc3VyZSB0aGUgZmFsbGJhY2sgdmFsdWUgaXMgY29uc2lzdGVudCB3aGVuIHVzZWQgd2l0aCBwcm94aWVzLCB3ZVxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIGxvY2FsIGZhbGxiYWNrX3ZhbHVlLCBidXQgb25seSBpZiB0aGUgZmFsbGJhY2sgaXMgYWN0aXZlbHkgdXNlZFxuXHRcdFx0XHRpZiAoZmFsbGJhY2tfdXNlZCAmJiBmYWxsYmFja192YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dW50cmFjaygoKSA9PiBnZXQoY3VycmVudF92YWx1ZSkpOyAvLyBmb3JjZSBhIHN5bmNocm9uaXNhdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBnZXQoY3VycmVudF92YWx1ZSk7XG5cdH07XG59XG4iLCJpbXBvcnQgeyBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IsIGlzX2FycmF5IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBjYXB0dXJlX3N0b3JlX2JpbmRpbmcgfSBmcm9tICcuL3JlYWN0aXZpdHkvc3RvcmUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0geyhpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHN0cmluZ30ga2V5X2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjb2xsZWN0aW9uLCBrZXlfZm4pIHtcblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcblx0XHRjb25zdCBtYXliZV9hcnJheSA9IGNvbGxlY3Rpb24oKTtcblx0XHRjb25zdCBhcnJheSA9IGlzX2FycmF5KG1heWJlX2FycmF5KVxuXHRcdFx0PyBtYXliZV9hcnJheVxuXHRcdFx0OiBtYXliZV9hcnJheSA9PSBudWxsXG5cdFx0XHRcdD8gW11cblx0XHRcdFx0OiBBcnJheS5mcm9tKG1heWJlX2FycmF5KTtcblx0XHRjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qga2V5ID0ga2V5X2ZuKGFycmF5W2ldLCBpKTtcblx0XHRcdGlmIChrZXlzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBTdHJpbmcoa2V5cy5nZXQoa2V5KSk7XG5cdFx0XHRcdGNvbnN0IGIgPSBTdHJpbmcoaSk7XG5cblx0XHRcdFx0LyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuXHRcdFx0XHRsZXQgayA9IFN0cmluZyhrZXkpO1xuXHRcdFx0XHRpZiAoay5zdGFydHNXaXRoKCdbb2JqZWN0ICcpKSBrID0gbnVsbDtcblxuXHRcdFx0XHRlLmVhY2hfa2V5X2R1cGxpY2F0ZShhLCBiLCBrKTtcblx0XHRcdH1cblx0XHRcdGtleXMuc2V0KGtleSwgaSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGJpbmRhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHBvcnRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9uICYgeyBbRklMRU5BTUVdOiBzdHJpbmcgfX0gY29tcG9uZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9wcm9wX2JpbmRpbmdzKCQkcHJvcHMsIGJpbmRhYmxlLCBleHBvcnRzLCBjb21wb25lbnQpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gJCRwcm9wcykge1xuXHRcdHZhciBzZXR0ZXIgPSBnZXRfZGVzY3JpcHRvcigkJHByb3BzLCBrZXkpPy5zZXQ7XG5cdFx0dmFyIG5hbWUgPSBjb21wb25lbnQubmFtZTtcblxuXHRcdGlmIChzZXR0ZXIpIHtcblx0XHRcdGlmIChleHBvcnRzLmluY2x1ZGVzKGtleSkpIHtcblx0XHRcdFx0ZS5iaW5kX2ludmFsaWRfZXhwb3J0KGNvbXBvbmVudFtGSUxFTkFNRV0sIGtleSwgbmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghYmluZGFibGUuaW5jbHVkZXMoa2V5KSkge1xuXHRcdFx0XHRlLmJpbmRfbm90X2JpbmRhYmxlKGtleSwgY29tcG9uZW50W0ZJTEVOQU1FXSwgbmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmRpbmdcbiAqIEBwYXJhbSB7KCkgPT4gUmVjb3JkPHN0cmluZywgYW55Pn0gZ2V0X29iamVjdFxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF9wcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2JpbmRpbmcoYmluZGluZywgZ2V0X29iamVjdCwgZ2V0X3Byb3BlcnR5LCBsaW5lLCBjb2x1bW4pIHtcblx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG5cdHZhciBmaWxlbmFtZSA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbj8uW0ZJTEVOQU1FXTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpZiAod2FybmVkKSByZXR1cm47XG5cblx0XHR2YXIgW29iamVjdCwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZyhnZXRfb2JqZWN0KTtcblxuXHRcdGlmIChpc19zdG9yZV9zdWIpIHJldHVybjtcblxuXHRcdHZhciBwcm9wZXJ0eSA9IGdldF9wcm9wZXJ0eSgpO1xuXG5cdFx0dmFyIHJhbiA9IGZhbHNlO1xuXG5cdFx0Ly8gYnkgbWFraW5nIHRoZSAocG9zc2libHkgZmFsc2UsIGJ1dCBpdCB3b3VsZCBiZSBhbiBleHRyZW1lIGVkZ2UgY2FzZSkgYXNzdW1wdGlvblxuXHRcdC8vIHRoYXQgYSBnZXR0ZXIgaGFzIGEgY29ycmVzcG9uZGluZyBzZXR0ZXIsIHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBwcm9wZXJ0eSBpc1xuXHRcdC8vIHJlYWN0aXZlIGJ5IHNlZWluZyBpZiB0aGlzIGVmZmVjdCBoYXMgZGVwZW5kZW5jaWVzXG5cdFx0dmFyIGVmZmVjdCA9IHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0aWYgKHJhbikgcmV0dXJuO1xuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0b2JqZWN0W3Byb3BlcnR5XTtcblx0XHR9KTtcblxuXHRcdHJhbiA9IHRydWU7XG5cblx0XHRpZiAoZWZmZWN0LmRlcHMgPT09IG51bGwpIHtcblx0XHRcdHZhciBsb2NhdGlvbiA9IGAke2ZpbGVuYW1lfToke2xpbmV9OiR7Y29sdW1ufWA7XG5cdFx0XHR3LmJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlKGJpbmRpbmcsIGxvY2F0aW9uKTtcblxuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IGlzX3ZvaWQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5cbmV4cG9ydCB7IGludmFsaWRfZGVmYXVsdF9zbmlwcGV0IH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSB0YWdfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnX2ZuKSB7XG5cdGNvbnN0IHRhZyA9IHRhZ19mbigpO1xuXHRpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuXHRcdHcuZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudCh0YWcpO1xuXHR9XG59XG5cbi8qKiBAcGFyYW0geygpID0+IHVua25vd259IHRhZ19mbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudF90YWcodGFnX2ZuKSB7XG5cdGNvbnN0IHRhZyA9IHRhZ19mbigpO1xuXHRjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcblx0aWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG5cdFx0ZS5zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWUoKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRlLnN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSk7XG5cdH1cbn1cbiIsImltcG9ydCB7Q2FsZW5kYXJEYXRlIGFzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmLCBDYWxlbmRhckRhdGVUaW1lIGFzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmfSBmcm9tIFwiLi9DYWxlbmRhckRhdGUubWpzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKGFtb3VudCwgbnVtZXJhdG9yKSB7XG4gICAgcmV0dXJuIGFtb3VudCAtIG51bWVyYXRvciAqIE1hdGguZmxvb3IoYW1vdW50IC8gbnVtZXJhdG9yKTtcbn1cbmZ1bmN0aW9uICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ3ODRkMTNkOGVlMzUxZjA3KGRhdGUpIHtcbiAgICBpZiAoZGF0ZS5lcmEpIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmKShkYXRlLmNhbGVuZGFyLCBkYXRlLmVyYSwgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG4gICAgZWxzZSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS55ZWFyLCBkYXRlLm1vbnRoLCBkYXRlLmRheSk7XG59XG5mdW5jdGlvbiAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkMjdmYTAxNzJhZTI2NDRiMyhkYXRlKSB7XG4gICAgaWYgKGRhdGUuZXJhKSByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksIGRhdGUuaG91ciwgZGF0ZS5taW51dGUsIGRhdGUuc2Vjb25kLCBkYXRlLm1pbGxpc2Vjb25kKTtcbiAgICBlbHNlIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmKShkYXRlLmNhbGVuZGFyLCBkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5LCBkYXRlLmhvdXIsIGRhdGUubWludXRlLCBkYXRlLnNlY29uZCk7XG59XG5cblxuZXhwb3J0IHskMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkODQyYTJjZjM3YWY5NzdlMSBhcyBtb2QsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ3ODRkMTNkOGVlMzUxZjA3IGFzIGNvcHksICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQyN2ZhMDE3MmFlMjY0NGIzIGFzIGNvcHlEYXRlVGltZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnQge0NhbGVuZGFyRGF0ZSBhcyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0Zn0gZnJvbSBcIi4vQ2FsZW5kYXJEYXRlLm1qc1wiO1xuaW1wb3J0IHttb2QgYXMgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTF9IGZyb20gXCIuL3V0aWxzLm1qc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gSUNVLlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGNhbiBiZSBmb3VuZCBpbiB0aGUgTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cblxuY29uc3QgJDNiNjIwNzRlYjA1NTg0YjIkdmFyJEVQT0NIID0gMTcyMTQyNjsgLy8gMDAxLzAxLzAzIEp1bGlhbiBDLkUuXG5mdW5jdGlvbiAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkZjI5N2ViODM5MDA2ZDMzOShlcmEsIHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICB5ZWFyID0gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQoZXJhLCB5ZWFyKTtcbiAgICBsZXQgeTEgPSB5ZWFyIC0gMTtcbiAgICBsZXQgbW9udGhPZmZzZXQgPSAtMjtcbiAgICBpZiAobW9udGggPD0gMikgbW9udGhPZmZzZXQgPSAwO1xuICAgIGVsc2UgaWYgKCQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwKHllYXIpKSBtb250aE9mZnNldCA9IC0xO1xuICAgIHJldHVybiAkM2I2MjA3NGViMDU1ODRiMiR2YXIkRVBPQ0ggLSAxICsgMzY1ICogeTEgKyBNYXRoLmZsb29yKHkxIC8gNCkgLSBNYXRoLmZsb29yKHkxIC8gMTAwKSArIE1hdGguZmxvb3IoeTEgLyA0MDApICsgTWF0aC5mbG9vcigoMzY3ICogbW9udGggLSAzNjIpIC8gMTIgKyBtb250aE9mZnNldCArIGRheSk7XG59XG5mdW5jdGlvbiAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCh5ZWFyKSB7XG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuZnVuY3Rpb24gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGMzNmUwZWNiMmQ0ZmE2OWQoZXJhLCB5ZWFyKSB7XG4gICAgcmV0dXJuIGVyYSA9PT0gJ0JDJyA/IDEgLSB5ZWFyIDogeWVhcjtcbn1cbmZ1bmN0aW9uICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ0NDc1YjdlNjE3ZWIxMjNjKHllYXIpIHtcbiAgICBsZXQgZXJhID0gJ0FEJztcbiAgICBpZiAoeWVhciA8PSAwKSB7XG4gICAgICAgIGVyYSA9ICdCQyc7XG4gICAgICAgIHllYXIgPSAxIC0geWVhcjtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZXJhLFxuICAgICAgICB5ZWFyXG4gICAgXTtcbn1cbmNvbnN0ICQzYjYyMDc0ZWIwNTU4NGIyJHZhciRkYXlzSW5Nb250aCA9IHtcbiAgICBzdGFuZGFyZDogW1xuICAgICAgICAzMSxcbiAgICAgICAgMjgsXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzAsXG4gICAgICAgIDMxXG4gICAgXSxcbiAgICBsZWFweWVhcjogW1xuICAgICAgICAzMSxcbiAgICAgICAgMjksXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICAgICAgMzAsXG4gICAgICAgIDMxXG4gICAgXVxufTtcbmNsYXNzICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjIHtcbiAgICBmcm9tSnVsaWFuRGF5KGpkKSB7XG4gICAgICAgIGxldCBqZDAgPSBqZDtcbiAgICAgICAgbGV0IGRlcG9jaCA9IGpkMCAtICQzYjYyMDc0ZWIwNTU4NGIyJHZhciRFUE9DSDtcbiAgICAgICAgbGV0IHF1YWRyaWNlbnQgPSBNYXRoLmZsb29yKGRlcG9jaCAvIDE0NjA5Nyk7XG4gICAgICAgIGxldCBkcWMgPSAoMCwgJDJiNGRjZTEzZGQ1YTE3ZmEkZXhwb3J0JDg0MmEyY2YzN2FmOTc3ZTEpKGRlcG9jaCwgMTQ2MDk3KTtcbiAgICAgICAgbGV0IGNlbnQgPSBNYXRoLmZsb29yKGRxYyAvIDM2NTI0KTtcbiAgICAgICAgbGV0IGRjZW50ID0gKDAsICQyYjRkY2UxM2RkNWExN2ZhJGV4cG9ydCQ4NDJhMmNmMzdhZjk3N2UxKShkcWMsIDM2NTI0KTtcbiAgICAgICAgbGV0IHF1YWQgPSBNYXRoLmZsb29yKGRjZW50IC8gMTQ2MSk7XG4gICAgICAgIGxldCBkcXVhZCA9ICgwLCAkMmI0ZGNlMTNkZDVhMTdmYSRleHBvcnQkODQyYTJjZjM3YWY5NzdlMSkoZGNlbnQsIDE0NjEpO1xuICAgICAgICBsZXQgeWluZGV4ID0gTWF0aC5mbG9vcihkcXVhZCAvIDM2NSk7XG4gICAgICAgIGxldCBleHRlbmRlZFllYXIgPSBxdWFkcmljZW50ICogNDAwICsgY2VudCAqIDEwMCArIHF1YWQgKiA0ICsgeWluZGV4ICsgKGNlbnQgIT09IDQgJiYgeWluZGV4ICE9PSA0ID8gMSA6IDApO1xuICAgICAgICBsZXQgW2VyYSwgeWVhcl0gPSAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNDQ3NWI3ZTYxN2ViMTIzYyhleHRlbmRlZFllYXIpO1xuICAgICAgICBsZXQgeWVhckRheSA9IGpkMCAtICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5KGVyYSwgeWVhciwgMSwgMSk7XG4gICAgICAgIGxldCBsZWFwQWRqID0gMjtcbiAgICAgICAgaWYgKGpkMCA8ICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5KGVyYSwgeWVhciwgMywgMSkpIGxlYXBBZGogPSAwO1xuICAgICAgICBlbHNlIGlmICgkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkNTUzZDdmYThlMzgwNWZjMCh5ZWFyKSkgbGVhcEFkaiA9IDE7XG4gICAgICAgIGxldCBtb250aCA9IE1hdGguZmxvb3IoKCh5ZWFyRGF5ICsgbGVhcEFkaikgKiAxMiArIDM3MykgLyAzNjcpO1xuICAgICAgICBsZXQgZGF5ID0gamQwIC0gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkoZXJhLCB5ZWFyLCBtb250aCwgMSkgKyAxO1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoZXJhLCB5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG4gICAgdG9KdWxpYW5EYXkoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JGYyOTdlYjgzOTAwNmQzMzkoZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkpO1xuICAgIH1cbiAgICBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiAkM2I2MjA3NGViMDU1ODRiMiR2YXIkZGF5c0luTW9udGhbJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzAoZGF0ZS55ZWFyKSA/ICdsZWFweWVhcicgOiAnc3RhbmRhcmQnXVtkYXRlLm1vbnRoIC0gMV07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBnZXRNb250aHNJblllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gMTI7XG4gICAgfVxuICAgIGdldERheXNJblllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDU1M2Q3ZmE4ZTM4MDVmYzAoZGF0ZS55ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGdldFllYXJzSW5FcmEoZGF0ZSkge1xuICAgICAgICByZXR1cm4gOTk5OTtcbiAgICB9XG4gICAgZ2V0RXJhcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdCQycsXG4gICAgICAgICAgICAnQUQnXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlzSW52ZXJzZUVyYShkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmVyYSA9PT0gJ0JDJztcbiAgICB9XG4gICAgYmFsYW5jZURhdGUoZGF0ZSkge1xuICAgICAgICBpZiAoZGF0ZS55ZWFyIDw9IDApIHtcbiAgICAgICAgICAgIGRhdGUuZXJhID0gZGF0ZS5lcmEgPT09ICdCQycgPyAnQUQnIDogJ0JDJztcbiAgICAgICAgICAgIGRhdGUueWVhciA9IDEgLSBkYXRlLnllYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gJ2dyZWdvcnknO1xuICAgIH1cbn1cblxuXG5leHBvcnQgeyQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRmMjk3ZWI4MzkwMDZkMzM5IGFzIGdyZWdvcmlhblRvSnVsaWFuRGF5LCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkYzM2ZTBlY2IyZDRmYTY5ZCBhcyBnZXRFeHRlbmRlZFllYXIsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ1NTNkN2ZhOGUzODA1ZmMwIGFzIGlzTGVhcFllYXIsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ0NDc1YjdlNjE3ZWIxMjNjIGFzIGZyb21FeHRlbmRlZFllYXIsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjIGFzIEdyZWdvcmlhbkNhbGVuZGFyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyZWdvcmlhbkNhbGVuZGFyLm1vZHVsZS5qcy5tYXBcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBEYXRhIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtY2xkci9jbGRyLWNvcmUvYmxvYi9tYXN0ZXIvc3VwcGxlbWVudGFsL3dlZWtEYXRhLmpzb25cbi8vIExvY2FsZXMgc3RhcnRpbmcgb24gU3VuZGF5IGhhdmUgYmVlbiByZW1vdmVkIGZvciBjb21wcmVzc2lvbi5cbmNvbnN0ICQyZmUyODZkMmZiNDQ5YWJiJGV4cG9ydCQ3YTVhY2JkNzdkNDE0YmQ5ID0ge1xuICAgICcwMDEnOiAxLFxuICAgIEFEOiAxLFxuICAgIEFFOiA2LFxuICAgIEFGOiA2LFxuICAgIEFJOiAxLFxuICAgIEFMOiAxLFxuICAgIEFNOiAxLFxuICAgIEFOOiAxLFxuICAgIEFSOiAxLFxuICAgIEFUOiAxLFxuICAgIEFVOiAxLFxuICAgIEFYOiAxLFxuICAgIEFaOiAxLFxuICAgIEJBOiAxLFxuICAgIEJFOiAxLFxuICAgIEJHOiAxLFxuICAgIEJIOiA2LFxuICAgIEJNOiAxLFxuICAgIEJOOiAxLFxuICAgIEJZOiAxLFxuICAgIENIOiAxLFxuICAgIENMOiAxLFxuICAgIENNOiAxLFxuICAgIENOOiAxLFxuICAgIENSOiAxLFxuICAgIENZOiAxLFxuICAgIENaOiAxLFxuICAgIERFOiAxLFxuICAgIERKOiA2LFxuICAgIERLOiAxLFxuICAgIERaOiA2LFxuICAgIEVDOiAxLFxuICAgIEVFOiAxLFxuICAgIEVHOiA2LFxuICAgIEVTOiAxLFxuICAgIEZJOiAxLFxuICAgIEZKOiAxLFxuICAgIEZPOiAxLFxuICAgIEZSOiAxLFxuICAgIEdCOiAxLFxuICAgIEdFOiAxLFxuICAgIEdGOiAxLFxuICAgIEdQOiAxLFxuICAgIEdSOiAxLFxuICAgIEhSOiAxLFxuICAgIEhVOiAxLFxuICAgIElFOiAxLFxuICAgIElROiA2LFxuICAgIElSOiA2LFxuICAgIElTOiAxLFxuICAgIElUOiAxLFxuICAgIEpPOiA2LFxuICAgIEtHOiAxLFxuICAgIEtXOiA2LFxuICAgIEtaOiAxLFxuICAgIExCOiAxLFxuICAgIExJOiAxLFxuICAgIExLOiAxLFxuICAgIExUOiAxLFxuICAgIExVOiAxLFxuICAgIExWOiAxLFxuICAgIExZOiA2LFxuICAgIE1DOiAxLFxuICAgIE1EOiAxLFxuICAgIE1FOiAxLFxuICAgIE1LOiAxLFxuICAgIE1OOiAxLFxuICAgIE1ROiAxLFxuICAgIE1WOiA1LFxuICAgIE1ZOiAxLFxuICAgIE5MOiAxLFxuICAgIE5POiAxLFxuICAgIE5aOiAxLFxuICAgIE9NOiA2LFxuICAgIFBMOiAxLFxuICAgIFFBOiA2LFxuICAgIFJFOiAxLFxuICAgIFJPOiAxLFxuICAgIFJTOiAxLFxuICAgIFJVOiAxLFxuICAgIFNEOiA2LFxuICAgIFNFOiAxLFxuICAgIFNJOiAxLFxuICAgIFNLOiAxLFxuICAgIFNNOiAxLFxuICAgIFNZOiA2LFxuICAgIFRKOiAxLFxuICAgIFRNOiAxLFxuICAgIFRSOiAxLFxuICAgIFVBOiAxLFxuICAgIFVZOiAxLFxuICAgIFVaOiAxLFxuICAgIFZBOiAxLFxuICAgIFZOOiAxLFxuICAgIFhLOiAxXG59O1xuXG5cbmV4cG9ydCB7JDJmZTI4NmQyZmI0NDlhYmIkZXhwb3J0JDdhNWFjYmQ3N2Q0MTRiZDkgYXMgd2Vla1N0YXJ0RGF0YX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWVrU3RhcnREYXRhLm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydCB7ZnJvbUFic29sdXRlIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjLCB0b0Fic29sdXRlIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjLCB0b0NhbGVuZGFyIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyLCB0b0NhbGVuZGFyRGF0ZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkOTM1MjJkMWE0MzlmMzYxN30gZnJvbSBcIi4vY29udmVyc2lvbi5tanNcIjtcbmltcG9ydCB7d2Vla1N0YXJ0RGF0YSBhcyAkMmZlMjg2ZDJmYjQ0OWFiYiRleHBvcnQkN2E1YWNiZDc3ZDQxNGJkOX0gZnJvbSBcIi4vd2Vla1N0YXJ0RGF0YS5tanNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWEzOWVjMTk3OTkzYWVmMChhLCBiKSB7XG4gICAgYiA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoYiwgYS5jYWxlbmRhcik7XG4gICAgcmV0dXJuIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhciAmJiBhLm1vbnRoID09PSBiLm1vbnRoICYmIGEuZGF5ID09PSBiLmRheTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhMThjODljYmQyNDE3MGZmKGEsIGIpIHtcbiAgICBiID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShiLCBhLmNhbGVuZGFyKTtcbiAgICAvLyBJbiB0aGUgSmFwYW5lc2UgY2FsZW5kYXIsIG1vbnRocyBjYW4gc3BhbiBtdWx0aXBsZSBlcmFzL3llYXJzLCBzbyBvbmx5IGNvbXBhcmUgdGhlIGZpcnN0IG9mIHRoZSBtb250aC5cbiAgICBhID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoYSk7XG4gICAgYiA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlKGIpO1xuICAgIHJldHVybiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXIgJiYgYS5tb250aCA9PT0gYi5tb250aDtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1ODQxZjllYjk3NzNmMjVmKGEsIGIpIHtcbiAgICBiID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKShiLCBhLmNhbGVuZGFyKTtcbiAgICBhID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIoYSk7XG4gICAgYiA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRmOTFlODlkM2QwNDA2MTAyKGIpO1xuICAgIHJldHVybiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXI7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkOTFiNjJlYmYyYmE3MDNlZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuY2FsZW5kYXIuaWRlbnRpZmllciA9PT0gYi5jYWxlbmRhci5pZGVudGlmaWVyICYmIGEuZXJhID09PSBiLmVyYSAmJiBhLnllYXIgPT09IGIueWVhciAmJiBhLm1vbnRoID09PSBiLm1vbnRoICYmIGEuZGF5ID09PSBiLmRheTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YThkYTBjNDRhM2FmZGYyKGEsIGIpIHtcbiAgICBhID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoYSk7XG4gICAgYiA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlKGIpO1xuICAgIHJldHVybiBhLmNhbGVuZGFyLmlkZW50aWZpZXIgPT09IGIuY2FsZW5kYXIuaWRlbnRpZmllciAmJiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXIgJiYgYS5tb250aCA9PT0gYi5tb250aDtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTg0MGY1YTZkZGE4MTQ3KGEsIGIpIHtcbiAgICBhID0gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIoYSk7XG4gICAgYiA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRmOTFlODlkM2QwNDA2MTAyKGIpO1xuICAgIHJldHVybiBhLmNhbGVuZGFyLmlkZW50aWZpZXIgPT09IGIuY2FsZW5kYXIuaWRlbnRpZmllciAmJiBhLmVyYSA9PT0gYi5lcmEgJiYgYS55ZWFyID09PSBiLnllYXI7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNjI5YjBhNDk3YWE2NTI2NyhkYXRlLCB0aW1lWm9uZSkge1xuICAgIHJldHVybiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWEzOWVjMTk3OTkzYWVmMChkYXRlLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZDBiZGY0NWFmMDNhNmVhMyh0aW1lWm9uZSkpO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDIwNjEwNTZkMDZkN2NkZjcoZGF0ZSwgbG9jYWxlKSB7XG4gICAgbGV0IGp1bGlhbiA9IGRhdGUuY2FsZW5kYXIudG9KdWxpYW5EYXkoZGF0ZSk7XG4gICAgLy8gSWYganVsaWFuIGlzIG5lZ2F0aXZlLCB0aGVuIGp1bGlhbiAlIDcgd2lsbCBiZSBuZWdhdGl2ZSwgc28gd2UgYWRqdXN0XG4gICAgLy8gYWNjb3JkaW5nbHkuICBKdWxpYW4gZGF5IDAgaXMgTW9uZGF5LlxuICAgIGxldCBkYXlPZldlZWsgPSBNYXRoLmNlaWwoanVsaWFuICsgMSAtICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRnZXRXZWVrU3RhcnQobG9jYWxlKSkgJSA3O1xuICAgIGlmIChkYXlPZldlZWsgPCAwKSBkYXlPZldlZWsgKz0gNztcbiAgICByZXR1cm4gZGF5T2ZXZWVrO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQ2MTkzOWRkNDQyMjE1Myh0aW1lWm9uZSkge1xuICAgIHJldHVybiAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKERhdGUubm93KCksIHRpbWVab25lKTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRkMGJkZjQ1YWYwM2E2ZWEzKHRpbWVab25lKSB7XG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkOTM1MjJkMWE0MzlmMzYxNykoJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQ2MTkzOWRkNDQyMjE1Myh0aW1lWm9uZSkpO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDY4NzgxZGRmMzFjMDA5MGYoYSwgYikge1xuICAgIHJldHVybiBhLmNhbGVuZGFyLnRvSnVsaWFuRGF5KGEpIC0gYi5jYWxlbmRhci50b0p1bGlhbkRheShiKTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRjMTlhODBhOTcyMWI4MGY2KGEsIGIpIHtcbiAgICByZXR1cm4gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJHRpbWVUb01zKGEpIC0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJHRpbWVUb01zKGIpO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJHRpbWVUb01zKGEpIHtcbiAgICByZXR1cm4gYS5ob3VyICogMzYwMDAwMCArIGEubWludXRlICogNjAwMDAgKyBhLnNlY29uZCAqIDEwMDAgKyBhLm1pbGxpc2Vjb25kO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDEyNmM5MWM5NDFkZTdlKGEsIHRpbWVab25lKSB7XG4gICAgbGV0IG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShhLCB0aW1lWm9uZSk7XG4gICAgbGV0IHRvbW9ycm93ID0gYS5hZGQoe1xuICAgICAgICBkYXlzOiAxXG4gICAgfSk7XG4gICAgbGV0IHRvbW9ycm93TXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMpKHRvbW9ycm93LCB0aW1lWm9uZSk7XG4gICAgcmV0dXJuICh0b21vcnJvd01zIC0gbXMpIC8gMzYwMDAwMDtcbn1cbmxldCAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkbG9jYWxUaW1lWm9uZSA9IG51bGw7XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMigpIHtcbiAgICAvLyBUT0RPOiBpbnZhbGlkYXRlIHRoaXMgc29tZWhvdz9cbiAgICBpZiAoJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGxvY2FsVGltZVpvbmUgPT0gbnVsbCkgJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGxvY2FsVGltZVpvbmUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICAgIHJldHVybiAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkbG9jYWxUaW1lWm9uZTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlKGRhdGUpIHtcbiAgICAvLyBVc2UgYHN1YnRyYWN0YCBpbnN0ZWFkIG9mIGBzZXRgIHNvIHdlIGRvbid0IGdldCBjb25zdHJhaW5lZCBpbiBhbiBlcmEuXG4gICAgcmV0dXJuIGRhdGUuc3VidHJhY3Qoe1xuICAgICAgICBkYXlzOiBkYXRlLmRheSAtIDFcbiAgICB9KTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhMjI1OGQ5YzQxMTg4MjVjKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5hZGQoe1xuICAgICAgICBkYXlzOiBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpIC0gZGF0ZS5kYXlcbiAgICB9KTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRmOTFlODlkM2QwNDA2MTAyKGRhdGUpIHtcbiAgICByZXR1cm4gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE1YTNiNDU0YWRhMjI2OGUoZGF0ZS5zdWJ0cmFjdCh7XG4gICAgICAgIG1vbnRoczogZGF0ZS5tb250aCAtIDFcbiAgICB9KSk7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkOGI3YWE1NWM2NmQ1NTY5ZShkYXRlKSB7XG4gICAgcmV0dXJuICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhMjI1OGQ5YzQxMTg4MjVjKGRhdGUuYWRkKHtcbiAgICAgICAgbW9udGhzOiBkYXRlLmNhbGVuZGFyLmdldE1vbnRoc0luWWVhcihkYXRlKSAtIGRhdGUubW9udGhcbiAgICB9KSk7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNTQxMmFjMTE3MTNiNzJhZChkYXRlKSB7XG4gICAgaWYgKGRhdGUuY2FsZW5kYXIuZ2V0TWluaW11bU1vbnRoSW5ZZWFyKSByZXR1cm4gZGF0ZS5jYWxlbmRhci5nZXRNaW5pbXVtTW9udGhJblllYXIoZGF0ZSk7XG4gICAgcmV0dXJuIDE7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYjJmNDk1M2QzMDE5ODFkNShkYXRlKSB7XG4gICAgaWYgKGRhdGUuY2FsZW5kYXIuZ2V0TWluaW11bURheUluTW9udGgpIHJldHVybiBkYXRlLmNhbGVuZGFyLmdldE1pbmltdW1EYXlJbk1vbnRoKGRhdGUpO1xuICAgIHJldHVybiAxO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDQyYzgxYTQ0NGZiZmI1ZDQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgbGV0IGRheU9mV2VlayA9ICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQyMDYxMDU2ZDA2ZDdjZGY3KGRhdGUsIGxvY2FsZSk7XG4gICAgcmV0dXJuIGRhdGUuc3VidHJhY3Qoe1xuICAgICAgICBkYXlzOiBkYXlPZldlZWtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlZjhiNmQ5MTMzMDg0ZjRlKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNDJjODFhNDQ0ZmJmYjVkNChkYXRlLCBsb2NhbGUpLmFkZCh7XG4gICAgICAgIGRheXM6IDZcbiAgICB9KTtcbn1cbmNvbnN0ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRjYWNoZWRSZWdpb25zID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJGdldFJlZ2lvbihsb2NhbGUpIHtcbiAgICAvLyBJZiB0aGUgSW50bC5Mb2NhbGUgQVBJIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIGdldCB0aGUgcmVnaW9uIGZvciB0aGUgbG9jYWxlLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoSW50bC5Mb2NhbGUpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0aW5nIGFuIEludGwuTG9jYWxlIGlzIGV4cGVuc2l2ZSwgc28gY2FjaGUgdGhlIHJlc3VsdC5cbiAgICAgICAgbGV0IHJlZ2lvbiA9ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRjYWNoZWRSZWdpb25zLmdldChsb2NhbGUpO1xuICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVnaW9uID0gbmV3IEludGwuTG9jYWxlKGxvY2FsZSkubWF4aW1pemUoKS5yZWdpb247XG4gICAgICAgICAgICBpZiAocmVnaW9uKSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkY2FjaGVkUmVnaW9ucy5zZXQobG9jYWxlLCByZWdpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWdpb247XG4gICAgfVxuICAgIC8vIElmIG5vdCwganVzdCB0cnkgc3BsaXR0aW5nIHRoZSBzdHJpbmcuXG4gICAgLy8gSWYgdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBsb2NhbGUgc3RyaW5nIGlzICd1JyxcbiAgICAvLyB0aGVuIHRoaXMgaXMgYSB1bmljb2RlIGV4dGVuc2lvbiwgc28gaWdub3JlIGl0LlxuICAgIC8vIE90aGVyd2lzZSwgaXQgc2hvdWxkIGJlIHRoZSByZWdpb24uXG4gICAgbGV0IHBhcnQgPSBsb2NhbGUuc3BsaXQoJy0nKVsxXTtcbiAgICByZXR1cm4gcGFydCA9PT0gJ3UnID8gdW5kZWZpbmVkIDogcGFydDtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRnZXRXZWVrU3RhcnQobG9jYWxlKSB7XG4gICAgLy8gVE9ETzogdXNlIEludGwuTG9jYWxlIGZvciB0aGlzIG9uY2UgYnJvd3NlcnMgc3VwcG9ydCB0aGUgd2Vla0luZm8gcHJvcGVydHlcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pbnRsLWxvY2FsZS1pbmZvXG4gICAgbGV0IHJlZ2lvbiA9ICQxNGUwZjI0ZWY0YWM1YzkyJHZhciRnZXRSZWdpb24obG9jYWxlKTtcbiAgICByZXR1cm4gcmVnaW9uID8gKDAsICQyZmUyODZkMmZiNDQ5YWJiJGV4cG9ydCQ3YTVhY2JkNzdkNDE0YmQ5KVtyZWdpb25dIHx8IDAgOiAwO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGNjYzFiMjQ3OWU3ZGQ2NTQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgbGV0IGRheXMgPSBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKCQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQyMDYxMDU2ZDA2ZDdjZGY3KCQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlKGRhdGUpLCBsb2NhbGUpICsgZGF5cykgLyA3KTtcbn1cbmZ1bmN0aW9uICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YzMzM2ExMTZlOTQ5Y2RkKGEsIGIpIHtcbiAgICBpZiAoYSAmJiBiKSByZXR1cm4gYS5jb21wYXJlKGIpIDw9IDAgPyBhIDogYjtcbiAgICByZXR1cm4gYSB8fCBiO1xufVxuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE3NWYyYmZmNTc4MTEwNTUoYSwgYikge1xuICAgIGlmIChhICYmIGIpIHJldHVybiBhLmNvbXBhcmUoYikgPj0gMCA/IGEgOiBiO1xuICAgIHJldHVybiBhIHx8IGI7XG59XG5jb25zdCAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkV0VFS0VORF9EQVRBID0ge1xuICAgIEFGOiBbXG4gICAgICAgIDQsXG4gICAgICAgIDVcbiAgICBdLFxuICAgIEFFOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIEJIOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIERaOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIEVHOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIElMOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIElROiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIElSOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDVcbiAgICBdLFxuICAgIEpPOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIEtXOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIExZOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIE9NOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFFBOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFNBOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFNEOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFNZOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdLFxuICAgIFlFOiBbXG4gICAgICAgIDUsXG4gICAgICAgIDZcbiAgICBdXG59O1xuZnVuY3Rpb24gJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDYxOGQ2MGVhMjk5ZGE0MihkYXRlLCBsb2NhbGUpIHtcbiAgICBsZXQganVsaWFuID0gZGF0ZS5jYWxlbmRhci50b0p1bGlhbkRheShkYXRlKTtcbiAgICAvLyBJZiBqdWxpYW4gaXMgbmVnYXRpdmUsIHRoZW4ganVsaWFuICUgNyB3aWxsIGJlIG5lZ2F0aXZlLCBzbyB3ZSBhZGp1c3RcbiAgICAvLyBhY2NvcmRpbmdseS4gIEp1bGlhbiBkYXkgMCBpcyBNb25kYXkuXG4gICAgbGV0IGRheU9mV2VlayA9IE1hdGguY2VpbChqdWxpYW4gKyAxKSAlIDc7XG4gICAgaWYgKGRheU9mV2VlayA8IDApIGRheU9mV2VlayArPSA3O1xuICAgIGxldCByZWdpb24gPSAkMTRlMGYyNGVmNGFjNWM5MiR2YXIkZ2V0UmVnaW9uKGxvY2FsZSk7XG4gICAgLy8gVXNlIEludGwuTG9jYWxlIGZvciB0aGlzIG9uY2Ugd2Vla0luZm8gaXMgc3VwcG9ydGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWludGwtbG9jYWxlLWluZm9cbiAgICBsZXQgW3N0YXJ0LCBlbmRdID0gJDE0ZTBmMjRlZjRhYzVjOTIkdmFyJFdFRUtFTkRfREFUQVtyZWdpb25dIHx8IFtcbiAgICAgICAgNixcbiAgICAgICAgMFxuICAgIF07XG4gICAgcmV0dXJuIGRheU9mV2VlayA9PT0gc3RhcnQgfHwgZGF5T2ZXZWVrID09PSBlbmQ7XG59XG5mdW5jdGlvbiAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWU5ZDg3MjU4ZTFkMTllZChkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gISQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MThkNjBlYTI5OWRhNDIoZGF0ZSwgbG9jYWxlKTtcbn1cblxuXG5leHBvcnQgeyQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlYTM5ZWMxOTc5OTNhZWYwIGFzIGlzU2FtZURheSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGExOGM4OWNiZDI0MTcwZmYgYXMgaXNTYW1lTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhNWEzYjQ1NGFkYTIyNjhlIGFzIHN0YXJ0T2ZNb250aCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDU4NDFmOWViOTc3M2YyNWYgYXMgaXNTYW1lWWVhciwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGY5MWU4OWQzZDA0MDYxMDIgYXMgc3RhcnRPZlllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ5MWI2MmViZjJiYTcwM2VlIGFzIGlzRXF1YWxEYXksICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1YThkYTBjNDRhM2FmZGYyIGFzIGlzRXF1YWxNb250aCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGVhODQwZjVhNmRkYTgxNDcgYXMgaXNFcXVhbFllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2MjliMGE0OTdhYTY1MjY3IGFzIGlzVG9kYXksICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRkMGJkZjQ1YWYwM2E2ZWEzIGFzIHRvZGF5LCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkMjA2MTA1NmQwNmQ3Y2RmNyBhcyBnZXREYXlPZldlZWssICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ0NjE5MzlkZDQ0MjIxNTMgYXMgbm93LCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNjg3ODFkZGYzMWMwMDkwZiBhcyBjb21wYXJlRGF0ZSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGMxOWE4MGE5NzIxYjgwZjYgYXMgY29tcGFyZVRpbWUsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQxMjZjOTFjOTQxZGU3ZSBhcyBnZXRIb3Vyc0luRGF5LCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMiBhcyBnZXRMb2NhbFRpbWVab25lLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYTIyNThkOWM0MTE4ODI1YyBhcyBlbmRPZk1vbnRoLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkOGI3YWE1NWM2NmQ1NTY5ZSBhcyBlbmRPZlllYXIsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ1NDEyYWMxMTcxM2I3MmFkIGFzIGdldE1pbmltdW1Nb250aEluWWVhciwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGIyZjQ5NTNkMzAxOTgxZDUgYXMgZ2V0TWluaW11bURheUluTW9udGgsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ0MmM4MWE0NDRmYmZiNWQ0IGFzIHN0YXJ0T2ZXZWVrLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkZWY4YjZkOTEzMzA4NGY0ZSBhcyBlbmRPZldlZWssICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRjY2MxYjI0NzllN2RkNjU0IGFzIGdldFdlZWtzSW5Nb250aCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDVjMzMzYTExNmU5NDljZGQgYXMgbWluRGF0ZSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JGE3NWYyYmZmNTc4MTEwNTUgYXMgbWF4RGF0ZSwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDYxOGQ2MGVhMjk5ZGE0MiBhcyBpc1dlZWtlbmQsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRlZTlkODcyNThlMWQxOWVkIGFzIGlzV2Vla2RheX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyaWVzLm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydCB7Q2FsZW5kYXJEYXRlIGFzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmLCBDYWxlbmRhckRhdGVUaW1lIGFzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmLCBUaW1lIGFzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ2ODBlYTE5NmVmZmNlNWYsIFpvbmVkRGF0ZVRpbWUgYXMgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWF9IGZyb20gXCIuL0NhbGVuZGFyRGF0ZS5tanNcIjtcbmltcG9ydCB7Y29uc3RyYWluIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyfSBmcm9tIFwiLi9tYW5pcHVsYXRpb24ubWpzXCI7XG5pbXBvcnQge2dldEV4dGVuZGVkWWVhciBhcyAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkYzM2ZTBlY2IyZDRmYTY5ZCwgR3JlZ29yaWFuQ2FsZW5kYXIgYXMgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWN9IGZyb20gXCIuL0dyZWdvcmlhbkNhbGVuZGFyLm1qc1wiO1xuaW1wb3J0IHtnZXRMb2NhbFRpbWVab25lIGFzICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyfSBmcm9tIFwiLi9xdWVyaWVzLm1qc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gdGhlIFRDMzkgVGVtcG9yYWwgcHJvcG9zYWwuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgY2FuIGJlIGZvdW5kIGluIHRoZSBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblxuXG5cblxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYihkYXRlKSB7XG4gICAgZGF0ZSA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKGRhdGUsIG5ldyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpKCkpO1xuICAgIGxldCB5ZWFyID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRjMzZlMGVjYjJkNGZhNjlkKShkYXRlLmVyYSwgZGF0ZS55ZWFyKTtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckdmFyJGVwb2NoRnJvbVBhcnRzKHllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5LCBkYXRlLmhvdXIsIGRhdGUubWludXRlLCBkYXRlLnNlY29uZCwgZGF0ZS5taWxsaXNlY29uZCk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZXBvY2hGcm9tUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgLy8gTm90ZTogRGF0ZS5VVEMoKSBpbnRlcnByZXRzIG9uZSBhbmQgdHdvLWRpZ2l0IHllYXJzIGFzIGJlaW5nIGluIHRoZVxuICAgIC8vIDIwdGggY2VudHVyeSwgc28gZG9uJ3QgdXNlIGl0XG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcywgdGltZVpvbmUpIHtcbiAgICAvLyBGYXN0IHBhdGggZm9yIFVUQy5cbiAgICBpZiAodGltZVpvbmUgPT09ICdVVEMnKSByZXR1cm4gMDtcbiAgICAvLyBGYXN0IHBhdGg6IGZvciBsb2NhbCB0aW1lem9uZSBhZnRlciAxOTcwLCB1c2UgbmF0aXZlIERhdGUuXG4gICAgaWYgKG1zID4gMCAmJiB0aW1lWm9uZSA9PT0gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpKSByZXR1cm4gbmV3IERhdGUobXMpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtNjAwMDA7XG4gICAgbGV0IHsgeWVhcjogeWVhciwgbW9udGg6IG1vbnRoLCBkYXk6IGRheSwgaG91cjogaG91ciwgbWludXRlOiBtaW51dGUsIHNlY29uZDogc2Vjb25kIH0gPSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VGltZVpvbmVQYXJ0cyhtcywgdGltZVpvbmUpO1xuICAgIGxldCB1dGMgPSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZXBvY2hGcm9tUGFydHMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIDApO1xuICAgIHJldHVybiB1dGMgLSBNYXRoLmZsb29yKG1zIC8gMTAwMCkgKiAxMDAwO1xufVxuY29uc3QgJDExZDg3ZjNmNzZlODg2NTckdmFyJGZvcm1hdHRlcnNCeVRpbWVab25lID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckdmFyJGdldFRpbWVab25lUGFydHMobXMsIHRpbWVab25lKSB7XG4gICAgbGV0IGZvcm1hdHRlciA9ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRmb3JtYXR0ZXJzQnlUaW1lWm9uZS5nZXQodGltZVpvbmUpO1xuICAgIGlmICghZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHtcbiAgICAgICAgICAgIHRpbWVab25lOiB0aW1lWm9uZSxcbiAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICBlcmE6ICdzaG9ydCcsXG4gICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnXG4gICAgICAgIH0pO1xuICAgICAgICAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZm9ybWF0dGVyc0J5VGltZVpvbmUuc2V0KHRpbWVab25lLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICBsZXQgcGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZShtcykpO1xuICAgIGxldCBuYW1lZFBhcnRzID0ge307XG4gICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cylpZiAocGFydC50eXBlICE9PSAnbGl0ZXJhbCcpIG5hbWVkUGFydHNbcGFydC50eXBlXSA9IHBhcnQudmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIEIgaW5zdGVhZCBvZiBCQy4uLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzUyMjUzXG4gICAgICAgIHllYXI6IG5hbWVkUGFydHMuZXJhID09PSAnQkMnIHx8IG5hbWVkUGFydHMuZXJhID09PSAnQicgPyAtbmFtZWRQYXJ0cy55ZWFyICsgMSA6ICtuYW1lZFBhcnRzLnllYXIsXG4gICAgICAgIG1vbnRoOiArbmFtZWRQYXJ0cy5tb250aCxcbiAgICAgICAgZGF5OiArbmFtZWRQYXJ0cy5kYXksXG4gICAgICAgIGhvdXI6IG5hbWVkUGFydHMuaG91ciA9PT0gJzI0JyA/IDAgOiArbmFtZWRQYXJ0cy5ob3VyLFxuICAgICAgICBtaW51dGU6ICtuYW1lZFBhcnRzLm1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiArbmFtZWRQYXJ0cy5zZWNvbmRcbiAgICB9O1xufVxuY29uc3QgJDExZDg3ZjNmNzZlODg2NTckdmFyJERBWU1JTExJUyA9IDg2NDAwMDAwO1xuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDEzNmYzOGVmZTdjYWY1NDkoZGF0ZSwgdGltZVpvbmUpIHtcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGUpO1xuICAgIGxldCBlYXJsaWVyID0gbXMgLSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcyAtICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMsIHRpbWVab25lKTtcbiAgICBsZXQgbGF0ZXIgPSBtcyAtICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1OWM5OWYzNTE1ZDM0OTNmKG1zICsgJDExZDg3ZjNmNzZlODg2NTckdmFyJERBWU1JTExJUywgdGltZVpvbmUpO1xuICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VmFsaWRXYWxsVGltZXMoZGF0ZSwgdGltZVpvbmUsIGVhcmxpZXIsIGxhdGVyKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRnZXRWYWxpZFdhbGxUaW1lcyhkYXRlLCB0aW1lWm9uZSwgZWFybGllciwgbGF0ZXIpIHtcbiAgICBsZXQgZm91bmQgPSBlYXJsaWVyID09PSBsYXRlciA/IFtcbiAgICAgICAgZWFybGllclxuICAgIF0gOiBbXG4gICAgICAgIGVhcmxpZXIsXG4gICAgICAgIGxhdGVyXG4gICAgXTtcbiAgICByZXR1cm4gZm91bmQuZmlsdGVyKChhYnNvbHV0ZSk9PiQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRpc1ZhbGlkV2FsbFRpbWUoZGF0ZSwgdGltZVpvbmUsIGFic29sdXRlKSk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkaXNWYWxpZFdhbGxUaW1lKGRhdGUsIHRpbWVab25lLCBhYnNvbHV0ZSkge1xuICAgIGxldCBwYXJ0cyA9ICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciRnZXRUaW1lWm9uZVBhcnRzKGFic29sdXRlLCB0aW1lWm9uZSk7XG4gICAgcmV0dXJuIGRhdGUueWVhciA9PT0gcGFydHMueWVhciAmJiBkYXRlLm1vbnRoID09PSBwYXJ0cy5tb250aCAmJiBkYXRlLmRheSA9PT0gcGFydHMuZGF5ICYmIGRhdGUuaG91ciA9PT0gcGFydHMuaG91ciAmJiBkYXRlLm1pbnV0ZSA9PT0gcGFydHMubWludXRlICYmIGRhdGUuc2Vjb25kID09PSBwYXJ0cy5zZWNvbmQ7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YyhkYXRlLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24gPSAnY29tcGF0aWJsZScpIHtcbiAgICBsZXQgZGF0ZVRpbWUgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NChkYXRlKTtcbiAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSB0aW1lIHpvbmUgaXMgVVRDLCB1c2UgbmF0aXZlIERhdGUuXG4gICAgaWYgKHRpbWVab25lID09PSAnVVRDJykgcmV0dXJuICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIoZGF0ZVRpbWUpO1xuICAgIC8vIEZhc3QgcGF0aDogaWYgdGhlIHRpbWUgem9uZSBpcyB0aGUgbG9jYWwgdGltZXpvbmUgYW5kIGRpc2FtYmlndWF0aW9uIGlzIGNvbXBhdGlibGUsIHVzZSBuYXRpdmUgRGF0ZS5cbiAgICBpZiAodGltZVpvbmUgPT09ICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMikoKSAmJiBkaXNhbWJpZ3VhdGlvbiA9PT0gJ2NvbXBhdGlibGUnKSB7XG4gICAgICAgIGRhdGVUaW1lID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIoZGF0ZVRpbWUsIG5ldyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpKCkpO1xuICAgICAgICAvLyBEb24ndCB1c2UgRGF0ZSBjb25zdHJ1Y3RvciBoZXJlIGJlY2F1c2UgdHdvLWRpZ2l0IHllYXJzIGFyZSBpbnRlcnByZXRlZCBpbiB0aGUgMjB0aCBjZW50dXJ5LlxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCB5ZWFyID0gKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCRjMzZlMGVjYjJkNGZhNjlkKShkYXRlVGltZS5lcmEsIGRhdGVUaW1lLnllYXIpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIsIGRhdGVUaW1lLm1vbnRoIC0gMSwgZGF0ZVRpbWUuZGF5KTtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhkYXRlVGltZS5ob3VyLCBkYXRlVGltZS5taW51dGUsIGRhdGVUaW1lLnNlY29uZCwgZGF0ZVRpbWUubWlsbGlzZWNvbmQpO1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGxldCBtcyA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIoZGF0ZVRpbWUpO1xuICAgIGxldCBvZmZzZXRCZWZvcmUgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcyAtICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMsIHRpbWVab25lKTtcbiAgICBsZXQgb2Zmc2V0QWZ0ZXIgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcyArICQxMWQ4N2YzZjc2ZTg4NjU3JHZhciREQVlNSUxMSVMsIHRpbWVab25lKTtcbiAgICBsZXQgdmFsaWQgPSAkMTFkODdmM2Y3NmU4ODY1NyR2YXIkZ2V0VmFsaWRXYWxsVGltZXMoZGF0ZVRpbWUsIHRpbWVab25lLCBtcyAtIG9mZnNldEJlZm9yZSwgbXMgLSBvZmZzZXRBZnRlcik7XG4gICAgaWYgKHZhbGlkLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHZhbGlkWzBdO1xuICAgIGlmICh2YWxpZC5sZW5ndGggPiAxKSBzd2l0Y2goZGlzYW1iaWd1YXRpb24pe1xuICAgICAgICAvLyAnY29tcGF0aWJsZScgbWVhbnMgJ2VhcmxpZXInIGZvciBcImZhbGwgYmFja1wiIHRyYW5zaXRpb25zXG4gICAgICAgIGNhc2UgJ2NvbXBhdGlibGUnOlxuICAgICAgICBjYXNlICdlYXJsaWVyJzpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFswXTtcbiAgICAgICAgY2FzZSAnbGF0ZXInOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkW3ZhbGlkLmxlbmd0aCAtIDFdO1xuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ011bHRpcGxlIHBvc3NpYmxlIGFic29sdXRlIHRpbWVzIGZvdW5kJyk7XG4gICAgfVxuICAgIHN3aXRjaChkaXNhbWJpZ3VhdGlvbil7XG4gICAgICAgIGNhc2UgJ2VhcmxpZXInOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG1zIC0gb2Zmc2V0QmVmb3JlLCBtcyAtIG9mZnNldEFmdGVyKTtcbiAgICAgICAgLy8gJ2NvbXBhdGlibGUnIG1lYW5zICdsYXRlcicgZm9yIFwic3ByaW5nIGZvcndhcmRcIiB0cmFuc2l0aW9uc1xuICAgICAgICBjYXNlICdjb21wYXRpYmxlJzpcbiAgICAgICAgY2FzZSAnbGF0ZXInOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1zIC0gb2Zmc2V0QmVmb3JlLCBtcyAtIG9mZnNldEFmdGVyKTtcbiAgICAgICAgY2FzZSAncmVqZWN0JzpcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdObyBzdWNoIGFic29sdXRlIHRpbWUgZm91bmQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTY3YTA5NWM2MjBiODZmZShkYXRlVGltZSwgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uID0gJ2NvbXBhdGlibGUnKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKGRhdGVUaW1lLCB0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKG1zLCB0aW1lWm9uZSkge1xuICAgIGxldCBvZmZzZXQgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTljOTlmMzUxNWQzNDkzZihtcywgdGltZVpvbmUpO1xuICAgIGxldCBkYXRlID0gbmV3IERhdGUobXMgKyBvZmZzZXQpO1xuICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIGxldCBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgbGV0IGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIGxldCBob3VyID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGxldCBtaW51dGUgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICBsZXQgc2Vjb25kID0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgbGV0IG1pbGxpc2Vjb25kID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSkoeWVhciA8IDEgPyAnQkMnIDogJ0FEJywgeWVhciA8IDEgPyAteWVhciArIDEgOiB5ZWFyLCBtb250aCwgZGF5LCB0aW1lWm9uZSwgb2Zmc2V0LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU1N2ZmMTAwZDkxYmQ0YjkoZGF0ZSwgdGltZVpvbmUpIHtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMoZGF0ZS5nZXRUaW1lKCksIHRpbWVab25lKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRkN2Y5MmJjZDM1OTZiMDg2KGRhdGUpIHtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGU1N2ZmMTAwZDkxYmQ0YjkoZGF0ZSwgKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ5MzUyMmQxYTQzOWYzNjE3KGRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYpKGRhdGVUaW1lLmNhbGVuZGFyLCBkYXRlVGltZS5lcmEsIGRhdGVUaW1lLnllYXIsIGRhdGVUaW1lLm1vbnRoLCBkYXRlVGltZS5kYXkpO1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDZmNGQ3ODE0OWYzZjUzYWMoZGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVyYTogZGF0ZS5lcmEsXG4gICAgICAgIHllYXI6IGRhdGUueWVhcixcbiAgICAgICAgbW9udGg6IGRhdGUubW9udGgsXG4gICAgICAgIGRheTogZGF0ZS5kYXlcbiAgICB9O1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDRkMDM5M2U3MzI4NTdiZTUoZGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhvdXI6IGRhdGUuaG91cixcbiAgICAgICAgbWludXRlOiBkYXRlLm1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBkYXRlLnNlY29uZCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGRhdGUubWlsbGlzZWNvbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQoZGF0ZSwgdGltZSkge1xuICAgIGxldCBob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCwgbWlsbGlzZWNvbmQgPSAwO1xuICAgIGlmICgndGltZVpvbmUnIGluIGRhdGUpICh7IGhvdXI6IGhvdXIsIG1pbnV0ZTogbWludXRlLCBzZWNvbmQ6IHNlY29uZCwgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kIH0gPSBkYXRlKTtcbiAgICBlbHNlIGlmICgnaG91cicgaW4gZGF0ZSAmJiAhdGltZSkgcmV0dXJuIGRhdGU7XG4gICAgaWYgKHRpbWUpICh7IGhvdXI6IGhvdXIsIG1pbnV0ZTogbWludXRlLCBzZWNvbmQ6IHNlY29uZCwgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kIH0gPSB0aW1lKTtcbiAgICByZXR1cm4gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZikoZGF0ZS5jYWxlbmRhciwgZGF0ZS5lcmEsIGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZDMzZjc5ZTNmZmMzZGM4MyhkYXRlVGltZSkge1xuICAgIHJldHVybiBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ2ODBlYTE5NmVmZmNlNWYpKGRhdGVUaW1lLmhvdXIsIGRhdGVUaW1lLm1pbnV0ZSwgZGF0ZVRpbWUuc2Vjb25kLCBkYXRlVGltZS5taWxsaXNlY29uZCk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMihkYXRlLCBjYWxlbmRhcikge1xuICAgIGlmIChkYXRlLmNhbGVuZGFyLmlkZW50aWZpZXIgPT09IGNhbGVuZGFyLmlkZW50aWZpZXIpIHJldHVybiBkYXRlO1xuICAgIGxldCBjYWxlbmRhckRhdGUgPSBjYWxlbmRhci5mcm9tSnVsaWFuRGF5KGRhdGUuY2FsZW5kYXIudG9KdWxpYW5EYXkoZGF0ZSkpO1xuICAgIGxldCBjb3B5ID0gZGF0ZS5jb3B5KCk7XG4gICAgY29weS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIGNvcHkuZXJhID0gY2FsZW5kYXJEYXRlLmVyYTtcbiAgICBjb3B5LnllYXIgPSBjYWxlbmRhckRhdGUueWVhcjtcbiAgICBjb3B5Lm1vbnRoID0gY2FsZW5kYXJEYXRlLm1vbnRoO1xuICAgIGNvcHkuZGF5ID0gY2FsZW5kYXJEYXRlLmRheTtcbiAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIpKGNvcHkpO1xuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDg0Yzk1YTgzYzc5OWUwNzQoZGF0ZSwgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uKSB7XG4gICAgaWYgKGRhdGUgaW5zdGFuY2VvZiAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEpKSB7XG4gICAgICAgIGlmIChkYXRlLnRpbWVab25lID09PSB0aW1lWm9uZSkgcmV0dXJuIGRhdGU7XG4gICAgICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NShkYXRlLCB0aW1lWm9uZSk7XG4gICAgfVxuICAgIGxldCBtcyA9ICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKGRhdGUsIHRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgcmV0dXJuICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKG1zLCB0aW1lWm9uZSk7XG59XG5mdW5jdGlvbiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkODNhYWMwN2I0YzM3YjI1KGRhdGUpIHtcbiAgICBsZXQgbXMgPSAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKGRhdGUpIC0gZGF0ZS5vZmZzZXQ7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MzhiMDAwMzNjYzExYzc1KGRhdGUsIHRpbWVab25lKSB7XG4gICAgbGV0IG1zID0gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGJkNGZiMmJjOGJiMDZmYihkYXRlKSAtIGRhdGUub2Zmc2V0O1xuICAgIHJldHVybiAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMigkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYyhtcywgdGltZVpvbmUpLCBkYXRlLmNhbGVuZGFyKTtcbn1cbmZ1bmN0aW9uICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRkOWI2N2JjOTNjMDk3NDkxKGRhdGUpIHtcbiAgICByZXR1cm4gJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUzOGIwMDAzM2NjMTFjNzUoZGF0ZSwgKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpKTtcbn1cblxuXG5leHBvcnQgeyQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIgYXMgZXBvY2hGcm9tRGF0ZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIgYXMgdG9DYWxlbmRhciwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDU5Yzk5ZjM1MTVkMzQ5M2YgYXMgZ2V0VGltZVpvbmVPZmZzZXQsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxMzZmMzhlZmU3Y2FmNTQ5IGFzIHBvc3NpYmxlQWJzb2x1dGVzLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YyBhcyB0b0Fic29sdXRlLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCBhcyB0b0NhbGVuZGFyRGF0ZVRpbWUsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRlNjdhMDk1YzYyMGI4NmZlIGFzIHRvRGF0ZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMgYXMgZnJvbUFic29sdXRlLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTU3ZmYxMDBkOTFiZDRiOSBhcyBmcm9tRGF0ZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGQ3ZjkyYmNkMzU5NmIwODYgYXMgZnJvbURhdGVUb0xvY2FsLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkOTM1MjJkMWE0MzlmMzYxNyBhcyB0b0NhbGVuZGFyRGF0ZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDZmNGQ3ODE0OWYzZjUzYWMgYXMgdG9EYXRlRmllbGRzLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNGQwMzkzZTczMjg1N2JlNSBhcyB0b1RpbWVGaWVsZHMsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRkMzNmNzllM2ZmYzNkYzgzIGFzIHRvVGltZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDg0Yzk1YTgzYzc5OWUwNzQgYXMgdG9ab25lZCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUzOGIwMDAzM2NjMTFjNzUgYXMgdG9UaW1lWm9uZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDgzYWFjMDdiNGMzN2IyNSBhcyB6b25lZFRvRGF0ZSwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGQ5YjY3YmM5M2MwOTc0OTEgYXMgdG9Mb2NhbFRpbWVab25lfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnNpb24ubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0IHtlcG9jaEZyb21EYXRlIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIsIGZyb21BYnNvbHV0ZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYywgdG9BYnNvbHV0ZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YywgdG9DYWxlbmRhciBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMiwgdG9DYWxlbmRhckRhdGVUaW1lIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0fSBmcm9tIFwiLi9jb252ZXJzaW9uLm1qc1wiO1xuaW1wb3J0IHtHcmVnb3JpYW5DYWxlbmRhciBhcyAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllY30gZnJvbSBcIi4vR3JlZ29yaWFuQ2FsZW5kYXIubWpzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJE9ORV9IT1VSID0gMzYwMDAwMDtcbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlMTZkODUyMGFmNDRhMDk2KGRhdGUsIGR1cmF0aW9uKSB7XG4gICAgbGV0IG11dGFibGVEYXRlID0gZGF0ZS5jb3B5KCk7XG4gICAgbGV0IGRheXMgPSAnaG91cicgaW4gbXV0YWJsZURhdGUgPyAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYWRkVGltZUZpZWxkcyhtdXRhYmxlRGF0ZSwgZHVyYXRpb24pIDogMDtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYWRkWWVhcnMobXV0YWJsZURhdGUsIGR1cmF0aW9uLnllYXJzIHx8IDApO1xuICAgIGlmIChtdXRhYmxlRGF0ZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKG11dGFibGVEYXRlLCBkYXRlKTtcbiAgICBtdXRhYmxlRGF0ZS5tb250aCArPSBkdXJhdGlvbi5tb250aHMgfHwgMDtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZVllYXJNb250aChtdXRhYmxlRGF0ZSk7XG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGNvbnN0cmFpbk1vbnRoRGF5KG11dGFibGVEYXRlKTtcbiAgICBtdXRhYmxlRGF0ZS5kYXkgKz0gKGR1cmF0aW9uLndlZWtzIHx8IDApICogNztcbiAgICBtdXRhYmxlRGF0ZS5kYXkgKz0gZHVyYXRpb24uZGF5cyB8fCAwO1xuICAgIG11dGFibGVEYXRlLmRheSArPSBkYXlzO1xuICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRiYWxhbmNlRGF5KG11dGFibGVEYXRlKTtcbiAgICBpZiAobXV0YWJsZURhdGUuY2FsZW5kYXIuYmFsYW5jZURhdGUpIG11dGFibGVEYXRlLmNhbGVuZGFyLmJhbGFuY2VEYXRlKG11dGFibGVEYXRlKTtcbiAgICAvLyBDb25zdHJhaW4gaW4gY2FzZSBhZGRpbmcgZW5kZWQgdXAgd2l0aCBhIGRhdGUgb3V0c2lkZSB0aGUgdmFsaWQgcmFuZ2UgZm9yIHRoZSBjYWxlbmRhciBzeXN0ZW0uXG4gICAgLy8gVGhlIGJlaGF2aW9yIGhlcmUgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gd2hlbiBjb25zdHJhaW5pbmcgaW4gdGhlIGBzZXRgIGZ1bmN0aW9uIGluIHRoYXRcbiAgICAvLyB3ZSBhZGp1c3Qgc21hbGxlciBmaWVsZHMgdG8gdGhlaXIgbWluaW11bS9tYXhpbXVtIHZhbHVlcyByYXRoZXIgdGhhbiBjb25zdHJhaW5pbmcgZWFjaCBmaWVsZFxuICAgIC8vIGluZGl2aWR1YWxseS4gVGhpcyBtYXRjaGVzIHRoZSBnZW5lcmFsIGJlaGF2aW9yIG9mIGBhZGRgIHZzIGBzZXRgIHJlZ2FyZGluZyBob3cgZmllbGRzIGFyZSBiYWxhbmNlZC5cbiAgICBpZiAobXV0YWJsZURhdGUueWVhciA8IDEpIHtcbiAgICAgICAgbXV0YWJsZURhdGUueWVhciA9IDE7XG4gICAgICAgIG11dGFibGVEYXRlLm1vbnRoID0gMTtcbiAgICAgICAgbXV0YWJsZURhdGUuZGF5ID0gMTtcbiAgICB9XG4gICAgbGV0IG1heFllYXIgPSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXRZZWFyc0luRXJhKG11dGFibGVEYXRlKTtcbiAgICBpZiAobXV0YWJsZURhdGUueWVhciA+IG1heFllYXIpIHtcbiAgICAgICAgdmFyIF9tdXRhYmxlRGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEsIF9tdXRhYmxlRGF0ZV9jYWxlbmRhcjtcbiAgICAgICAgbGV0IGlzSW52ZXJzZUVyYSA9IChfbXV0YWJsZURhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhID0gKF9tdXRhYmxlRGF0ZV9jYWxlbmRhciA9IG11dGFibGVEYXRlLmNhbGVuZGFyKS5pc0ludmVyc2VFcmEpID09PSBudWxsIHx8IF9tdXRhYmxlRGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tdXRhYmxlRGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEuY2FsbChfbXV0YWJsZURhdGVfY2FsZW5kYXIsIG11dGFibGVEYXRlKTtcbiAgICAgICAgbXV0YWJsZURhdGUueWVhciA9IG1heFllYXI7XG4gICAgICAgIG11dGFibGVEYXRlLm1vbnRoID0gaXNJbnZlcnNlRXJhID8gMSA6IG11dGFibGVEYXRlLmNhbGVuZGFyLmdldE1vbnRoc0luWWVhcihtdXRhYmxlRGF0ZSk7XG4gICAgICAgIG11dGFibGVEYXRlLmRheSA9IGlzSW52ZXJzZUVyYSA/IDEgOiBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChtdXRhYmxlRGF0ZSk7XG4gICAgfVxuICAgIGlmIChtdXRhYmxlRGF0ZS5tb250aCA8IDEpIHtcbiAgICAgICAgbXV0YWJsZURhdGUubW9udGggPSAxO1xuICAgICAgICBtdXRhYmxlRGF0ZS5kYXkgPSAxO1xuICAgIH1cbiAgICBsZXQgbWF4TW9udGggPSBtdXRhYmxlRGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIobXV0YWJsZURhdGUpO1xuICAgIGlmIChtdXRhYmxlRGF0ZS5tb250aCA+IG1heE1vbnRoKSB7XG4gICAgICAgIG11dGFibGVEYXRlLm1vbnRoID0gbWF4TW9udGg7XG4gICAgICAgIG11dGFibGVEYXRlLmRheSA9IG11dGFibGVEYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKG11dGFibGVEYXRlKTtcbiAgICB9XG4gICAgbXV0YWJsZURhdGUuZGF5ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4obXV0YWJsZURhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgobXV0YWJsZURhdGUpLCBtdXRhYmxlRGF0ZS5kYXkpKTtcbiAgICByZXR1cm4gbXV0YWJsZURhdGU7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYWRkWWVhcnMoZGF0ZSwgeWVhcnMpIHtcbiAgICB2YXIgX2RhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLCBfZGF0ZV9jYWxlbmRhcjtcbiAgICBpZiAoKF9kYXRlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSA9IChfZGF0ZV9jYWxlbmRhciA9IGRhdGUuY2FsZW5kYXIpLmlzSW52ZXJzZUVyYSkgPT09IG51bGwgfHwgX2RhdGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0ZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEuY2FsbChfZGF0ZV9jYWxlbmRhciwgZGF0ZSkpIHllYXJzID0gLXllYXJzO1xuICAgIGRhdGUueWVhciArPSB5ZWFycztcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRiYWxhbmNlWWVhck1vbnRoKGRhdGUpIHtcbiAgICB3aGlsZShkYXRlLm1vbnRoIDwgMSl7XG4gICAgICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRZZWFycyhkYXRlLCAtMSk7XG4gICAgICAgIGRhdGUubW9udGggKz0gZGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIoZGF0ZSk7XG4gICAgfVxuICAgIGxldCBtb250aHNJblllYXIgPSAwO1xuICAgIHdoaWxlKGRhdGUubW9udGggPiAobW9udGhzSW5ZZWFyID0gZGF0ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIoZGF0ZSkpKXtcbiAgICAgICAgZGF0ZS5tb250aCAtPSBtb250aHNJblllYXI7XG4gICAgICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRZZWFycyhkYXRlLCAxKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZURheShkYXRlKSB7XG4gICAgd2hpbGUoZGF0ZS5kYXkgPCAxKXtcbiAgICAgICAgZGF0ZS5tb250aC0tO1xuICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZVllYXJNb250aChkYXRlKTtcbiAgICAgICAgZGF0ZS5kYXkgKz0gZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKTtcbiAgICB9XG4gICAgd2hpbGUoZGF0ZS5kYXkgPiBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKXtcbiAgICAgICAgZGF0ZS5kYXkgLT0gZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKTtcbiAgICAgICAgZGF0ZS5tb250aCsrO1xuICAgICAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkYmFsYW5jZVllYXJNb250aChkYXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY29uc3RyYWluTW9udGhEYXkoZGF0ZSkge1xuICAgIGRhdGUubW9udGggPSBNYXRoLm1heCgxLCBNYXRoLm1pbihkYXRlLmNhbGVuZGFyLmdldE1vbnRoc0luWWVhcihkYXRlKSwgZGF0ZS5tb250aCkpO1xuICAgIGRhdGUuZGF5ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZGF0ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aChkYXRlKSwgZGF0ZS5kYXkpKTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKGRhdGUpIHtcbiAgICBpZiAoZGF0ZS5jYWxlbmRhci5jb25zdHJhaW5EYXRlKSBkYXRlLmNhbGVuZGFyLmNvbnN0cmFpbkRhdGUoZGF0ZSk7XG4gICAgZGF0ZS55ZWFyID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZGF0ZS5jYWxlbmRhci5nZXRZZWFyc0luRXJhKGRhdGUpLCBkYXRlLnllYXIpKTtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY29uc3RyYWluTW9udGhEYXkoZGF0ZSk7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikge1xuICAgIGxldCBpbnZlcnNlRHVyYXRpb24gPSB7fTtcbiAgICBmb3IobGV0IGtleSBpbiBkdXJhdGlvbilpZiAodHlwZW9mIGR1cmF0aW9uW2tleV0gPT09ICdudW1iZXInKSBpbnZlcnNlRHVyYXRpb25ba2V5XSA9IC1kdXJhdGlvbltrZXldO1xuICAgIHJldHVybiBpbnZlcnNlRHVyYXRpb247XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMyhkYXRlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTE2ZDg1MjBhZjQ0YTA5NihkYXRlLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUoZGF0ZSwgZmllbGRzKSB7XG4gICAgbGV0IG11dGFibGVEYXRlID0gZGF0ZS5jb3B5KCk7XG4gICAgaWYgKGZpZWxkcy5lcmEgIT0gbnVsbCkgbXV0YWJsZURhdGUuZXJhID0gZmllbGRzLmVyYTtcbiAgICBpZiAoZmllbGRzLnllYXIgIT0gbnVsbCkgbXV0YWJsZURhdGUueWVhciA9IGZpZWxkcy55ZWFyO1xuICAgIGlmIChmaWVsZHMubW9udGggIT0gbnVsbCkgbXV0YWJsZURhdGUubW9udGggPSBmaWVsZHMubW9udGg7XG4gICAgaWYgKGZpZWxkcy5kYXkgIT0gbnVsbCkgbXV0YWJsZURhdGUuZGF5ID0gZmllbGRzLmRheTtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlRGF0ZSk7XG4gICAgcmV0dXJuIG11dGFibGVEYXRlO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYodmFsdWUsIGZpZWxkcykge1xuICAgIGxldCBtdXRhYmxlVmFsdWUgPSB2YWx1ZS5jb3B5KCk7XG4gICAgaWYgKGZpZWxkcy5ob3VyICE9IG51bGwpIG11dGFibGVWYWx1ZS5ob3VyID0gZmllbGRzLmhvdXI7XG4gICAgaWYgKGZpZWxkcy5taW51dGUgIT0gbnVsbCkgbXV0YWJsZVZhbHVlLm1pbnV0ZSA9IGZpZWxkcy5taW51dGU7XG4gICAgaWYgKGZpZWxkcy5zZWNvbmQgIT0gbnVsbCkgbXV0YWJsZVZhbHVlLnNlY29uZCA9IGZpZWxkcy5zZWNvbmQ7XG4gICAgaWYgKGZpZWxkcy5taWxsaXNlY29uZCAhPSBudWxsKSBtdXRhYmxlVmFsdWUubWlsbGlzZWNvbmQgPSBmaWVsZHMubWlsbGlzZWNvbmQ7XG4gICAgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IobXV0YWJsZVZhbHVlKTtcbiAgICByZXR1cm4gbXV0YWJsZVZhbHVlO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGJhbGFuY2VUaW1lKHRpbWUpIHtcbiAgICB0aW1lLnNlY29uZCArPSBNYXRoLmZsb29yKHRpbWUubWlsbGlzZWNvbmQgLyAxMDAwKTtcbiAgICB0aW1lLm1pbGxpc2Vjb25kID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJG5vbk5lZ2F0aXZlTW9kKHRpbWUubWlsbGlzZWNvbmQsIDEwMDApO1xuICAgIHRpbWUubWludXRlICs9IE1hdGguZmxvb3IodGltZS5zZWNvbmQgLyA2MCk7XG4gICAgdGltZS5zZWNvbmQgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkbm9uTmVnYXRpdmVNb2QodGltZS5zZWNvbmQsIDYwKTtcbiAgICB0aW1lLmhvdXIgKz0gTWF0aC5mbG9vcih0aW1lLm1pbnV0ZSAvIDYwKTtcbiAgICB0aW1lLm1pbnV0ZSA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZCh0aW1lLm1pbnV0ZSwgNjApO1xuICAgIGxldCBkYXlzID0gTWF0aC5mbG9vcih0aW1lLmhvdXIgLyAyNCk7XG4gICAgdGltZS5ob3VyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJG5vbk5lZ2F0aXZlTW9kKHRpbWUuaG91ciwgMjQpO1xuICAgIHJldHVybiBkYXlzO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IodGltZSkge1xuICAgIHRpbWUubWlsbGlzZWNvbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLm1pbGxpc2Vjb25kLCAxMDAwKSk7XG4gICAgdGltZS5zZWNvbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aW1lLnNlY29uZCwgNTkpKTtcbiAgICB0aW1lLm1pbnV0ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUubWludXRlLCA1OSkpO1xuICAgIHRpbWUuaG91ciA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUuaG91ciwgMjMpKTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRub25OZWdhdGl2ZU1vZChhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IGEgJSBiO1xuICAgIGlmIChyZXN1bHQgPCAwKSByZXN1bHQgKz0gYjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGFkZFRpbWVGaWVsZHModGltZSwgZHVyYXRpb24pIHtcbiAgICB0aW1lLmhvdXIgKz0gZHVyYXRpb24uaG91cnMgfHwgMDtcbiAgICB0aW1lLm1pbnV0ZSArPSBkdXJhdGlvbi5taW51dGVzIHx8IDA7XG4gICAgdGltZS5zZWNvbmQgKz0gZHVyYXRpb24uc2Vjb25kcyB8fCAwO1xuICAgIHRpbWUubWlsbGlzZWNvbmQgKz0gZHVyYXRpb24ubWlsbGlzZWNvbmRzIHx8IDA7XG4gICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRiYWxhbmNlVGltZSh0aW1lKTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ3ZWQ4N2I2YmMyNTA2NDcwKHRpbWUsIGR1cmF0aW9uKSB7XG4gICAgbGV0IHJlcyA9IHRpbWUuY29weSgpO1xuICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRhZGRUaW1lRmllbGRzKHJlcywgZHVyYXRpb24pO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZmUzNGQzYTM4MWNkNzUwMSh0aW1lLCBkdXJhdGlvbikge1xuICAgIHJldHVybiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkN2VkODdiNmJjMjUwNjQ3MCh0aW1lLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkM2UyNTQ0ZTg4YTI1YmZmOChkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGQ1MmNlZDZiYWRmYjlhNGModmFsdWUsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpIHtcbiAgICBsZXQgbXV0YWJsZSA9IHZhbHVlLmNvcHkoKTtcbiAgICBzd2l0Y2goZmllbGQpe1xuICAgICAgICBjYXNlICdlcmEnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBlcmFzID0gdmFsdWUuY2FsZW5kYXIuZ2V0RXJhcygpO1xuICAgICAgICAgICAgICAgIGxldCBlcmFJbmRleCA9IGVyYXMuaW5kZXhPZih2YWx1ZS5lcmEpO1xuICAgICAgICAgICAgICAgIGlmIChlcmFJbmRleCA8IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlcmE6ICcgKyB2YWx1ZS5lcmEpO1xuICAgICAgICAgICAgICAgIGVyYUluZGV4ID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUoZXJhSW5kZXgsIGFtb3VudCwgMCwgZXJhcy5sZW5ndGggLSAxLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgICAgIG11dGFibGUuZXJhID0gZXJhc1tlcmFJbmRleF07XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RyYWluIHRoZSB5ZWFyIGFuZCBvdGhlciBmaWVsZHMgd2l0aGluIHRoZSBlcmEsIHNvIHRoZSBlcmEgZG9lc24ndCBjaGFuZ2Ugd2hlbiB3ZSBiYWxhbmNlIGJlbG93LlxuICAgICAgICAgICAgICAgICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKG11dGFibGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHZhciBfbXV0YWJsZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEsIF9tdXRhYmxlX2NhbGVuZGFyO1xuICAgICAgICAgICAgaWYgKChfbXV0YWJsZV9jYWxlbmRhcl9pc0ludmVyc2VFcmEgPSAoX211dGFibGVfY2FsZW5kYXIgPSBtdXRhYmxlLmNhbGVuZGFyKS5pc0ludmVyc2VFcmEpID09PSBudWxsIHx8IF9tdXRhYmxlX2NhbGVuZGFyX2lzSW52ZXJzZUVyYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX211dGFibGVfY2FsZW5kYXJfaXNJbnZlcnNlRXJhLmNhbGwoX211dGFibGVfY2FsZW5kYXIsIG11dGFibGUpKSBhbW91bnQgPSAtYW1vdW50O1xuICAgICAgICAgICAgLy8gVGhlIHllYXIgZmllbGQgc2hvdWxkIG5vdCBjeWNsZSB3aXRoaW4gdGhlIGVyYSBhcyB0aGF0IGNhbiBjYXVzZSB3ZWlyZCBiZWhhdmlvciBhZmZlY3Rpbmcgb3RoZXIgZmllbGRzLlxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhbHNvIGFsbG93IHZhbHVlcyA8IDEgc28gdGhhdCBkZWNyZW1lbnRpbmcgZ29lcyB0byB0aGUgcHJldmlvdXMgZXJhLiBJZiB3ZSBnZXQgLUluZmluaXR5IGJhY2tcbiAgICAgICAgICAgIC8vIHdlIGtub3cgd2Ugd3JhcHBlZCBhcm91bmQgYWZ0ZXIgcmVhY2hpbmcgOTk5OSAodGhlIG1heGltdW0pLCBzbyBzZXQgdGhlIHllYXIgYmFjayB0byAxLlxuICAgICAgICAgICAgbXV0YWJsZS55ZWFyID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUueWVhciwgYW1vdW50LCAtSW5maW5pdHksIDk5OTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICBpZiAobXV0YWJsZS55ZWFyID09PSAtSW5maW5pdHkpIG11dGFibGUueWVhciA9IDE7XG4gICAgICAgICAgICBpZiAobXV0YWJsZS5jYWxlbmRhci5iYWxhbmNlWWVhck1vbnRoKSBtdXRhYmxlLmNhbGVuZGFyLmJhbGFuY2VZZWFyTW9udGgobXV0YWJsZSwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIG11dGFibGUubW9udGggPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5tb250aCwgYW1vdW50LCAxLCB2YWx1ZS5jYWxlbmRhci5nZXRNb250aHNJblllYXIodmFsdWUpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBtdXRhYmxlLmRheSA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKHZhbHVlLmRheSwgYW1vdW50LCAxLCB2YWx1ZS5jYWxlbmRhci5nZXREYXlzSW5Nb250aCh2YWx1ZSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmllbGQgJyArIGZpZWxkKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNhbGVuZGFyLmJhbGFuY2VEYXRlKSB2YWx1ZS5jYWxlbmRhci5iYWxhbmNlRGF0ZShtdXRhYmxlKTtcbiAgICAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYzRlMmVjYWM0OTM1MWVmMihtdXRhYmxlKTtcbiAgICByZXR1cm4gbXV0YWJsZTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkZDAyYjNlMDAwN2RmZTI4KHZhbHVlLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgbGV0IG11dGFibGUgPSB2YWx1ZS5jb3B5KCk7XG4gICAgc3dpdGNoKGZpZWxkKXtcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGhvdXJzID0gdmFsdWUuaG91cjtcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gMjM7XG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaG91ckN5Y2xlKSA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzUE0gPSBob3VycyA+PSAxMjtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gaXNQTSA/IDEyIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gaXNQTSA/IDIzIDogMTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG11dGFibGUuaG91ciA9ICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRjeWNsZVZhbHVlKGhvdXJzLCBhbW91bnQsIG1pbiwgbWF4LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgbXV0YWJsZS5taW51dGUgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5taW51dGUsIGFtb3VudCwgMCwgNTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIG11dGFibGUuc2Vjb25kID0gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJGN5Y2xlVmFsdWUodmFsdWUuc2Vjb25kLCBhbW91bnQsIDAsIDU5LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm91bmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgIG11dGFibGUubWlsbGlzZWNvbmQgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZS5taWxsaXNlY29uZCwgYW1vdW50LCAwLCA5OTksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmllbGQgJyArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG11dGFibGU7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZSh2YWx1ZSwgYW1vdW50LCBtaW4sIG1heCwgcm91bmQgPSBmYWxzZSkge1xuICAgIGlmIChyb3VuZCkge1xuICAgICAgICB2YWx1ZSArPSBNYXRoLnNpZ24oYW1vdW50KTtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB2YWx1ZSA9IG1heDtcbiAgICAgICAgbGV0IGRpdiA9IE1hdGguYWJzKGFtb3VudCk7XG4gICAgICAgIGlmIChhbW91bnQgPiAwKSB2YWx1ZSA9IE1hdGguY2VpbCh2YWx1ZSAvIGRpdikgKiBkaXY7XG4gICAgICAgIGVsc2UgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gZGl2KSAqIGRpdjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB2YWx1ZSA9IG1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSBhbW91bnQ7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbikgdmFsdWUgPSBtYXggLSAobWluIC0gdmFsdWUgLSAxKTtcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHZhbHVlID0gbWluICsgKHZhbHVlIC0gbWF4IC0gMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5NmIxZDI4MzQ5Mjc0NjM3KGRhdGVUaW1lLCBkdXJhdGlvbikge1xuICAgIGxldCBtcztcbiAgICBpZiAoZHVyYXRpb24ueWVhcnMgIT0gbnVsbCAmJiBkdXJhdGlvbi55ZWFycyAhPT0gMCB8fCBkdXJhdGlvbi5tb250aHMgIT0gbnVsbCAmJiBkdXJhdGlvbi5tb250aHMgIT09IDAgfHwgZHVyYXRpb24ud2Vla3MgIT0gbnVsbCAmJiBkdXJhdGlvbi53ZWVrcyAhPT0gMCB8fCBkdXJhdGlvbi5kYXlzICE9IG51bGwgJiYgZHVyYXRpb24uZGF5cyAhPT0gMCkge1xuICAgICAgICBsZXQgcmVzID0gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGUxNmQ4NTIwYWY0NGEwOTYoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0KShkYXRlVGltZSksIHtcbiAgICAgICAgICAgIHllYXJzOiBkdXJhdGlvbi55ZWFycyxcbiAgICAgICAgICAgIG1vbnRoczogZHVyYXRpb24ubW9udGhzLFxuICAgICAgICAgICAgd2Vla3M6IGR1cmF0aW9uLndlZWtzLFxuICAgICAgICAgICAgZGF5czogZHVyYXRpb24uZGF5c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIGRhdGUgbWF5IGNoYW5nZSB0aGUgdGltZXpvbmUgb2Zmc2V0LCBzbyB3ZSBuZWVkIHRvIHJlY29tcHV0ZVxuICAgICAgICAvLyB1c2luZyB0aGUgJ2NvbXBhdGlibGUnIGRpc2FtYmlndWF0aW9uLlxuICAgICAgICBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykocmVzLCBkYXRlVGltZS50aW1lWm9uZSk7XG4gICAgfSBlbHNlIC8vIE90aGVyd2lzZSwgcHJlc2VydmUgdGhlIG9mZnNldCBvZiB0aGUgb3JpZ2luYWwgZGF0ZS5cbiAgICBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYmQ0ZmIyYmM4YmIwNmZiKShkYXRlVGltZSkgLSBkYXRlVGltZS5vZmZzZXQ7XG4gICAgLy8gUGVyZm9ybSB0aW1lIG1hbmlwdWxhdGlvbiBpbiBtaWxsaXNlY29uZHMgcmF0aGVyIHRoYW4gb24gdGhlIG9yaWdpbmFsIHRpbWUgZmllbGRzIHRvIGFjY291bnQgZm9yIERTVC5cbiAgICAvLyBGb3IgZXhhbXBsZSwgYWRkaW5nIG9uZSBob3VyIGR1cmluZyBhIERTVCB0cmFuc2l0aW9uIG1heSByZXN1bHQgaW4gdGhlIGhvdXIgZmllbGQgc3RheWluZyB0aGUgc2FtZSBvclxuICAgIC8vIHNraXBwaW5nIGFuIGhvdXIuIFRoaXMgcmVzdWx0cyBpbiB0aGUgb2Zmc2V0IGZpZWxkIGNoYW5naW5nIHZhbHVlIGluc3RlYWQgb2YgdGhlIHNwZWNpZmllZCBmaWVsZC5cbiAgICBtcyArPSBkdXJhdGlvbi5taWxsaXNlY29uZHMgfHwgMDtcbiAgICBtcyArPSAoZHVyYXRpb24uc2Vjb25kcyB8fCAwKSAqIDEwMDA7XG4gICAgbXMgKz0gKGR1cmF0aW9uLm1pbnV0ZXMgfHwgMCkgKiA2MDAwMDtcbiAgICBtcyArPSAoZHVyYXRpb24uaG91cnMgfHwgMCkgKiAzNjAwMDAwO1xuICAgIGxldCByZXMgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKG1zLCBkYXRlVGltZS50aW1lWm9uZSk7XG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikocmVzLCBkYXRlVGltZS5jYWxlbmRhcik7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNjgxNGNhYWMzNGNhMDNjNyhkYXRlVGltZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDk2YjFkMjgzNDkyNzQ2MzcoZGF0ZVRpbWUsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQzZTI1NDRlODhhMjViZmY4KGR1cmF0aW9uKSk7XG59XG5mdW5jdGlvbiAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkOWEyOTdkMTExZmM4NmI3OShkYXRlVGltZSwgZmllbGQsIGFtb3VudCwgb3B0aW9ucykge1xuICAgIC8vIEZvciBkYXRlIGZpZWxkcywgd2Ugd2FudCB0aGUgdGltZSB0byByZW1haW4gY29uc2lzdGVudCBhbmQgdGhlIFVUQyBvZmZzZXQgdG8gcG90ZW50aWFsbHkgY2hhbmdlIHRvIGFjY291bnQgZm9yIERTVCBjaGFuZ2VzLlxuICAgIC8vIEZvciB0aW1lIGZpZWxkcywgd2Ugd2FudCB0aGUgdGltZSB0byBjaGFuZ2UgYnkgdGhlIGFtb3VudCBnaXZlbi4gVGhpcyBtYXkgcmVzdWx0IGluIHRoZSBob3VyIGZpZWxkIHN0YXlpbmcgdGhlIHNhbWUsIGJ1dCB0aGUgVVRDXG4gICAgLy8gb2Zmc2V0IGNoYW5naW5nIGluIHRoZSBjYXNlIG9mIGEgYmFja3dhcmQgRFNUIHRyYW5zaXRpb24sIG9yIHNraXBwaW5nIGFuIGhvdXIgaW4gdGhlIGNhc2Ugb2YgYSBmb3J3YXJkIERTVCB0cmFuc2l0aW9uLlxuICAgIHN3aXRjaChmaWVsZCl7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBtaW4gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtYXggPSAyMztcbiAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ob3VyQ3ljbGUpID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNQTSA9IGRhdGVUaW1lLmhvdXIgPj0gMTI7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGlzUE0gPyAxMiA6IDA7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGlzUE0gPyAyMyA6IDExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBob3VyIG1heSBiZSBhZmZlY3RlZCBieSBkYXlsaWdodCBzYXZpbmcgdGltZS5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaXQgbWlnaHQganVtcCBmb3J3YXJkIGF0IG1pZG5pZ2h0LCBhbmQgc2tpcCAxYW0uXG4gICAgICAgICAgICAgICAgLy8gT3IgaXQgbWlnaHQgZW5kIGF0IG1pZG5pZ2h0IGFuZCByZXBlYXQgdGhlIDExcG0gaG91ci4gVG8gaGFuZGxlIHRoaXMsIHdlIGdldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3NzaWJsZSBhYnNvbHV0ZSB0aW1lcyBmb3IgdGhlIG1pbiBhbmQgbWF4LCBhbmQgZmluZCB0aGUgbWF4aW11bSByYW5nZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgd2l0aGluIHRoZSBjdXJyZW50IGRheS5cbiAgICAgICAgICAgICAgICBsZXQgcGxhaW5EYXRlVGltZSA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCkoZGF0ZVRpbWUpO1xuICAgICAgICAgICAgICAgIGxldCBtaW5EYXRlID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKSgkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTVkNWUxYzE4MjJiNmU1NihwbGFpbkRhdGVUaW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IG1pblxuICAgICAgICAgICAgICAgIH0pLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWluQWJzb2x1dGUgPSBbXG4gICAgICAgICAgICAgICAgICAgICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykobWluRGF0ZSwgZGF0ZVRpbWUudGltZVpvbmUsICdlYXJsaWVyJyksXG4gICAgICAgICAgICAgICAgICAgICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykobWluRGF0ZSwgZGF0ZVRpbWUudGltZVpvbmUsICdsYXRlcicpXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKG1zKT0+KDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLmRheSA9PT0gbWluRGF0ZS5kYXkpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBtYXhEYXRlID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKSgkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTVkNWUxYzE4MjJiNmU1NihwbGFpbkRhdGVUaW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IG1heFxuICAgICAgICAgICAgICAgIH0pLCBuZXcgKDAsICQzYjYyMDc0ZWIwNTU4NGIyJGV4cG9ydCQ4MGVlNjI0NWVjNGYyOWVjKSgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF4QWJzb2x1dGUgPSBbXG4gICAgICAgICAgICAgICAgICAgICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykobWF4RGF0ZSwgZGF0ZVRpbWUudGltZVpvbmUsICdlYXJsaWVyJyksXG4gICAgICAgICAgICAgICAgICAgICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykobWF4RGF0ZSwgZGF0ZVRpbWUudGltZVpvbmUsICdsYXRlcicpXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKG1zKT0+KDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLmRheSA9PT0gbWF4RGF0ZS5kYXkpLnBvcCgpO1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGhvdXJzIG1heSByZXBlYXQsIHdlIG5lZWQgdG8gb3BlcmF0ZSBvbiB0aGUgYWJzb2x1dGUgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIGhvdXJzIGZyb20gdGhlIFVuaXggZXBvY2ggc28gdGhhdCBjeWNsZVZhbHVlIHdvcmtzIGNvcnJlY3RseSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBjb252ZXJ0ZWQgYmFjayB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICAgICAgbGV0IG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIpKGRhdGVUaW1lKSAtIGRhdGVUaW1lLm9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKG1zIC8gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJE9ORV9IT1VSKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gbXMgJSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVI7XG4gICAgICAgICAgICAgICAgbXMgPSAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkY3ljbGVWYWx1ZShob3VycywgYW1vdW50LCBNYXRoLmZsb29yKG1pbkFic29sdXRlIC8gJDczNTIyMGMyZDQ3NzRkZDMkdmFyJE9ORV9IT1VSKSwgTWF0aC5mbG9vcihtYXhBYnNvbHV0ZSAvICQ3MzUyMjBjMmQ0Nzc0ZGQzJHZhciRPTkVfSE9VUiksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yb3VuZCkgKiAkNzM1MjIwYzJkNDc3NGRkMyR2YXIkT05FX0hPVVIgKyByZW1haW5kZXI7XG4gICAgICAgICAgICAgICAgLy8gTm93IGNvbXB1dGUgdGhlIG5ldyB0aW1lem9uZSBvZmZzZXQsIGFuZCBjb252ZXJ0IHRoZSBhYnNvbHV0ZSB0aW1lIGJhY2sgdG8gbG9jYWwgdGltZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiNGEwMzZhZjNmYzBiMDMyKSgoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDFiOTY2OTJhMWJhMDQyYWMpKG1zLCBkYXRlVGltZS50aW1lWm9uZSksIGRhdGVUaW1lLmNhbGVuZGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkZDAyYjNlMDAwN2RmZTI4KGRhdGVUaW1lLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSAnZXJhJzpcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGQ1MmNlZDZiYWRmYjlhNGMoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0KShkYXRlVGltZSksIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGxldCBtcyA9ICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTEwN2M4MmY5NDUxOGY1YykocmVzLCBkYXRlVGltZS50aW1lWm9uZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLCBkYXRlVGltZS5jYWxlbmRhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpZWxkICcgKyBmaWVsZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDMxYjU0MzBlYjE4YmU0ZjgoZGF0ZVRpbWUsIGZpZWxkcywgZGlzYW1iaWd1YXRpb24pIHtcbiAgICAvLyBTZXQgdGhlIGRhdGUvdGltZSBmaWVsZHMsIGFuZCByZWNvbXB1dGUgdGhlIFVUQyBvZmZzZXQgdG8gYWNjb3VudCBmb3IgRFNUIGNoYW5nZXMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHZhbGlkYXRlIGJ5IGNvbnZlcnRpbmcgYmFjayB0byBhIGxvY2FsIHRpbWUgaW4gY2FzZSBob3VycyBhcmUgc2tpcHBlZCBkdXJpbmcgZm9yd2FyZCBEU1QgdHJhbnNpdGlvbnMuXG4gICAgbGV0IHBsYWluRGF0ZVRpbWUgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGRhdGVUaW1lKTtcbiAgICBsZXQgcmVzID0gJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYoJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUocGxhaW5EYXRlVGltZSwgZmllbGRzKSwgZmllbGRzKTtcbiAgICAvLyBJZiB0aGUgcmVzdWx0aW5nIHBsYWluIGRhdGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsLCByZXR1cm4gdGhlIG9yaWdpbmFsIHRpbWUuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG9mZnNldCB3aGVuIHNldHRpbmcgdGhlIHRpbWUgdG8gdGhlIHNhbWUgdmFsdWUuXG4gICAgaWYgKHJlcy5jb21wYXJlKHBsYWluRGF0ZVRpbWUpID09PSAwKSByZXR1cm4gZGF0ZVRpbWU7XG4gICAgbGV0IG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKShyZXMsIGRhdGVUaW1lLnRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjRhMDM2YWYzZmMwYjAzMikoKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxYjk2NjkyYTFiYTA0MmFjKShtcywgZGF0ZVRpbWUudGltZVpvbmUpLCBkYXRlVGltZS5jYWxlbmRhcik7XG59XG5cblxuZXhwb3J0IHskNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTE2ZDg1MjBhZjQ0YTA5NiBhcyBhZGQsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyIGFzIGNvbnN0cmFpbiwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDNlMjU0NGU4OGEyNWJmZjggYXMgaW52ZXJ0RHVyYXRpb24sICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ0ZTJkMmVhZDY1ZTVmN2UzIGFzIHN1YnRyYWN0LCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkYWRhYTRjZjdlZjFiNjViZSBhcyBzZXQsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlNWQ1ZTFjMTgyMmI2ZTU2IGFzIHNldFRpbWUsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ3NTU1ZGUxZTA3MDUxMGNiIGFzIGNvbnN0cmFpblRpbWUsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ3ZWQ4N2I2YmMyNTA2NDcwIGFzIGFkZFRpbWUsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRmZTM0ZDNhMzgxY2Q3NTAxIGFzIHN1YnRyYWN0VGltZSwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGQ1MmNlZDZiYWRmYjlhNGMgYXMgY3ljbGVEYXRlLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZGQwMmIzZTAwMDdkZmUyOCBhcyBjeWNsZVRpbWUsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5NmIxZDI4MzQ5Mjc0NjM3IGFzIGFkZFpvbmVkLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNjgxNGNhYWMzNGNhMDNjNyBhcyBzdWJ0cmFjdFpvbmVkLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkOWEyOTdkMTExZmM4NmI3OSBhcyBjeWNsZVpvbmVkLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkMzFiNTQzMGViMThiZTRmOCBhcyBzZXRab25lZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYW5pcHVsYXRpb24ubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0IHtDYWxlbmRhckRhdGUgYXMgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYsIENhbGVuZGFyRGF0ZVRpbWUgYXMgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGNhODcxZThkYmI4MDk2NmYsIFRpbWUgYXMgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1ZiwgWm9uZWREYXRlVGltZSBhcyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYX0gZnJvbSBcIi4vQ2FsZW5kYXJEYXRlLm1qc1wiO1xuaW1wb3J0IHtlcG9jaEZyb21EYXRlIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIsIGZyb21BYnNvbHV0ZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYywgcG9zc2libGVBYnNvbHV0ZXMgYXMgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDEzNmYzOGVmZTdjYWY1NDksIHRvQWJzb2x1dGUgYXMgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDUxMDdjODJmOTQ1MThmNWMsIHRvQ2FsZW5kYXIgYXMgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIsIHRvQ2FsZW5kYXJEYXRlVGltZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCwgdG9UaW1lWm9uZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkNTM4YjAwMDMzY2MxMWM3NX0gZnJvbSBcIi4vY29udmVyc2lvbi5tanNcIjtcbmltcG9ydCB7Z2V0TG9jYWxUaW1lWm9uZSBhcyAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYWE4YjQxNzM1YWZjYWJkMn0gZnJvbSBcIi4vcXVlcmllcy5tanNcIjtcbmltcG9ydCB7R3JlZ29yaWFuQ2FsZW5kYXIgYXMgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWN9IGZyb20gXCIuL0dyZWdvcmlhbkNhbGVuZGFyLm1qc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkVElNRV9SRSA9IC9eKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KFxcLlxcZCspPyQvO1xuY29uc3QgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfUkUgPSAvXihbKy1dXFxkezZ9fFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSkkLztcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciREQVRFX1RJTUVfUkUgPSAvXihbKy1dXFxkezZ9fFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSkoPzpUKFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KD86OihcXGR7Mn0pKT8oXFwuXFxkKyk/JC87XG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkWk9ORURfREFURV9USU1FX1JFID0gL14oWystXVxcZHs2fXxcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pKD86VChcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyg/OjooXFxkezJ9KSk/KFxcLlxcZCspPyg/OihbKy1dXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyk/XFxbKC4qPylcXF0kLztcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRBQlNPTFVURV9SRSA9IC9eKFsrLV1cXGR7Nn18XFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KSg/OlQoXFxkezJ9KSk/KD86OihcXGR7Mn0pKT8oPzo6KFxcZHsyfSkpPyhcXC5cXGQrKT8oPzooPzooWystXVxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8pfFopJC87XG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkREFURV9USU1FX0RVUkFUSU9OX1JFID0gL14oKD88bmVnYXRpdmU+LSl8XFwrKT9QKCg/PHllYXJzPlxcZCopWSk/KCg/PG1vbnRocz5cXGQqKU0pPygoPzx3ZWVrcz5cXGQqKVcpPygoPzxkYXlzPlxcZCopRCk/KCg/PHRpbWU+VCkoKD88aG91cnM+XFxkKlsuLF0/XFxkezEsOX0pSCk/KCg/PG1pbnV0ZXM+XFxkKlsuLF0/XFxkezEsOX0pTSk/KCg/PHNlY29uZHM+XFxkKlsuLF0/XFxkezEsOX0pUyk/KT8kLztcbmNvbnN0ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRyZXF1aXJlZER1cmF0aW9uVGltZUdyb3VwcyA9IFtcbiAgICAnaG91cnMnLFxuICAgICdtaW51dGVzJyxcbiAgICAnc2Vjb25kcydcbl07XG5jb25zdCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcmVxdWlyZWREdXJhdGlvbkdyb3VwcyA9IFtcbiAgICAneWVhcnMnLFxuICAgICdtb250aHMnLFxuICAgICd3ZWVrcycsXG4gICAgJ2RheXMnLFxuICAgIC4uLiRmYWU5NzdhYWZjMzkzYzVjJHZhciRyZXF1aXJlZER1cmF0aW9uVGltZUdyb3Vwc1xuXTtcbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRjOTY5OGVjN2YwNWEwN2UxKHZhbHVlKSB7XG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkVElNRV9SRSk7XG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVNPIDg2MDEgdGltZSBzdHJpbmc6ICcgKyB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1ZikoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDAsIDIzKSwgbVsyXSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzJdLCAwLCA1OSkgOiAwLCBtWzNdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bM10sIDAsIDU5KSA6IDAsIG1bNF0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs0XSwgMCwgSW5maW5pdHkpICogMTAwMCA6IDApO1xufVxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDZiODYyMTYwZDI5NWM4ZSh2YWx1ZSkge1xuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfUkUpO1xuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElTTyA4NjAxIGRhdGUgc3RyaW5nOiAnICsgdmFsdWUpO1xuICAgIGxldCBkYXRlID0gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0ZikoJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIDAsIDk5OTkpLCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsyXSwgMSwgMTIpLCAxKTtcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcbiAgICByZXR1cm4gZGF0ZTtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1ODg5MzdiY2Q2MGFkZTU1KHZhbHVlKSB7XG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkREFURV9USU1FX1JFKTtcbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nOiAnICsgdmFsdWUpO1xuICAgIGxldCB5ZWFyID0gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMV0sIC05OTk5LCA5OTk5KTtcbiAgICBsZXQgZXJhID0geWVhciA8IDEgPyAnQkMnIDogJ0FEJztcbiAgICBsZXQgZGF0ZSA9IG5ldyAoMCwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGNhODcxZThkYmI4MDk2NmYpKGVyYSwgeWVhciA8IDEgPyAteWVhciArIDEgOiB5ZWFyLCAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsyXSwgMSwgMTIpLCAxLCBtWzRdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNF0sIDAsIDIzKSA6IDAsIG1bNV0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs1XSwgMCwgNTkpIDogMCwgbVs2XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzZdLCAwLCA1OSkgOiAwLCBtWzddID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bN10sIDAsIEluZmluaXR5KSAqIDEwMDAgOiAwKTtcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcbiAgICByZXR1cm4gZGF0ZTtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmZDc4OTNmMDZlOTJhNmE0KHZhbHVlLCBkaXNhbWJpZ3VhdGlvbikge1xuICAgIGxldCBtID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJFpPTkVEX0RBVEVfVElNRV9SRSk7XG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZzogJyArIHZhbHVlKTtcbiAgICBsZXQgeWVhciA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzFdLCAtOTk5OSwgOTk5OSk7XG4gICAgbGV0IGVyYSA9IHllYXIgPCAxID8gJ0JDJyA6ICdBRCc7XG4gICAgbGV0IGRhdGUgPSBuZXcgKDAsICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKShlcmEsIHllYXIgPCAxID8gLXllYXIgKyAxIDogeWVhciwgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bMl0sIDEsIDEyKSwgMSwgbVsxMF0sIDAsIG1bNF0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs0XSwgMCwgMjMpIDogMCwgbVs1XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzVdLCAwLCA1OSkgOiAwLCBtWzZdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNl0sIDAsIDU5KSA6IDAsIG1bN10gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs3XSwgMCwgSW5maW5pdHkpICogMTAwMCA6IDApO1xuICAgIGRhdGUuZGF5ID0gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bM10sIDAsIGRhdGUuY2FsZW5kYXIuZ2V0RGF5c0luTW9udGgoZGF0ZSkpO1xuICAgIGxldCBwbGFpbkRhdGVUaW1lID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiMjFlMGIxMjRlMjI0NDg0KShkYXRlKTtcbiAgICBsZXQgbXM7XG4gICAgaWYgKG1bOF0pIHtcbiAgICAgICAgdmFyIF9tXztcbiAgICAgICAgZGF0ZS5vZmZzZXQgPSAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs4XSwgLTIzLCAyMykgKiAzNjAwMDAwICsgJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKChfbV8gPSBtWzldKSAhPT0gbnVsbCAmJiBfbV8gIT09IHZvaWQgMCA/IF9tXyA6ICcwJywgMCwgNTkpICogNjAwMDA7XG4gICAgICAgIG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRiZDRmYjJiYzhiYjA2ZmIpKGRhdGUpIC0gZGF0ZS5vZmZzZXQ7XG4gICAgICAgIC8vIFZhbGlkYXRlIG9mZnNldCBhZ2FpbnN0IHBhcnNlZCBkYXRlLlxuICAgICAgICBsZXQgYWJzb2x1dGVzID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQxMzZmMzhlZmU3Y2FmNTQ5KShwbGFpbkRhdGVUaW1lLCBkYXRlLnRpbWVab25lKTtcbiAgICAgICAgaWYgKCFhYnNvbHV0ZXMuaW5jbHVkZXMobXMpKSB0aHJvdyBuZXcgRXJyb3IoYE9mZnNldCAkeyRmYWU5NzdhYWZjMzkzYzVjJHZhciRvZmZzZXRUb1N0cmluZyhkYXRlLm9mZnNldCl9IGlzIGludmFsaWQgZm9yICR7JGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDQyMjNkZTE0NzA4YWRjNjMoZGF0ZSl9IGluICR7ZGF0ZS50aW1lWm9uZX1gKTtcbiAgICB9IGVsc2UgLy8gQ29udmVydCB0byBhYnNvbHV0ZSBhbmQgYmFjayB0byBmaXggaW52YWxpZCB0aW1lcyBkdWUgdG8gRFNULlxuICAgIG1zID0gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MTA3YzgyZjk0NTE4ZjVjKSgoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKHBsYWluRGF0ZVRpbWUpLCBkYXRlLnRpbWVab25lLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkMWI5NjY5MmExYmEwNDJhYykobXMsIGRhdGUudGltZVpvbmUpO1xufVxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDVhZGZkYWIwNTE2OGMyMTkodmFsdWUsIHRpbWVab25lKSB7XG4gICAgbGV0IG0gPSB2YWx1ZS5tYXRjaCgkZmFlOTc3YWFmYzM5M2M1YyR2YXIkQUJTT0xVVEVfUkUpO1xuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmc6ICcgKyB2YWx1ZSk7XG4gICAgbGV0IHllYXIgPSAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVsxXSwgLTk5OTksIDk5OTkpO1xuICAgIGxldCBlcmEgPSB5ZWFyIDwgMSA/ICdCQycgOiAnQUQnO1xuICAgIGxldCBkYXRlID0gbmV3ICgwLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSkoZXJhLCB5ZWFyIDwgMSA/IC15ZWFyICsgMSA6IHllYXIsICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzJdLCAxLCAxMiksIDEsIHRpbWVab25lLCAwLCBtWzRdID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bNF0sIDAsIDIzKSA6IDAsIG1bNV0gPyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIobVs1XSwgMCwgNTkpIDogMCwgbVs2XSA/ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzZdLCAwLCA1OSkgOiAwLCBtWzddID8gJGZhZTk3N2FhZmMzOTNjNWMkdmFyJHBhcnNlTnVtYmVyKG1bN10sIDAsIEluZmluaXR5KSAqIDEwMDAgOiAwKTtcbiAgICBkYXRlLmRheSA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzNdLCAwLCBkYXRlLmNhbGVuZGFyLmdldERheXNJbk1vbnRoKGRhdGUpKTtcbiAgICB2YXIgX21fO1xuICAgIGlmIChtWzhdKSBkYXRlLm9mZnNldCA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcihtWzhdLCAtMjMsIDIzKSAqIDM2MDAwMDAgKyAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIoKF9tXyA9IG1bOV0pICE9PSBudWxsICYmIF9tXyAhPT0gdm9pZCAwID8gX21fIDogJzAnLCAwLCA1OSkgKiA2MDAwMDtcbiAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ1MzhiMDAwMzNjYzExYzc1KShkYXRlLCB0aW1lWm9uZSk7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkOGUzODQ0MzIzNjJlZDBmMCh2YWx1ZSkge1xuICAgIHJldHVybiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNWFkZmRhYjA1MTY4YzIxOSh2YWx1ZSwgKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRhYThiNDE3MzVhZmNhYmQyKSgpKTtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJHZhciRwYXJzZU51bWJlcih2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBsZXQgdmFsID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodmFsIDwgbWluIHx8IHZhbCA+IG1heCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIG91dCBvZiByYW5nZTogJHttaW59IDw9ICR7dmFsfSA8PSAke21heH1gKTtcbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGY1OWRlZTgyMjQ4ZjVhZDQodGltZSkge1xuICAgIHJldHVybiBgJHtTdHJpbmcodGltZS5ob3VyKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyh0aW1lLm1pbnV0ZSkucGFkU3RhcnQoMiwgJzAnKX06JHtTdHJpbmcodGltZS5zZWNvbmQpLnBhZFN0YXJ0KDIsICcwJyl9JHt0aW1lLm1pbGxpc2Vjb25kID8gU3RyaW5nKHRpbWUubWlsbGlzZWNvbmQgLyAxMDAwKS5zbGljZSgxKSA6ICcnfWA7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNjBkZmQ3NGFhOTY3OTFiZChkYXRlKSB7XG4gICAgbGV0IGdyZWdvcmlhbkRhdGUgPSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGI0YTAzNmFmM2ZjMGIwMzIpKGRhdGUsIG5ldyAoMCwgJDNiNjIwNzRlYjA1NTg0YjIkZXhwb3J0JDgwZWU2MjQ1ZWM0ZjI5ZWMpKCkpO1xuICAgIGxldCB5ZWFyO1xuICAgIGlmIChncmVnb3JpYW5EYXRlLmVyYSA9PT0gJ0JDJykgeWVhciA9IGdyZWdvcmlhbkRhdGUueWVhciA9PT0gMSA/ICcwMDAwJyA6ICctJyArIFN0cmluZyhNYXRoLmFicygxIC0gZ3JlZ29yaWFuRGF0ZS55ZWFyKSkucGFkU3RhcnQoNiwgJzAwJyk7XG4gICAgZWxzZSB5ZWFyID0gU3RyaW5nKGdyZWdvcmlhbkRhdGUueWVhcikucGFkU3RhcnQoNCwgJzAnKTtcbiAgICByZXR1cm4gYCR7eWVhcn0tJHtTdHJpbmcoZ3JlZ29yaWFuRGF0ZS5tb250aCkucGFkU3RhcnQoMiwgJzAnKX0tJHtTdHJpbmcoZ3JlZ29yaWFuRGF0ZS5kYXkpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbn1cbmZ1bmN0aW9uICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKGRhdGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGAkeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2MGRmZDc0YWE5Njc5MWJkKGRhdGUpfVQkeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmNTlkZWU4MjI0OGY1YWQ0KGRhdGUpfWA7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkb2Zmc2V0VG9TdHJpbmcob2Zmc2V0KSB7XG4gICAgbGV0IHNpZ24gPSBNYXRoLnNpZ24ob2Zmc2V0KSA8IDAgPyAnLScgOiAnKyc7XG4gICAgb2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgICBsZXQgb2Zmc2V0SG91cnMgPSBNYXRoLmZsb29yKG9mZnNldCAvIDM2MDAwMDApO1xuICAgIGxldCBvZmZzZXRNaW51dGVzID0gb2Zmc2V0ICUgMzYwMDAwMCAvIDYwMDAwO1xuICAgIHJldHVybiBgJHtzaWdufSR7U3RyaW5nKG9mZnNldEhvdXJzKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhvZmZzZXRNaW51dGVzKS5wYWRTdGFydCgyLCAnMCcpfWA7XG59XG5mdW5jdGlvbiAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYmY3OWYxZWJmNGIxODc5MihkYXRlKSB7XG4gICAgcmV0dXJuIGAkeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKGRhdGUpfSR7JGZhZTk3N2FhZmMzOTNjNWMkdmFyJG9mZnNldFRvU3RyaW5nKGRhdGUub2Zmc2V0KX1bJHtkYXRlLnRpbWVab25lfV1gO1xufVxuZnVuY3Rpb24gJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGVjYWU4MjliYjM3NDdlYTYodmFsdWUpIHtcbiAgICB2YXIgX21hdGNoX2dyb3VwcywgX21hdGNoX2dyb3VwczEsIF9tYXRjaF9ncm91cHMyLCBfbWF0Y2hfZ3JvdXBzMywgX21hdGNoX2dyb3VwczQsIF9tYXRjaF9ncm91cHM1LCBfbWF0Y2hfZ3JvdXBzNiwgX21hdGNoX2dyb3VwczcsIF9tYXRjaF9ncm91cHM4O1xuICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goJGZhZTk3N2FhZmMzOTNjNWMkdmFyJERBVEVfVElNRV9EVVJBVElPTl9SRSk7XG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX1gKTtcbiAgICBjb25zdCBwYXJzZUR1cmF0aW9uR3JvdXAgPSAoZ3JvdXAsIGlzTmVnYXRpdmUsIG1pbiwgbWF4KT0+e1xuICAgICAgICBpZiAoIWdyb3VwKSByZXR1cm4gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ24gPSBpc05lZ2F0aXZlID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcGFyc2VOdW1iZXIoZ3JvdXAucmVwbGFjZSgnLCcsICcuJyksIG1pbiwgbWF4KTtcbiAgICAgICAgfSBjYXRjaCAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIER1cmF0aW9uIHN0cmluZzogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICEhKChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzLm5lZ2F0aXZlKTtcbiAgICBjb25zdCBoYXNSZXF1aXJlZEdyb3VwcyA9ICRmYWU5NzdhYWZjMzkzYzVjJHZhciRyZXF1aXJlZER1cmF0aW9uR3JvdXBzLnNvbWUoKGdyb3VwKT0+e1xuICAgICAgICB2YXIgX21hdGNoX2dyb3VwcztcbiAgICAgICAgcmV0dXJuIChfbWF0Y2hfZ3JvdXBzID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzW2dyb3VwXTtcbiAgICB9KTtcbiAgICBpZiAoIWhhc1JlcXVpcmVkR3JvdXBzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgIGNvbnN0IGR1cmF0aW9uU3RyaW5nSW5jbHVkZXNUaW1lID0gKF9tYXRjaF9ncm91cHMxID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3VwczEudGltZTtcbiAgICBpZiAoZHVyYXRpb25TdHJpbmdJbmNsdWRlc1RpbWUpIHtcbiAgICAgICAgY29uc3QgaGFzUmVxdWlyZWREdXJhdGlvblRpbWVHcm91cHMgPSAkZmFlOTc3YWFmYzM5M2M1YyR2YXIkcmVxdWlyZWREdXJhdGlvblRpbWVHcm91cHMuc29tZSgoZ3JvdXApPT57XG4gICAgICAgICAgICB2YXIgX21hdGNoX2dyb3VwcztcbiAgICAgICAgICAgIHJldHVybiAoX21hdGNoX2dyb3VwcyA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3Vwc1tncm91cF07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhhc1JlcXVpcmVkRHVyYXRpb25UaW1lR3JvdXBzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczIgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzMi55ZWFycywgaXNOZWdhdGl2ZSwgMCwgOTk5OSksXG4gICAgICAgIG1vbnRoczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzMyA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHMzLm1vbnRocywgaXNOZWdhdGl2ZSwgMCwgMTIpLFxuICAgICAgICB3ZWVrczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzNCA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM0LndlZWtzLCBpc05lZ2F0aXZlLCAwLCBJbmZpbml0eSksXG4gICAgICAgIGRheXM6IHBhcnNlRHVyYXRpb25Hcm91cCgoX21hdGNoX2dyb3VwczUgPSBtYXRjaC5ncm91cHMpID09PSBudWxsIHx8IF9tYXRjaF9ncm91cHM1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0Y2hfZ3JvdXBzNS5kYXlzLCBpc05lZ2F0aXZlLCAwLCAzMSksXG4gICAgICAgIGhvdXJzOiBwYXJzZUR1cmF0aW9uR3JvdXAoKF9tYXRjaF9ncm91cHM2ID0gbWF0Y2guZ3JvdXBzKSA9PT0gbnVsbCB8fCBfbWF0Y2hfZ3JvdXBzNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoX2dyb3VwczYuaG91cnMsIGlzTmVnYXRpdmUsIDAsIDIzKSxcbiAgICAgICAgbWludXRlczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzNyA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM3Lm1pbnV0ZXMsIGlzTmVnYXRpdmUsIDAsIDU5KSxcbiAgICAgICAgc2Vjb25kczogcGFyc2VEdXJhdGlvbkdyb3VwKChfbWF0Y2hfZ3JvdXBzOCA9IG1hdGNoLmdyb3VwcykgPT09IG51bGwgfHwgX21hdGNoX2dyb3VwczggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRjaF9ncm91cHM4LnNlY29uZHMsIGlzTmVnYXRpdmUsIDAsIDU5KVxuICAgIH07XG4gICAgaWYgKGR1cmF0aW9uLmhvdXJzICE9PSB1bmRlZmluZWQgJiYgZHVyYXRpb24uaG91cnMgJSAxICE9PSAwICYmIChkdXJhdGlvbi5taW51dGVzIHx8IGR1cmF0aW9uLnNlY29uZHMpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSVNPIDg2MDEgRHVyYXRpb24gc3RyaW5nOiAke3ZhbHVlfSAtIG9ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWxgKTtcbiAgICBpZiAoZHVyYXRpb24ubWludXRlcyAhPT0gdW5kZWZpbmVkICYmIGR1cmF0aW9uLm1pbnV0ZXMgJSAxICE9PSAwICYmIGR1cmF0aW9uLnNlY29uZHMpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJU08gODYwMSBEdXJhdGlvbiBzdHJpbmc6ICR7dmFsdWV9IC0gb25seSB0aGUgc21hbGxlc3QgdW5pdCBjYW4gYmUgZnJhY3Rpb25hbGApO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbn1cblxuXG5leHBvcnQgeyRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRjOTY5OGVjN2YwNWEwN2UxIGFzIHBhcnNlVGltZSwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDZiODYyMTYwZDI5NWM4ZSBhcyBwYXJzZURhdGUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ1ODg5MzdiY2Q2MGFkZTU1IGFzIHBhcnNlRGF0ZVRpbWUsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmZDc4OTNmMDZlOTJhNmE0IGFzIHBhcnNlWm9uZWREYXRlVGltZSwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDQyMjNkZTE0NzA4YWRjNjMgYXMgZGF0ZVRpbWVUb1N0cmluZywgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDVhZGZkYWIwNTE2OGMyMTkgYXMgcGFyc2VBYnNvbHV0ZSwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDhlMzg0NDMyMzYyZWQwZjAgYXMgcGFyc2VBYnNvbHV0ZVRvTG9jYWwsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRmNTlkZWU4MjI0OGY1YWQ0IGFzIHRpbWVUb1N0cmluZywgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDYwZGZkNzRhYTk2NzkxYmQgYXMgZGF0ZVRvU3RyaW5nLCAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYmY3OWYxZWJmNGIxODc5MiBhcyB6b25lZERhdGVUaW1lVG9TdHJpbmcsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCRlY2FlODI5YmIzNzQ3ZWE2IGFzIHBhcnNlRHVyYXRpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLm1vZHVsZS5qcy5tYXBcbiIsImZ1bmN0aW9uIF9jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24ob2JqLCBwcml2YXRlQ29sbGVjdGlvbikge1xuICAgIGlmIChwcml2YXRlQ29sbGVjdGlvbi5oYXMob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgdGhlIHNhbWUgcHJpdmF0ZSBlbGVtZW50cyB0d2ljZSBvbiBhbiBvYmplY3RcIik7XG4gICAgfVxufVxuZXhwb3J0IHsgX2NoZWNrX3ByaXZhdGVfcmVkZWNsYXJhdGlvbiBhcyBfIH07XG4iLCJpbXBvcnQgeyBfIGFzIF9jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24gfSBmcm9tIFwiLi9fY2hlY2tfcHJpdmF0ZV9yZWRlY2xhcmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIF9jbGFzc19wcml2YXRlX2ZpZWxkX2luaXQob2JqLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIF9jaGVja19wcml2YXRlX3JlZGVjbGFyYXRpb24ob2JqLCBwcml2YXRlTWFwKTtcbiAgICBwcml2YXRlTWFwLnNldChvYmosIHZhbHVlKTtcbn1cbmV4cG9ydCB7IF9jbGFzc19wcml2YXRlX2ZpZWxkX2luaXQgYXMgXyB9O1xuIiwiaW1wb3J0IHthZGQgYXMgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGUxNmQ4NTIwYWY0NGEwOTYsIGFkZFRpbWUgYXMgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDdlZDg3YjZiYzI1MDY0NzAsIGFkZFpvbmVkIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5NmIxZDI4MzQ5Mjc0NjM3LCBjb25zdHJhaW4gYXMgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIsIGNvbnN0cmFpblRpbWUgYXMgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDc1NTVkZTFlMDcwNTEwY2IsIGN5Y2xlRGF0ZSBhcyAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0YywgY3ljbGVUaW1lIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRkZDAyYjNlMDAwN2RmZTI4LCBjeWNsZVpvbmVkIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ5YTI5N2QxMTFmYzg2Yjc5LCBzZXQgYXMgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUsIHNldFRpbWUgYXMgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYsIHNldFpvbmVkIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQzMWI1NDMwZWIxOGJlNGY4LCBzdWJ0cmFjdCBhcyAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMywgc3VidHJhY3RUaW1lIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRmZTM0ZDNhMzgxY2Q3NTAxLCBzdWJ0cmFjdFpvbmVkIGFzICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ2ODE0Y2FhYzM0Y2EwM2M3fSBmcm9tIFwiLi9tYW5pcHVsYXRpb24ubWpzXCI7XG5pbXBvcnQge2NvbXBhcmVEYXRlIGFzICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCQ2ODc4MWRkZjMxYzAwOTBmLCBjb21wYXJlVGltZSBhcyAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYzE5YTgwYTk3MjFiODBmNn0gZnJvbSBcIi4vcXVlcmllcy5tanNcIjtcbmltcG9ydCB7ZGF0ZVRpbWVUb1N0cmluZyBhcyAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkNDIyM2RlMTQ3MDhhZGM2MywgZGF0ZVRvU3RyaW5nIGFzICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ2MGRmZDc0YWE5Njc5MWJkLCB0aW1lVG9TdHJpbmcgYXMgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGY1OWRlZTgyMjQ4ZjVhZDQsIHpvbmVkRGF0ZVRpbWVUb1N0cmluZyBhcyAkZmFlOTc3YWFmYzM5M2M1YyRleHBvcnQkYmY3OWYxZWJmNGIxODc5Mn0gZnJvbSBcIi4vc3RyaW5nLm1qc1wiO1xuaW1wb3J0IHtHcmVnb3JpYW5DYWxlbmRhciBhcyAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllY30gZnJvbSBcIi4vR3JlZ29yaWFuQ2FsZW5kYXIubWpzXCI7XG5pbXBvcnQge3RvQ2FsZW5kYXJEYXRlVGltZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkYjIxZTBiMTI0ZTIyNDQ4NCwgdG9EYXRlIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCRlNjdhMDk1YzYyMGI4NmZlLCB0b1pvbmVkIGFzICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ4NGM5NWE4M2M3OTllMDc0LCB6b25lZFRvRGF0ZSBhcyAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkODNhYWMwN2I0YzM3YjI1fSBmcm9tIFwiLi9jb252ZXJzaW9uLm1qc1wiO1xuaW1wb3J0IHtfIGFzICRha3N5MSRffSBmcm9tIFwiQHN3Yy9oZWxwZXJzL18vX2NsYXNzX3ByaXZhdGVfZmllbGRfaW5pdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cblxuZnVuY3Rpb24gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKSB7XG4gICAgbGV0IGNhbGVuZGFyID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnID8gYXJncy5zaGlmdCgpIDogbmV3ICgwLCAkM2I2MjA3NGViMDU1ODRiMiRleHBvcnQkODBlZTYyNDVlYzRmMjllYykoKTtcbiAgICBsZXQgZXJhO1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIGVyYSA9IGFyZ3Muc2hpZnQoKTtcbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVyYXMgPSBjYWxlbmRhci5nZXRFcmFzKCk7XG4gICAgICAgIGVyYSA9IGVyYXNbZXJhcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgbGV0IHllYXIgPSBhcmdzLnNoaWZ0KCk7XG4gICAgbGV0IG1vbnRoID0gYXJncy5zaGlmdCgpO1xuICAgIGxldCBkYXkgPSBhcmdzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY2FsZW5kYXIsXG4gICAgICAgIGVyYSxcbiAgICAgICAgeWVhcixcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGRheVxuICAgIF07XG59XG52YXIgLy8gVGhpcyBwcmV2ZW50cyBUeXBlU2NyaXB0IGZyb20gYWxsb3dpbmcgb3RoZXIgdHlwZXMgd2l0aCB0aGUgc2FtZSBmaWVsZHMgdG8gbWF0Y2guXG4vLyBpLmUuIGEgWm9uZWREYXRlVGltZSBzaG91bGQgbm90IGJlIGJlIHBhc3NhYmxlIHRvIGEgcGFyYW1ldGVyIHRoYXQgZXhwZWN0cyBDYWxlbmRhckRhdGUuXG4vLyBJZiB0aGF0IGJlaGF2aW9yIGlzIGRlc2lyZWQsIHVzZSB0aGUgQW55Q2FsZW5kYXJEYXRlIGludGVyZmFjZSBpbnN0ZWFkLlxuLy8gQHRzLWlnbm9yZVxuJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDk5ZmFhNzYwYzc5MDhlNGYge1xuICAgIC8qKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIGRhdGUuICovIGNvcHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVyYSkgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0Zih0aGlzLmNhbGVuZGFyLCB0aGlzLmVyYSwgdGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkOTlmYWE3NjBjNzkwOGU0Zih0aGlzLmNhbGVuZGFyLCB0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gZHVyYXRpb24gYWRkZWQgdG8gaXQuICovIGFkZChkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRlMTZkODUyMGFmNDRhMDk2KSh0aGlzLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIHN1YnRyYWN0ZWQgZnJvbSBpdC4gKi8gc3VidHJhY3QoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNGUyZDJlYWQ2NWU1ZjdlMykodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlYCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMgc2V0IHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuIE90aGVyIGZpZWxkcyB3aWxsIGJlIGNvbnN0cmFpbmVkIGFjY29yZGluZ2x5LiAqLyBzZXQoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUpKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVgIHdpdGggdGhlIGdpdmVuIGZpZWxkIGFkanVzdGVkIGJ5IGEgc3BlY2lmaWVkIGFtb3VudC5cbiAgICogV2hlbiB0aGUgcmVzdWx0aW5nIHZhbHVlIHJlYWNoZXMgdGhlIGxpbWl0cyBvZiB0aGUgZmllbGQsIGl0IHdyYXBzIGFyb3VuZC5cbiAgICovIGN5Y2xlKGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0YykodGhpcywgZmllbGQsIGFtb3VudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyB0aGUgZGF0ZSB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0LCB3aXRoIHRoZSB0aW1lIHNldCB0byBtaWRuaWdodCBpbiB0aGUgZ2l2ZW4gdGltZSB6b25lLiAqLyB0b0RhdGUodGltZVpvbmUpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTY3YTA5NWM2MjBiODZmZSkodGhpcywgdGltZVpvbmUpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZy4gKi8gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JDYwZGZkNzRhYTk2NzkxYmQpKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29tcGFyZXMgdGhpcyBkYXRlIHdpdGggYW5vdGhlci4gQSBuZWdhdGl2ZSByZXN1bHQgaW5kaWNhdGVzIHRoYXQgdGhpcyBkYXRlIGlzIGJlZm9yZSB0aGUgZ2l2ZW4gb25lLCBhbmQgYSBwb3NpdGl2ZSBkYXRlIGluZGljYXRlcyB0aGF0IGl0IGlzIGFmdGVyLiAqLyBjb21wYXJlKGIpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkNjg3ODFkZGYzMWMwMDkwZikodGhpcywgYik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICAoMCwgJGFrc3kxJF8pKHRoaXMsICQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZSwge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgW2NhbGVuZGFyLCBlcmEsIHllYXIsIG1vbnRoLCBkYXldID0gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgICAgICB0aGlzLmVyYSA9IGVyYTtcbiAgICAgICAgdGhpcy55ZWFyID0geWVhcjtcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xuICAgICAgICB0aGlzLmRheSA9IGRheTtcbiAgICAgICAgKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKSh0aGlzKTtcbiAgICB9XG59XG52YXIgLy8gVGhpcyBwcmV2ZW50cyBUeXBlU2NyaXB0IGZyb20gYWxsb3dpbmcgb3RoZXIgdHlwZXMgd2l0aCB0aGUgc2FtZSBmaWVsZHMgdG8gbWF0Y2guXG4vLyBAdHMtaWdub3JlXG4kMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUxID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1ZiB7XG4gICAgLyoqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgdGltZS4gKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkNjgwZWExOTZlZmZjZTVmKHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYFRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIGFkZGVkIHRvIGl0LiAqLyBhZGQoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkN2VkODdiNmJjMjUwNjQ3MCkodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZHVyYXRpb24gc3VidHJhY3RlZCBmcm9tIGl0LiAqLyBzdWJ0cmFjdChkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRmZTM0ZDNhMzgxY2Q3NTAxKSh0aGlzLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMgc2V0IHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuIE90aGVyIGZpZWxkcyB3aWxsIGJlIGNvbnN0cmFpbmVkIGFjY29yZGluZ2x5LiAqLyBzZXQoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGU1ZDVlMWMxODIyYjZlNTYpKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGBUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyB2YWx1ZSByZWFjaGVzIHRoZSBsaW1pdHMgb2YgdGhlIGZpZWxkLCBpdCB3cmFwcyBhcm91bmQuXG4gICAqLyBjeWNsZShmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGRkMDJiM2UwMDA3ZGZlMjgpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIHRpbWUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZy4gKi8gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGY1OWRlZTgyMjQ4ZjVhZDQpKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29tcGFyZXMgdGhpcyB0aW1lIHdpdGggYW5vdGhlci4gQSBuZWdhdGl2ZSByZXN1bHQgaW5kaWNhdGVzIHRoYXQgdGhpcyB0aW1lIGlzIGJlZm9yZSB0aGUgZ2l2ZW4gb25lLCBhbmQgYSBwb3NpdGl2ZSB0aW1lIGluZGljYXRlcyB0aGF0IGl0IGlzIGFmdGVyLiAqLyBjb21wYXJlKGIpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkMTRlMGYyNGVmNGFjNWM5MiRleHBvcnQkYzE5YTgwYTk3MjFiODBmNikodGhpcywgYik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGhvdXIgPSAwLCBtaW51dGUgPSAwLCBzZWNvbmQgPSAwLCBtaWxsaXNlY29uZCA9IDApe1xuICAgICAgICAoMCwgJGFrc3kxJF8pKHRoaXMsICQzNWVhOGRiOWNiMmNjYjkwJHZhciRfdHlwZTEsIHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ob3VyID0gaG91cjtcbiAgICAgICAgdGhpcy5taW51dGUgPSBtaW51dGU7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNzU1NWRlMWUwNzA1MTBjYikodGhpcyk7XG4gICAgfVxufVxudmFyIC8vIFRoaXMgcHJldmVudHMgVHlwZVNjcmlwdCBmcm9tIGFsbG93aW5nIG90aGVyIHR5cGVzIHdpdGggdGhlIHNhbWUgZmllbGRzIHRvIG1hdGNoLlxuLy8gQHRzLWlnbm9yZVxuJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMiA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmIHtcbiAgICAvKiogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBkYXRlLiAqLyBjb3B5KCkge1xuICAgICAgICBpZiAodGhpcy5lcmEpIHJldHVybiBuZXcgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGNhODcxZThkYmI4MDk2NmYodGhpcy5jYWxlbmRhciwgdGhpcy5lcmEsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3ICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRjYTg3MWU4ZGJiODA5NjZmKHRoaXMuY2FsZW5kYXIsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIGFkZGVkIHRvIGl0LiAqLyBhZGQoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTE2ZDg1MjBhZjQ0YTA5NikodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgQ2FsZW5kYXJEYXRlVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZHVyYXRpb24gc3VidHJhY3RlZCBmcm9tIGl0LiAqLyBzdWJ0cmFjdChkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCQ0ZTJkMmVhZDY1ZTVmN2UzKSh0aGlzLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBDYWxlbmRhckRhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMgc2V0IHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuIE90aGVyIGZpZWxkcyB3aWxsIGJlIGNvbnN0cmFpbmVkIGFjY29yZGluZ2x5LiAqLyBzZXQoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGFkYWE0Y2Y3ZWYxYjY1YmUpKCgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZTVkNWUxYzE4MjJiNmU1NikodGhpcywgZmllbGRzKSwgZmllbGRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgYENhbGVuZGFyRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGZpZWxkIGFkanVzdGVkIGJ5IGEgc3BlY2lmaWVkIGFtb3VudC5cbiAgICogV2hlbiB0aGUgcmVzdWx0aW5nIHZhbHVlIHJlYWNoZXMgdGhlIGxpbWl0cyBvZiB0aGUgZmllbGQsIGl0IHdyYXBzIGFyb3VuZC5cbiAgICovIGN5Y2xlKGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoKGZpZWxkKXtcbiAgICAgICAgICAgIGNhc2UgJ2VyYSc6XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkZDUyY2VkNmJhZGZiOWE0YykodGhpcywgZmllbGQsIGFtb3VudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGRkMDJiM2UwMDA3ZGZlMjgpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDb252ZXJ0cyB0aGUgZGF0ZSB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0IGluIHRoZSBnaXZlbiB0aW1lIHpvbmUuICovIHRvRGF0ZSh0aW1lWm9uZSwgZGlzYW1iaWd1YXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkMTFkODdmM2Y3NmU4ODY1NyRleHBvcnQkZTY3YTA5NWM2MjBiODZmZSkodGhpcywgdGltZVpvbmUsIGRpc2FtYmlndWF0aW9uKTtcbiAgICB9XG4gICAgLyoqIENvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyA4NjAxIGZvcm1hdHRlZCBzdHJpbmcuICovIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsICRmYWU5NzdhYWZjMzkzYzVjJGV4cG9ydCQ0MjIzZGUxNDcwOGFkYzYzKSh0aGlzKTtcbiAgICB9XG4gICAgLyoqIENvbXBhcmVzIHRoaXMgZGF0ZSB3aXRoIGFub3RoZXIuIEEgbmVnYXRpdmUgcmVzdWx0IGluZGljYXRlcyB0aGF0IHRoaXMgZGF0ZSBpcyBiZWZvcmUgdGhlIGdpdmVuIG9uZSwgYW5kIGEgcG9zaXRpdmUgZGF0ZSBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhZnRlci4gKi8gY29tcGFyZShiKSB7XG4gICAgICAgIGxldCByZXMgPSAoMCwgJDE0ZTBmMjRlZjRhYzVjOTIkZXhwb3J0JDY4NzgxZGRmMzFjMDA5MGYpKHRoaXMsIGIpO1xuICAgICAgICBpZiAocmVzID09PSAwKSByZXR1cm4gKDAsICQxNGUwZjI0ZWY0YWM1YzkyJGV4cG9ydCRjMTlhODBhOTcyMWI4MGY2KSh0aGlzLCAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JGIyMWUwYjEyNGUyMjQ0ODQpKGIpKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgICgwLCAkYWtzeTEkXykodGhpcywgJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMiwge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgW2NhbGVuZGFyLCBlcmEsIHllYXIsIG1vbnRoLCBkYXldID0gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgICAgICB0aGlzLmVyYSA9IGVyYTtcbiAgICAgICAgdGhpcy55ZWFyID0geWVhcjtcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xuICAgICAgICB0aGlzLmRheSA9IGRheTtcbiAgICAgICAgdGhpcy5ob3VyID0gYXJncy5zaGlmdCgpIHx8IDA7XG4gICAgICAgIHRoaXMubWludXRlID0gYXJncy5zaGlmdCgpIHx8IDA7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gYXJncy5zaGlmdCgpIHx8IDA7XG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgKDAsICQ3MzUyMjBjMmQ0Nzc0ZGQzJGV4cG9ydCRjNGUyZWNhYzQ5MzUxZWYyKSh0aGlzKTtcbiAgICB9XG59XG52YXIgLy8gVGhpcyBwcmV2ZW50cyBUeXBlU2NyaXB0IGZyb20gYWxsb3dpbmcgb3RoZXIgdHlwZXMgd2l0aCB0aGUgc2FtZSBmaWVsZHMgdG8gbWF0Y2guXG4vLyBAdHMtaWdub3JlXG4kMzVlYThkYjljYjJjY2I5MCR2YXIkX3R5cGUzID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JGQzYjcyODhlNzk5NGVkZWEge1xuICAgIC8qKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIGRhdGUuICovIGNvcHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVyYSkgcmV0dXJuIG5ldyAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSh0aGlzLmNhbGVuZGFyLCB0aGlzLmVyYSwgdGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy50aW1lWm9uZSwgdGhpcy5vZmZzZXQsIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3ICQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCRkM2I3Mjg4ZTc5OTRlZGVhKHRoaXMuY2FsZW5kYXIsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMudGltZVpvbmUsIHRoaXMub2Zmc2V0LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGBab25lZERhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBkdXJhdGlvbiBhZGRlZCB0byBpdC4gKi8gYWRkKGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDk2YjFkMjgzNDkyNzQ2MzcpKHRoaXMsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYFpvbmVkRGF0ZVRpbWVgIHdpdGggdGhlIGdpdmVuIGR1cmF0aW9uIHN1YnRyYWN0ZWQgZnJvbSBpdC4gKi8gc3VidHJhY3QoZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkNjgxNGNhYWMzNGNhMDNjNykodGhpcywgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBgWm9uZWREYXRlVGltZWAgd2l0aCB0aGUgZ2l2ZW4gZmllbGRzIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLiBPdGhlciBmaWVsZHMgd2lsbCBiZSBjb25zdHJhaW5lZCBhY2NvcmRpbmdseS4gKi8gc2V0KGZpZWxkcywgZGlzYW1iaWd1YXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCAkNzM1MjIwYzJkNDc3NGRkMyRleHBvcnQkMzFiNTQzMGViMThiZTRmOCkodGhpcywgZmllbGRzLCBkaXNhbWJpZ3VhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGBab25lZERhdGVUaW1lYCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBhZGp1c3RlZCBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyB2YWx1ZSByZWFjaGVzIHRoZSBsaW1pdHMgb2YgdGhlIGZpZWxkLCBpdCB3cmFwcyBhcm91bmQuXG4gICAqLyBjeWNsZShmaWVsZCwgYW1vdW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JDlhMjk3ZDExMWZjODZiNzkpKHRoaXMsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gKi8gdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gKDAsICQxMWQ4N2YzZjc2ZTg4NjU3JGV4cG9ydCQ4M2FhYzA3YjRjMzdiMjUpKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZywgaW5jbHVkaW5nIHRoZSBVVEMgb2Zmc2V0IGFuZCB0aW1lIHpvbmUgaWRlbnRpZmllci4gKi8gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgJGZhZTk3N2FhZmMzOTNjNWMkZXhwb3J0JGJmNzlmMWViZjRiMTg3OTIpKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHN0cmluZyBpbiBVVEMuICovIHRvQWJzb2x1dGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKiBDb21wYXJlcyB0aGlzIGRhdGUgd2l0aCBhbm90aGVyLiBBIG5lZ2F0aXZlIHJlc3VsdCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGRhdGUgaXMgYmVmb3JlIHRoZSBnaXZlbiBvbmUsIGFuZCBhIHBvc2l0aXZlIGRhdGUgaW5kaWNhdGVzIHRoYXQgaXQgaXMgYWZ0ZXIuICovIGNvbXBhcmUoYikge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGEgYmFkIGlkZWE/P1xuICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS5nZXRUaW1lKCkgLSAoMCwgJDExZDg3ZjNmNzZlODg2NTckZXhwb3J0JDg0Yzk1YTgzYzc5OWUwNzQpKGIsIHRoaXMudGltZVpvbmUpLnRvRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgICgwLCAkYWtzeTEkXykodGhpcywgJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJF90eXBlMywge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgW2NhbGVuZGFyLCBlcmEsIHllYXIsIG1vbnRoLCBkYXldID0gJDM1ZWE4ZGI5Y2IyY2NiOTAkdmFyJHNoaWZ0QXJncyhhcmdzKTtcbiAgICAgICAgbGV0IHRpbWVab25lID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gYXJncy5zaGlmdCgpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgICAgIHRoaXMuZXJhID0gZXJhO1xuICAgICAgICB0aGlzLnllYXIgPSB5ZWFyO1xuICAgICAgICB0aGlzLm1vbnRoID0gbW9udGg7XG4gICAgICAgIHRoaXMuZGF5ID0gZGF5O1xuICAgICAgICB0aGlzLnRpbWVab25lID0gdGltZVpvbmU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmhvdXIgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgdGhpcy5taW51dGUgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgdGhpcy5zZWNvbmQgPSBhcmdzLnNoaWZ0KCkgfHwgMDtcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IGFyZ3Muc2hpZnQoKSB8fCAwO1xuICAgICAgICAoMCwgJDczNTIyMGMyZDQ3NzRkZDMkZXhwb3J0JGM0ZTJlY2FjNDkzNTFlZjIpKHRoaXMpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgeyQzNWVhOGRiOWNiMmNjYjkwJGV4cG9ydCQ5OWZhYTc2MGM3OTA4ZTRmIGFzIENhbGVuZGFyRGF0ZSwgJDM1ZWE4ZGI5Y2IyY2NiOTAkZXhwb3J0JDY4MGVhMTk2ZWZmY2U1ZiBhcyBUaW1lLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkY2E4NzFlOGRiYjgwOTY2ZiBhcyBDYWxlbmRhckRhdGVUaW1lLCAkMzVlYThkYjljYjJjY2I5MCRleHBvcnQkZDNiNzI4OGU3OTk0ZWRlYSBhcyBab25lZERhdGVUaW1lfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGVuZGFyRGF0ZS5tb2R1bGUuanMubWFwXG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gbGV0ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRmb3JtYXR0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbmNsYXNzICRmYjE4ZDU0MWVhMWFkNzE3JGV4cG9ydCRhZDk5MWI2NjEzMzg1MWNmIHtcbiAgICAvKiogRm9ybWF0cyBhIGRhdGUgYXMgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUgYW5kIGZvcm1hdCBvcHRpb25zIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICovIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEZvcm1hdHMgYSBkYXRlIHRvIGFuIGFycmF5IG9mIHBhcnRzIHN1Y2ggYXMgc2VwYXJhdG9ycywgbnVtYmVycywgcHVuY3R1YXRpb24sIGFuZCBtb3JlLiAqLyBmb3JtYXRUb1BhcnRzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEZvcm1hdHMgYSBkYXRlIHJhbmdlIGFzIGEgc3RyaW5nLiAqLyBmb3JtYXRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdHRlci5mb3JtYXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJykgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0VuZCBkYXRlIG11c3QgYmUgPj0gc3RhcnQgZGF0ZScpO1xuICAgICAgICAvLyBWZXJ5IGJhc2ljIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnMuXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdHRlci5mb3JtYXQoc3RhcnQpfSBcXHV7MjAxM30gJHt0aGlzLmZvcm1hdHRlci5mb3JtYXQoZW5kKX1gO1xuICAgIH1cbiAgICAvKiogRm9ybWF0cyBhIGRhdGUgcmFuZ2UgYXMgYW4gYXJyYXkgb2YgcGFydHMuICovIGZvcm1hdFJhbmdlVG9QYXJ0cyhzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMgPT09ICdmdW5jdGlvbicpIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZvcm1hdFJhbmdlVG9QYXJ0cyhzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRW5kIGRhdGUgbXVzdCBiZSA+PSBzdGFydCBkYXRlJyk7XG4gICAgICAgIGxldCBzdGFydFBhcnRzID0gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhzdGFydCk7XG4gICAgICAgIGxldCBlbmRQYXJ0cyA9IHRoaXMuZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoZW5kKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnN0YXJ0UGFydHMubWFwKChwKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnc3RhcnRSYW5nZSdcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIiBcXHUyMDEzIFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ3NoYXJlZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5lbmRQYXJ0cy5tYXAoKHApPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdlbmRSYW5nZSdcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIHJlc29sdmVkIGZvcm1hdHRpbmcgb3B0aW9ucyBiYXNlZCBvbiB0aGUgdmFsdWVzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICovIHJlc29sdmVkT3B0aW9ucygpIHtcbiAgICAgICAgbGV0IHJlc29sdmVkT3B0aW9ucyA9IHRoaXMuZm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgICBpZiAoJGZiMThkNTQxZWExYWQ3MTckdmFyJGhhc0J1Z2d5UmVzb2x2ZWRIb3VyQ3ljbGUoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkSG91ckN5Y2xlKSB0aGlzLnJlc29sdmVkSG91ckN5Y2xlID0gJGZiMThkNTQxZWExYWQ3MTckdmFyJGdldFJlc29sdmVkSG91ckN5Y2xlKHJlc29sdmVkT3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICByZXNvbHZlZE9wdGlvbnMuaG91ckN5Y2xlID0gdGhpcy5yZXNvbHZlZEhvdXJDeWNsZTtcbiAgICAgICAgICAgIHJlc29sdmVkT3B0aW9ucy5ob3VyMTIgPSB0aGlzLnJlc29sdmVkSG91ckN5Y2xlID09PSAnaDExJyB8fCB0aGlzLnJlc29sdmVkSG91ckN5Y2xlID09PSAnaDEyJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgdXNlcyBhIGRpZmZlcmVudCBuYW1lIGZvciB0aGUgRXRoaW9waWMgKEFtZXRlIEFsZW0pIGNhbGVuZGFyLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjQxNTY0XG4gICAgICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuY2FsZW5kYXIgPT09ICdldGhpb3BpYy1hbWV0ZS1hbGVtJykgcmVzb2x2ZWRPcHRpb25zLmNhbGVuZGFyID0gJ2V0aGlvYWEnO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRPcHRpb25zO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID0gJGZiMThkNTQxZWExYWQ3MTckdmFyJGdldENhY2hlZERhdGVGb3JtYXR0ZXIobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG59XG4vLyBUaGVyZSBhcmUgbXVsdGlwbGUgYnVncyBpbnZvbHZpbmcgdGhlIGhvdXIxMiBhbmQgaG91ckN5Y2xlIG9wdGlvbnMgaW4gdmFyaW91cyBicm93c2VyIGVuZ2luZXMuXG4vLyAgIC0gQ2hyb21lIFsxXSAoYW5kIHRoZSBFQ01BIDQwMiBzcGVjIFsyXSkgcmVzb2x2ZSBob3VyMTI6IGZhbHNlIGluIEVuZ2xpc2ggYW5kIG90aGVyIGxvY2FsZXMgdG8gaDI0ICgyNDowMCAtIDIzOjU5KVxuLy8gICAgIHJhdGhlciB0aGFuIGgyMyAoMDA6MDAgLSAyMzo1OSkuIFNhbWUgY2FuIGhhcHBlbiB3aXRoIGhvdXIxMjogdHJ1ZSBpbiBGcmVuY2gsIHdoaWNoIENocm9tZSByZXNvbHZlcyB0byBoMTEgKDAwOjAwIC0gMTE6NTkpXG4vLyAgICAgcmF0aGVyIHRoYW4gaDEyICgxMjowMCAtIDExOjU5KS5cbi8vICAgLSBXZWJLaXQgcmV0dXJucyBhbiBpbmNvcnJlY3QgaG91ckN5Y2xlIHJlc29sdmVkIG9wdGlvbiBpbiB0aGUgRnJlbmNoIGxvY2FsZSBkdWUgdG8gaW5jb3JyZWN0IHBhcnNpbmcgb2YgJ2gnIGxpdGVyYWxcbi8vICAgICBpbiB0aGUgcmVzb2x2ZWQgcGF0dGVybi4gSXQgYWxzbyBmb3JtYXRzIGluY29ycmVjdGx5IHdoZW4gc3BlY2lmeWluZyB0aGUgaG91ckN5Y2xlIG9wdGlvbiBmb3IgdGhlIHNhbWUgcmVhc29uLiBbM11cbi8vIFsxXSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ1NzkxXG4vLyBbMl0gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTQwMi9pc3N1ZXMvNDAyXG4vLyBbM10gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyOTMxM1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2NsZHIvYmxvYi8wMThiNTVlZmY3Y2ViMzg5YzdlM2ZjNDRlMmY2NTdlYWUzYjEwYjM4L2NvbW1vbi9zdXBwbGVtZW50YWwvc3VwcGxlbWVudGFsRGF0YS54bWwjTDQ3NzQtTDQ4MDJcbmNvbnN0ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRob3VyMTJQcmVmZXJlbmNlcyA9IHtcbiAgICB0cnVlOiB7XG4gICAgICAgIC8vIE9ubHkgSmFwYW5lc2UgdXNlcyB0aGUgaDExIHN0eWxlIGZvciAxMiBob3VyIHRpbWUuIEFsbCBvdGhlcnMgdXNlIGgxMi5cbiAgICAgICAgamE6ICdoMTEnXG4gICAgfSxcbiAgICBmYWxzZToge1xuICAgIH1cbn07XG5mdW5jdGlvbiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZ2V0Q2FjaGVkRGF0ZUZvcm1hdHRlcihsb2NhbGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFdvcmsgYXJvdW5kIGJ1Z2d5IGhvdXIxMiBiZWhhdmlvciBpbiBDaHJvbWUgLyBFQ01BIDQwMiBzcGVjIGJ5IHVzaW5nIGhvdXJDeWNsZSBpbnN0ZWFkLlxuICAgIC8vIE9ubHkgYXBwbHkgdGhlIHdvcmthcm91bmQgaWYgdGhlIGlzc3VlIGlzIGRldGVjdGVkLCBiZWNhdXNlIHRoZSBob3VyQ3ljbGUgb3B0aW9uIGlzIGJ1Z2d5IGluIFNhZmFyaS5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaG91cjEyID09PSAnYm9vbGVhbicgJiYgJGZiMThkNTQxZWExYWQ3MTckdmFyJGhhc0J1Z2d5SG91cjEyQmVoYXZpb3IoKSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcHJlZiA9ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRob3VyMTJQcmVmZXJlbmNlc1tTdHJpbmcob3B0aW9ucy5ob3VyMTIpXVtsb2NhbGUuc3BsaXQoJy0nKVswXV07XG4gICAgICAgIGxldCBkZWZhdWx0SG91ckN5Y2xlID0gb3B0aW9ucy5ob3VyMTIgPyAnaDEyJyA6ICdoMjMnO1xuICAgICAgICBvcHRpb25zLmhvdXJDeWNsZSA9IHByZWYgIT09IG51bGwgJiYgcHJlZiAhPT0gdm9pZCAwID8gcHJlZiA6IGRlZmF1bHRIb3VyQ3ljbGU7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmhvdXIxMjtcbiAgICB9XG4gICAgbGV0IGNhY2hlS2V5ID0gbG9jYWxlICsgKG9wdGlvbnMgPyBPYmplY3QuZW50cmllcyhvcHRpb25zKS5zb3J0KChhLCBiKT0+YVswXSA8IGJbMF0gPyAtMSA6IDEpLmpvaW4oKSA6ICcnKTtcbiAgICBpZiAoJGZiMThkNTQxZWExYWQ3MTckdmFyJGZvcm1hdHRlckNhY2hlLmhhcyhjYWNoZUtleSkpIHJldHVybiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZm9ybWF0dGVyQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBsZXQgbnVtYmVyRm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZm9ybWF0dGVyQ2FjaGUuc2V0KGNhY2hlS2V5LCBudW1iZXJGb3JtYXR0ZXIpO1xuICAgIHJldHVybiBudW1iZXJGb3JtYXR0ZXI7XG59XG5sZXQgJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneUhvdXIxMkJlaGF2aW9yID0gbnVsbDtcbmZ1bmN0aW9uICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRoYXNCdWdneUhvdXIxMkJlaGF2aW9yKCkge1xuICAgIGlmICgkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkX2hhc0J1Z2d5SG91cjEyQmVoYXZpb3IgPT0gbnVsbCkgJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneUhvdXIxMkJlaGF2aW9yID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIGhvdXIxMjogZmFsc2VcbiAgICB9KS5mb3JtYXQobmV3IERhdGUoMjAyMCwgMiwgMywgMCkpID09PSAnMjQnO1xuICAgIHJldHVybiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkX2hhc0J1Z2d5SG91cjEyQmVoYXZpb3I7XG59XG5sZXQgJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlID0gbnVsbDtcbmZ1bmN0aW9uICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRoYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlKCkge1xuICAgIGlmICgkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkX2hhc0J1Z2d5UmVzb2x2ZWRIb3VyQ3ljbGUgPT0gbnVsbCkgJGZiMThkNTQxZWExYWQ3MTckdmFyJF9oYXNCdWdneVJlc29sdmVkSG91ckN5Y2xlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2ZyJywge1xuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIGhvdXIxMjogZmFsc2VcbiAgICB9KS5yZXNvbHZlZE9wdGlvbnMoKS5ob3VyQ3ljbGUgPT09ICdoMTInO1xuICAgIHJldHVybiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkX2hhc0J1Z2d5UmVzb2x2ZWRIb3VyQ3ljbGU7XG59XG5mdW5jdGlvbiAkZmIxOGQ1NDFlYTFhZDcxNyR2YXIkZ2V0UmVzb2x2ZWRIb3VyQ3ljbGUobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnRpbWVTdHlsZSAmJiAhb3B0aW9ucy5ob3VyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIC8vIFdvcmsgYXJvdW5kIGJ1Z2d5IHJlc3VsdHMgaW4gcmVzb2x2ZWQgaG91ckN5Y2xlIGFuZCBob3VyMTIgb3B0aW9ucyBpbiBXZWJLaXQuXG4gICAgLy8gRm9ybWF0IHRoZSBtaW5pbXVtIHBvc3NpYmxlIGhvdXIgYW5kIG1heGltdW0gcG9zc2libGUgaG91ciBpbiBhIGRheSBhbmQgcGFyc2UgdGhlIHJlc3VsdHMuXG4gICAgbG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoLygtdS0pPy1udS1bYS16QS1aMC05XSsvLCAnJyk7XG4gICAgbG9jYWxlICs9IChsb2NhbGUuaW5jbHVkZXMoJy11LScpID8gJycgOiAnLXUnKSArICctbnUtbGF0bic7XG4gICAgbGV0IGZvcm1hdHRlciA9ICRmYjE4ZDU0MWVhMWFkNzE3JHZhciRnZXRDYWNoZWREYXRlRm9ybWF0dGVyKGxvY2FsZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0aW1lWm9uZTogdW5kZWZpbmVkIC8vIHVzZSBsb2NhbCB0aW1lem9uZVxuICAgIH0pO1xuICAgIGxldCBtaW4gPSBwYXJzZUludChmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgyMDIwLCAyLCAzLCAwKSkuZmluZCgocCk9PnAudHlwZSA9PT0gJ2hvdXInKS52YWx1ZSwgMTApO1xuICAgIGxldCBtYXggPSBwYXJzZUludChmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgyMDIwLCAyLCAzLCAyMykpLmZpbmQoKHApPT5wLnR5cGUgPT09ICdob3VyJykudmFsdWUsIDEwKTtcbiAgICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMjMpIHJldHVybiAnaDIzJztcbiAgICBpZiAobWluID09PSAyNCAmJiBtYXggPT09IDIzKSByZXR1cm4gJ2gyNCc7XG4gICAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDExKSByZXR1cm4gJ2gxMSc7XG4gICAgaWYgKG1pbiA9PT0gMTIgJiYgbWF4ID09PSAxMSkgcmV0dXJuICdoMTInO1xuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBob3VyIGN5Y2xlIHJlc3VsdCcpO1xufVxuXG5cbmV4cG9ydCB7JGZiMThkNTQxZWExYWQ3MTckZXhwb3J0JGFkOTkxYjY2MTMzODUxY2YgYXMgRGF0ZUZvcm1hdHRlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRlRm9ybWF0dGVyLm1vZHVsZS5qcy5tYXBcbiIsInZhciBsPWU9PnR5cGVvZiBlPT1cImJvb2xlYW5cIj9gJHtlfWA6ZT09PTA/XCIwXCI6ZSx1PWU9PiFlfHx0eXBlb2YgZSE9XCJvYmplY3RcInx8T2JqZWN0LmtleXMoZSkubGVuZ3RoPT09MCx4PShlLG8pPT5KU09OLnN0cmluZ2lmeShlKT09PUpTT04uc3RyaW5naWZ5KG8pLEE9ZT0+dHlwZW9mIGU9PVwiYm9vbGVhblwiO2Z1bmN0aW9uIGkoZSxvKXtlLmZvckVhY2goZnVuY3Rpb24ocil7QXJyYXkuaXNBcnJheShyKT9pKHIsbyk6by5wdXNoKHIpO30pO31mdW5jdGlvbiB5KGUpe2xldCBvPVtdO3JldHVybiBpKGUsbyksb312YXIgYT0oLi4uZSk9PnkoZSkuZmlsdGVyKEJvb2xlYW4pLHA9KGUsbyk9PntsZXQgcj17fSxjPU9iamVjdC5rZXlzKGUpLGY9T2JqZWN0LmtleXMobyk7Zm9yKGxldCB0IG9mIGMpaWYoZi5pbmNsdWRlcyh0KSl7bGV0IHM9ZVt0XSxuPW9bdF07QXJyYXkuaXNBcnJheShzKXx8QXJyYXkuaXNBcnJheShuKT9yW3RdPWEobixzKTp0eXBlb2Ygcz09XCJvYmplY3RcIiYmdHlwZW9mIG49PVwib2JqZWN0XCI/clt0XT1wKHMsbik6clt0XT1uK1wiIFwiK3M7fWVsc2Ugclt0XT1lW3RdO2ZvcihsZXQgdCBvZiBmKWMuaW5jbHVkZXModCl8fChyW3RdPW9bdF0pO3JldHVybiByfSxnPWU9PiFlfHx0eXBlb2YgZSE9XCJzdHJpbmdcIj9lOmUucmVwbGFjZSgvXFxzKy9nLFwiIFwiKS50cmltKCk7XG5cbmV4cG9ydCB7IGwgYXMgYSwgdSBhcyBiLCB4IGFzIGMsIEEgYXMgZCwgeSBhcyBlLCBhIGFzIGYsIHAgYXMgZywgZyBhcyBoIH07XG4iLCJjb25zdCBDTEFTU19QQVJUX1NFUEFSQVRPUiA9ICctJztcbmNvbnN0IGNyZWF0ZUNsYXNzR3JvdXBVdGlscyA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IGNsYXNzTWFwID0gY3JlYXRlQ2xhc3NNYXAoY29uZmlnKTtcbiAgY29uc3Qge1xuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHMsXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGdldENsYXNzR3JvdXBJZCA9IGNsYXNzTmFtZSA9PiB7XG4gICAgY29uc3QgY2xhc3NQYXJ0cyA9IGNsYXNzTmFtZS5zcGxpdChDTEFTU19QQVJUX1NFUEFSQVRPUik7XG4gICAgLy8gQ2xhc3NlcyBsaWtlIGAtaW5zZXQtMWAgcHJvZHVjZSBhbiBlbXB0eSBzdHJpbmcgYXMgZmlyc3QgY2xhc3NQYXJ0LiBXZSBhc3N1bWUgdGhhdCBjbGFzc2VzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgY29ycmVjdGx5IGFuZCByZW1vdmUgaXQgZnJvbSBjbGFzc1BhcnRzLlxuICAgIGlmIChjbGFzc1BhcnRzWzBdID09PSAnJyAmJiBjbGFzc1BhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgY2xhc3NQYXJ0cy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0R3JvdXBSZWN1cnNpdmUoY2xhc3NQYXJ0cywgY2xhc3NNYXApIHx8IGdldEdyb3VwSWRGb3JBcmJpdHJhcnlQcm9wZXJ0eShjbGFzc05hbWUpO1xuICB9O1xuICBjb25zdCBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHMgPSAoY2xhc3NHcm91cElkLCBoYXNQb3N0Zml4TW9kaWZpZXIpID0+IHtcbiAgICBjb25zdCBjb25mbGljdHMgPSBjb25mbGljdGluZ0NsYXNzR3JvdXBzW2NsYXNzR3JvdXBJZF0gfHwgW107XG4gICAgaWYgKGhhc1Bvc3RmaXhNb2RpZmllciAmJiBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNbY2xhc3NHcm91cElkXSkge1xuICAgICAgcmV0dXJuIFsuLi5jb25mbGljdHMsIC4uLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1tjbGFzc0dyb3VwSWRdXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZsaWN0cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRDbGFzc0dyb3VwSWQsXG4gICAgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzXG4gIH07XG59O1xuY29uc3QgZ2V0R3JvdXBSZWN1cnNpdmUgPSAoY2xhc3NQYXJ0cywgY2xhc3NQYXJ0T2JqZWN0KSA9PiB7XG4gIGlmIChjbGFzc1BhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjbGFzc1BhcnRPYmplY3QuY2xhc3NHcm91cElkO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRDbGFzc1BhcnQgPSBjbGFzc1BhcnRzWzBdO1xuICBjb25zdCBuZXh0Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmdldChjdXJyZW50Q2xhc3NQYXJ0KTtcbiAgY29uc3QgY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0ID0gbmV4dENsYXNzUGFydE9iamVjdCA/IGdldEdyb3VwUmVjdXJzaXZlKGNsYXNzUGFydHMuc2xpY2UoMSksIG5leHRDbGFzc1BhcnRPYmplY3QpIDogdW5kZWZpbmVkO1xuICBpZiAoY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0KSB7XG4gICAgcmV0dXJuIGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydDtcbiAgfVxuICBpZiAoY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBjbGFzc1Jlc3QgPSBjbGFzc1BhcnRzLmpvaW4oQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICByZXR1cm4gY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMuZmluZCgoe1xuICAgIHZhbGlkYXRvclxuICB9KSA9PiB2YWxpZGF0b3IoY2xhc3NSZXN0KSk/LmNsYXNzR3JvdXBJZDtcbn07XG5jb25zdCBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4ID0gL15cXFsoLispXFxdJC87XG5jb25zdCBnZXRHcm91cElkRm9yQXJiaXRyYXJ5UHJvcGVydHkgPSBjbGFzc05hbWUgPT4ge1xuICBpZiAoYXJiaXRyYXJ5UHJvcGVydHlSZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICBjb25zdCBhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZSA9IGFyYml0cmFyeVByb3BlcnR5UmVnZXguZXhlYyhjbGFzc05hbWUpWzFdO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWU/LnN1YnN0cmluZygwLCBhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZS5pbmRleE9mKCc6JykpO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgLy8gSSB1c2UgdHdvIGRvdHMgaGVyZSBiZWNhdXNlIG9uZSBkb3QgaXMgdXNlZCBhcyBwcmVmaXggZm9yIGNsYXNzIGdyb3VwcyBpbiBwbHVnaW5zXG4gICAgICByZXR1cm4gJ2FyYml0cmFyeS4uJyArIHByb3BlcnR5O1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3Rpbmcgb25seVxuICovXG5jb25zdCBjcmVhdGVDbGFzc01hcCA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZSxcbiAgICBwcmVmaXhcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgY2xhc3NNYXAgPSB7XG4gICAgbmV4dFBhcnQ6IG5ldyBNYXAoKSxcbiAgICB2YWxpZGF0b3JzOiBbXVxuICB9O1xuICBjb25zdCBwcmVmaXhlZENsYXNzR3JvdXBFbnRyaWVzID0gZ2V0UHJlZml4ZWRDbGFzc0dyb3VwRW50cmllcyhPYmplY3QuZW50cmllcyhjb25maWcuY2xhc3NHcm91cHMpLCBwcmVmaXgpO1xuICBwcmVmaXhlZENsYXNzR3JvdXBFbnRyaWVzLmZvckVhY2goKFtjbGFzc0dyb3VwSWQsIGNsYXNzR3JvdXBdKSA9PiB7XG4gICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0dyb3VwLCBjbGFzc01hcCwgY2xhc3NHcm91cElkLCB0aGVtZSk7XG4gIH0pO1xuICByZXR1cm4gY2xhc3NNYXA7XG59O1xuY29uc3QgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseSA9IChjbGFzc0dyb3VwLCBjbGFzc1BhcnRPYmplY3QsIGNsYXNzR3JvdXBJZCwgdGhlbWUpID0+IHtcbiAgY2xhc3NHcm91cC5mb3JFYWNoKGNsYXNzRGVmaW5pdGlvbiA9PiB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjbGFzc1BhcnRPYmplY3RUb0VkaXQgPSBjbGFzc0RlZmluaXRpb24gPT09ICcnID8gY2xhc3NQYXJ0T2JqZWN0IDogZ2V0UGFydChjbGFzc1BhcnRPYmplY3QsIGNsYXNzRGVmaW5pdGlvbik7XG4gICAgICBjbGFzc1BhcnRPYmplY3RUb0VkaXQuY2xhc3NHcm91cElkID0gY2xhc3NHcm91cElkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNsYXNzRGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGlzVGhlbWVHZXR0ZXIoY2xhc3NEZWZpbml0aW9uKSkge1xuICAgICAgICBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5KGNsYXNzRGVmaW5pdGlvbih0aGVtZSksIGNsYXNzUGFydE9iamVjdCwgY2xhc3NHcm91cElkLCB0aGVtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNsYXNzUGFydE9iamVjdC52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgICB2YWxpZGF0b3I6IGNsYXNzRGVmaW5pdGlvbixcbiAgICAgICAgY2xhc3NHcm91cElkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmVudHJpZXMoY2xhc3NEZWZpbml0aW9uKS5mb3JFYWNoKChba2V5LCBjbGFzc0dyb3VwXSkgPT4ge1xuICAgICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0dyb3VwLCBnZXRQYXJ0KGNsYXNzUGFydE9iamVjdCwga2V5KSwgY2xhc3NHcm91cElkLCB0aGVtZSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbmNvbnN0IGdldFBhcnQgPSAoY2xhc3NQYXJ0T2JqZWN0LCBwYXRoKSA9PiB7XG4gIGxldCBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0O1xuICBwYXRoLnNwbGl0KENMQVNTX1BBUlRfU0VQQVJBVE9SKS5mb3JFYWNoKHBhdGhQYXJ0ID0+IHtcbiAgICBpZiAoIWN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuaGFzKHBhdGhQYXJ0KSkge1xuICAgICAgY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5zZXQocGF0aFBhcnQsIHtcbiAgICAgICAgbmV4dFBhcnQ6IG5ldyBNYXAoKSxcbiAgICAgICAgdmFsaWRhdG9yczogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5nZXQocGF0aFBhcnQpO1xuICB9KTtcbiAgcmV0dXJuIGN1cnJlbnRDbGFzc1BhcnRPYmplY3Q7XG59O1xuY29uc3QgaXNUaGVtZUdldHRlciA9IGZ1bmMgPT4gZnVuYy5pc1RoZW1lR2V0dGVyO1xuY29uc3QgZ2V0UHJlZml4ZWRDbGFzc0dyb3VwRW50cmllcyA9IChjbGFzc0dyb3VwRW50cmllcywgcHJlZml4KSA9PiB7XG4gIGlmICghcHJlZml4KSB7XG4gICAgcmV0dXJuIGNsYXNzR3JvdXBFbnRyaWVzO1xuICB9XG4gIHJldHVybiBjbGFzc0dyb3VwRW50cmllcy5tYXAoKFtjbGFzc0dyb3VwSWQsIGNsYXNzR3JvdXBdKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZWRDbGFzc0dyb3VwID0gY2xhc3NHcm91cC5tYXAoY2xhc3NEZWZpbml0aW9uID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgY2xhc3NEZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2xhc3NEZWZpbml0aW9uKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW3ByZWZpeCArIGtleSwgdmFsdWVdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhc3NEZWZpbml0aW9uO1xuICAgIH0pO1xuICAgIHJldHVybiBbY2xhc3NHcm91cElkLCBwcmVmaXhlZENsYXNzR3JvdXBdO1xuICB9KTtcbn07XG5cbi8vIExSVSBjYWNoZSBpbnNwaXJlZCBmcm9tIGhhc2hscnUgKGh0dHBzOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9oYXNobHJ1L2Jsb2IvdjEuMC40L2luZGV4LmpzKSBidXQgb2JqZWN0IHJlcGxhY2VkIHdpdGggTWFwIHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbmNvbnN0IGNyZWF0ZUxydUNhY2hlID0gbWF4Q2FjaGVTaXplID0+IHtcbiAgaWYgKG1heENhY2hlU2l6ZSA8IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICBzZXQ6ICgpID0+IHt9XG4gICAgfTtcbiAgfVxuICBsZXQgY2FjaGVTaXplID0gMDtcbiAgbGV0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgcHJldmlvdXNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdXBkYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgY2FjaGVTaXplKys7XG4gICAgaWYgKGNhY2hlU2l6ZSA+IG1heENhY2hlU2l6ZSkge1xuICAgICAgY2FjaGVTaXplID0gMDtcbiAgICAgIHByZXZpb3VzQ2FjaGUgPSBjYWNoZTtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgodmFsdWUgPSBwcmV2aW91c0NhY2hlLmdldChrZXkpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IElNUE9SVEFOVF9NT0RJRklFUiA9ICchJztcbmNvbnN0IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lID0gY29uZmlnID0+IHtcbiAgY29uc3Qge1xuICAgIHNlcGFyYXRvcixcbiAgICBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc1NlcGFyYXRvclNpbmdsZUNoYXJhY3RlciA9IHNlcGFyYXRvci5sZW5ndGggPT09IDE7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9yQ2hhcmFjdGVyID0gc2VwYXJhdG9yWzBdO1xuICBjb25zdCBzZXBhcmF0b3JMZW5ndGggPSBzZXBhcmF0b3IubGVuZ3RoO1xuICAvLyBwYXJzZUNsYXNzTmFtZSBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2Jsb2IvdjMuMi4yL3NyYy91dGlsL3NwbGl0QXRUb3BMZXZlbE9ubHkuanNcbiAgY29uc3QgcGFyc2VDbGFzc05hbWUgPSBjbGFzc05hbWUgPT4ge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtdO1xuICAgIGxldCBicmFja2V0RGVwdGggPSAwO1xuICAgIGxldCBtb2RpZmllclN0YXJ0ID0gMDtcbiAgICBsZXQgcG9zdGZpeE1vZGlmaWVyUG9zaXRpb247XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyID0gY2xhc3NOYW1lW2luZGV4XTtcbiAgICAgIGlmIChicmFja2V0RGVwdGggPT09IDApIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09IGZpcnN0U2VwYXJhdG9yQ2hhcmFjdGVyICYmIChpc1NlcGFyYXRvclNpbmdsZUNoYXJhY3RlciB8fCBjbGFzc05hbWUuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VwYXJhdG9yTGVuZ3RoKSA9PT0gc2VwYXJhdG9yKSkge1xuICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGNsYXNzTmFtZS5zbGljZShtb2RpZmllclN0YXJ0LCBpbmRleCkpO1xuICAgICAgICAgIG1vZGlmaWVyU3RhcnQgPSBpbmRleCArIHNlcGFyYXRvckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJy8nKSB7XG4gICAgICAgICAgcG9zdGZpeE1vZGlmaWVyUG9zaXRpb24gPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICdbJykge1xuICAgICAgICBicmFja2V0RGVwdGgrKztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJ10nKSB7XG4gICAgICAgIGJyYWNrZXREZXB0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyID0gbW9kaWZpZXJzLmxlbmd0aCA9PT0gMCA/IGNsYXNzTmFtZSA6IGNsYXNzTmFtZS5zdWJzdHJpbmcobW9kaWZpZXJTdGFydCk7XG4gICAgY29uc3QgaGFzSW1wb3J0YW50TW9kaWZpZXIgPSBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyLnN0YXJ0c1dpdGgoSU1QT1JUQU5UX01PRElGSUVSKTtcbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lID0gaGFzSW1wb3J0YW50TW9kaWZpZXIgPyBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyLnN1YnN0cmluZygxKSA6IGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXI7XG4gICAgY29uc3QgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA9IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uICYmIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID4gbW9kaWZpZXJTdGFydCA/IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uIC0gbW9kaWZpZXJTdGFydCA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH07XG4gIH07XG4gIGlmIChleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjbGFzc05hbWUgPT4gZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUoe1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcGFyc2VDbGFzc05hbWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGFyc2VDbGFzc05hbWU7XG59O1xuLyoqXG4gKiBTb3J0cyBtb2RpZmllcnMgYWNjb3JkaW5nIHRvIGZvbGxvd2luZyBzY2hlbWE6XG4gKiAtIFByZWRlZmluZWQgbW9kaWZpZXJzIGFyZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHlcbiAqIC0gV2hlbiBhbiBhcmJpdHJhcnkgdmFyaWFudCBhcHBlYXJzLCBpdCBtdXN0IGJlIHByZXNlcnZlZCB3aGljaCBtb2RpZmllcnMgYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgaXRcbiAqL1xuY29uc3Qgc29ydE1vZGlmaWVycyA9IG1vZGlmaWVycyA9PiB7XG4gIGlmIChtb2RpZmllcnMubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJzO1xuICB9XG4gIGNvbnN0IHNvcnRlZE1vZGlmaWVycyA9IFtdO1xuICBsZXQgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4ge1xuICAgIGNvbnN0IGlzQXJiaXRyYXJ5VmFyaWFudCA9IG1vZGlmaWVyWzBdID09PSAnWyc7XG4gICAgaWYgKGlzQXJiaXRyYXJ5VmFyaWFudCkge1xuICAgICAgc29ydGVkTW9kaWZpZXJzLnB1c2goLi4udW5zb3J0ZWRNb2RpZmllcnMuc29ydCgpLCBtb2RpZmllcik7XG4gICAgICB1bnNvcnRlZE1vZGlmaWVycyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnNvcnRlZE1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICBzb3J0ZWRNb2RpZmllcnMucHVzaCguLi51bnNvcnRlZE1vZGlmaWVycy5zb3J0KCkpO1xuICByZXR1cm4gc29ydGVkTW9kaWZpZXJzO1xufTtcbmNvbnN0IGNyZWF0ZUNvbmZpZ1V0aWxzID0gY29uZmlnID0+ICh7XG4gIGNhY2hlOiBjcmVhdGVMcnVDYWNoZShjb25maWcuY2FjaGVTaXplKSxcbiAgcGFyc2VDbGFzc05hbWU6IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lKGNvbmZpZyksXG4gIC4uLmNyZWF0ZUNsYXNzR3JvdXBVdGlscyhjb25maWcpXG59KTtcbmNvbnN0IFNQTElUX0NMQVNTRVNfUkVHRVggPSAvXFxzKy87XG5jb25zdCBtZXJnZUNsYXNzTGlzdCA9IChjbGFzc0xpc3QsIGNvbmZpZ1V0aWxzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwYXJzZUNsYXNzTmFtZSxcbiAgICBnZXRDbGFzc0dyb3VwSWQsXG4gICAgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzXG4gIH0gPSBjb25maWdVdGlscztcbiAgLyoqXG4gICAqIFNldCBvZiBjbGFzc0dyb3VwSWRzIGluIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAqIGB7aW1wb3J0YW50TW9kaWZpZXJ9e3ZhcmlhbnRNb2RpZmllcnN9e2NsYXNzR3JvdXBJZH1gXG4gICAqIEBleGFtcGxlICdmbG9hdCdcbiAgICogQGV4YW1wbGUgJ2hvdmVyOmZvY3VzOmJnLWNvbG9yJ1xuICAgKiBAZXhhbXBsZSAnbWQ6IXByJ1xuICAgKi9cbiAgY29uc3QgY2xhc3NHcm91cHNJbkNvbmZsaWN0ID0gW107XG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc0xpc3QudHJpbSgpLnNwbGl0KFNQTElUX0NMQVNTRVNfUkVHRVgpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGluZGV4ID0gY2xhc3NOYW1lcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxDbGFzc05hbWUgPSBjbGFzc05hbWVzW2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBtb2RpZmllcnMsXG4gICAgICBoYXNJbXBvcnRhbnRNb2RpZmllcixcbiAgICAgIGJhc2VDbGFzc05hbWUsXG4gICAgICBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uXG4gICAgfSA9IHBhcnNlQ2xhc3NOYW1lKG9yaWdpbmFsQ2xhc3NOYW1lKTtcbiAgICBsZXQgaGFzUG9zdGZpeE1vZGlmaWVyID0gQm9vbGVhbihtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uKTtcbiAgICBsZXQgY2xhc3NHcm91cElkID0gZ2V0Q2xhc3NHcm91cElkKGhhc1Bvc3RmaXhNb2RpZmllciA/IGJhc2VDbGFzc05hbWUuc3Vic3RyaW5nKDAsIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb24pIDogYmFzZUNsYXNzTmFtZSk7XG4gICAgaWYgKCFjbGFzc0dyb3VwSWQpIHtcbiAgICAgIGlmICghaGFzUG9zdGZpeE1vZGlmaWVyKSB7XG4gICAgICAgIC8vIE5vdCBhIFRhaWx3aW5kIGNsYXNzXG4gICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjbGFzc0dyb3VwSWQgPSBnZXRDbGFzc0dyb3VwSWQoYmFzZUNsYXNzTmFtZSk7XG4gICAgICBpZiAoIWNsYXNzR3JvdXBJZCkge1xuICAgICAgICAvLyBOb3QgYSBUYWlsd2luZCBjbGFzc1xuICAgICAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/ICcgJyArIHJlc3VsdCA6IHJlc3VsdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhbnRNb2RpZmllciA9IHNvcnRNb2RpZmllcnMobW9kaWZpZXJzKS5qb2luKCc6Jyk7XG4gICAgY29uc3QgbW9kaWZpZXJJZCA9IGhhc0ltcG9ydGFudE1vZGlmaWVyID8gdmFyaWFudE1vZGlmaWVyICsgSU1QT1JUQU5UX01PRElGSUVSIDogdmFyaWFudE1vZGlmaWVyO1xuICAgIGNvbnN0IGNsYXNzSWQgPSBtb2RpZmllcklkICsgY2xhc3NHcm91cElkO1xuICAgIGlmIChjbGFzc0dyb3Vwc0luQ29uZmxpY3QuaW5jbHVkZXMoY2xhc3NJZCkpIHtcbiAgICAgIC8vIFRhaWx3aW5kIGNsYXNzIG9taXR0ZWQgZHVlIHRvIGNvbmZsaWN0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY2xhc3NHcm91cHNJbkNvbmZsaWN0LnB1c2goY2xhc3NJZCk7XG4gICAgY29uc3QgY29uZmxpY3RHcm91cHMgPSBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHMoY2xhc3NHcm91cElkLCBoYXNQb3N0Zml4TW9kaWZpZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmxpY3RHcm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gY29uZmxpY3RHcm91cHNbaV07XG4gICAgICBjbGFzc0dyb3Vwc0luQ29uZmxpY3QucHVzaChtb2RpZmllcklkICsgZ3JvdXApO1xuICAgIH1cbiAgICAvLyBUYWlsd2luZCBjbGFzcyBub3QgaW4gY29uZmxpY3RcbiAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/ICcgJyArIHJlc3VsdCA6IHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtlZWQvY2xzeCBhbmQgbW9kaWZpZWQgdG8gc3VpdCB0aGUgbmVlZHMgb2YgdGFpbHdpbmQtbWVyZ2UgYmV0dGVyLlxuICpcbiAqIFNwZWNpZmljYWxseTpcbiAqIC0gUnVudGltZSBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4L2Jsb2IvdjEuMi4xL3NyYy9pbmRleC5qc1xuICogLSBUeXBlU2NyaXB0IHR5cGVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4L2Jsb2IvdjEuMi4xL2Nsc3guZC50c1xuICpcbiAqIE9yaWdpbmFsIGNvZGUgaGFzIE1JVCBsaWNlbnNlOiBDb3B5cmlnaHQgKGMpIEx1a2UgRWR3YXJkcyA8bHVrZS5lZHdhcmRzMDVAZ21haWwuY29tPiAobHVrZWVkLmNvbSlcbiAqL1xuZnVuY3Rpb24gdHdKb2luKCkge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgYXJndW1lbnQ7XG4gIGxldCByZXNvbHZlZFZhbHVlO1xuICBsZXQgc3RyaW5nID0gJyc7XG4gIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoYXJndW1lbnQgPSBhcmd1bWVudHNbaW5kZXgrK10pIHtcbiAgICAgIGlmIChyZXNvbHZlZFZhbHVlID0gdG9WYWx1ZShhcmd1bWVudCkpIHtcbiAgICAgICAgc3RyaW5nICYmIChzdHJpbmcgKz0gJyAnKTtcbiAgICAgICAgc3RyaW5nICs9IHJlc29sdmVkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5jb25zdCB0b1ZhbHVlID0gbWl4ID0+IHtcbiAgaWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1peDtcbiAgfVxuICBsZXQgcmVzb2x2ZWRWYWx1ZTtcbiAgbGV0IHN0cmluZyA9ICcnO1xuICBmb3IgKGxldCBrID0gMDsgayA8IG1peC5sZW5ndGg7IGsrKykge1xuICAgIGlmIChtaXhba10pIHtcbiAgICAgIGlmIChyZXNvbHZlZFZhbHVlID0gdG9WYWx1ZShtaXhba10pKSB7XG4gICAgICAgIHN0cmluZyAmJiAoc3RyaW5nICs9ICcgJyk7XG4gICAgICAgIHN0cmluZyArPSByZXNvbHZlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVRhaWx3aW5kTWVyZ2UoY3JlYXRlQ29uZmlnRmlyc3QsIC4uLmNyZWF0ZUNvbmZpZ1Jlc3QpIHtcbiAgbGV0IGNvbmZpZ1V0aWxzO1xuICBsZXQgY2FjaGVHZXQ7XG4gIGxldCBjYWNoZVNldDtcbiAgbGV0IGZ1bmN0aW9uVG9DYWxsID0gaW5pdFRhaWx3aW5kTWVyZ2U7XG4gIGZ1bmN0aW9uIGluaXRUYWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUNvbmZpZ1Jlc3QucmVkdWNlKChwcmV2aW91c0NvbmZpZywgY3JlYXRlQ29uZmlnQ3VycmVudCkgPT4gY3JlYXRlQ29uZmlnQ3VycmVudChwcmV2aW91c0NvbmZpZyksIGNyZWF0ZUNvbmZpZ0ZpcnN0KCkpO1xuICAgIGNvbmZpZ1V0aWxzID0gY3JlYXRlQ29uZmlnVXRpbHMoY29uZmlnKTtcbiAgICBjYWNoZUdldCA9IGNvbmZpZ1V0aWxzLmNhY2hlLmdldDtcbiAgICBjYWNoZVNldCA9IGNvbmZpZ1V0aWxzLmNhY2hlLnNldDtcbiAgICBmdW5jdGlvblRvQ2FsbCA9IHRhaWx3aW5kTWVyZ2U7XG4gICAgcmV0dXJuIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KTtcbiAgfVxuICBmdW5jdGlvbiB0YWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlR2V0KGNsYXNzTGlzdCk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VDbGFzc0xpc3QoY2xhc3NMaXN0LCBjb25maWdVdGlscyk7XG4gICAgY2FjaGVTZXQoY2xhc3NMaXN0LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbGxUYWlsd2luZE1lcmdlKCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvQ2FsbCh0d0pvaW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5jb25zdCBmcm9tVGhlbWUgPSBrZXkgPT4ge1xuICBjb25zdCB0aGVtZUdldHRlciA9IHRoZW1lID0+IHRoZW1lW2tleV0gfHwgW107XG4gIHRoZW1lR2V0dGVyLmlzVGhlbWVHZXR0ZXIgPSB0cnVlO1xuICByZXR1cm4gdGhlbWVHZXR0ZXI7XG59O1xuY29uc3QgYXJiaXRyYXJ5VmFsdWVSZWdleCA9IC9eXFxbKD86KFthLXotXSspOik/KC4rKVxcXSQvaTtcbmNvbnN0IGZyYWN0aW9uUmVnZXggPSAvXlxcZCtcXC9cXGQrJC87XG5jb25zdCBzdHJpbmdMZW5ndGhzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydweCcsICdmdWxsJywgJ3NjcmVlbiddKTtcbmNvbnN0IHRzaGlydFVuaXRSZWdleCA9IC9eKFxcZCsoXFwuXFxkKyk/KT8oeHN8c218bWR8bGd8eGwpJC87XG5jb25zdCBsZW5ndGhVbml0UmVnZXggPSAvXFxkKyglfHB4fHI/ZW18W3NkbF0/dihbaHdpYl18bWlufG1heCl8cHR8cGN8aW58Y218bW18Y2FwfGNofGV4fHI/bGh8Y3Eod3xofGl8YnxtaW58bWF4KSl8XFxiKGNhbGN8bWlufG1heHxjbGFtcClcXCguK1xcKXxeMCQvO1xuY29uc3QgY29sb3JGdW5jdGlvblJlZ2V4ID0gL14ocmdiYT98aHNsYT98aHdifChvayk/KGxhYnxsY2gpKVxcKC4rXFwpJC87XG4vLyBTaGFkb3cgYWx3YXlzIGJlZ2lucyB3aXRoIHggYW5kIHkgb2Zmc2V0IHNlcGFyYXRlZCBieSB1bmRlcnNjb3JlIG9wdGlvbmFsbHkgcHJlcGVuZGVkIGJ5IGluc2V0XG5jb25zdCBzaGFkb3dSZWdleCA9IC9eKGluc2V0Xyk/LT8oKFxcZCspP1xcLj8oXFxkKylbYS16XSt8MClfLT8oKFxcZCspP1xcLj8oXFxkKylbYS16XSt8MCkvO1xuY29uc3QgaW1hZ2VSZWdleCA9IC9eKHVybHxpbWFnZXxpbWFnZS1zZXR8Y3Jvc3MtZmFkZXxlbGVtZW50fChyZXBlYXRpbmctKT8obGluZWFyfHJhZGlhbHxjb25pYyktZ3JhZGllbnQpXFwoLitcXCkkLztcbmNvbnN0IGlzTGVuZ3RoID0gdmFsdWUgPT4gaXNOdW1iZXIodmFsdWUpIHx8IHN0cmluZ0xlbmd0aHMuaGFzKHZhbHVlKSB8fCBmcmFjdGlvblJlZ2V4LnRlc3QodmFsdWUpO1xuY29uc3QgaXNBcmJpdHJhcnlMZW5ndGggPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAnbGVuZ3RoJywgaXNMZW5ndGhPbmx5KTtcbmNvbnN0IGlzTnVtYmVyID0gdmFsdWUgPT4gQm9vbGVhbih2YWx1ZSkgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKTtcbmNvbnN0IGlzQXJiaXRyYXJ5TnVtYmVyID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJ251bWJlcicsIGlzTnVtYmVyKTtcbmNvbnN0IGlzSW50ZWdlciA9IHZhbHVlID0+IEJvb2xlYW4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbHVlKSk7XG5jb25zdCBpc1BlcmNlbnQgPSB2YWx1ZSA9PiB2YWx1ZS5lbmRzV2l0aCgnJScpICYmIGlzTnVtYmVyKHZhbHVlLnNsaWNlKDAsIC0xKSk7XG5jb25zdCBpc0FyYml0cmFyeVZhbHVlID0gdmFsdWUgPT4gYXJiaXRyYXJ5VmFsdWVSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzVHNoaXJ0U2l6ZSA9IHZhbHVlID0+IHRzaGlydFVuaXRSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IHNpemVMYWJlbHMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2xlbmd0aCcsICdzaXplJywgJ3BlcmNlbnRhZ2UnXSk7XG5jb25zdCBpc0FyYml0cmFyeVNpemUgPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBzaXplTGFiZWxzLCBpc05ldmVyKTtcbmNvbnN0IGlzQXJiaXRyYXJ5UG9zaXRpb24gPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAncG9zaXRpb24nLCBpc05ldmVyKTtcbmNvbnN0IGltYWdlTGFiZWxzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydpbWFnZScsICd1cmwnXSk7XG5jb25zdCBpc0FyYml0cmFyeUltYWdlID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaW1hZ2VMYWJlbHMsIGlzSW1hZ2UpO1xuY29uc3QgaXNBcmJpdHJhcnlTaGFkb3cgPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAnJywgaXNTaGFkb3cpO1xuY29uc3QgaXNBbnkgPSAoKSA9PiB0cnVlO1xuY29uc3QgZ2V0SXNBcmJpdHJhcnlWYWx1ZSA9ICh2YWx1ZSwgbGFiZWwsIHRlc3RWYWx1ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBhcmJpdHJhcnlWYWx1ZVJlZ2V4LmV4ZWModmFsdWUpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycgPyByZXN1bHRbMV0gPT09IGxhYmVsIDogbGFiZWwuaGFzKHJlc3VsdFsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXN0VmFsdWUocmVzdWx0WzJdKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaXNMZW5ndGhPbmx5ID0gdmFsdWUgPT5cbi8vIGBjb2xvckZ1bmN0aW9uUmVnZXhgIGNoZWNrIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbG9yIGZ1bmN0aW9ucyBjYW4gaGF2ZSBwZXJjZW50YWdlcyBpbiB0aGVtIHdoaWNoIHdoaWNoIHdvdWxkIGJlIGluY29ycmVjdGx5IGNsYXNzaWZpZWQgYXMgbGVuZ3Rocy5cbi8vIEZvciBleGFtcGxlLCBgaHNsKDAgMCUgMCUpYCB3b3VsZCBiZSBjbGFzc2lmaWVkIGFzIGEgbGVuZ3RoIHdpdGhvdXQgdGhpcyBjaGVjay5cbi8vIEkgY291bGQgYWxzbyB1c2UgbG9va2JlaGluZCBhc3NlcnRpb24gaW4gYGxlbmd0aFVuaXRSZWdleGAgYnV0IHRoYXQgaXNuJ3Qgc3VwcG9ydGVkIHdpZGVseSBlbm91Z2guXG5sZW5ndGhVbml0UmVnZXgudGVzdCh2YWx1ZSkgJiYgIWNvbG9yRnVuY3Rpb25SZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzTmV2ZXIgPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzU2hhZG93ID0gdmFsdWUgPT4gc2hhZG93UmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc0ltYWdlID0gdmFsdWUgPT4gaW1hZ2VSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IHZhbGlkYXRvcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBpc0FueSxcbiAgaXNBcmJpdHJhcnlJbWFnZSxcbiAgaXNBcmJpdHJhcnlMZW5ndGgsXG4gIGlzQXJiaXRyYXJ5TnVtYmVyLFxuICBpc0FyYml0cmFyeVBvc2l0aW9uLFxuICBpc0FyYml0cmFyeVNoYWRvdyxcbiAgaXNBcmJpdHJhcnlTaXplLFxuICBpc0FyYml0cmFyeVZhbHVlLFxuICBpc0ludGVnZXIsXG4gIGlzTGVuZ3RoLFxuICBpc051bWJlcixcbiAgaXNQZXJjZW50LFxuICBpc1RzaGlydFNpemVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICB2YWx1ZTogJ01vZHVsZSdcbn0pO1xuY29uc3QgZ2V0RGVmYXVsdENvbmZpZyA9ICgpID0+IHtcbiAgY29uc3QgY29sb3JzID0gZnJvbVRoZW1lKCdjb2xvcnMnKTtcbiAgY29uc3Qgc3BhY2luZyA9IGZyb21UaGVtZSgnc3BhY2luZycpO1xuICBjb25zdCBibHVyID0gZnJvbVRoZW1lKCdibHVyJyk7XG4gIGNvbnN0IGJyaWdodG5lc3MgPSBmcm9tVGhlbWUoJ2JyaWdodG5lc3MnKTtcbiAgY29uc3QgYm9yZGVyQ29sb3IgPSBmcm9tVGhlbWUoJ2JvcmRlckNvbG9yJyk7XG4gIGNvbnN0IGJvcmRlclJhZGl1cyA9IGZyb21UaGVtZSgnYm9yZGVyUmFkaXVzJyk7XG4gIGNvbnN0IGJvcmRlclNwYWNpbmcgPSBmcm9tVGhlbWUoJ2JvcmRlclNwYWNpbmcnKTtcbiAgY29uc3QgYm9yZGVyV2lkdGggPSBmcm9tVGhlbWUoJ2JvcmRlcldpZHRoJyk7XG4gIGNvbnN0IGNvbnRyYXN0ID0gZnJvbVRoZW1lKCdjb250cmFzdCcpO1xuICBjb25zdCBncmF5c2NhbGUgPSBmcm9tVGhlbWUoJ2dyYXlzY2FsZScpO1xuICBjb25zdCBodWVSb3RhdGUgPSBmcm9tVGhlbWUoJ2h1ZVJvdGF0ZScpO1xuICBjb25zdCBpbnZlcnQgPSBmcm9tVGhlbWUoJ2ludmVydCcpO1xuICBjb25zdCBnYXAgPSBmcm9tVGhlbWUoJ2dhcCcpO1xuICBjb25zdCBncmFkaWVudENvbG9yU3RvcHMgPSBmcm9tVGhlbWUoJ2dyYWRpZW50Q29sb3JTdG9wcycpO1xuICBjb25zdCBncmFkaWVudENvbG9yU3RvcFBvc2l0aW9ucyA9IGZyb21UaGVtZSgnZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnMnKTtcbiAgY29uc3QgaW5zZXQgPSBmcm9tVGhlbWUoJ2luc2V0Jyk7XG4gIGNvbnN0IG1hcmdpbiA9IGZyb21UaGVtZSgnbWFyZ2luJyk7XG4gIGNvbnN0IG9wYWNpdHkgPSBmcm9tVGhlbWUoJ29wYWNpdHknKTtcbiAgY29uc3QgcGFkZGluZyA9IGZyb21UaGVtZSgncGFkZGluZycpO1xuICBjb25zdCBzYXR1cmF0ZSA9IGZyb21UaGVtZSgnc2F0dXJhdGUnKTtcbiAgY29uc3Qgc2NhbGUgPSBmcm9tVGhlbWUoJ3NjYWxlJyk7XG4gIGNvbnN0IHNlcGlhID0gZnJvbVRoZW1lKCdzZXBpYScpO1xuICBjb25zdCBza2V3ID0gZnJvbVRoZW1lKCdza2V3Jyk7XG4gIGNvbnN0IHNwYWNlID0gZnJvbVRoZW1lKCdzcGFjZScpO1xuICBjb25zdCB0cmFuc2xhdGUgPSBmcm9tVGhlbWUoJ3RyYW5zbGF0ZScpO1xuICBjb25zdCBnZXRPdmVyc2Nyb2xsID0gKCkgPT4gWydhdXRvJywgJ2NvbnRhaW4nLCAnbm9uZSddO1xuICBjb25zdCBnZXRPdmVyZmxvdyA9ICgpID0+IFsnYXV0bycsICdoaWRkZW4nLCAnY2xpcCcsICd2aXNpYmxlJywgJ3Njcm9sbCddO1xuICBjb25zdCBnZXRTcGFjaW5nV2l0aEF1dG9BbmRBcmJpdHJhcnkgPSAoKSA9PiBbJ2F1dG8nLCBpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nXTtcbiAgY29uc3QgZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkgPSAoKSA9PiBbaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZ107XG4gIGNvbnN0IGdldExlbmd0aFdpdGhFbXB0eUFuZEFyYml0cmFyeSA9ICgpID0+IFsnJywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXTtcbiAgY29uc3QgZ2V0TnVtYmVyV2l0aEF1dG9BbmRBcmJpdHJhcnkgPSAoKSA9PiBbJ2F1dG8nLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYWx1ZV07XG4gIGNvbnN0IGdldFBvc2l0aW9ucyA9ICgpID0+IFsnYm90dG9tJywgJ2NlbnRlcicsICdsZWZ0JywgJ2xlZnQtYm90dG9tJywgJ2xlZnQtdG9wJywgJ3JpZ2h0JywgJ3JpZ2h0LWJvdHRvbScsICdyaWdodC10b3AnLCAndG9wJ107XG4gIGNvbnN0IGdldExpbmVTdHlsZXMgPSAoKSA9PiBbJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJywgJ25vbmUnXTtcbiAgY29uc3QgZ2V0QmxlbmRNb2RlcyA9ICgpID0+IFsnbm9ybWFsJywgJ211bHRpcGx5JywgJ3NjcmVlbicsICdvdmVybGF5JywgJ2RhcmtlbicsICdsaWdodGVuJywgJ2NvbG9yLWRvZGdlJywgJ2NvbG9yLWJ1cm4nLCAnaGFyZC1saWdodCcsICdzb2Z0LWxpZ2h0JywgJ2RpZmZlcmVuY2UnLCAnZXhjbHVzaW9uJywgJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2NvbG9yJywgJ2x1bWlub3NpdHknXTtcbiAgY29uc3QgZ2V0QWxpZ24gPSAoKSA9PiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmV0d2VlbicsICdhcm91bmQnLCAnZXZlbmx5JywgJ3N0cmV0Y2gnXTtcbiAgY29uc3QgZ2V0WmVyb0FuZEVtcHR5ID0gKCkgPT4gWycnLCAnMCcsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBnZXRCcmVha3MgPSAoKSA9PiBbJ2F1dG8nLCAnYXZvaWQnLCAnYWxsJywgJ2F2b2lkLXBhZ2UnLCAncGFnZScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NvbHVtbiddO1xuICBjb25zdCBnZXROdW1iZXJBbmRBcmJpdHJhcnkgPSAoKSA9PiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICByZXR1cm4ge1xuICAgIGNhY2hlU2l6ZTogNTAwLFxuICAgIHNlcGFyYXRvcjogJzonLFxuICAgIHRoZW1lOiB7XG4gICAgICBjb2xvcnM6IFtpc0FueV0sXG4gICAgICBzcGFjaW5nOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXSxcbiAgICAgIGJsdXI6IFsnbm9uZScsICcnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5VmFsdWVdLFxuICAgICAgYnJpZ2h0bmVzczogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBib3JkZXJDb2xvcjogW2NvbG9yc10sXG4gICAgICBib3JkZXJSYWRpdXM6IFsnbm9uZScsICcnLCAnZnVsbCcsIGlzVHNoaXJ0U2l6ZSwgaXNBcmJpdHJhcnlWYWx1ZV0sXG4gICAgICBib3JkZXJTcGFjaW5nOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpLFxuICAgICAgYm9yZGVyV2lkdGg6IGdldExlbmd0aFdpdGhFbXB0eUFuZEFyYml0cmFyeSgpLFxuICAgICAgY29udHJhc3Q6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgZ3JheXNjYWxlOiBnZXRaZXJvQW5kRW1wdHkoKSxcbiAgICAgIGh1ZVJvdGF0ZTogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBpbnZlcnQ6IGdldFplcm9BbmRFbXB0eSgpLFxuICAgICAgZ2FwOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpLFxuICAgICAgZ3JhZGllbnRDb2xvclN0b3BzOiBbY29sb3JzXSxcbiAgICAgIGdyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zOiBbaXNQZXJjZW50LCBpc0FyYml0cmFyeUxlbmd0aF0sXG4gICAgICBpbnNldDogZ2V0U3BhY2luZ1dpdGhBdXRvQW5kQXJiaXRyYXJ5KCksXG4gICAgICBtYXJnaW46IGdldFNwYWNpbmdXaXRoQXV0b0FuZEFyYml0cmFyeSgpLFxuICAgICAgb3BhY2l0eTogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBwYWRkaW5nOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpLFxuICAgICAgc2F0dXJhdGU6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgc2NhbGU6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgc2VwaWE6IGdldFplcm9BbmRFbXB0eSgpLFxuICAgICAgc2tldzogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBzcGFjZTogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIHRyYW5zbGF0ZTogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgIH0sXG4gICAgY2xhc3NHcm91cHM6IHtcbiAgICAgIC8vIExheW91dFxuICAgICAgLyoqXG4gICAgICAgKiBBc3BlY3QgUmF0aW9cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hc3BlY3QtcmF0aW9cbiAgICAgICAqL1xuICAgICAgYXNwZWN0OiBbe1xuICAgICAgICBhc3BlY3Q6IFsnYXV0bycsICdzcXVhcmUnLCAndmlkZW8nLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRhaW5lclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRhaW5lclxuICAgICAgICovXG4gICAgICBjb250YWluZXI6IFsnY29udGFpbmVyJ10sXG4gICAgICAvKipcbiAgICAgICAqIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb2x1bW5zXG4gICAgICAgKi9cbiAgICAgIGNvbHVtbnM6IFt7XG4gICAgICAgIGNvbHVtbnM6IFtpc1RzaGlydFNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgQWZ0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1hZnRlclxuICAgICAgICovXG4gICAgICAnYnJlYWstYWZ0ZXInOiBbe1xuICAgICAgICAnYnJlYWstYWZ0ZXInOiBnZXRCcmVha3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEJlZm9yZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWJlZm9yZVxuICAgICAgICovXG4gICAgICAnYnJlYWstYmVmb3JlJzogW3tcbiAgICAgICAgJ2JyZWFrLWJlZm9yZSc6IGdldEJyZWFrcygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgSW5zaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstaW5zaWRlXG4gICAgICAgKi9cbiAgICAgICdicmVhay1pbnNpZGUnOiBbe1xuICAgICAgICAnYnJlYWstaW5zaWRlJzogWydhdXRvJywgJ2F2b2lkJywgJ2F2b2lkLXBhZ2UnLCAnYXZvaWQtY29sdW1uJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggRGVjb3JhdGlvbiBCcmVha1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1kZWNvcmF0aW9uLWJyZWFrXG4gICAgICAgKi9cbiAgICAgICdib3gtZGVjb3JhdGlvbic6IFt7XG4gICAgICAgICdib3gtZGVjb3JhdGlvbic6IFsnc2xpY2UnLCAnY2xvbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaXppbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2l6aW5nXG4gICAgICAgKi9cbiAgICAgIGJveDogW3tcbiAgICAgICAgYm94OiBbJ2JvcmRlcicsICdjb250ZW50J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwbGF5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGlzcGxheVxuICAgICAgICovXG4gICAgICBkaXNwbGF5OiBbJ2Jsb2NrJywgJ2lubGluZS1ibG9jaycsICdpbmxpbmUnLCAnZmxleCcsICdpbmxpbmUtZmxleCcsICd0YWJsZScsICdpbmxpbmUtdGFibGUnLCAndGFibGUtY2FwdGlvbicsICd0YWJsZS1jZWxsJywgJ3RhYmxlLWNvbHVtbicsICd0YWJsZS1jb2x1bW4tZ3JvdXAnLCAndGFibGUtZm9vdGVyLWdyb3VwJywgJ3RhYmxlLWhlYWRlci1ncm91cCcsICd0YWJsZS1yb3ctZ3JvdXAnLCAndGFibGUtcm93JywgJ2Zsb3ctcm9vdCcsICdncmlkJywgJ2lubGluZS1ncmlkJywgJ2NvbnRlbnRzJywgJ2xpc3QtaXRlbScsICdoaWRkZW4nXSxcbiAgICAgIC8qKlxuICAgICAgICogRmxvYXRzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxvYXRcbiAgICAgICAqL1xuICAgICAgZmxvYXQ6IFt7XG4gICAgICAgIGZsb2F0OiBbJ3JpZ2h0JywgJ2xlZnQnLCAnbm9uZScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENsZWFyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2xlYXJcbiAgICAgICAqL1xuICAgICAgY2xlYXI6IFt7XG4gICAgICAgIGNsZWFyOiBbJ2xlZnQnLCAncmlnaHQnLCAnYm90aCcsICdub25lJywgJ3N0YXJ0JywgJ2VuZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSXNvbGF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaXNvbGF0aW9uXG4gICAgICAgKi9cbiAgICAgIGlzb2xhdGlvbjogWydpc29sYXRlJywgJ2lzb2xhdGlvbi1hdXRvJ10sXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCBGaXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtZml0XG4gICAgICAgKi9cbiAgICAgICdvYmplY3QtZml0JzogW3tcbiAgICAgICAgb2JqZWN0OiBbJ2NvbnRhaW4nLCAnY292ZXInLCAnZmlsbCcsICdub25lJywgJ3NjYWxlLWRvd24nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29iamVjdC1wb3NpdGlvblxuICAgICAgICovXG4gICAgICAnb2JqZWN0LXBvc2l0aW9uJzogW3tcbiAgICAgICAgb2JqZWN0OiBbLi4uZ2V0UG9zaXRpb25zKCksIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyZmxvd1xuICAgICAgICovXG4gICAgICBvdmVyZmxvdzogW3tcbiAgICAgICAgb3ZlcmZsb3c6IGdldE92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ292ZXJmbG93LXgnOiBbe1xuICAgICAgICAnb3ZlcmZsb3cteCc6IGdldE92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ292ZXJmbG93LXknOiBbe1xuICAgICAgICAnb3ZlcmZsb3cteSc6IGdldE92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICBvdmVyc2Nyb2xsOiBbe1xuICAgICAgICBvdmVyc2Nyb2xsOiBnZXRPdmVyc2Nyb2xsKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgICdvdmVyc2Nyb2xsLXgnOiBbe1xuICAgICAgICAnb3ZlcnNjcm9sbC14JzogZ2V0T3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnb3ZlcnNjcm9sbC15JzogW3tcbiAgICAgICAgJ292ZXJzY3JvbGwteSc6IGdldE92ZXJzY3JvbGwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IFsnc3RhdGljJywgJ2ZpeGVkJywgJ2Fic29sdXRlJywgJ3JlbGF0aXZlJywgJ3N0aWNreSddLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3AgLyBSaWdodCAvIEJvdHRvbSAvIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgaW5zZXQ6IFt7XG4gICAgICAgIGluc2V0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHQgLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgICdpbnNldC14JzogW3tcbiAgICAgICAgJ2luc2V0LXgnOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgICdpbnNldC15JzogW3tcbiAgICAgICAgJ2luc2V0LXknOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgc3RhcnQ6IFt7XG4gICAgICAgIHN0YXJ0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGVuZDogW3tcbiAgICAgICAgZW5kOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHRvcDogW3tcbiAgICAgICAgdG9wOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgcmlnaHQ6IFt7XG4gICAgICAgIHJpZ2h0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGJvdHRvbTogW3tcbiAgICAgICAgYm90dG9tOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBsZWZ0OiBbe1xuICAgICAgICBsZWZ0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVmlzaWJpbGl0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Zpc2liaWxpdHlcbiAgICAgICAqL1xuICAgICAgdmlzaWJpbGl0eTogWyd2aXNpYmxlJywgJ2ludmlzaWJsZScsICdjb2xsYXBzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBaLUluZGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvei1pbmRleFxuICAgICAgICovXG4gICAgICB6OiBbe1xuICAgICAgICB6OiBbJ2F1dG8nLCBpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIEZsZXhib3ggYW5kIEdyaWRcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBCYXNpc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtYmFzaXNcbiAgICAgICAqL1xuICAgICAgYmFzaXM6IFt7XG4gICAgICAgIGJhc2lzOiBnZXRTcGFjaW5nV2l0aEF1dG9BbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggRGlyZWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1kaXJlY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ2ZsZXgtZGlyZWN0aW9uJzogW3tcbiAgICAgICAgZmxleDogWydyb3cnLCAncm93LXJldmVyc2UnLCAnY29sJywgJ2NvbC1yZXZlcnNlJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFdyYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LXdyYXBcbiAgICAgICAqL1xuICAgICAgJ2ZsZXgtd3JhcCc6IFt7XG4gICAgICAgIGZsZXg6IFsnd3JhcCcsICd3cmFwLXJldmVyc2UnLCAnbm93cmFwJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleFxuICAgICAgICovXG4gICAgICBmbGV4OiBbe1xuICAgICAgICBmbGV4OiBbJzEnLCAnYXV0bycsICdpbml0aWFsJywgJ25vbmUnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggR3Jvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZ3Jvd1xuICAgICAgICovXG4gICAgICBncm93OiBbe1xuICAgICAgICBncm93OiBnZXRaZXJvQW5kRW1wdHkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggU2hyaW5rXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1zaHJpbmtcbiAgICAgICAqL1xuICAgICAgc2hyaW5rOiBbe1xuICAgICAgICBzaHJpbms6IGdldFplcm9BbmRFbXB0eSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3JkZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vcmRlclxuICAgICAgICovXG4gICAgICBvcmRlcjogW3tcbiAgICAgICAgb3JkZXI6IFsnZmlyc3QnLCAnbGFzdCcsICdub25lJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgVGVtcGxhdGUgQ29sdW1uc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtdGVtcGxhdGUtY29sdW1uc1xuICAgICAgICovXG4gICAgICAnZ3JpZC1jb2xzJzogW3tcbiAgICAgICAgJ2dyaWQtY29scyc6IFtpc0FueV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtc3RhcnQtZW5kJzogW3tcbiAgICAgICAgY29sOiBbJ2F1dG8nLCB7XG4gICAgICAgICAgc3BhbjogWydmdWxsJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgICB9LCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1jb2x1bW5cbiAgICAgICAqL1xuICAgICAgJ2NvbC1zdGFydCc6IFt7XG4gICAgICAgICdjb2wtc3RhcnQnOiBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1jb2x1bW5cbiAgICAgICAqL1xuICAgICAgJ2NvbC1lbmQnOiBbe1xuICAgICAgICAnY29sLWVuZCc6IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFRlbXBsYXRlIFJvd3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXRlbXBsYXRlLXJvd3NcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtcm93cyc6IFt7XG4gICAgICAgICdncmlkLXJvd3MnOiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgU3RhcnQgLyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LXN0YXJ0LWVuZCc6IFt7XG4gICAgICAgIHJvdzogWydhdXRvJywge1xuICAgICAgICAgIHNwYW46IFtpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICAgIH0sIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LXN0YXJ0JzogW3tcbiAgICAgICAgJ3Jvdy1zdGFydCc6IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFJvdyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LWVuZCc6IFt7XG4gICAgICAgICdyb3ctZW5kJzogZ2V0TnVtYmVyV2l0aEF1dG9BbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBGbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLWZsb3dcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtZmxvdyc6IFt7XG4gICAgICAgICdncmlkLWZsb3cnOiBbJ3JvdycsICdjb2wnLCAnZGVuc2UnLCAncm93LWRlbnNlJywgJ2NvbC1kZW5zZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tY29sdW1uc1xuICAgICAgICovXG4gICAgICAnYXV0by1jb2xzJzogW3tcbiAgICAgICAgJ2F1dG8tY29scyc6IFsnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZyJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gUm93c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1yb3dzXG4gICAgICAgKi9cbiAgICAgICdhdXRvLXJvd3MnOiBbe1xuICAgICAgICAnYXV0by1yb3dzJzogWydhdXRvJywgJ21pbicsICdtYXgnLCAnZnInLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICBnYXA6IFt7XG4gICAgICAgIGdhcDogW2dhcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICAnZ2FwLXgnOiBbe1xuICAgICAgICAnZ2FwLXgnOiBbZ2FwXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ2FwXG4gICAgICAgKi9cbiAgICAgICdnYXAteSc6IFt7XG4gICAgICAgICdnYXAteSc6IFtnYXBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1jb250ZW50XG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LWNvbnRlbnQnOiBbe1xuICAgICAgICBqdXN0aWZ5OiBbJ25vcm1hbCcsIC4uLmdldEFsaWduKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBJdGVtc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktaXRlbXNcbiAgICAgICAqL1xuICAgICAgJ2p1c3RpZnktaXRlbXMnOiBbe1xuICAgICAgICAnanVzdGlmeS1pdGVtcyc6IFsnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBKdXN0aWZ5IFNlbGZcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LXNlbGZcbiAgICAgICAqL1xuICAgICAgJ2p1c3RpZnktc2VsZic6IFt7XG4gICAgICAgICdqdXN0aWZ5LXNlbGYnOiBbJ2F1dG8nLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tY29udGVudFxuICAgICAgICovXG4gICAgICAnYWxpZ24tY29udGVudCc6IFt7XG4gICAgICAgIGNvbnRlbnQ6IFsnbm9ybWFsJywgLi4uZ2V0QWxpZ24oKSwgJ2Jhc2VsaW5lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBJdGVtc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWl0ZW1zXG4gICAgICAgKi9cbiAgICAgICdhbGlnbi1pdGVtcyc6IFt7XG4gICAgICAgIGl0ZW1zOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmFzZWxpbmUnLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLXNlbGZcbiAgICAgICAqL1xuICAgICAgJ2FsaWduLXNlbGYnOiBbe1xuICAgICAgICBzZWxmOiBbJ2F1dG8nLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJywgJ2Jhc2VsaW5lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtY29udGVudFxuICAgICAgICovXG4gICAgICAncGxhY2UtY29udGVudCc6IFt7XG4gICAgICAgICdwbGFjZS1jb250ZW50JzogWy4uLmdldEFsaWduKCksICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1pdGVtc1xuICAgICAgICovXG4gICAgICAncGxhY2UtaXRlbXMnOiBbe1xuICAgICAgICAncGxhY2UtaXRlbXMnOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmFzZWxpbmUnLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLXNlbGZcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLXNlbGYnOiBbe1xuICAgICAgICAncGxhY2Utc2VsZic6IFsnYXV0bycsICdzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ3N0cmV0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvLyBTcGFjaW5nXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHA6IFt7XG4gICAgICAgIHA6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHg6IFt7XG4gICAgICAgIHB4OiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB5OiBbe1xuICAgICAgICBweTogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHM6IFt7XG4gICAgICAgIHBzOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGU6IFt7XG4gICAgICAgIHBlOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHQ6IFt7XG4gICAgICAgIHB0OiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwcjogW3tcbiAgICAgICAgcHI6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwYjogW3tcbiAgICAgICAgcGI6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGw6IFt7XG4gICAgICAgIHBsOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbTogW3tcbiAgICAgICAgbTogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBteDogW3tcbiAgICAgICAgbXg6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXk6IFt7XG4gICAgICAgIG15OiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtczogW3tcbiAgICAgICAgbXM6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtZTogW3tcbiAgICAgICAgbWU6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtdDogW3tcbiAgICAgICAgbXQ6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1yOiBbe1xuICAgICAgICBtcjogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1iOiBbe1xuICAgICAgICBtYjogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtbDogW3tcbiAgICAgICAgbWw6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXgnOiBbe1xuICAgICAgICAnc3BhY2UteCc6IFtzcGFjZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS14LXJldmVyc2UnOiBbJ3NwYWNlLXgtcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICAnc3BhY2UteSc6IFt7XG4gICAgICAgICdzcGFjZS15JzogW3NwYWNlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWSBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXktcmV2ZXJzZSc6IFsnc3BhY2UteS1yZXZlcnNlJ10sXG4gICAgICAvLyBTaXppbmdcbiAgICAgIC8qKlxuICAgICAgICogV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aFxuICAgICAgICovXG4gICAgICB3OiBbe1xuICAgICAgICB3OiBbJ2F1dG8nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3Z3JywgJ2x2dycsICdkdncnLCBpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1pbi1XaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi13aWR0aFxuICAgICAgICovXG4gICAgICAnbWluLXcnOiBbe1xuICAgICAgICAnbWluLXcnOiBbaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZywgJ21pbicsICdtYXgnLCAnZml0J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXgtV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ21heC13JzogW3tcbiAgICAgICAgJ21heC13JzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdub25lJywgJ2Z1bGwnLCAnbWluJywgJ21heCcsICdmaXQnLCAncHJvc2UnLCB7XG4gICAgICAgICAgc2NyZWVuOiBbaXNUc2hpcnRTaXplXVxuICAgICAgICB9LCBpc1RzaGlydFNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGg6IFt7XG4gICAgICAgIGg6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZpdCcsICdzdmgnLCAnbHZoJywgJ2R2aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWluLUhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgJ21pbi1oJzogW3tcbiAgICAgICAgJ21pbi1oJzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdtaW4nLCAnbWF4JywgJ2ZpdCcsICdzdmgnLCAnbHZoJywgJ2R2aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWF4LUhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21heC1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgJ21heC1oJzogW3tcbiAgICAgICAgJ21heC1oJzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdtaW4nLCAnbWF4JywgJ2ZpdCcsICdzdmgnLCAnbHZoJywgJ2R2aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NpemVcbiAgICAgICAqL1xuICAgICAgc2l6ZTogW3tcbiAgICAgICAgc2l6ZTogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdhdXRvJywgJ21pbicsICdtYXgnLCAnZml0J11cbiAgICAgIH1dLFxuICAgICAgLy8gVHlwb2dyYXBoeVxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNpemVcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtc2l6ZSc6IFt7XG4gICAgICAgIHRleHQ6IFsnYmFzZScsIGlzVHNoaXJ0U2l6ZSwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTbW9vdGhpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNtb290aGluZ1xuICAgICAgICovXG4gICAgICAnZm9udC1zbW9vdGhpbmcnOiBbJ2FudGlhbGlhc2VkJywgJ3N1YnBpeGVsLWFudGlhbGlhc2VkJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXN0eWxlXG4gICAgICAgKi9cbiAgICAgICdmb250LXN0eWxlJzogWydpdGFsaWMnLCAnbm90LWl0YWxpYyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFdlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtd2VpZ2h0XG4gICAgICAgKi9cbiAgICAgICdmb250LXdlaWdodCc6IFt7XG4gICAgICAgIGZvbnQ6IFsndGhpbicsICdleHRyYWxpZ2h0JywgJ2xpZ2h0JywgJ25vcm1hbCcsICdtZWRpdW0nLCAnc2VtaWJvbGQnLCAnYm9sZCcsICdleHRyYWJvbGQnLCAnYmxhY2snLCBpc0FyYml0cmFyeU51bWJlcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IEZhbWlseVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtZmFtaWx5XG4gICAgICAgKi9cbiAgICAgICdmb250LWZhbWlseSc6IFt7XG4gICAgICAgIGZvbnQ6IFtpc0FueV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tbm9ybWFsJzogWydub3JtYWwtbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tb3JkaW5hbCc6IFsnb3JkaW5hbCddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tc2xhc2hlZC16ZXJvJzogWydzbGFzaGVkLXplcm8nXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLWZpZ3VyZSc6IFsnbGluaW5nLW51bXMnLCAnb2xkc3R5bGUtbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tc3BhY2luZyc6IFsncHJvcG9ydGlvbmFsLW51bXMnLCAndGFidWxhci1udW1zJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgJ2Z2bi1mcmFjdGlvbic6IFsnZGlhZ29uYWwtZnJhY3Rpb25zJywgJ3N0YWNrZWQtZnJhY3Rpb25zJ10sXG4gICAgICAvKipcbiAgICAgICAqIExldHRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGV0dGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgdHJhY2tpbmc6IFt7XG4gICAgICAgIHRyYWNraW5nOiBbJ3RpZ2h0ZXInLCAndGlnaHQnLCAnbm9ybWFsJywgJ3dpZGUnLCAnd2lkZXInLCAnd2lkZXN0JywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaW5lIENsYW1wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1jbGFtcFxuICAgICAgICovXG4gICAgICAnbGluZS1jbGFtcCc6IFt7XG4gICAgICAgICdsaW5lLWNsYW1wJzogWydub25lJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpbmUgSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGluZS1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgbGVhZGluZzogW3tcbiAgICAgICAgbGVhZGluZzogWydub25lJywgJ3RpZ2h0JywgJ3NudWcnLCAnbm9ybWFsJywgJ3JlbGF4ZWQnLCAnbG9vc2UnLCBpc0xlbmd0aCwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1pbWFnZVxuICAgICAgICovXG4gICAgICAnbGlzdC1pbWFnZSc6IFt7XG4gICAgICAgICdsaXN0LWltYWdlJzogWydub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFR5cGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXR5cGVcbiAgICAgICAqL1xuICAgICAgJ2xpc3Qtc3R5bGUtdHlwZSc6IFt7XG4gICAgICAgIGxpc3Q6IFsnbm9uZScsICdkaXNjJywgJ2RlY2ltYWwnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdsaXN0LXN0eWxlLXBvc2l0aW9uJzogW3tcbiAgICAgICAgbGlzdDogWydpbnNpZGUnLCAnb3V0c2lkZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2Vob2xkZXIgQ29sb3JcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZWhvbGRlci1jb2xvclxuICAgICAgICovXG4gICAgICAncGxhY2Vob2xkZXItY29sb3InOiBbe1xuICAgICAgICBwbGFjZWhvbGRlcjogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZWhvbGRlciBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItb3BhY2l0eVxuICAgICAgICovXG4gICAgICAncGxhY2Vob2xkZXItb3BhY2l0eSc6IFt7XG4gICAgICAgICdwbGFjZWhvbGRlci1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBBbGlnbm1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWFsaWduXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWFsaWdubWVudCc6IFt7XG4gICAgICAgIHRleHQ6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWNvbG9yJzogW3tcbiAgICAgICAgdGV4dDogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3BhY2l0eSc6IFt7XG4gICAgICAgICd0ZXh0LW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb25cbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbic6IFsndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCcsICduby11bmRlcmxpbmUnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXN0eWxlXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tc3R5bGUnOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbLi4uZ2V0TGluZVN0eWxlcygpLCAnd2F2eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFRoaWNrbmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi10aGlja25lc3NcbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbi10aGlja25lc3MnOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbJ2F1dG8nLCAnZnJvbS1mb250JywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVW5kZXJsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtdW5kZXJsaW5lLW9mZnNldFxuICAgICAgICovXG4gICAgICAndW5kZXJsaW5lLW9mZnNldCc6IFt7XG4gICAgICAgICd1bmRlcmxpbmUtb2Zmc2V0JzogWydhdXRvJywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tY29sb3InOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVHJhbnNmb3JtXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC10cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgJ3RleHQtdHJhbnNmb3JtJzogWyd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJywgJ2NhcGl0YWxpemUnLCAnbm9ybWFsLWNhc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3ZlcmZsb3cnOiBbJ3RydW5jYXRlJywgJ3RleHQtZWxsaXBzaXMnLCAndGV4dC1jbGlwJ10sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgV3JhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtd3JhcFxuICAgICAgICovXG4gICAgICAndGV4dC13cmFwJzogW3tcbiAgICAgICAgdGV4dDogWyd3cmFwJywgJ25vd3JhcCcsICdiYWxhbmNlJywgJ3ByZXR0eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBJbmRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWluZGVudFxuICAgICAgICovXG4gICAgICBpbmRlbnQ6IFt7XG4gICAgICAgIGluZGVudDogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFZlcnRpY2FsIEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3ZlcnRpY2FsLWFsaWduXG4gICAgICAgKi9cbiAgICAgICd2ZXJ0aWNhbC1hbGlnbic6IFt7XG4gICAgICAgIGFsaWduOiBbJ2Jhc2VsaW5lJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJywgJ3RleHQtdG9wJywgJ3RleHQtYm90dG9tJywgJ3N1YicsICdzdXBlcicsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2hpdGVzcGFjZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3doaXRlc3BhY2VcbiAgICAgICAqL1xuICAgICAgd2hpdGVzcGFjZTogW3tcbiAgICAgICAgd2hpdGVzcGFjZTogWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZScsICdwcmUtbGluZScsICdwcmUtd3JhcCcsICdicmVhay1zcGFjZXMnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdvcmQgQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93b3JkLWJyZWFrXG4gICAgICAgKi9cbiAgICAgIGJyZWFrOiBbe1xuICAgICAgICBicmVhazogWydub3JtYWwnLCAnd29yZHMnLCAnYWxsJywgJ2tlZXAnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh5cGhlbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oeXBoZW5zXG4gICAgICAgKi9cbiAgICAgIGh5cGhlbnM6IFt7XG4gICAgICAgIGh5cGhlbnM6IFsnbm9uZScsICdtYW51YWwnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRlbnRcbiAgICAgICAqL1xuICAgICAgY29udGVudDogW3tcbiAgICAgICAgY29udGVudDogWydub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gQmFja2dyb3VuZHNcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBBdHRhY2htZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1hdHRhY2htZW50XG4gICAgICAgKi9cbiAgICAgICdiZy1hdHRhY2htZW50JzogW3tcbiAgICAgICAgYmc6IFsnZml4ZWQnLCAnbG9jYWwnLCAnc2Nyb2xsJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENsaXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNsaXBcbiAgICAgICAqL1xuICAgICAgJ2JnLWNsaXAnOiBbe1xuICAgICAgICAnYmctY2xpcCc6IFsnYm9yZGVyJywgJ3BhZGRpbmcnLCAnY29udGVudCcsICd0ZXh0J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIE9wYWNpdHlcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JnLW9wYWNpdHknOiBbe1xuICAgICAgICAnYmctb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ2JnLW9yaWdpbic6IFt7XG4gICAgICAgICdiZy1vcmlnaW4nOiBbJ2JvcmRlcicsICdwYWRkaW5nJywgJ2NvbnRlbnQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdiZy1wb3NpdGlvbic6IFt7XG4gICAgICAgIGJnOiBbLi4uZ2V0UG9zaXRpb25zKCksIGlzQXJiaXRyYXJ5UG9zaXRpb25dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBSZXBlYXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXJlcGVhdFxuICAgICAgICovXG4gICAgICAnYmctcmVwZWF0JzogW3tcbiAgICAgICAgYmc6IFsnbm8tcmVwZWF0Jywge1xuICAgICAgICAgIHJlcGVhdDogWycnLCAneCcsICd5JywgJ3JvdW5kJywgJ3NwYWNlJ11cbiAgICAgICAgfV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXNpemVcbiAgICAgICAqL1xuICAgICAgJ2JnLXNpemUnOiBbe1xuICAgICAgICBiZzogWydhdXRvJywgJ2NvdmVyJywgJ2NvbnRhaW4nLCBpc0FyYml0cmFyeVNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtaW1hZ2VcbiAgICAgICAqL1xuICAgICAgJ2JnLWltYWdlJzogW3tcbiAgICAgICAgYmc6IFsnbm9uZScsIHtcbiAgICAgICAgICAnZ3JhZGllbnQtdG8nOiBbJ3QnLCAndHInLCAncicsICdicicsICdiJywgJ2JsJywgJ2wnLCAndGwnXVxuICAgICAgICB9LCBpc0FyYml0cmFyeUltYWdlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdiZy1jb2xvcic6IFt7XG4gICAgICAgIGJnOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIEZyb20gUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtZnJvbS1wb3MnOiBbe1xuICAgICAgICBmcm9tOiBbZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYS1wb3MnOiBbe1xuICAgICAgICB2aWE6IFtncmFkaWVudENvbG9yU3RvcFBvc2l0aW9uc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10by1wb3MnOiBbe1xuICAgICAgICB0bzogW2dyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIEZyb21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtZnJvbSc6IFt7XG4gICAgICAgIGZyb206IFtncmFkaWVudENvbG9yU3RvcHNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYSc6IFt7XG4gICAgICAgIHZpYTogW2dyYWRpZW50Q29sb3JTdG9wc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUb1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10byc6IFt7XG4gICAgICAgIHRvOiBbZ3JhZGllbnRDb2xvclN0b3BzXVxuICAgICAgfV0sXG4gICAgICAvLyBCb3JkZXJzXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIHJvdW5kZWQ6IFt7XG4gICAgICAgIHJvdW5kZWQ6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLXMnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZSc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXQnOiBbe1xuICAgICAgICAncm91bmRlZC10JzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1yJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtcic6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWInOiBbe1xuICAgICAgICAncm91bmRlZC1iJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWwnOiBbe1xuICAgICAgICAncm91bmRlZC1sJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1zcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLXNzJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtc2UnOiBbe1xuICAgICAgICAncm91bmRlZC1zZSc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lZSc6IFt7XG4gICAgICAgICdyb3VuZGVkLWVlJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtZXMnOiBbe1xuICAgICAgICAncm91bmRlZC1lcyc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdGwnOiBbe1xuICAgICAgICAncm91bmRlZC10bCc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXRyJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtdHInOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1icic6IFt7XG4gICAgICAgICdyb3VuZGVkLWJyJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbSBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1ibCc6IFt7XG4gICAgICAgICdyb3VuZGVkLWJsJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13JzogW3tcbiAgICAgICAgYm9yZGVyOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXgnOiBbe1xuICAgICAgICAnYm9yZGVyLXgnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy1zJzogW3tcbiAgICAgICAgJ2JvcmRlci1zJzogW2JvcmRlcldpZHRoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LWUnOiBbe1xuICAgICAgICAnYm9yZGVyLWUnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctdCc6IFt7XG4gICAgICAgICdib3JkZXItdCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXInOiBbe1xuICAgICAgICAnYm9yZGVyLXInOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctYic6IFt7XG4gICAgICAgICdib3JkZXItYic6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctbCc6IFt7XG4gICAgICAgICdib3JkZXItbCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdib3JkZXItb3BhY2l0eSc6IFt7XG4gICAgICAgICdib3JkZXItb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zdHlsZVxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXN0eWxlJzogW3tcbiAgICAgICAgYm9yZGVyOiBbLi4uZ2V0TGluZVN0eWxlcygpLCAnaGlkZGVuJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXgnOiBbe1xuICAgICAgICAnZGl2aWRlLXgnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXgtcmV2ZXJzZSc6IFsnZGl2aWRlLXgtcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXknOiBbe1xuICAgICAgICAnZGl2aWRlLXknOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXktcmV2ZXJzZSc6IFsnZGl2aWRlLXktcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUtb3BhY2l0eSc6IFt7XG4gICAgICAgICdkaXZpZGUtb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1zdHlsZVxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXN0eWxlJzogW3tcbiAgICAgICAgZGl2aWRlOiBnZXRMaW5lU3R5bGVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvcic6IFt7XG4gICAgICAgIGJvcmRlcjogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3IteCc6IFt7XG4gICAgICAgICdib3JkZXIteCc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1zJzogW3tcbiAgICAgICAgJ2JvcmRlci1zJzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBFXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3ItZSc6IFt7XG4gICAgICAgICdib3JkZXItZSc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3ItdCc6IFt7XG4gICAgICAgICdib3JkZXItdCc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1yJzogW3tcbiAgICAgICAgJ2JvcmRlci1yJzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1iJzogW3tcbiAgICAgICAgJ2JvcmRlci1iJzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3ItbCc6IFt7XG4gICAgICAgICdib3JkZXItbCc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2RpdmlkZS1jb2xvcic6IFt7XG4gICAgICAgIGRpdmlkZTogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLXN0eWxlXG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLXN0eWxlJzogW3tcbiAgICAgICAgb3V0bGluZTogWycnLCAuLi5nZXRMaW5lU3R5bGVzKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBPZmZzZXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLW9mZnNldFxuICAgICAgICovXG4gICAgICAnb3V0bGluZS1vZmZzZXQnOiBbe1xuICAgICAgICAnb3V0bGluZS1vZmZzZXQnOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtdyc6IFt7XG4gICAgICAgIG91dGxpbmU6IFtpc0xlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtY29sb3InOiBbe1xuICAgICAgICBvdXRsaW5lOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdyaW5nLXcnOiBbe1xuICAgICAgICByaW5nOiBnZXRMZW5ndGhXaXRoRW1wdHlBbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgV2lkdGggSW5zZXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdyaW5nLXctaW5zZXQnOiBbJ3JpbmctaW5zZXQnXSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3JpbmctY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3JpbmctY29sb3InOiBbe1xuICAgICAgICByaW5nOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb3BhY2l0eVxuICAgICAgICovXG4gICAgICAncmluZy1vcGFjaXR5JzogW3tcbiAgICAgICAgJ3Jpbmctb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgT2Zmc2V0IFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1vZmZzZXQtd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ3Jpbmctb2Zmc2V0LXcnOiBbe1xuICAgICAgICAncmluZy1vZmZzZXQnOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgT2Zmc2V0IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1vZmZzZXQtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3Jpbmctb2Zmc2V0LWNvbG9yJzogW3tcbiAgICAgICAgJ3Jpbmctb2Zmc2V0JzogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLy8gRWZmZWN0c1xuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2hhZG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvd1xuICAgICAgICovXG4gICAgICBzaGFkb3c6IFt7XG4gICAgICAgIHNoYWRvdzogWycnLCAnaW5uZXInLCAnbm9uZScsIGlzVHNoaXJ0U2l6ZSwgaXNBcmJpdHJhcnlTaGFkb3ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm94IFNoYWRvdyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3ctY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3NoYWRvdy1jb2xvcic6IFt7XG4gICAgICAgIHNoYWRvdzogW2lzQW55XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgIG9wYWNpdHk6IFt7XG4gICAgICAgIG9wYWNpdHk6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1peCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWl4LWJsZW5kLW1vZGVcbiAgICAgICAqL1xuICAgICAgJ21peC1ibGVuZCc6IFt7XG4gICAgICAgICdtaXgtYmxlbmQnOiBbLi4uZ2V0QmxlbmRNb2RlcygpLCAncGx1cy1saWdodGVyJywgJ3BsdXMtZGFya2VyJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEJsZW5kIE1vZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWJsZW5kLW1vZGVcbiAgICAgICAqL1xuICAgICAgJ2JnLWJsZW5kJzogW3tcbiAgICAgICAgJ2JnLWJsZW5kJzogZ2V0QmxlbmRNb2RlcygpXG4gICAgICB9XSxcbiAgICAgIC8vIEZpbHRlcnNcbiAgICAgIC8qKlxuICAgICAgICogRmlsdGVyXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmlsdGVyXG4gICAgICAgKi9cbiAgICAgIGZpbHRlcjogW3tcbiAgICAgICAgZmlsdGVyOiBbJycsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCbHVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmx1clxuICAgICAgICovXG4gICAgICBibHVyOiBbe1xuICAgICAgICBibHVyOiBbYmx1cl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCcmlnaHRuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJpZ2h0bmVzc1xuICAgICAgICovXG4gICAgICBicmlnaHRuZXNzOiBbe1xuICAgICAgICBicmlnaHRuZXNzOiBbYnJpZ2h0bmVzc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250cmFzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRyYXN0XG4gICAgICAgKi9cbiAgICAgIGNvbnRyYXN0OiBbe1xuICAgICAgICBjb250cmFzdDogW2NvbnRyYXN0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERyb3AgU2hhZG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZHJvcC1zaGFkb3dcbiAgICAgICAqL1xuICAgICAgJ2Ryb3Atc2hhZG93JzogW3tcbiAgICAgICAgJ2Ryb3Atc2hhZG93JzogWycnLCAnbm9uZScsIGlzVHNoaXJ0U2l6ZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgZ3JheXNjYWxlOiBbe1xuICAgICAgICBncmF5c2NhbGU6IFtncmF5c2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSHVlIFJvdGF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2h1ZS1yb3RhdGVcbiAgICAgICAqL1xuICAgICAgJ2h1ZS1yb3RhdGUnOiBbe1xuICAgICAgICAnaHVlLXJvdGF0ZSc6IFtodWVSb3RhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSW52ZXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaW52ZXJ0XG4gICAgICAgKi9cbiAgICAgIGludmVydDogW3tcbiAgICAgICAgaW52ZXJ0OiBbaW52ZXJ0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNhdHVyYXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2F0dXJhdGVcbiAgICAgICAqL1xuICAgICAgc2F0dXJhdGU6IFt7XG4gICAgICAgIHNhdHVyYXRlOiBbc2F0dXJhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2VwaWFcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zZXBpYVxuICAgICAgICovXG4gICAgICBzZXBpYTogW3tcbiAgICAgICAgc2VwaWE6IFtzZXBpYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBGaWx0ZXJcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1maWx0ZXJcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWZpbHRlcic6IFt7XG4gICAgICAgICdiYWNrZHJvcC1maWx0ZXInOiBbJycsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBCbHVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtYmx1clxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtYmx1cic6IFt7XG4gICAgICAgICdiYWNrZHJvcC1ibHVyJzogW2JsdXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQnJpZ2h0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJyaWdodG5lc3NcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWJyaWdodG5lc3MnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtYnJpZ2h0bmVzcyc6IFticmlnaHRuZXNzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIENvbnRyYXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtY29udHJhc3RcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWNvbnRyYXN0JzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWNvbnRyYXN0JzogW2NvbnRyYXN0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEdyYXlzY2FsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWdyYXlzY2FsZVxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtZ3JheXNjYWxlJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWdyYXlzY2FsZSc6IFtncmF5c2NhbGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgSHVlIFJvdGF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWh1ZS1yb3RhdGVcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWh1ZS1yb3RhdGUnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtaHVlLXJvdGF0ZSc6IFtodWVSb3RhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgSW52ZXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtaW52ZXJ0XG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1pbnZlcnQnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtaW52ZXJ0JzogW2ludmVydF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atb3BhY2l0eVxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3Atb3BhY2l0eSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgU2F0dXJhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1zYXR1cmF0ZVxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3Atc2F0dXJhdGUnOiBbe1xuICAgICAgICAnYmFja2Ryb3Atc2F0dXJhdGUnOiBbc2F0dXJhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgU2VwaWFcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1zZXBpYVxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3Atc2VwaWEnOiBbe1xuICAgICAgICAnYmFja2Ryb3Atc2VwaWEnOiBbc2VwaWFdXG4gICAgICB9XSxcbiAgICAgIC8vIFRhYmxlc1xuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sbGFwc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sbGFwc2VcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xsYXBzZSc6IFt7XG4gICAgICAgIGJvcmRlcjogWydjb2xsYXBzZScsICdzZXBhcmF0ZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFNwYWNpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICAnYm9yZGVyLXNwYWNpbmcnOiBbe1xuICAgICAgICAnYm9yZGVyLXNwYWNpbmcnOiBbYm9yZGVyU3BhY2luZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1zcGFjaW5nLXgnOiBbe1xuICAgICAgICAnYm9yZGVyLXNwYWNpbmcteCc6IFtib3JkZXJTcGFjaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICAnYm9yZGVyLXNwYWNpbmcteSc6IFt7XG4gICAgICAgICdib3JkZXItc3BhY2luZy15JzogW2JvcmRlclNwYWNpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGFibGUgTGF5b3V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGFibGUtbGF5b3V0XG4gICAgICAgKi9cbiAgICAgICd0YWJsZS1sYXlvdXQnOiBbe1xuICAgICAgICB0YWJsZTogWydhdXRvJywgJ2ZpeGVkJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDYXB0aW9uIFNpZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jYXB0aW9uLXNpZGVcbiAgICAgICAqL1xuICAgICAgY2FwdGlvbjogW3tcbiAgICAgICAgY2FwdGlvbjogWyd0b3AnLCAnYm90dG9tJ11cbiAgICAgIH1dLFxuICAgICAgLy8gVHJhbnNpdGlvbnMgYW5kIEFuaW1hdGlvblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuaXNpdGlvbiBQcm9wZXJ0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tcHJvcGVydHlcbiAgICAgICAqL1xuICAgICAgdHJhbnNpdGlvbjogW3tcbiAgICAgICAgdHJhbnNpdGlvbjogWydub25lJywgJ2FsbCcsICcnLCAnY29sb3JzJywgJ29wYWNpdHknLCAnc2hhZG93JywgJ3RyYW5zZm9ybScsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBEdXJhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tZHVyYXRpb25cbiAgICAgICAqL1xuICAgICAgZHVyYXRpb246IFt7XG4gICAgICAgIGR1cmF0aW9uOiBnZXROdW1iZXJBbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gVGltaW5nIEZ1bmN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgZWFzZTogW3tcbiAgICAgICAgZWFzZTogWydsaW5lYXInLCAnaW4nLCAnb3V0JywgJ2luLW91dCcsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBEZWxheVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tZGVsYXlcbiAgICAgICAqL1xuICAgICAgZGVsYXk6IFt7XG4gICAgICAgIGRlbGF5OiBnZXROdW1iZXJBbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FuaW1hdGlvblxuICAgICAgICovXG4gICAgICBhbmltYXRlOiBbe1xuICAgICAgICBhbmltYXRlOiBbJ25vbmUnLCAnc3BpbicsICdwaW5nJywgJ3B1bHNlJywgJ2JvdW5jZScsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIFRyYW5zZm9ybXNcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNmb3JtXG4gICAgICAgKi9cbiAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgdHJhbnNmb3JtOiBbJycsICdncHUnLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICBzY2FsZTogW3tcbiAgICAgICAgc2NhbGU6IFtzY2FsZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZSBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgJ3NjYWxlLXgnOiBbe1xuICAgICAgICAnc2NhbGUteCc6IFtzY2FsZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZSBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgJ3NjYWxlLXknOiBbe1xuICAgICAgICAnc2NhbGUteSc6IFtzY2FsZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yb3RhdGVcbiAgICAgICAqL1xuICAgICAgcm90YXRlOiBbe1xuICAgICAgICByb3RhdGU6IFtpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNsYXRlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgJ3RyYW5zbGF0ZS14JzogW3tcbiAgICAgICAgJ3RyYW5zbGF0ZS14JzogW3RyYW5zbGF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICAndHJhbnNsYXRlLXknOiBbe1xuICAgICAgICAndHJhbnNsYXRlLXknOiBbdHJhbnNsYXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNrZXcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NrZXdcbiAgICAgICAqL1xuICAgICAgJ3NrZXcteCc6IFt7XG4gICAgICAgICdza2V3LXgnOiBbc2tld11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3IFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgKi9cbiAgICAgICdza2V3LXknOiBbe1xuICAgICAgICAnc2tldy15JzogW3NrZXddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIE9yaWdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybS1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiBbe1xuICAgICAgICBvcmlnaW46IFsnY2VudGVyJywgJ3RvcCcsICd0b3AtcmlnaHQnLCAncmlnaHQnLCAnYm90dG9tLXJpZ2h0JywgJ2JvdHRvbScsICdib3R0b20tbGVmdCcsICdsZWZ0JywgJ3RvcC1sZWZ0JywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gSW50ZXJhY3Rpdml0eVxuICAgICAgLyoqXG4gICAgICAgKiBBY2NlbnQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hY2NlbnQtY29sb3JcbiAgICAgICAqL1xuICAgICAgYWNjZW50OiBbe1xuICAgICAgICBhY2NlbnQ6IFsnYXV0bycsIGNvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBcHBlYXJhbmNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYXBwZWFyYW5jZVxuICAgICAgICovXG4gICAgICBhcHBlYXJhbmNlOiBbe1xuICAgICAgICBhcHBlYXJhbmNlOiBbJ25vbmUnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ3Vyc29yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY3Vyc29yXG4gICAgICAgKi9cbiAgICAgIGN1cnNvcjogW3tcbiAgICAgICAgY3Vyc29yOiBbJ2F1dG8nLCAnZGVmYXVsdCcsICdwb2ludGVyJywgJ3dhaXQnLCAndGV4dCcsICdtb3ZlJywgJ2hlbHAnLCAnbm90LWFsbG93ZWQnLCAnbm9uZScsICdjb250ZXh0LW1lbnUnLCAncHJvZ3Jlc3MnLCAnY2VsbCcsICdjcm9zc2hhaXInLCAndmVydGljYWwtdGV4dCcsICdhbGlhcycsICdjb3B5JywgJ25vLWRyb3AnLCAnZ3JhYicsICdncmFiYmluZycsICdhbGwtc2Nyb2xsJywgJ2NvbC1yZXNpemUnLCAncm93LXJlc2l6ZScsICduLXJlc2l6ZScsICdlLXJlc2l6ZScsICdzLXJlc2l6ZScsICd3LXJlc2l6ZScsICduZS1yZXNpemUnLCAnbnctcmVzaXplJywgJ3NlLXJlc2l6ZScsICdzdy1yZXNpemUnLCAnZXctcmVzaXplJywgJ25zLXJlc2l6ZScsICduZXN3LXJlc2l6ZScsICdud3NlLXJlc2l6ZScsICd6b29tLWluJywgJ3pvb20tb3V0JywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDYXJldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3QtaW4tdGltZS1tb2RlI2NhcmV0LWNvbG9yLXV0aWxpdGllc1xuICAgICAgICovXG4gICAgICAnY2FyZXQtY29sb3InOiBbe1xuICAgICAgICBjYXJldDogW2NvbG9yc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQb2ludGVyIEV2ZW50c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BvaW50ZXItZXZlbnRzXG4gICAgICAgKi9cbiAgICAgICdwb2ludGVyLWV2ZW50cyc6IFt7XG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6IFsnbm9uZScsICdhdXRvJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSZXNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yZXNpemVcbiAgICAgICAqL1xuICAgICAgcmVzaXplOiBbe1xuICAgICAgICByZXNpemU6IFsnbm9uZScsICd5JywgJ3gnLCAnJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgQmVoYXZpb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1iZWhhdmlvcic6IFt7XG4gICAgICAgIHNjcm9sbDogWydhdXRvJywgJ3Ntb290aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1teCc6IFt7XG4gICAgICAgICdzY3JvbGwtbXgnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW15JzogW3tcbiAgICAgICAgJ3Njcm9sbC1teSc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1zJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tcyc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tZSc6IFt7XG4gICAgICAgICdzY3JvbGwtbWUnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXQnOiBbe1xuICAgICAgICAnc2Nyb2xsLW10JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXInOiBbe1xuICAgICAgICAnc2Nyb2xsLW1yJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1iJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tYic6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbWwnOiBbe1xuICAgICAgICAnc2Nyb2xsLW1sJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXB4JzogW3tcbiAgICAgICAgJ3Njcm9sbC1weCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1weSc6IFt7XG4gICAgICAgICdzY3JvbGwtcHknOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBzJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wcyc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBlJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wZSc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXB0JzogW3tcbiAgICAgICAgJ3Njcm9sbC1wdCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHInOiBbe1xuICAgICAgICAnc2Nyb2xsLXByJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcGInOiBbe1xuICAgICAgICAnc2Nyb2xsLXBiJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBsJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wbCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBBbGlnblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLWFsaWduXG4gICAgICAgKi9cbiAgICAgICdzbmFwLWFsaWduJzogW3tcbiAgICAgICAgc25hcDogWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2FsaWduLW5vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFN0b3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC1zdG9wXG4gICAgICAgKi9cbiAgICAgICdzbmFwLXN0b3AnOiBbe1xuICAgICAgICBzbmFwOiBbJ25vcm1hbCcsICdhbHdheXMnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC10eXBlXG4gICAgICAgKi9cbiAgICAgICdzbmFwLXR5cGUnOiBbe1xuICAgICAgICBzbmFwOiBbJ25vbmUnLCAneCcsICd5JywgJ2JvdGgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGUgU3RyaWN0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgJ3NuYXAtc3RyaWN0bmVzcyc6IFt7XG4gICAgICAgIHNuYXA6IFsnbWFuZGF0b3J5JywgJ3Byb3hpbWl0eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIHRvdWNoOiBbe1xuICAgICAgICB0b3VjaDogWydhdXRvJywgJ25vbmUnLCAnbWFuaXB1bGF0aW9uJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICAndG91Y2gteCc6IFt7XG4gICAgICAgICd0b3VjaC1wYW4nOiBbJ3gnLCAnbGVmdCcsICdyaWdodCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ3RvdWNoLXknOiBbe1xuICAgICAgICAndG91Y2gtcGFuJzogWyd5JywgJ3VwJywgJ2Rvd24nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBQaW5jaCBab29tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgICd0b3VjaC1weic6IFsndG91Y2gtcGluY2gtem9vbSddLFxuICAgICAgLyoqXG4gICAgICAgKiBVc2VyIFNlbGVjdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3VzZXItc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogW3tcbiAgICAgICAgc2VsZWN0OiBbJ25vbmUnLCAndGV4dCcsICdhbGwnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2lsbCBDaGFuZ2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWxsLWNoYW5nZVxuICAgICAgICovXG4gICAgICAnd2lsbC1jaGFuZ2UnOiBbe1xuICAgICAgICAnd2lsbC1jaGFuZ2UnOiBbJ2F1dG8nLCAnc2Nyb2xsJywgJ2NvbnRlbnRzJywgJ3RyYW5zZm9ybScsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIFNWR1xuICAgICAgLyoqXG4gICAgICAgKiBGaWxsXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmlsbFxuICAgICAgICovXG4gICAgICBmaWxsOiBbe1xuICAgICAgICBmaWxsOiBbY29sb3JzLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3Ryb2tlIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3Ryb2tlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdzdHJva2Utdyc6IFt7XG4gICAgICAgIHN0cm9rZTogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aCwgaXNBcmJpdHJhcnlOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3Ryb2tlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3Ryb2tlXG4gICAgICAgKi9cbiAgICAgIHN0cm9rZTogW3tcbiAgICAgICAgc3Ryb2tlOiBbY29sb3JzLCAnbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8vIEFjY2Vzc2liaWxpdHlcbiAgICAgIC8qKlxuICAgICAgICogU2NyZWVuIFJlYWRlcnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JlZW4tcmVhZGVyc1xuICAgICAgICovXG4gICAgICBzcjogWydzci1vbmx5JywgJ25vdC1zci1vbmx5J10sXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlZCBDb2xvciBBZGp1c3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb3JjZWQtY29sb3ItYWRqdXN0XG4gICAgICAgKi9cbiAgICAgICdmb3JjZWQtY29sb3ItYWRqdXN0JzogW3tcbiAgICAgICAgJ2ZvcmNlZC1jb2xvci1hZGp1c3QnOiBbJ2F1dG8nLCAnbm9uZSddXG4gICAgICB9XVxuICAgIH0sXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3Vwczoge1xuICAgICAgb3ZlcmZsb3c6IFsnb3ZlcmZsb3cteCcsICdvdmVyZmxvdy15J10sXG4gICAgICBvdmVyc2Nyb2xsOiBbJ292ZXJzY3JvbGwteCcsICdvdmVyc2Nyb2xsLXknXSxcbiAgICAgIGluc2V0OiBbJ2luc2V0LXgnLCAnaW5zZXQteScsICdzdGFydCcsICdlbmQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG4gICAgICAnaW5zZXQteCc6IFsncmlnaHQnLCAnbGVmdCddLFxuICAgICAgJ2luc2V0LXknOiBbJ3RvcCcsICdib3R0b20nXSxcbiAgICAgIGZsZXg6IFsnYmFzaXMnLCAnZ3JvdycsICdzaHJpbmsnXSxcbiAgICAgIGdhcDogWydnYXAteCcsICdnYXAteSddLFxuICAgICAgcDogWydweCcsICdweScsICdwcycsICdwZScsICdwdCcsICdwcicsICdwYicsICdwbCddLFxuICAgICAgcHg6IFsncHInLCAncGwnXSxcbiAgICAgIHB5OiBbJ3B0JywgJ3BiJ10sXG4gICAgICBtOiBbJ214JywgJ215JywgJ21zJywgJ21lJywgJ210JywgJ21yJywgJ21iJywgJ21sJ10sXG4gICAgICBteDogWydtcicsICdtbCddLFxuICAgICAgbXk6IFsnbXQnLCAnbWInXSxcbiAgICAgIHNpemU6IFsndycsICdoJ10sXG4gICAgICAnZm9udC1zaXplJzogWydsZWFkaW5nJ10sXG4gICAgICAnZnZuLW5vcm1hbCc6IFsnZnZuLW9yZGluYWwnLCAnZnZuLXNsYXNoZWQtemVybycsICdmdm4tZmlndXJlJywgJ2Z2bi1zcGFjaW5nJywgJ2Z2bi1mcmFjdGlvbiddLFxuICAgICAgJ2Z2bi1vcmRpbmFsJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnZnZuLXNsYXNoZWQtemVybyc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1maWd1cmUnOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tc3BhY2luZyc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1mcmFjdGlvbic6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2xpbmUtY2xhbXAnOiBbJ2Rpc3BsYXknLCAnb3ZlcmZsb3cnXSxcbiAgICAgIHJvdW5kZWQ6IFsncm91bmRlZC1zJywgJ3JvdW5kZWQtZScsICdyb3VuZGVkLXQnLCAncm91bmRlZC1yJywgJ3JvdW5kZWQtYicsICdyb3VuZGVkLWwnLCAncm91bmRlZC1zcycsICdyb3VuZGVkLXNlJywgJ3JvdW5kZWQtZWUnLCAncm91bmRlZC1lcycsICdyb3VuZGVkLXRsJywgJ3JvdW5kZWQtdHInLCAncm91bmRlZC1icicsICdyb3VuZGVkLWJsJ10sXG4gICAgICAncm91bmRlZC1zJzogWydyb3VuZGVkLXNzJywgJ3JvdW5kZWQtZXMnXSxcbiAgICAgICdyb3VuZGVkLWUnOiBbJ3JvdW5kZWQtc2UnLCAncm91bmRlZC1lZSddLFxuICAgICAgJ3JvdW5kZWQtdCc6IFsncm91bmRlZC10bCcsICdyb3VuZGVkLXRyJ10sXG4gICAgICAncm91bmRlZC1yJzogWydyb3VuZGVkLXRyJywgJ3JvdW5kZWQtYnInXSxcbiAgICAgICdyb3VuZGVkLWInOiBbJ3JvdW5kZWQtYnInLCAncm91bmRlZC1ibCddLFxuICAgICAgJ3JvdW5kZWQtbCc6IFsncm91bmRlZC10bCcsICdyb3VuZGVkLWJsJ10sXG4gICAgICAnYm9yZGVyLXNwYWNpbmcnOiBbJ2JvcmRlci1zcGFjaW5nLXgnLCAnYm9yZGVyLXNwYWNpbmcteSddLFxuICAgICAgJ2JvcmRlci13JzogWydib3JkZXItdy1zJywgJ2JvcmRlci13LWUnLCAnYm9yZGVyLXctdCcsICdib3JkZXItdy1yJywgJ2JvcmRlci13LWInLCAnYm9yZGVyLXctbCddLFxuICAgICAgJ2JvcmRlci13LXgnOiBbJ2JvcmRlci13LXInLCAnYm9yZGVyLXctbCddLFxuICAgICAgJ2JvcmRlci13LXknOiBbJ2JvcmRlci13LXQnLCAnYm9yZGVyLXctYiddLFxuICAgICAgJ2JvcmRlci1jb2xvcic6IFsnYm9yZGVyLWNvbG9yLXMnLCAnYm9yZGVyLWNvbG9yLWUnLCAnYm9yZGVyLWNvbG9yLXQnLCAnYm9yZGVyLWNvbG9yLXInLCAnYm9yZGVyLWNvbG9yLWInLCAnYm9yZGVyLWNvbG9yLWwnXSxcbiAgICAgICdib3JkZXItY29sb3IteCc6IFsnYm9yZGVyLWNvbG9yLXInLCAnYm9yZGVyLWNvbG9yLWwnXSxcbiAgICAgICdib3JkZXItY29sb3IteSc6IFsnYm9yZGVyLWNvbG9yLXQnLCAnYm9yZGVyLWNvbG9yLWInXSxcbiAgICAgICdzY3JvbGwtbSc6IFsnc2Nyb2xsLW14JywgJ3Njcm9sbC1teScsICdzY3JvbGwtbXMnLCAnc2Nyb2xsLW1lJywgJ3Njcm9sbC1tdCcsICdzY3JvbGwtbXInLCAnc2Nyb2xsLW1iJywgJ3Njcm9sbC1tbCddLFxuICAgICAgJ3Njcm9sbC1teCc6IFsnc2Nyb2xsLW1yJywgJ3Njcm9sbC1tbCddLFxuICAgICAgJ3Njcm9sbC1teSc6IFsnc2Nyb2xsLW10JywgJ3Njcm9sbC1tYiddLFxuICAgICAgJ3Njcm9sbC1wJzogWydzY3JvbGwtcHgnLCAnc2Nyb2xsLXB5JywgJ3Njcm9sbC1wcycsICdzY3JvbGwtcGUnLCAnc2Nyb2xsLXB0JywgJ3Njcm9sbC1wcicsICdzY3JvbGwtcGInLCAnc2Nyb2xsLXBsJ10sXG4gICAgICAnc2Nyb2xsLXB4JzogWydzY3JvbGwtcHInLCAnc2Nyb2xsLXBsJ10sXG4gICAgICAnc2Nyb2xsLXB5JzogWydzY3JvbGwtcHQnLCAnc2Nyb2xsLXBiJ10sXG4gICAgICB0b3VjaDogWyd0b3VjaC14JywgJ3RvdWNoLXknLCAndG91Y2gtcHonXSxcbiAgICAgICd0b3VjaC14JzogWyd0b3VjaCddLFxuICAgICAgJ3RvdWNoLXknOiBbJ3RvdWNoJ10sXG4gICAgICAndG91Y2gtcHonOiBbJ3RvdWNoJ11cbiAgICB9LFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyczoge1xuICAgICAgJ2ZvbnQtc2l6ZSc6IFsnbGVhZGluZyddXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYmFzZUNvbmZpZyBDb25maWcgd2hlcmUgb3RoZXIgY29uZmlnIHdpbGwgYmUgbWVyZ2VkIGludG8uIFRoaXMgb2JqZWN0IHdpbGwgYmUgbXV0YXRlZC5cbiAqIEBwYXJhbSBjb25maWdFeHRlbnNpb24gUGFydGlhbCBjb25maWcgdG8gbWVyZ2UgaW50byB0aGUgYGJhc2VDb25maWdgLlxuICovXG5jb25zdCBtZXJnZUNvbmZpZ3MgPSAoYmFzZUNvbmZpZywge1xuICBjYWNoZVNpemUsXG4gIHByZWZpeCxcbiAgc2VwYXJhdG9yLFxuICBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSxcbiAgZXh0ZW5kID0ge30sXG4gIG92ZXJyaWRlID0ge31cbn0pID0+IHtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAnY2FjaGVTaXplJywgY2FjaGVTaXplKTtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAncHJlZml4JywgcHJlZml4KTtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAnc2VwYXJhdG9yJywgc2VwYXJhdG9yKTtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAnZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUnLCBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSk7XG4gIGZvciAoY29uc3QgY29uZmlnS2V5IGluIG92ZXJyaWRlKSB7XG4gICAgb3ZlcnJpZGVDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWdbY29uZmlnS2V5XSwgb3ZlcnJpZGVbY29uZmlnS2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZW5kKSB7XG4gICAgbWVyZ2VDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWdba2V5XSwgZXh0ZW5kW2tleV0pO1xuICB9XG4gIHJldHVybiBiYXNlQ29uZmlnO1xufTtcbmNvbnN0IG92ZXJyaWRlUHJvcGVydHkgPSAoYmFzZU9iamVjdCwgb3ZlcnJpZGVLZXksIG92ZXJyaWRlVmFsdWUpID0+IHtcbiAgaWYgKG92ZXJyaWRlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGJhc2VPYmplY3Rbb3ZlcnJpZGVLZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgfVxufTtcbmNvbnN0IG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyA9IChiYXNlT2JqZWN0LCBvdmVycmlkZU9iamVjdCkgPT4ge1xuICBpZiAob3ZlcnJpZGVPYmplY3QpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZU9iamVjdCkge1xuICAgICAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlT2JqZWN0LCBrZXksIG92ZXJyaWRlT2JqZWN0W2tleV0pO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG1lcmdlQ29uZmlnUHJvcGVydGllcyA9IChiYXNlT2JqZWN0LCBtZXJnZU9iamVjdCkgPT4ge1xuICBpZiAobWVyZ2VPYmplY3QpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXJnZU9iamVjdCkge1xuICAgICAgY29uc3QgbWVyZ2VWYWx1ZSA9IG1lcmdlT2JqZWN0W2tleV07XG4gICAgICBpZiAobWVyZ2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2VPYmplY3Rba2V5XSA9IChiYXNlT2JqZWN0W2tleV0gfHwgW10pLmNvbmNhdChtZXJnZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5jb25zdCBleHRlbmRUYWlsd2luZE1lcmdlID0gKGNvbmZpZ0V4dGVuc2lvbiwgLi4uY3JlYXRlQ29uZmlnKSA9PiB0eXBlb2YgY29uZmlnRXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nID8gY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnLCBjb25maWdFeHRlbnNpb24sIC4uLmNyZWF0ZUNvbmZpZykgOiBjcmVhdGVUYWlsd2luZE1lcmdlKCgpID0+IG1lcmdlQ29uZmlncyhnZXREZWZhdWx0Q29uZmlnKCksIGNvbmZpZ0V4dGVuc2lvbiksIC4uLmNyZWF0ZUNvbmZpZyk7XG5jb25zdCB0d01lcmdlID0gLyojX19QVVJFX18qL2NyZWF0ZVRhaWx3aW5kTWVyZ2UoZ2V0RGVmYXVsdENvbmZpZyk7XG5leHBvcnQgeyBjcmVhdGVUYWlsd2luZE1lcmdlLCBleHRlbmRUYWlsd2luZE1lcmdlLCBmcm9tVGhlbWUsIGdldERlZmF1bHRDb25maWcsIG1lcmdlQ29uZmlncywgdHdKb2luLCB0d01lcmdlLCB2YWxpZGF0b3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUtbWpzLm1qcy5tYXBcbiIsImltcG9ydCB7IGUsIGIsIGcsIGMsIGYsIGEsIGggfSBmcm9tICcuL2NodW5rLUkyUUdYQUEzLmpzJztcbmltcG9ydCB7IHR3TWVyZ2UsIGV4dGVuZFRhaWx3aW5kTWVyZ2UgfSBmcm9tICd0YWlsd2luZC1tZXJnZSc7XG5cbnZhciBpZT17dHdNZXJnZTohMCx0d01lcmdlQ29uZmlnOnt9LHJlc3BvbnNpdmVWYXJpYW50czohMX0seD1zPT5zfHx2b2lkIDAsTj0oLi4ucyk9PngoZShzKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIikpLFI9bnVsbCx2PXt9LHE9ITEsTT0oLi4ucyk9PmIkMT0+YiQxLnR3TWVyZ2U/KCghUnx8cSkmJihxPSExLFI9Yih2KT90d01lcmdlOmV4dGVuZFRhaWx3aW5kTWVyZ2Uoey4uLnYsZXh0ZW5kOnt0aGVtZTp2LnRoZW1lLGNsYXNzR3JvdXBzOnYuY2xhc3NHcm91cHMsY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzOnYuY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzLGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6di5jb25mbGljdGluZ0NsYXNzR3JvdXBzLC4uLnYuZXh0ZW5kfX0pKSx4KFIoTihzKSkpKTpOKHMpLF89KHMsYik9Pntmb3IobGV0IGUgaW4gYilzLmhhc093blByb3BlcnR5KGUpP3NbZV09TihzW2VdLGJbZV0pOnNbZV09YltlXTtyZXR1cm4gc30sY2U9KHMsYiQxKT0+e2xldHtleHRlbmQ6ZT1udWxsLHNsb3RzOk89e30sdmFyaWFudHM6VT17fSxjb21wb3VuZFZhcmlhbnRzOlc9W10sY29tcG91bmRTbG90czpDPVtdLGRlZmF1bHRWYXJpYW50czp6PXt9fT1zLG09ey4uLmllLC4uLmIkMX0saz1lIT1udWxsJiZlLmJhc2U/TihlLmJhc2Uscz09bnVsbD92b2lkIDA6cy5iYXNlKTpzPT1udWxsP3ZvaWQgMDpzLmJhc2UsZyQxPWUhPW51bGwmJmUudmFyaWFudHMmJiFiKGUudmFyaWFudHMpP2coVSxlLnZhcmlhbnRzKTpVLHc9ZSE9bnVsbCYmZS5kZWZhdWx0VmFyaWFudHMmJiFiKGUuZGVmYXVsdFZhcmlhbnRzKT97Li4uZS5kZWZhdWx0VmFyaWFudHMsLi4uen06ejshYihtLnR3TWVyZ2VDb25maWcpJiYhYyhtLnR3TWVyZ2VDb25maWcsdikmJihxPSEwLHY9bS50d01lcmdlQ29uZmlnKTtsZXQgUz1iKGU9PW51bGw/dm9pZCAwOmUuc2xvdHMpLFQ9YihPKT97fTp7YmFzZTpOKHM9PW51bGw/dm9pZCAwOnMuYmFzZSxTJiYoZT09bnVsbD92b2lkIDA6ZS5iYXNlKSksLi4uT30saj1TP1Q6Xyh7Li4uZT09bnVsbD92b2lkIDA6ZS5zbG90c30sYihUKT97YmFzZTpzPT1udWxsP3ZvaWQgMDpzLmJhc2V9OlQpLGgkMT1iKGU9PW51bGw/dm9pZCAwOmUuY29tcG91bmRWYXJpYW50cyk/VzpmKGU9PW51bGw/dm9pZCAwOmUuY29tcG91bmRWYXJpYW50cyxXKSxWPWw9PntpZihiKGckMSkmJmIoTykmJlMpcmV0dXJuIE0oayxsPT1udWxsP3ZvaWQgMDpsLmNsYXNzLGw9PW51bGw/dm9pZCAwOmwuY2xhc3NOYW1lKShtKTtpZihoJDEmJiFBcnJheS5pc0FycmF5KGgkMSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiY29tcG91bmRWYXJpYW50c1wiIHByb3AgbXVzdCBiZSBhbiBhcnJheS4gUmVjZWl2ZWQ6ICR7dHlwZW9mIGgkMX1gKTtpZihDJiYhQXJyYXkuaXNBcnJheShDKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJjb21wb3VuZFNsb3RzXCIgcHJvcCBtdXN0IGJlIGFuIGFycmF5LiBSZWNlaXZlZDogJHt0eXBlb2YgQ31gKTtsZXQgUD0oYSxuLHQ9W10saSk9PntsZXQgcj10O2lmKHR5cGVvZiBuPT1cInN0cmluZ1wiKXI9ci5jb25jYXQoaChuKS5zcGxpdChcIiBcIikubWFwKG89PmAke2F9OiR7b31gKSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KG4pKXI9ci5jb25jYXQobi5yZWR1Y2UoKG8sYyk9Pm8uY29uY2F0KGAke2F9OiR7Y31gKSxbXSkpO2Vsc2UgaWYodHlwZW9mIG49PVwib2JqZWN0XCImJnR5cGVvZiBpPT1cInN0cmluZ1wiKXtmb3IobGV0IG8gaW4gbilpZihuLmhhc093blByb3BlcnR5KG8pJiZvPT09aSl7bGV0IGM9bltvXTtpZihjJiZ0eXBlb2YgYz09XCJzdHJpbmdcIil7bGV0IHU9aChjKTtyW2ldP3JbaV09cltpXS5jb25jYXQodS5zcGxpdChcIiBcIikubWFwKGY9PmAke2F9OiR7Zn1gKSk6cltpXT11LnNwbGl0KFwiIFwiKS5tYXAoZj0+YCR7YX06JHtmfWApO31lbHNlIEFycmF5LmlzQXJyYXkoYykmJmMubGVuZ3RoPjAmJihyW2ldPWMucmVkdWNlKCh1LGYpPT51LmNvbmNhdChgJHthfToke2Z9YCksW10pKTt9fXJldHVybiByfSxEPShhJDEsbj1nJDEsdD1udWxsLGk9bnVsbCk9Pnt2YXIgTDtsZXQgcj1uW2EkMV07aWYoIXJ8fGIocikpcmV0dXJuIG51bGw7bGV0IG89KEw9aT09bnVsbD92b2lkIDA6aVthJDFdKSE9bnVsbD9MOmw9PW51bGw/dm9pZCAwOmxbYSQxXTtpZihvPT09bnVsbClyZXR1cm4gbnVsbDtsZXQgYz1hKG8pLHU9QXJyYXkuaXNBcnJheShtLnJlc3BvbnNpdmVWYXJpYW50cykmJm0ucmVzcG9uc2l2ZVZhcmlhbnRzLmxlbmd0aD4wfHxtLnJlc3BvbnNpdmVWYXJpYW50cz09PSEwLGY9dz09bnVsbD92b2lkIDA6d1thJDFdLGQ9W107aWYodHlwZW9mIGM9PVwib2JqZWN0XCImJnUpZm9yKGxldFtFLFFdb2YgT2JqZWN0LmVudHJpZXMoYykpe2xldCBuZT1yW1FdO2lmKEU9PT1cImluaXRpYWxcIil7Zj1RO2NvbnRpbnVlfUFycmF5LmlzQXJyYXkobS5yZXNwb25zaXZlVmFyaWFudHMpJiYhbS5yZXNwb25zaXZlVmFyaWFudHMuaW5jbHVkZXMoRSl8fChkPVAoRSxuZSxkLHQpKTt9bGV0ICQ9YyE9bnVsbCYmdHlwZW9mIGMhPVwib2JqZWN0XCI/YzphKGYpLEE9clskfHxcImZhbHNlXCJdO3JldHVybiB0eXBlb2YgZD09XCJvYmplY3RcIiYmdHlwZW9mIHQ9PVwic3RyaW5nXCImJmRbdF0/XyhkLEEpOmQubGVuZ3RoPjA/KGQucHVzaChBKSx0PT09XCJiYXNlXCI/ZC5qb2luKFwiIFwiKTpkKTpBfSxwPSgpPT5nJDE/T2JqZWN0LmtleXMoZyQxKS5tYXAoYT0+RChhLGckMSkpOm51bGwsZWU9KGEsbik9PntpZighZyQxfHx0eXBlb2YgZyQxIT1cIm9iamVjdFwiKXJldHVybiBudWxsO2xldCB0PW5ldyBBcnJheTtmb3IobGV0IGkgaW4gZyQxKXtsZXQgcj1EKGksZyQxLGEsbiksbz1hPT09XCJiYXNlXCImJnR5cGVvZiByPT1cInN0cmluZ1wiP3I6ciYmclthXTtvJiYodFt0Lmxlbmd0aF09byk7fXJldHVybiB0fSxIPXt9O2ZvcihsZXQgYSBpbiBsKWxbYV0hPT12b2lkIDAmJihIW2FdPWxbYV0pO2xldCBJPShhLG4pPT57dmFyIGk7bGV0IHQ9dHlwZW9mKGw9PW51bGw/dm9pZCAwOmxbYV0pPT1cIm9iamVjdFwiP3tbYV06KGk9bFthXSk9PW51bGw/dm9pZCAwOmkuaW5pdGlhbH06e307cmV0dXJuIHsuLi53LC4uLkgsLi4udCwuLi5ufX0sSj0oYT1bXSxuKT0+e2xldCB0PVtdO2ZvcihsZXR7Y2xhc3M6aSxjbGFzc05hbWU6ciwuLi5vfW9mIGEpe2xldCBjPSEwO2ZvcihsZXRbdSxmXW9mIE9iamVjdC5lbnRyaWVzKG8pKXtsZXQgZD1JKHUsbilbdV07aWYoQXJyYXkuaXNBcnJheShmKSl7aWYoIWYuaW5jbHVkZXMoZCkpe2M9ITE7YnJlYWt9fWVsc2Uge2xldCAkPUE9PkE9PW51bGx8fEE9PT0hMTtpZigkKGYpJiYkKGQpKWNvbnRpbnVlO2lmKGQhPT1mKXtjPSExO2JyZWFrfX19YyYmKGkmJnQucHVzaChpKSxyJiZ0LnB1c2gocikpO31yZXR1cm4gdH0sdGU9YT0+e2xldCBuPUooaCQxLGEpO2lmKCFBcnJheS5pc0FycmF5KG4pKXJldHVybiBuO2xldCB0PXt9O2ZvcihsZXQgaSBvZiBuKWlmKHR5cGVvZiBpPT1cInN0cmluZ1wiJiYodC5iYXNlPU0odC5iYXNlLGkpKG0pKSx0eXBlb2YgaT09XCJvYmplY3RcIilmb3IobGV0W3Isb11vZiBPYmplY3QuZW50cmllcyhpKSl0W3JdPU0odFtyXSxvKShtKTtyZXR1cm4gdH0sYWU9YT0+e2lmKEMubGVuZ3RoPDEpcmV0dXJuIG51bGw7bGV0IG49e307Zm9yKGxldHtzbG90czp0PVtdLGNsYXNzOmksY2xhc3NOYW1lOnIsLi4ub31vZiBDKXtpZighYihvKSl7bGV0IGM9ITA7Zm9yKGxldCB1IG9mIE9iamVjdC5rZXlzKG8pKXtsZXQgZj1JKHUsYSlbdV07aWYoZj09PXZvaWQgMHx8KEFycmF5LmlzQXJyYXkob1t1XSk/IW9bdV0uaW5jbHVkZXMoZik6b1t1XSE9PWYpKXtjPSExO2JyZWFrfX1pZighYyljb250aW51ZX1mb3IobGV0IGMgb2YgdCluW2NdPW5bY118fFtdLG5bY10ucHVzaChbaSxyXSk7fXJldHVybiBufTtpZighYihPKXx8IVMpe2xldCBhPXt9O2lmKHR5cGVvZiBqPT1cIm9iamVjdFwiJiYhYihqKSlmb3IobGV0IG4gb2YgT2JqZWN0LmtleXMoaikpYVtuXT10PT57dmFyIGkscjtyZXR1cm4gTShqW25dLGVlKG4sdCksKChpPXRlKHQpKSE9bnVsbD9pOltdKVtuXSwoKHI9YWUodCkpIT1udWxsP3I6W10pW25dLHQ9PW51bGw/dm9pZCAwOnQuY2xhc3MsdD09bnVsbD92b2lkIDA6dC5jbGFzc05hbWUpKG0pfTtyZXR1cm4gYX1yZXR1cm4gTShrLHAoKSxKKGgkMSksbD09bnVsbD92b2lkIDA6bC5jbGFzcyxsPT1udWxsP3ZvaWQgMDpsLmNsYXNzTmFtZSkobSl9LEs9KCk9PntpZighKCFnJDF8fHR5cGVvZiBnJDEhPVwib2JqZWN0XCIpKXJldHVybiBPYmplY3Qua2V5cyhnJDEpfTtyZXR1cm4gVi52YXJpYW50S2V5cz1LKCksVi5leHRlbmQ9ZSxWLmJhc2U9ayxWLnNsb3RzPWosVi52YXJpYW50cz1nJDEsVi5kZWZhdWx0VmFyaWFudHM9dyxWLmNvbXBvdW5kU2xvdHM9QyxWLmNvbXBvdW5kVmFyaWFudHM9aCQxLFZ9LGZlPXM9PihiLGUpPT5jZShiLGU/ZyhzLGUpOnMpO1xuXG5leHBvcnQgeyBNIGFzIGNuLCBOIGFzIGNuQmFzZSwgZmUgYXMgY3JlYXRlVFYsIGllIGFzIGRlZmF1bHRDb25maWcsIGNlIGFzIHR2LCB4IGFzIHZvaWRFbXB0eSB9O1xuIiwiaW1wb3J0IHsgdHlwZSBDbGFzc1ZhbHVlLCBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHR3TWVyZ2UgfSBmcm9tIFwidGFpbHdpbmQtbWVyZ2VcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNuKC4uLmlucHV0czogQ2xhc3NWYWx1ZVtdKSB7XG5cdHJldHVybiB0d01lcmdlKGNsc3goaW5wdXRzKSk7XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiIG1vZHVsZT5cblx0aW1wb3J0IHR5cGUgeyBXaXRoRWxlbWVudFJlZiB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgdHlwZSB7IEhUTUxBbmNob3JBdHRyaWJ1dGVzLCBIVE1MQnV0dG9uQXR0cmlidXRlcyB9IGZyb20gJ3N2ZWx0ZS9lbGVtZW50cyc7XG5cdGltcG9ydCB7IHR5cGUgVmFyaWFudFByb3BzLCB0diB9IGZyb20gJ3RhaWx3aW5kLXZhcmlhbnRzJztcblxuXHRleHBvcnQgY29uc3QgYnV0dG9uVmFyaWFudHMgPSB0dih7XG5cdFx0YmFzZTogJ3Jpbmctb2Zmc2V0LWJhY2tncm91bmQgZm9jdXMtdmlzaWJsZTpyaW5nLXJpbmcgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGdhcC0yIHdoaXRlc3BhY2Utbm93cmFwIHJvdW5kZWQtbWQgdGV4dC1zbSBmb250LW1lZGl1bSB0cmFuc2l0aW9uLWNvbG9ycyBmb2N1cy12aXNpYmxlOm91dGxpbmUtbm9uZSBmb2N1cy12aXNpYmxlOnJpbmctMiBmb2N1cy12aXNpYmxlOnJpbmctb2Zmc2V0LTIgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZSBkaXNhYmxlZDpvcGFjaXR5LTUwIFsmX3N2Z106cG9pbnRlci1ldmVudHMtbm9uZSBbJl9zdmddOnNpemUtNCBbJl9zdmddOnNocmluay0wJyxcblx0XHR2YXJpYW50czoge1xuXHRcdFx0dmFyaWFudDoge1xuXHRcdFx0XHRkZWZhdWx0OiAnYmctcHJpbWFyeSB0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCBob3ZlcjpiZy1wcmltYXJ5LzkwJyxcblx0XHRcdFx0ZGVzdHJ1Y3RpdmU6ICdiZy1kZXN0cnVjdGl2ZSB0ZXh0LWRlc3RydWN0aXZlLWZvcmVncm91bmQgaG92ZXI6YmctZGVzdHJ1Y3RpdmUvOTAnLFxuXHRcdFx0XHRvdXRsaW5lOiAnYm9yZGVyLWlucHV0IGJnLWJhY2tncm91bmQgaG92ZXI6YmctYWNjZW50IGhvdmVyOnRleHQtYWNjZW50LWZvcmVncm91bmQgYm9yZGVyJyxcblx0XHRcdFx0c2Vjb25kYXJ5OiAnYmctc2Vjb25kYXJ5IHRleHQtc2Vjb25kYXJ5LWZvcmVncm91bmQgaG92ZXI6Ymctc2Vjb25kYXJ5LzgwJyxcblx0XHRcdFx0Z2hvc3Q6ICdob3ZlcjpiZy1hY2NlbnQgaG92ZXI6dGV4dC1hY2NlbnQtZm9yZWdyb3VuZCcsXG5cdFx0XHRcdGxpbms6ICd0ZXh0LXByaW1hcnkgdW5kZXJsaW5lLW9mZnNldC00IGhvdmVyOnVuZGVybGluZSdcblx0XHRcdH0sXG5cdFx0XHRzaXplOiB7XG5cdFx0XHRcdGRlZmF1bHQ6ICdoLTEwIHB4LTQgcHktMicsXG5cdFx0XHRcdHNtOiAnaC05IHJvdW5kZWQtbWQgcHgtMycsXG5cdFx0XHRcdGxnOiAnaC0xMSByb3VuZGVkLW1kIHB4LTgnLFxuXHRcdFx0XHRpY29uOiAnaC0xMCB3LTEwJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVmYXVsdFZhcmlhbnRzOiB7XG5cdFx0XHR2YXJpYW50OiAnZGVmYXVsdCcsXG5cdFx0XHRzaXplOiAnZGVmYXVsdCdcblx0XHR9XG5cdH0pO1xuXG5cdGV4cG9ydCB0eXBlIEJ1dHRvblZhcmlhbnQgPSBWYXJpYW50UHJvcHM8dHlwZW9mIGJ1dHRvblZhcmlhbnRzPlsndmFyaWFudCddO1xuXHRleHBvcnQgdHlwZSBCdXR0b25TaXplID0gVmFyaWFudFByb3BzPHR5cGVvZiBidXR0b25WYXJpYW50cz5bJ3NpemUnXTtcblxuXHRleHBvcnQgdHlwZSBCdXR0b25Qcm9wcyA9IFdpdGhFbGVtZW50UmVmPEhUTUxCdXR0b25BdHRyaWJ1dGVzPiAmXG5cdFx0V2l0aEVsZW1lbnRSZWY8SFRNTEFuY2hvckF0dHJpYnV0ZXM+ICYge1xuXHRcdFx0dmFyaWFudD86IEJ1dHRvblZhcmlhbnQ7XG5cdFx0XHRzaXplPzogQnV0dG9uU2l6ZTtcblx0XHR9O1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdHZhcmlhbnQgPSAnZGVmYXVsdCcsXG5cdFx0c2l6ZSA9ICdkZWZhdWx0Jyxcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0aHJlZiA9IHVuZGVmaW5lZCxcblx0XHR0eXBlID0gJ2J1dHRvbicsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IEJ1dHRvblByb3BzID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBocmVmfVxuXHQ8YSBiaW5kOnRoaXM9e3JlZn0gY2xhc3M9e2NuKGJ1dHRvblZhcmlhbnRzKHsgdmFyaWFudCwgc2l6ZSwgY2xhc3NOYW1lIH0pKX0ge2hyZWZ9IHsuLi5yZXN0UHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC9hPlxuezplbHNlfVxuXHQ8YnV0dG9uXG5cdFx0YmluZDp0aGlzPXtyZWZ9XG5cdFx0Y2xhc3M9e2NuKGJ1dHRvblZhcmlhbnRzKHsgdmFyaWFudCwgc2l6ZSwgY2xhc3NOYW1lIH0pKX1cblx0XHR7dHlwZX1cblx0XHR7Li4ucmVzdFByb3BzfVxuXHQ+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2J1dHRvbj5cbnsvaWZ9XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9IGZyb20gXCIuLi91dGlscy9pcy5qc1wiO1xuY29uc3QgQm94U3ltYm9sID0gU3ltYm9sKFwiYm94XCIpO1xuY29uc3QgaXNXcml0YWJsZVN5bWJvbCA9IFN5bWJvbChcImlzLXdyaXRhYmxlXCIpO1xuLyoqXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIEJveFxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnVuZWQuZGV2L2RvY3MvZnVuY3Rpb25zL2JveH1cbiAqL1xuZnVuY3Rpb24gaXNCb3godmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIEJveFN5bWJvbCBpbiB2YWx1ZTtcbn1cbi8qKlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBXcml0YWJsZUJveFxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnVuZWQuZGV2L2RvY3MvZnVuY3Rpb25zL2JveH1cbiAqL1xuZnVuY3Rpb24gaXNXcml0YWJsZUJveCh2YWx1ZSkge1xuICAgIHJldHVybiBib3guaXNCb3godmFsdWUpICYmIGlzV3JpdGFibGVTeW1ib2wgaW4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYm94KGluaXRpYWxWYWx1ZSkge1xuICAgIGxldCBjdXJyZW50ID0gJHN0YXRlKGluaXRpYWxWYWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW0JveFN5bWJvbF06IHRydWUsXG4gICAgICAgIFtpc1dyaXRhYmxlU3ltYm9sXTogdHJ1ZSxcbiAgICAgICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGN1cnJlbnQodikge1xuICAgICAgICAgICAgY3VycmVudCA9IHY7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYm94V2l0aChnZXR0ZXIsIHNldHRlcikge1xuICAgIGNvbnN0IGRlcml2ZWQgPSAkZGVyaXZlZC5ieShnZXR0ZXIpO1xuICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtCb3hTeW1ib2xdOiB0cnVlLFxuICAgICAgICAgICAgW2lzV3JpdGFibGVTeW1ib2xdOiB0cnVlLFxuICAgICAgICAgICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnQodikge1xuICAgICAgICAgICAgICAgIHNldHRlcih2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW0JveFN5bWJvbF06IHRydWUsXG4gICAgICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJveEZyb20odmFsdWUpIHtcbiAgICBpZiAoYm94LmlzQm94KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGJveC53aXRoKHZhbHVlKTtcbiAgICByZXR1cm4gYm94KHZhbHVlKTtcbn1cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBnZXRzIGFuIG9iamVjdCBvZiBib3hlcywgYW5kIHJldHVybnMgYW4gb2JqZWN0IG9mIHJlYWN0aXZlIHZhbHVlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjb3VudCA9IGJveCgwKVxuICogY29uc3QgZmxhdCA9IGJveC5mbGF0dGVuKHsgY291bnQsIGRvdWJsZTogYm94LndpdGgoKCkgPT4gY291bnQuY3VycmVudCkgfSlcbiAqIC8vIHR5cGUgb2YgZmxhdCBpcyB7IGNvdW50OiBudW1iZXIsIHJlYWRvbmx5IGRvdWJsZTogbnVtYmVyIH1cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3J1bmVkLmRldi9kb2NzL2Z1bmN0aW9ucy9ib3h9XG4gKi9cbmZ1bmN0aW9uIGJveEZsYXR0ZW4oYm94ZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYm94ZXMpLnJlZHVjZSgoYWNjLCBba2V5LCBiXSkgPT4ge1xuICAgICAgICBpZiAoIWJveC5pc0JveChiKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7IFtrZXldOiBiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3guaXNXcml0YWJsZUJveChiKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjYywga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHRzL25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgICAgIGIuY3VycmVudCA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWNjLCBrZXksIHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgY29udmVydHMgYSBib3ggdG8gYSByZWFkb25seSBib3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNvdW50ID0gYm94KDApIC8vIFdyaXRhYmxlQm94PG51bWJlcj5cbiAqIGNvbnN0IGNvdW50UmVhZG9ubHkgPSBib3gucmVhZG9ubHkoY291bnQpIC8vIFJlYWRhYmxlQm94PG51bWJlcj5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3J1bmVkLmRldi9kb2NzL2Z1bmN0aW9ucy9ib3h9XG4gKi9cbmZ1bmN0aW9uIHRvUmVhZG9ubHlCb3goYikge1xuICAgIGlmICghYm94LmlzV3JpdGFibGVCb3goYikpXG4gICAgICAgIHJldHVybiBiO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtCb3hTeW1ib2xdOiB0cnVlLFxuICAgICAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuYm94LmZyb20gPSBib3hGcm9tO1xuYm94LndpdGggPSBib3hXaXRoO1xuYm94LmZsYXR0ZW4gPSBib3hGbGF0dGVuO1xuYm94LnJlYWRvbmx5ID0gdG9SZWFkb25seUJveDtcbmJveC5pc0JveCA9IGlzQm94O1xuYm94LmlzV3JpdGFibGVCb3ggPSBpc1dyaXRhYmxlQm94O1xuIiwiLyoqXG4gKiBDb21wb3NlcyBldmVudCBoYW5kbGVycyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoIGFuIGV2ZW50LlxuICogSWYgdGhlIHByZXZpb3VzIGhhbmRsZXIgY2FuY2VscyB0aGUgZXZlbnQgdXNpbmcgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgLCB0aGUgaGFuZGxlcnNcbiAqIHRoYXQgZm9sbG93IHdpbGwgbm90IGJlIGNhbGxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VIYW5kbGVycyguLi5oYW5kbGVycykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmN1cnJlbnQ/LmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuIiwiLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvZ3JhbW1hci5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvY3NzLXBhcnNlL3B1bGwvNDkjaXNzdWVjb21tZW50LTMwMDg4MDI3XG52YXIgQ09NTUVOVF9SRUdFWCA9IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9nO1xuXG52YXIgTkVXTElORV9SRUdFWCA9IC9cXG4vZztcbnZhciBXSElURVNQQUNFX1JFR0VYID0gL15cXHMqLztcblxuLy8gZGVjbGFyYXRpb25cbnZhciBQUk9QRVJUWV9SRUdFWCA9IC9eKFxcKj9bLSMvKlxcXFxcXHddKyhcXFtbMC05YS16Xy1dK1xcXSk/KVxccyovO1xudmFyIENPTE9OX1JFR0VYID0gL146XFxzKi87XG52YXIgVkFMVUVfUkVHRVggPSAvXigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07XSkrKS87XG52YXIgU0VNSUNPTE9OX1JFR0VYID0gL15bO1xcc10qLztcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbnZhciBUUklNX1JFR0VYID0gL15cXHMrfFxccyskL2c7XG5cbi8vIHN0cmluZ3NcbnZhciBORVdMSU5FID0gJ1xcbic7XG52YXIgRk9SV0FSRF9TTEFTSCA9ICcvJztcbnZhciBBU1RFUklTSyA9ICcqJztcbnZhciBFTVBUWV9TVFJJTkcgPSAnJztcblxuLy8gdHlwZXNcbnZhciBUWVBFX0NPTU1FTlQgPSAnY29tbWVudCc7XG52YXIgVFlQRV9ERUNMQVJBVElPTiA9ICdkZWNsYXJhdGlvbic7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHlsZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICghc3R5bGUpIHJldHVybiBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogUG9zaXRpb25hbC5cbiAgICovXG4gIHZhciBsaW5lbm8gPSAxO1xuICB2YXIgY29sdW1uID0gMTtcblxuICAvKipcbiAgICogVXBkYXRlIGxpbmVubyBhbmQgY29sdW1uIGJhc2VkIG9uIGBzdHJgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihzdHIpIHtcbiAgICB2YXIgbGluZXMgPSBzdHIubWF0Y2goTkVXTElORV9SRUdFWCk7XG4gICAgaWYgKGxpbmVzKSBsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgIHZhciBpID0gc3RyLmxhc3RJbmRleE9mKE5FV0xJTkUpO1xuICAgIGNvbHVtbiA9IH5pID8gc3RyLmxlbmd0aCAtIGkgOiBjb2x1bW4gKyBzdHIubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgcG9zaXRpb24gYW5kIHBhdGNoIGBub2RlLnBvc2l0aW9uYC5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB7IGxpbmU6IGxpbmVubywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUucG9zaXRpb24gPSBuZXcgUG9zaXRpb24oc3RhcnQpO1xuICAgICAgd2hpdGVzcGFjZSgpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBub2RlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0YXJ0XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbmRcbiAgICogQHByb3BlcnR5IHt1bmRlZmluZWR8U3RyaW5nfSBzb3VyY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvc2l0aW9uKHN0YXJ0KSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0geyBsaW5lOiBsaW5lbm8sIGNvbHVtbjogY29sdW1uIH07XG4gICAgdGhpcy5zb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb24tZW51bWVyYWJsZSBzb3VyY2Ugc3RyaW5nLlxuICAgKi9cbiAgUG9zaXRpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBzdHlsZTtcblxuICB2YXIgZXJyb3JzTGlzdCA9IFtdO1xuXG4gIC8qKlxuICAgKiBFcnJvciBgbXNnYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBvcHRpb25zLnNvdXJjZSArICc6JyArIGxpbmVubyArICc6JyArIGNvbHVtbiArICc6ICcgKyBtc2dcbiAgICApO1xuICAgIGVyci5yZWFzb24gPSBtc2c7XG4gICAgZXJyLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgZXJyLmxpbmUgPSBsaW5lbm87XG4gICAgZXJyLmNvbHVtbiA9IGNvbHVtbjtcbiAgICBlcnIuc291cmNlID0gc3R5bGU7XG5cbiAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIGVycm9yc0xpc3QucHVzaChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIGByZWAgYW5kIHJldHVybiBjYXB0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZHxBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIG1hdGNoKHJlKSB7XG4gICAgdmFyIG0gPSByZS5leGVjKHN0eWxlKTtcbiAgICBpZiAoIW0pIHJldHVybjtcbiAgICB2YXIgc3RyID0gbVswXTtcbiAgICB1cGRhdGVQb3NpdGlvbihzdHIpO1xuICAgIHN0eWxlID0gc3R5bGUuc2xpY2Uoc3RyLmxlbmd0aCk7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugd2hpdGVzcGFjZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdoaXRlc3BhY2UoKSB7XG4gICAgbWF0Y2goV0hJVEVTUEFDRV9SRUdFWCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY29tbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtydWxlc11cbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBmdW5jdGlvbiBjb21tZW50cyhydWxlcykge1xuICAgIHZhciBjO1xuICAgIHJ1bGVzID0gcnVsZXMgfHwgW107XG4gICAgd2hpbGUgKChjID0gY29tbWVudCgpKSkge1xuICAgICAgaWYgKGMgIT09IGZhbHNlKSB7XG4gICAgICAgIHJ1bGVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjb21tZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gY29tbWVudCgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICBpZiAoRk9SV0FSRF9TTEFTSCAhPSBzdHlsZS5jaGFyQXQoMCkgfHwgQVNURVJJU0sgIT0gc3R5bGUuY2hhckF0KDEpKSByZXR1cm47XG5cbiAgICB2YXIgaSA9IDI7XG4gICAgd2hpbGUgKFxuICAgICAgRU1QVFlfU1RSSU5HICE9IHN0eWxlLmNoYXJBdChpKSAmJlxuICAgICAgKEFTVEVSSVNLICE9IHN0eWxlLmNoYXJBdChpKSB8fCBGT1JXQVJEX1NMQVNIICE9IHN0eWxlLmNoYXJBdChpICsgMSkpXG4gICAgKSB7XG4gICAgICArK2k7XG4gICAgfVxuICAgIGkgKz0gMjtcblxuICAgIGlmIChFTVBUWV9TVFJJTkcgPT09IHN0eWxlLmNoYXJBdChpIC0gMSkpIHtcbiAgICAgIHJldHVybiBlcnJvcignRW5kIG9mIGNvbW1lbnQgbWlzc2luZycpO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBzdHlsZS5zbGljZSgyLCBpIC0gMik7XG4gICAgY29sdW1uICs9IDI7XG4gICAgdXBkYXRlUG9zaXRpb24oc3RyKTtcbiAgICBzdHlsZSA9IHN0eWxlLnNsaWNlKGkpO1xuICAgIGNvbHVtbiArPSAyO1xuXG4gICAgcmV0dXJuIHBvcyh7XG4gICAgICB0eXBlOiBUWVBFX0NPTU1FTlQsXG4gICAgICBjb21tZW50OiBzdHJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIGRlY2xhcmF0aW9uKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuXG4gICAgLy8gcHJvcFxuICAgIHZhciBwcm9wID0gbWF0Y2goUFJPUEVSVFlfUkVHRVgpO1xuICAgIGlmICghcHJvcCkgcmV0dXJuO1xuICAgIGNvbW1lbnQoKTtcblxuICAgIC8vIDpcbiAgICBpZiAoIW1hdGNoKENPTE9OX1JFR0VYKSkgcmV0dXJuIGVycm9yKFwicHJvcGVydHkgbWlzc2luZyAnOidcIik7XG5cbiAgICAvLyB2YWxcbiAgICB2YXIgdmFsID0gbWF0Y2goVkFMVUVfUkVHRVgpO1xuXG4gICAgdmFyIHJldCA9IHBvcyh7XG4gICAgICB0eXBlOiBUWVBFX0RFQ0xBUkFUSU9OLFxuICAgICAgcHJvcGVydHk6IHRyaW0ocHJvcFswXS5yZXBsYWNlKENPTU1FTlRfUkVHRVgsIEVNUFRZX1NUUklORykpLFxuICAgICAgdmFsdWU6IHZhbFxuICAgICAgICA/IHRyaW0odmFsWzBdLnJlcGxhY2UoQ09NTUVOVF9SRUdFWCwgRU1QVFlfU1RSSU5HKSlcbiAgICAgICAgOiBFTVBUWV9TVFJJTkdcbiAgICB9KTtcblxuICAgIC8vIDtcbiAgICBtYXRjaChTRU1JQ09MT05fUkVHRVgpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgZnVuY3Rpb24gZGVjbGFyYXRpb25zKCkge1xuICAgIHZhciBkZWNscyA9IFtdO1xuXG4gICAgY29tbWVudHMoZGVjbHMpO1xuXG4gICAgLy8gZGVjbGFyYXRpb25zXG4gICAgdmFyIGRlY2w7XG4gICAgd2hpbGUgKChkZWNsID0gZGVjbGFyYXRpb24oKSkpIHtcbiAgICAgIGlmIChkZWNsICE9PSBmYWxzZSkge1xuICAgICAgICBkZWNscy5wdXNoKGRlY2wpO1xuICAgICAgICBjb21tZW50cyhkZWNscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xzO1xuICB9XG5cbiAgd2hpdGVzcGFjZSgpO1xuICByZXR1cm4gZGVjbGFyYXRpb25zKCk7XG59O1xuXG4vKipcbiAqIFRyaW0gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoVFJJTV9SRUdFWCwgRU1QVFlfU1RSSU5HKSA6IEVNUFRZX1NUUklORztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3R5bGVUb09iamVjdDtcbnZhciBpbmxpbmVfc3R5bGVfcGFyc2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImlubGluZS1zdHlsZS1wYXJzZXJcIikpO1xuLyoqXG4gKiBQYXJzZXMgaW5saW5lIHN0eWxlIHRvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gc3R5bGUgLSBJbmxpbmUgc3R5bGUuXG4gKiBAcGFyYW0gaXRlcmF0b3IgLSBJdGVyYXRvci5cbiAqIEByZXR1cm5zIC0gU3R5bGUgb2JqZWN0IG9yIG51bGwuXG4gKlxuICogQGV4YW1wbGUgUGFyc2luZyBpbmxpbmUgc3R5bGUgdG8gb2JqZWN0OlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgcGFyc2UgZnJvbSAnc3R5bGUtdG8tb2JqZWN0JztcbiAqIHBhcnNlKCdsaW5lLWhlaWdodDogNDI7Jyk7IC8vIHsgJ2xpbmUtaGVpZ2h0JzogJzQyJyB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gU3R5bGVUb09iamVjdChzdHlsZSwgaXRlcmF0b3IpIHtcbiAgICB2YXIgc3R5bGVPYmplY3QgPSBudWxsO1xuICAgIGlmICghc3R5bGUgfHwgdHlwZW9mIHN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfVxuICAgIHZhciBkZWNsYXJhdGlvbnMgPSAoMCwgaW5saW5lX3N0eWxlX3BhcnNlcl8xLmRlZmF1bHQpKHN0eWxlKTtcbiAgICB2YXIgaGFzSXRlcmF0b3IgPSB0eXBlb2YgaXRlcmF0b3IgPT09ICdmdW5jdGlvbic7XG4gICAgZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbi50eXBlICE9PSAnZGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnR5ID0gZGVjbGFyYXRpb24ucHJvcGVydHksIHZhbHVlID0gZGVjbGFyYXRpb24udmFsdWU7XG4gICAgICAgIGlmIChoYXNJdGVyYXRvcikge1xuICAgICAgICAgICAgaXRlcmF0b3IocHJvcGVydHksIHZhbHVlLCBkZWNsYXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlT2JqZWN0ID0gc3R5bGVPYmplY3QgfHwge307XG4gICAgICAgICAgICBzdHlsZU9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBTdHlsZVRvT2JqZWN0IGZyb20gJy4uL2Nqcy9pbmRleC5qcyc7XG5cbi8vIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggcm9sbHVwIHVtZCBidWlsZFxuZXhwb3J0IGRlZmF1bHQgU3R5bGVUb09iamVjdC5kZWZhdWx0IHx8IFN0eWxlVG9PYmplY3Q7XG4iLCJjb25zdCBOVU1CRVJfQ0hBUl9SRSA9IC9cXGQvO1xuY29uc3QgU1RSX1NQTElUVEVSUyA9IFtcIi1cIiwgXCJfXCIsIFwiL1wiLCBcIi5cIl07XG5mdW5jdGlvbiBpc1VwcGVyY2FzZShjaGFyID0gXCJcIikge1xuICAgIGlmIChOVU1CRVJfQ0hBUl9SRS50ZXN0KGNoYXIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBjaGFyICE9PSBjaGFyLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5Q2FzZShzdHIpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGxldCBidWZmID0gXCJcIjtcbiAgICBsZXQgcHJldmlvdXNVcHBlcjtcbiAgICBsZXQgcHJldmlvdXNTcGxpdHRlcjtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyKSB7XG4gICAgICAgIC8vIFNwbGl0dGVyXG4gICAgICAgIGNvbnN0IGlzU3BsaXR0ZXIgPSBTVFJfU1BMSVRURVJTLmluY2x1ZGVzKGNoYXIpO1xuICAgICAgICBpZiAoaXNTcGxpdHRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChidWZmKTtcbiAgICAgICAgICAgIGJ1ZmYgPSBcIlwiO1xuICAgICAgICAgICAgcHJldmlvdXNVcHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVXBwZXIgPSBpc1VwcGVyY2FzZShjaGFyKTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3BsaXR0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBDYXNlIHJpc2luZyBlZGdlXG4gICAgICAgICAgICBpZiAocHJldmlvdXNVcHBlciA9PT0gZmFsc2UgJiYgaXNVcHBlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goYnVmZik7XG4gICAgICAgICAgICAgICAgYnVmZiA9IGNoYXI7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNVcHBlciA9IGlzVXBwZXI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYXNlIGZhbGxpbmcgZWRnZVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzVXBwZXIgPT09IHRydWUgJiYgaXNVcHBlciA9PT0gZmFsc2UgJiYgYnVmZi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXIgPSBidWZmLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGJ1ZmYuc2xpY2UoMCwgTWF0aC5tYXgoMCwgYnVmZi5sZW5ndGggLSAxKSkpO1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBsYXN0Q2hhciArIGNoYXI7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNVcHBlciA9IGlzVXBwZXI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsIGNoYXJcbiAgICAgICAgYnVmZiArPSBjaGFyO1xuICAgICAgICBwcmV2aW91c1VwcGVyID0gaXNVcHBlcjtcbiAgICAgICAgcHJldmlvdXNTcGxpdHRlciA9IGlzU3BsaXR0ZXI7XG4gICAgfVxuICAgIHBhcnRzLnB1c2goYnVmZik7XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhc2NhbENhc2Uoc3RyKSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBzcGxpdEJ5Q2FzZShzdHIpXG4gICAgICAgIC5tYXAoKHApID0+IHVwcGVyRmlyc3QocCkpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gbG93ZXJGaXJzdChwYXNjYWxDYXNlKHN0ciB8fCBcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24ga2ViYWJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgPyBzcGxpdEJ5Q2FzZShzdHIpXG4gICAgICAgICAgICAubWFwKChwKSA9PiBwLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAuam9pbihcIi1cIilcbiAgICAgICAgOiBcIlwiO1xufVxuZnVuY3Rpb24gdXBwZXJGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyID8gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkgOiBcIlwiO1xufVxuZnVuY3Rpb24gbG93ZXJGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyID8gc3RyWzBdLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkgOiBcIlwiO1xufVxuIiwiaW1wb3J0IHBhcnNlIGZyb20gXCJzdHlsZS10by1vYmplY3RcIjtcbmltcG9ydCB7IGNhbWVsQ2FzZSwgcGFzY2FsQ2FzZSB9IGZyb20gXCIuL3N0cmluZ3MuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjc3NUb1N0eWxlT2JqKGNzcykge1xuICAgIGlmICghY3NzKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3Qgc3R5bGVPYmogPSB7fTtcbiAgICBmdW5jdGlvbiBpdGVyYXRvcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLW1vei1cIikgfHxcbiAgICAgICAgICAgIG5hbWUuc3RhcnRzV2l0aChcIi13ZWJraXQtXCIpIHx8XG4gICAgICAgICAgICBuYW1lLnN0YXJ0c1dpdGgoXCItbXMtXCIpIHx8XG4gICAgICAgICAgICBuYW1lLnN0YXJ0c1dpdGgoXCItby1cIikpIHtcbiAgICAgICAgICAgIHN0eWxlT2JqW3Bhc2NhbENhc2UobmFtZSldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICAgICAgICBzdHlsZU9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlT2JqW2NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcGFyc2UoY3NzLCBpdGVyYXRvcik7XG4gICAgcmV0dXJuIHN0eWxlT2JqO1xufVxuIiwiLyoqXG4gKiBFeGVjdXRlcyBhbiBhcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gKiBAdGVtcGxhdGUgVCBUaGUgdHlwZXMgb2YgdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBjYWxsYmFjayBmdW5jdGlvbnMgdGFrZS5cbiAqIEBwYXJhbSBjYWxsYmFja3MgYXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIGV4ZWN1dGUuXG4gKiBAcmV0dXJucyBBIG5ldyBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBvZiB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZUNhbGxiYWNrcyguLi5jYWxsYmFja3MpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbiIsImZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihtYXRjaGVyLCByZXBsYWNlcikge1xuICAgIGNvbnN0IHJlZ2V4ID0gUmVnRXhwKG1hdGNoZXIsIFwiZ1wiKTtcbiAgICByZXR1cm4gKHN0cikgPT4ge1xuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBpZiBub3QgYSBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGFuIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCBidXQgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBtYXRjaCBiZXR3ZWVuIHN0cmluZyBhbmQgbWF0Y2hlclxuICAgICAgICBpZiAoIXN0ci5tYXRjaChyZWdleCkpXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAvLyBleGVjdXRlcyB0aGUgcmVwbGFjZXIgZnVuY3Rpb24gZm9yIGVhY2ggbWF0Y2hcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4LCByZXBsYWNlcik7XG4gICAgfTtcbn1cbmNvbnN0IGNhbWVsVG9LZWJhYiA9IGNyZWF0ZVBhcnNlcigvW0EtWl0vLCAobWF0Y2gpID0+IGAtJHttYXRjaC50b0xvd2VyQ2FzZSgpfWApO1xuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlVG9DU1Moc3R5bGVPYmopIHtcbiAgICBpZiAoIXN0eWxlT2JqIHx8IHR5cGVvZiBzdHlsZU9iaiAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHN0eWxlT2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBhbiBhcmd1bWVudCBvZiB0eXBlIG9iamVjdCwgYnV0IGdvdCAke3R5cGVvZiBzdHlsZU9ian1gKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlT2JqKVxuICAgICAgICAubWFwKChwcm9wZXJ0eSkgPT4gYCR7Y2FtZWxUb0tlYmFiKHByb3BlcnR5KX06ICR7c3R5bGVPYmpbcHJvcGVydHldfTtgKVxuICAgICAgICAuam9pbihcIlxcblwiKTtcbn1cbiIsImltcG9ydCB7IHN0eWxlVG9DU1MgfSBmcm9tIFwiLi9zdHlsZS10by1jc3MuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVRvU3RyaW5nKHN0eWxlID0ge30pIHtcbiAgICByZXR1cm4gc3R5bGVUb0NTUyhzdHlsZSkucmVwbGFjZShcIlxcblwiLCBcIiBcIik7XG59XG5leHBvcnQgY29uc3Qgc3JPbmx5U3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgd2lkdGg6IFwiMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgIG1hcmdpbjogXCItMXB4XCIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgY2xpcDogXCJyZWN0KDAsIDAsIDAsIDApXCIsXG4gICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICBib3JkZXJXaWR0aDogXCIwXCIsXG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLTEwMCUpXCJcbn07XG5leHBvcnQgY29uc3Qgc3JPbmx5U3R5bGVzU3RyaW5nID0gc3R5bGVUb1N0cmluZyhzck9ubHlTdHlsZXMpO1xuIiwiLyoqXG4gKiBNb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL21haW4vcGFja2FnZXMvJTQwcmVhY3QtYXJpYS91dGlscy9zcmMvbWVyZ2VQcm9wcy50cyAoc2VlIE5PVElDRS50eHQgZm9yIHNvdXJjZSlcbiAqL1xuaW1wb3J0IHsgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBjb21wb3NlSGFuZGxlcnMgfSBmcm9tIFwiLi9jb21wb3NlLWhhbmRsZXJzLmpzXCI7XG5pbXBvcnQgeyBjc3NUb1N0eWxlT2JqIH0gZnJvbSBcIi4vY3NzLXRvLXN0eWxlLW9iai5qc1wiO1xuaW1wb3J0IHsgZXhlY3V0ZUNhbGxiYWNrcyB9IGZyb20gXCIuL2V4ZWN1dGUtY2FsbGJhY2tzLmpzXCI7XG5pbXBvcnQgeyBzdHlsZVRvU3RyaW5nIH0gZnJvbSBcIi4vc3R5bGUuanNcIjtcbmZ1bmN0aW9uIGlzRXZlbnRIYW5kbGVyKGtleSkge1xuICAgIC8vIHdlIGNoZWNrIGlmIHRoZSAzcmQgY2hhcmFjdGVyIGlzIHVwcGVyY2FzZSB0byBhdm9pZCBtZXJnaW5nIG91ciBvd25cbiAgICAvLyBjdXN0b20gY2FsbGJhY2tzIGxpa2UgYG9uVmFsdWVDaGFuZ2VgIGFuZCBzdHJpY3RseSBtZXJnZSBuYXRpdmUgZXZlbnQgaGFuZGxlcnNcbiAgICByZXR1cm4ga2V5Lmxlbmd0aCA+IDIgJiYga2V5LnN0YXJ0c1dpdGgoXCJvblwiKSAmJiBrZXlbMl0gPT09IGtleVsyXT8udG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIHByb3Agb2JqZWN0cywgbWVyZ2VzIHRoZW0gaW50byBhIHNpbmdsZSBvYmplY3QuXG4gKiAtIEF1dG9tYXRpY2FsbHkgY29tcG9zZXMgZXZlbnQgaGFuZGxlcnMgKGUuZy4gYG9uY2xpY2tgLCBgb25pbnB1dGAsIGV0Yy4pXG4gKiAtIENoYWlucyByZWd1bGFyIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIG5hbWUgc28gdGhleSBhcmUgY2FsbGVkIGluIG9yZGVyXG4gKiAtIE1lcmdlcyBjbGFzcyBzdHJpbmdzIHdpdGggYGNsc3hgXG4gKiAtIE1lcmdlcyBzdHlsZSBvYmplY3RzIGFuZCBjb252ZXJ0cyB0aGVtIHRvIHN0cmluZ3NcbiAqIC0gSGFuZGxlcyBhIGJ1ZyB3aXRoIFN2ZWx0ZSB3aGVyZSBzZXR0aW5nIHRoZSBgaGlkZGVuYCBhdHRyaWJ1dGUgdG8gYGZhbHNlYCBkb2Vzbid0IHJlbW92ZSBpdFxuICogLSBPdmVycmlkZXMgb3RoZXIgdmFsdWVzIHdpdGggdGhlIGxhc3Qgb25lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmFyZ3NbMF0gfTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBhcmdzW2ldO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgYSA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgY29uc3QgYiA9IHByb3BzW2tleV07XG4gICAgICAgICAgICBjb25zdCBhSXNGdW5jdGlvbiA9IHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBjb25zdCBiSXNGdW5jdGlvbiA9IHR5cGVvZiBiID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICAvLyBjb21wb3NlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICBpZiAoYUlzRnVuY3Rpb24gJiYgdHlwZW9mIGJJc0Z1bmN0aW9uICYmIGlzRXZlbnRIYW5kbGVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbWVyZ2luZyBvZiBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IGFIYW5kbGVyID0gYTtcbiAgICAgICAgICAgICAgICBjb25zdCBiSGFuZGxlciA9IGI7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21wb3NlSGFuZGxlcnMoYUhhbmRsZXIsIGJIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFJc0Z1bmN0aW9uICYmIGJJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhaW4gbm9uLWV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBleGVjdXRlQ2FsbGJhY2tzKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNsYXNzXCIgJiYgdHlwZW9mIGEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbWVyZ2luZyBjbGFzcyBzdHJpbmdzXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbHN4KGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhSXNPYmplY3QgPSB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBiSXNPYmplY3QgPSB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBhSXNTdHJpbmcgPSB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBiSXNTdHJpbmcgPSB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBpZiAoYUlzT2JqZWN0ICYmIGJJc09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGFyZSBzdHlsZSBvYmplY3RzLCBtZXJnZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFJc09iamVjdCAmJiBiSXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBpcyBzdHlsZSBvYmplY3QsIGIgaXMgc3RyaW5nLCBjb252ZXJ0IGIgdG8gc3R5bGUgb2JqZWN0IGFuZCBtZXJnZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRTdHlsZSA9IGNzc1RvU3R5bGVPYmooYik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0geyAuLi5hLCAuLi5wYXJzZWRTdHlsZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhSXNTdHJpbmcgJiYgYklzT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgaXMgc3RyaW5nLCBiIGlzIHN0eWxlIG9iamVjdCwgY29udmVydCBhIHRvIHN0eWxlIG9iamVjdCBhbmQgbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU3R5bGUgPSBjc3NUb1N0eWxlT2JqKGEpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHsgLi4ucGFyc2VkU3R5bGUsIC4uLmIgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYUlzU3RyaW5nICYmIGJJc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGFyZSBzdHJpbmdzLCBjb252ZXJ0IGJvdGggdG8gb2JqZWN0cyBhbmQgbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU3R5bGVBID0gY3NzVG9TdHlsZU9iaihhKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU3R5bGVCID0gY3NzVG9TdHlsZU9iaihiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB7IC4uLnBhcnNlZFN0eWxlQSwgLi4ucGFyc2VkU3R5bGVCIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFJc09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJJc09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgb3RoZXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBiICE9PSB1bmRlZmluZWQgPyBiIDogYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IHN0eWxlIG9iamVjdCB0byBzdHJpbmdcbiAgICBpZiAodHlwZW9mIHJlc3VsdC5zdHlsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXN1bHQuc3R5bGUgPSBzdHlsZVRvU3RyaW5nKHJlc3VsdC5zdHlsZSkucmVwbGFjZUFsbChcIlxcblwiLCBcIiBcIik7XG4gICAgfVxuICAgIC8vIGhhbmRsZSB3ZWlyZCBzdmVsdGUgYnVnIHdoZXJlIGBoaWRkZW5gIGlzIG5vdCByZW1vdmVkIHdoZW4gc2V0IHRvIGBmYWxzZWBcbiAgICBpZiAocmVzdWx0LmhpZGRlbiAhPT0gdHJ1ZSkge1xuICAgICAgICByZXN1bHQuaGlkZGVuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgd2VpcmQgc3ZlbHRlIGJ1ZyB3aGVyZSBgZGlzYWJsZWRgIGlzIG5vdCByZW1vdmVkIHdoZW4gc2V0IHRvIGBmYWxzZWBcbiAgICBpZiAocmVzdWx0LmRpc2FibGVkICE9PSB0cnVlKSB7XG4gICAgICAgIHJlc3VsdC5kaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhhdCBJRCBhbmQgc2V0cyBpdCB0byB0aGUgYm94ZWQgbm9kZS5cbiAqIFJlYWN0aXZlIHVzaW5nIGAkZWZmZWN0YCB0byBlbnN1cmUgd2hlbiB0aGUgSUQgb3IgY29uZGl0aW9uIGNoYW5nZXMsXG4gKiBhbiB1cGRhdGUgaXMgdHJpZ2dlcmVkIGFuZCBuZXcgbm9kZSBpcyBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkJ5SWQoeyBpZCwgcmVmLCBkZXBzID0gKCkgPT4gdHJ1ZSwgb25SZWZDaGFuZ2UgPSAoKSA9PiB7IH0sIGdldFJvb3ROb2RlID0gKCkgPT4gKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdW5kZWZpbmVkKSB9KSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gJGRlcml2ZWQuYnkoKCkgPT4gZGVwcygpKTtcbiAgICBjb25zdCByb290Tm9kZSA9ICRkZXJpdmVkLmJ5KCgpID0+IGdldFJvb3ROb2RlKCkpO1xuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyByZS1ydW4gd2hlbiB0aGUgSUQgY2hhbmdlcy5cbiAgICAgICAgaWQuY3VycmVudDtcbiAgICAgICAgLy8gcmUtcnVuIHdoZW4gdGhlIGRlcHMgY2hhbmdlcy5cbiAgICAgICAgZGVwZW5kZW5jaWVzO1xuICAgICAgICByb290Tm9kZTtcbiAgICAgICAgcmV0dXJuIHVudHJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHJvb3ROb2RlPy5nZXRFbGVtZW50QnlJZChpZC5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZWZDaGFuZ2UocmVmLmN1cnJlbnQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIG9uUmVmQ2hhbmdlKG51bGwpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveUVmZmVjdChmbikge1xuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbiIsIi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYSBjYWxsYmFjayBhZnRlciBhIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJTbGVlcChtcywgY2IpIHtcbiAgICBzZXRUaW1lb3V0KGNiLCBtcyk7XG59XG4iLCJpbXBvcnQgeyB0aWNrIH0gZnJvbSBcInN2ZWx0ZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyVGljayhmbikge1xuICAgIHRpY2soKS50aGVuKGZuKTtcbn1cbiIsImltcG9ydCB7IHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBhIHJlYWN0aXZlIGBjdXJyZW50YCBwcm9wZXJ0eVxuICpcbiAqIEFjY2VwdHMgYW4gaW5pdGlhbCB2YWx1ZSwgYW5kIGFuIG9wdGlvbmFsIGBzdGFydGAgZnVuY3Rpb24sIHdoaWNoIGhhcyBhIGBzZXRgIGZ1bmN0aW9uIGFzIGl0cyBmaXJzdCBhcmd1bWVudCxcbiAqIHdoaWNoIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgYGN1cnJlbnRgIHByb3BlcnR5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8c2NyaXB0PlxuICogY29uc3Qgbm93ID0gbmV3IFJlYWRhYmxlKG5ldyBEYXRlKCksIChzZXQpID0+IHtcbiAqIFx0Y29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiBzZXQobmV3IERhdGUoKSksIDEwMDApO1xuICogXHRyZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gKiB9KTtcbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxwPntub3cuY3VycmVudC50b0xvY2FsZVRpbWVTdHJpbmcoKX08L3A+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3J1bmVkLmRldi9kb2NzL3V0aWxpdGllcy9yZWFkYWJsZX1cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZSB7XG4gICAgI2N1cnJlbnQgPSAkc3RhdGUoKTtcbiAgICAjc3RhcnQ7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlLCBzdGFydCkge1xuICAgICAgICB0aGlzLiNjdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB0aGlzLiNzdGFydCA9IHN0YXJ0O1xuICAgIH1cbiAgICAjc3Vic2NyaWJlcnMgPSAwO1xuICAgICNzdG9wID0gbnVsbDtcbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgaWYgKCRlZmZlY3QudHJhY2tpbmcoKSkge1xuICAgICAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc3Vic2NyaWJlcnMrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jc3Vic2NyaWJlcnMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3Vic2NyaWJlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdWJzY3JpYmVycy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI3N1YnNjcmliZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuI3N1YnNjcmliZXJzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNzdWJzY3JpYmUoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4jdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jY3VycmVudDtcbiAgICB9XG4gICAgI3N1YnNjcmliZShpbkVmZmVjdCkge1xuICAgICAgICB0aGlzLiNzdG9wID1cbiAgICAgICAgICAgIHRoaXMuI3N0YXJ0KCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2N1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sIGluRWZmZWN0KSA/PyBudWxsO1xuICAgIH1cbiAgICAjdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdG9wID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiNzdG9wKCk7XG4gICAgICAgIHRoaXMuI3N0b3AgPSBudWxsO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcIi4uL1JlYWRhYmxlL3JlYWRhYmxlLnN2ZWx0ZS5qc1wiO1xuaW1wb3J0IHsgYnJvd3NlciB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC91dGlscy9icm93c2VyLmpzXCI7XG4vKipcbiAqIEFuIG9iamVjdCBob2xkaW5nIGEgcmVhY3RpdmUgdmFsdWUgdGhhdCBpcyBlcXVhbCB0byBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAuXG4gKiBJdCBhdXRvbWF0aWNhbGx5IGxpc3RlbnMgZm9yIGNoYW5nZXMsIGtlZXBpbmcgdGhlIHJlZmVyZW5jZSB1cCB0byBkYXRlLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnVuZWQuZGV2L2RvY3MvdXRpbGl0aWVzL2FjdGl2ZS1lbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgYWN0aXZlRWxlbWVudCA9IG5ldyBSZWFkYWJsZShudWxsLCAoc2V0LCBpbnNpZGVFZmZlY3QpID0+IHtcbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghYnJvd3NlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgICBpZiAoIWluc2lkZUVmZmVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHVwZGF0ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHVwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdXBkYXRlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHVwZGF0ZSk7XG4gICAgfTtcbn0pO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gXCIuL2lzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0KHZhbHVlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iLCJpbXBvcnQgeyBnZXQgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvdXRpbHMvZ2V0LmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSByZWFjdGl2ZSB2YWx1ZSBob2xkaW5nIHRoZSBzaXplIG9mIGBub2RlYC5cbiAqXG4gKiBBY2NlcHRzIGFuIGBvcHRpb25zYCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAtIGBpbml0aWFsU2l6ZWA6IFRoZSBpbml0aWFsIHNpemUgb2YgdGhlIGVsZW1lbnQuIERlZmF1bHRzIHRvIGB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfWAuXG4gKiAtIGBib3hgOiBUaGUgYm94IG1vZGVsIHRvIHVzZS4gQ2FuIGJlIGVpdGhlciBgXCJjb250ZW50LWJveFwiYCBvciBgXCJib3JkZXItYm94XCJgLiBEZWZhdWx0cyB0byBgXCJib3JkZXItYm94XCJgLlxuICpcbiAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9ydW5lZC5kZXYvZG9jcy91dGlsaXRpZXMvZWxlbWVudC1zaXplfVxuICovXG5leHBvcnQgY2xhc3MgRWxlbWVudFNpemUge1xuICAgICNzaXplID0gJHN0YXRlKHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICB9KTtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvcHRpb25zID0geyBib3g6IFwiYm9yZGVyLWJveFwiIH0pIHtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLmluaXRpYWxTaXplPy53aWR0aCA/PyAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmluaXRpYWxTaXplPy5oZWlnaHQgPz8gMCxcbiAgICAgICAgfTtcbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlJCA9IGdldChub2RlKTtcbiAgICAgICAgICAgIGlmICghbm9kZSQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94U2l6ZSA9IG9wdGlvbnMuYm94ID09PSBcImNvbnRlbnQtYm94XCIgPyBlbnRyeS5jb250ZW50Qm94U2l6ZSA6IGVudHJ5LmJvcmRlckJveFNpemU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveFNpemVBcnIgPSBBcnJheS5pc0FycmF5KGJveFNpemUpID8gYm94U2l6ZSA6IFtib3hTaXplXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc2l6ZS53aWR0aCA9IGJveFNpemVBcnIucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5pbmxpbmVTaXplKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NpemUuaGVpZ2h0ID0gYm94U2l6ZUFyci5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmJsb2NrU2l6ZSksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlJCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzaXplLndpZHRoO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZS5oZWlnaHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgdW50cmFjayB9IGZyb20gXCJzdmVsdGVcIjtcbmZ1bmN0aW9uIHJ1bkVmZmVjdChmbHVzaCwgZWZmZWN0KSB7XG4gICAgc3dpdGNoIChmbHVzaCkge1xuICAgICAgICBjYXNlIFwicG9zdFwiOlxuICAgICAgICAgICAgJGVmZmVjdChlZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgICAgICRlZmZlY3QucHJlKGVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBydW5XYXRjaGVyKHNvdXJjZXMsIGZsdXNoLCBlZmZlY3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGF6eSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIC8vIFJ1biB0aGUgZWZmZWN0IGltbWVkaWF0ZWx5IGlmIGBsYXp5YCBpcyBgZmFsc2VgLlxuICAgIGxldCBhY3RpdmUgPSAhbGF6eTtcbiAgICAvLyBPbiB0aGUgZmlyc3QgcnVuLCBpZiB0aGUgZGVwZW5kZW5jaWVzIGFyZSBhbiBhcnJheSwgcGFzcyBhbiBlbXB0eSBhcnJheVxuICAgIC8vIHRvIHRoZSBwcmV2aW91cyB2YWx1ZSBpbnN0ZWFkIG9mIGB1bmRlZmluZWRgIHRvIGFsbG93IGRlc3RydWN0dXJpbmcuXG4gICAgLy9cbiAgICAvLyB3YXRjaCgoKSA9PiBbYSwgYl0sIChbYSwgYl0sIFtwcmV2QSwgcHJldkJdKSA9PiB7IC4uLiB9KTtcbiAgICBsZXQgcHJldmlvdXNWYWx1ZXMgPSBBcnJheS5pc0FycmF5KHNvdXJjZXMpXG4gICAgICAgID8gW11cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcnVuRWZmZWN0KGZsdXNoLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoc291cmNlcykgPyBzb3VyY2VzLm1hcCgoc291cmNlKSA9PiBzb3VyY2UoKSkgOiBzb3VyY2VzKCk7XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xlYW51cCA9IHVudHJhY2soKCkgPT4gZWZmZWN0KHZhbHVlcywgcHJldmlvdXNWYWx1ZXMpKTtcbiAgICAgICAgcHJldmlvdXNWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuV2F0Y2hlck9uY2Uoc291cmNlcywgZmx1c2gsIGVmZmVjdCkge1xuICAgIGNvbnN0IGNsZWFudXBSb290ID0gJGVmZmVjdC5yb290KCgpID0+IHtcbiAgICAgICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICAgICAgcnVuV2F0Y2hlcihzb3VyY2VzLCBmbHVzaCwgKHZhbHVlcywgcHJldmlvdXNWYWx1ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cFJvb3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSBgbGF6eWAgaXMgYHRydWVgLCBgcHJldmlvdXNWYWx1ZXNgIGlzIGFsd2F5cyBkZWZpbmVkLlxuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IGVmZmVjdCh2YWx1ZXMsIHByZXZpb3VzVmFsdWVzKTtcbiAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgICAgIH0sIFxuICAgICAgICAvLyBSdW5uaW5nIHRoZSBlZmZlY3QgaW1tZWRpYXRlbHkganVzdCBvbmNlIG1ha2VzIG5vIHNlbnNlIGF0IGFsbC5cbiAgICAgICAgLy8gVGhhdCdzIGp1c3QgYG9uTW91bnRgIHdpdGggZXh0cmEgc3RlcHMuXG4gICAgICAgIHsgbGF6eTogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNsZWFudXBSb290O1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoKHNvdXJjZXMsIGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJ1bldhdGNoZXIoc291cmNlcywgXCJwb3N0XCIsIGVmZmVjdCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFByZShzb3VyY2VzLCBlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICBydW5XYXRjaGVyKHNvdXJjZXMsIFwicHJlXCIsIGVmZmVjdCwgb3B0aW9ucyk7XG59XG53YXRjaC5wcmUgPSB3YXRjaFByZTtcbmV4cG9ydCBmdW5jdGlvbiB3YXRjaE9uY2Uoc291cmNlLCBlZmZlY3QpIHtcbiAgICBydW5XYXRjaGVyT25jZShzb3VyY2UsIFwicG9zdFwiLCBlZmZlY3QpO1xufVxuZnVuY3Rpb24gd2F0Y2hPbmNlUHJlKHNvdXJjZSwgZWZmZWN0KSB7XG4gICAgcnVuV2F0Y2hlck9uY2Uoc291cmNlLCBcInByZVwiLCBlZmZlY3QpO1xufVxud2F0Y2hPbmNlLnByZSA9IHdhdGNoT25jZVByZTtcbiIsIi8qKlxuICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGEgZ2V0dGVyLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnVuZWQuZGV2L2RvY3MvdXRpbGl0aWVzL3ByZXZpb3VzfVxuICovXG5leHBvcnQgY2xhc3MgUHJldmlvdXMge1xuICAgICNwcmV2aW91cyA9ICRzdGF0ZSgpO1xuICAgICNjdXJyO1xuICAgIGNvbnN0cnVjdG9yKGdldHRlcikge1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3ByZXZpb3VzID0gdGhpcy4jY3VycjtcbiAgICAgICAgICAgIHRoaXMuI2N1cnIgPSBnZXR0ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJldmlvdXM7XG4gICAgfVxufVxuIiwiLyoqIEBpbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5cbi8qKiBAcGFyYW0ge1NvdXJjZTxudW1iZXI+fSBzb3VyY2UgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnQoc291cmNlKSB7XG5cdHNldChzb3VyY2UsIHNvdXJjZS52ICsgMSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0RGF0YU9wZW5DbG9zZWQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhQ2hlY2tlZChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gXCJjaGVja2VkXCIgOiBcInVuY2hlY2tlZFwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFyaWFEaXNhYmxlZChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJpYVJlYWRvbmx5KGNvbmRpdGlvbikge1xuICAgIHJldHVybiBjb25kaXRpb24gPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmlhRXhwYW5kZWQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFEaXNhYmxlZChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gXCJcIiA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmlhUmVxdWlyZWQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFyaWFTZWxlY3RlZChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJpYUNoZWNrZWQoY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZSkge1xuICAgIGlmIChpbmRldGVybWluYXRlKSB7XG4gICAgICAgIHJldHVybiBcIm1peGVkXCI7XG4gICAgfVxuICAgIHJldHVybiBjaGVja2VkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJpYU9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFyaWFIaWRkZW4oY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFyaWFJbnZhbGlkKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBjb25kaXRpb24gPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhT3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICByZXR1cm4gb3JpZW50YXRpb247XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YUludmFsaWQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IFwiXCIgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVJlcXVpcmVkKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBjb25kaXRpb24gPyBcIlwiIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFSZWFkb25seShjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gXCJcIiA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhU2VsZWN0ZWQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IFwiXCIgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVVuYXZhaWxhYmxlKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBjb25kaXRpb24gPyBcIlwiIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEhpZGRlbihjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNhYmxlZChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmlhUHJlc3NlZChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVxdWlyZWQoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IHRydWUgOiB1bmRlZmluZWQ7XG59XG4iLCJleHBvcnQgY29uc3QgQUxUID0gXCJBbHRcIjtcbmV4cG9ydCBjb25zdCBBUlJPV19ET1dOID0gXCJBcnJvd0Rvd25cIjtcbmV4cG9ydCBjb25zdCBBUlJPV19MRUZUID0gXCJBcnJvd0xlZnRcIjtcbmV4cG9ydCBjb25zdCBBUlJPV19SSUdIVCA9IFwiQXJyb3dSaWdodFwiO1xuZXhwb3J0IGNvbnN0IEFSUk9XX1VQID0gXCJBcnJvd1VwXCI7XG5leHBvcnQgY29uc3QgQkFDS1NQQUNFID0gXCJCYWNrc3BhY2VcIjtcbmV4cG9ydCBjb25zdCBDQVBTX0xPQ0sgPSBcIkNhcHNMb2NrXCI7XG5leHBvcnQgY29uc3QgQ09OVFJPTCA9IFwiQ29udHJvbFwiO1xuZXhwb3J0IGNvbnN0IERFTEVURSA9IFwiRGVsZXRlXCI7XG5leHBvcnQgY29uc3QgRU5EID0gXCJFbmRcIjtcbmV4cG9ydCBjb25zdCBFTlRFUiA9IFwiRW50ZXJcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEUgPSBcIkVzY2FwZVwiO1xuZXhwb3J0IGNvbnN0IEYxID0gXCJGMVwiO1xuZXhwb3J0IGNvbnN0IEYxMCA9IFwiRjEwXCI7XG5leHBvcnQgY29uc3QgRjExID0gXCJGMTFcIjtcbmV4cG9ydCBjb25zdCBGMTIgPSBcIkYxMlwiO1xuZXhwb3J0IGNvbnN0IEYyID0gXCJGMlwiO1xuZXhwb3J0IGNvbnN0IEYzID0gXCJGM1wiO1xuZXhwb3J0IGNvbnN0IEY0ID0gXCJGNFwiO1xuZXhwb3J0IGNvbnN0IEY1ID0gXCJGNVwiO1xuZXhwb3J0IGNvbnN0IEY2ID0gXCJGNlwiO1xuZXhwb3J0IGNvbnN0IEY3ID0gXCJGN1wiO1xuZXhwb3J0IGNvbnN0IEY4ID0gXCJGOFwiO1xuZXhwb3J0IGNvbnN0IEY5ID0gXCJGOVwiO1xuZXhwb3J0IGNvbnN0IEhPTUUgPSBcIkhvbWVcIjtcbmV4cG9ydCBjb25zdCBNRVRBID0gXCJNZXRhXCI7XG5leHBvcnQgY29uc3QgUEFHRV9ET1dOID0gXCJQYWdlRG93blwiO1xuZXhwb3J0IGNvbnN0IFBBR0VfVVAgPSBcIlBhZ2VVcFwiO1xuZXhwb3J0IGNvbnN0IFNISUZUID0gXCJTaGlmdFwiO1xuZXhwb3J0IGNvbnN0IFNQQUNFID0gXCIgXCI7XG5leHBvcnQgY29uc3QgVEFCID0gXCJUYWJcIjtcbmV4cG9ydCBjb25zdCBDVFJMID0gXCJDb250cm9sXCI7XG5leHBvcnQgY29uc3QgQVNURVJJU0sgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBhID0gXCJhXCI7XG5leHBvcnQgY29uc3QgUCA9IFwiUFwiO1xuZXhwb3J0IGNvbnN0IEEgPSBcIkFcIjtcbmV4cG9ydCBjb25zdCBwID0gXCJwXCI7XG5leHBvcnQgY29uc3QgbiA9IFwiblwiO1xuZXhwb3J0IGNvbnN0IGogPSBcImpcIjtcbmV4cG9ydCBjb25zdCBrID0gXCJrXCI7XG4iLCJleHBvcnQgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzSU9TID0gZ2V0SXNJT1MoKTtcbmZ1bmN0aW9uIGdldElzSU9TKCkge1xuICAgIHJldHVybiAoaXNCcm93c2VyICYmXG4gICAgICAgIHdpbmRvdz8ubmF2aWdhdG9yPy51c2VyQWdlbnQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby11bnVzZWQtY2FwdHVyaW5nLWdyb3VwXG4gICAgICAgICgvaVAoYWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGlQYWQgUHJvIEdlbjMgZG9lcyBub3QgaWRlbnRpZnkgaXRzZWxmIGFzIGlQYWQsIGJ1dCBhcyBNYWNpbnRvc2guXG4gICAgICAgICAgICAod2luZG93Py5uYXZpZ2F0b3I/Lm1heFRvdWNoUG9pbnRzID4gMiAmJlxuICAgICAgICAgICAgICAgIC9pUGFkfE1hY2ludG9zaC8udGVzdCh3aW5kb3c/Lm5hdmlnYXRvci51c2VyQWdlbnQpKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRPclNWR0VsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlclN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKE51bWJlcih2YWx1ZSkpICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUb3VjaChlKSB7XG4gICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZvY3VzVmlzaWJsZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTm90TnVsbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIGEgdmFsaWQgYEhUTUxJbnB1dEVsZW1lbnRgIHdpdGhcbiAqIGEgYHNlbGVjdGAgbWV0aG9kIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2VsZWN0YWJsZUlucHV0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgXCJzZWxlY3RcIiBpbiBlbGVtZW50O1xufVxuLyoqXG4gKiBHaXZlbiBhIG5vZGUsIGRldGVybWluZSBpZiBpdCBpcyBoaWRkZW4gYnkgd2Fsa2luZyB1cCB0aGVcbiAqIERPTSB0cmVlIHVudGlsIHdlIGhpdCB0aGUgYHN0b3BBdGAgbm9kZSAoZXhjbHVzaXZlKSwgaWYgcHJvdmlkZWQpXG4gKiBvdGhlcndpc2Ugd2Ugc3RvcCBhdCB0aGUgZG9jdW1lbnQgcm9vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEhpZGRlbihub2RlLCBzdG9wQXQpIHtcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAvLyB3ZSBzdG9wIGF0IGB1cFRvYCAoZXhjbHVkaW5nIGl0KVxuICAgICAgICBpZiAoc3RvcEF0ICE9PSB1bmRlZmluZWQgJiYgbm9kZSA9PT0gc3RvcEF0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5ID09PSBcIm5vbmVcIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBnZXRDb250ZXh0IGFzIGdldFN2ZWx0ZUNvbnRleHQsIGhhc0NvbnRleHQsIHNldENvbnRleHQgYXMgc2V0U3ZlbHRlQ29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzZXRTdmVsdGVDb250ZXh0KGtleSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgdHJ1ZUtleSA9IHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBrZXk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5LmRlc2NyaXB0aW9uIDoga2V5O1xuICAgIGlmICghaGFzQ29udGV4dCh0cnVlS2V5KSkge1xuICAgICAgICBpZiAoZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGNvbnRleHQgZGVwZW5kZW5jeTogJHtkZXNjcmlwdGlvbn0gYW5kIG5vIGZhbGxiYWNrIHdhcyBwcm92aWRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdmVsdGVDb250ZXh0KGtleSk7XG59XG5mdW5jdGlvbiBnZXRTeW1ib2xEZXNjcmlwdGlvbihwcm92aWRlckNvbXBvbmVudE5hbWUsIGNvbnRleHROYW1lKSB7XG4gICAgaWYgKGNvbnRleHROYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBjb250ZXh0TmFtZTtcbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyQ29tcG9uZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBjb250ZXh0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBgJHtwcm92aWRlckNvbXBvbmVudE5hbWV9Q29udGV4dGA7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZXJDb21wb25lbnROYW1lKSAmJiBjb250ZXh0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBgJHtwcm92aWRlckNvbXBvbmVudE5hbWVbMF19Q29udGV4dGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY29udGV4dE5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0TmFtZTtcbiAgICAgICAgcmV0dXJuIGAke3Byb3ZpZGVyQ29tcG9uZW50TmFtZX1Db250ZXh0YDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwcm92aWRlckNvbXBvbmVudE5hbWUsIGNvbnRleHROYW1lLCB1c2VTeW1ib2wgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3ltYm9sRGVzY3JpcHRpb24gPSBnZXRTeW1ib2xEZXNjcmlwdGlvbihwcm92aWRlckNvbXBvbmVudE5hbWUsIGNvbnRleHROYW1lKTtcbiAgICBjb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKGBiaXRzLXVpLiR7c3ltYm9sRGVzY3JpcHRpb259YCk7XG4gICAgY29uc3Qga2V5ID0gc3ltYm9sRGVzY3JpcHRpb247XG4gICAgZnVuY3Rpb24gZ2V0Q3R4KGZhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBnZXRDb250ZXh0KHVzZVN5bWJvbCA/IHN5bWJvbCA6IGtleSwgZmFsbGJhY2spO1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRleHQgXFxgJHtzeW1ib2xEZXNjcmlwdGlvbn1cXGAgbm90IGZvdW5kLiBDb21wb25lbnQgbXVzdCBiZSB1c2VkIHdpdGhpbiAke0FycmF5LmlzQXJyYXkocHJvdmlkZXJDb21wb25lbnROYW1lKVxuICAgICAgICAgICAgICAgID8gYG9uZSBvZiB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICR7cHJvdmlkZXJDb21wb25lbnROYW1lLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgICAgICAgICAgOiBgXFxgJHtwcm92aWRlckNvbXBvbmVudE5hbWV9XFxgYH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdHMvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDdHgodmFsdWUpIHtcbiAgICAgICAgaWYgKHVzZVN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldENvbnRleHQoc3ltYm9sLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0Q29udGV4dChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3NldEN0eCwgZ2V0Q3R4XTtcbn1cbiIsImltcG9ydCB7IGFmdGVyVGljaywgdXNlUmVmQnlJZCB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcbmltcG9ydCB7IHdhdGNoIH0gZnJvbSBcInJ1bmVkXCI7XG5pbXBvcnQgeyBnZXRBcmlhRGlzYWJsZWQsIGdldEFyaWFFeHBhbmRlZCwgZ2V0RGF0YURpc2FibGVkLCBnZXREYXRhT3BlbkNsb3NlZCwgZ2V0RGF0YU9yaWVudGF0aW9uLCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9hdHRycy5qc1wiO1xuaW1wb3J0IHsga2JkIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2tiZC5qc1wiO1xuaW1wb3J0IHsgdXNlUm92aW5nRm9jdXMsIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL3VzZS1yb3ZpbmctZm9jdXMuc3ZlbHRlLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2NyZWF0ZS1jb250ZXh0LmpzXCI7XG5jb25zdCBBQ0NPUkRJT05fUk9PVF9BVFRSID0gXCJkYXRhLWFjY29yZGlvbi1yb290XCI7XG5jb25zdCBBQ0NPUkRJT05fVFJJR0dFUl9BVFRSID0gXCJkYXRhLWFjY29yZGlvbi10cmlnZ2VyXCI7XG5jb25zdCBBQ0NPUkRJT05fQ09OVEVOVF9BVFRSID0gXCJkYXRhLWFjY29yZGlvbi1jb250ZW50XCI7XG5jb25zdCBBQ0NPUkRJT05fSVRFTV9BVFRSID0gXCJkYXRhLWFjY29yZGlvbi1pdGVtXCI7XG5jb25zdCBBQ0NPUkRJT05fSEVBREVSX0FUVFIgPSBcImRhdGEtYWNjb3JkaW9uLWhlYWRlclwiO1xuY2xhc3MgQWNjb3JkaW9uQmFzZVN0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICBkaXNhYmxlZDtcbiAgICAjbG9vcDtcbiAgICBvcmllbnRhdGlvbjtcbiAgICByb3ZpbmdGb2N1c0dyb3VwO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMuI2lkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiBwcm9wcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uO1xuICAgICAgICB0aGlzLiNsb29wID0gcHJvcHMubG9vcDtcbiAgICAgICAgdGhpcy5yb3ZpbmdGb2N1c0dyb3VwID0gdXNlUm92aW5nRm9jdXMoe1xuICAgICAgICAgICAgcm9vdE5vZGVJZDogdGhpcy4jaWQsXG4gICAgICAgICAgICBjYW5kaWRhdGVBdHRyOiBBQ0NPUkRJT05fVFJJR0dFUl9BVFRSLFxuICAgICAgICAgICAgbG9vcDogdGhpcy4jbG9vcCxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiB0aGlzLm9yaWVudGF0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgXCJkYXRhLW9yaWVudGF0aW9uXCI6IGdldERhdGFPcmllbnRhdGlvbih0aGlzLm9yaWVudGF0aW9uLmN1cnJlbnQpLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMuZGlzYWJsZWQuY3VycmVudCksXG4gICAgICAgIFtBQ0NPUkRJT05fUk9PVF9BVFRSXTogXCJcIixcbiAgICB9KSk7XG59XG5leHBvcnQgY2xhc3MgQWNjb3JkaW9uU2luZ2xlU3RhdGUgZXh0ZW5kcyBBY2NvcmRpb25CYXNlU3RhdGUge1xuICAgICN2YWx1ZTtcbiAgICBpc011bHRpID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVzSXRlbSA9IHRoaXMuaW5jbHVkZXNJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlSXRlbSA9IHRoaXMudG9nZ2xlSXRlbS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBpbmNsdWRlc0l0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdmFsdWUuY3VycmVudCA9PT0gaXRlbTtcbiAgICB9XG4gICAgdG9nZ2xlSXRlbShpdGVtKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlLmN1cnJlbnQgPSB0aGlzLmluY2x1ZGVzSXRlbShpdGVtKSA/IFwiXCIgOiBpdGVtO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25NdWx0aVN0YXRlIGV4dGVuZHMgQWNjb3JkaW9uQmFzZVN0YXRlIHtcbiAgICAjdmFsdWU7XG4gICAgaXNNdWx0aSA9IHRydWU7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVzSXRlbSA9IHRoaXMuaW5jbHVkZXNJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlSXRlbSA9IHRoaXMudG9nZ2xlSXRlbS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBpbmNsdWRlc0l0ZW0oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdmFsdWUuY3VycmVudC5pbmNsdWRlcyhpdGVtKTtcbiAgICB9XG4gICAgdG9nZ2xlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVzSXRlbShpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy4jdmFsdWUuY3VycmVudCA9IHRoaXMuI3ZhbHVlLmN1cnJlbnQuZmlsdGVyKCh2KSA9PiB2ICE9PSBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhbHVlLmN1cnJlbnQgPSBbLi4udGhpcy4jdmFsdWUuY3VycmVudCwgaXRlbV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWNjb3JkaW9uSXRlbVN0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICB2YWx1ZTtcbiAgICBkaXNhYmxlZDtcbiAgICByb290O1xuICAgIGlzQWN0aXZlID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmluY2x1ZGVzSXRlbSh0aGlzLnZhbHVlLmN1cnJlbnQpKTtcbiAgICBpc0Rpc2FibGVkID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5kaXNhYmxlZC5jdXJyZW50IHx8IHRoaXMucm9vdC5kaXNhYmxlZC5jdXJyZW50KTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgdGhpcy5yb290ID0gcHJvcHMucm9vdFN0YXRlO1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQodGhpcyk7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLmlzQWN0aXZlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIHRoaXMucm9vdC50b2dnbGVJdGVtKHRoaXMudmFsdWUuY3VycmVudCk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBnZXREYXRhT3BlbkNsb3NlZCh0aGlzLmlzQWN0aXZlKSxcbiAgICAgICAgXCJkYXRhLWRpc2FibGVkXCI6IGdldERhdGFEaXNhYmxlZCh0aGlzLmlzRGlzYWJsZWQpLFxuICAgICAgICBcImRhdGEtb3JpZW50YXRpb25cIjogZ2V0RGF0YU9yaWVudGF0aW9uKHRoaXMucm9vdC5vcmllbnRhdGlvbi5jdXJyZW50KSxcbiAgICAgICAgW0FDQ09SRElPTl9JVEVNX0FUVFJdOiBcIlwiLFxuICAgIH0pKTtcbn1cbmNsYXNzIEFjY29yZGlvblRyaWdnZXJTdGF0ZSB7XG4gICAgI3JlZjtcbiAgICAjZGlzYWJsZWQ7XG4gICAgI2lkO1xuICAgICNyb290O1xuICAgICNpdGVtU3RhdGU7XG4gICAgI2lzRGlzYWJsZWQgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLiNkaXNhYmxlZC5jdXJyZW50IHx8XG4gICAgICAgIHRoaXMuI2l0ZW1TdGF0ZS5kaXNhYmxlZC5jdXJyZW50IHx8XG4gICAgICAgIHRoaXMuI3Jvb3QuZGlzYWJsZWQuY3VycmVudCk7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGl0ZW1TdGF0ZSkge1xuICAgICAgICB0aGlzLiNkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLiNpdGVtU3RhdGUgPSBpdGVtU3RhdGU7XG4gICAgICAgIHRoaXMuI3Jvb3QgPSBpdGVtU3RhdGUucm9vdDtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLm9ua2V5ZG93biA9IHRoaXMub25rZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25jbGljayA9IHRoaXMub25jbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiBwcm9wcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25jbGljayhlKSB7XG4gICAgICAgIGlmICh0aGlzLiNpc0Rpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApXG4gICAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLiNpdGVtU3RhdGUudXBkYXRlVmFsdWUoKTtcbiAgICB9XG4gICAgb25rZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2lzRGlzYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlLmtleSA9PT0ga2JkLlNQQUNFIHx8IGUua2V5ID09PSBrYmQuRU5URVIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuI2l0ZW1TdGF0ZS51cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Jvb3Qucm92aW5nRm9jdXNHcm91cC5oYW5kbGVLZXlkb3duKHRoaXMuI3JlZi5jdXJyZW50LCBlKTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgZGlzYWJsZWQ6IHRoaXMuI2lzRGlzYWJsZWQsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBnZXRBcmlhRXhwYW5kZWQodGhpcy4jaXRlbVN0YXRlLmlzQWN0aXZlKSxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGdldEFyaWFEaXNhYmxlZCh0aGlzLiNpc0Rpc2FibGVkKSxcbiAgICAgICAgXCJkYXRhLWRpc2FibGVkXCI6IGdldERhdGFEaXNhYmxlZCh0aGlzLiNpc0Rpc2FibGVkKSxcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGdldERhdGFPcGVuQ2xvc2VkKHRoaXMuI2l0ZW1TdGF0ZS5pc0FjdGl2ZSksXG4gICAgICAgIFwiZGF0YS1vcmllbnRhdGlvblwiOiBnZXREYXRhT3JpZW50YXRpb24odGhpcy4jcm9vdC5vcmllbnRhdGlvbi5jdXJyZW50KSxcbiAgICAgICAgW0FDQ09SRElPTl9UUklHR0VSX0FUVFJdOiBcIlwiLFxuICAgICAgICB0YWJpbmRleDogMCxcbiAgICAgICAgLy9cbiAgICAgICAgb25jbGljazogdGhpcy5vbmNsaWNrLFxuICAgICAgICBvbmtleWRvd246IHRoaXMub25rZXlkb3duLFxuICAgIH0pKTtcbn1cbmNsYXNzIEFjY29yZGlvbkNvbnRlbnRTdGF0ZSB7XG4gICAgaXRlbTtcbiAgICAjcmVmO1xuICAgICNpZDtcbiAgICAjb3JpZ2luYWxTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgI2lzTW91bnRBbmltYXRpb25QcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAjd2lkdGggPSAkc3RhdGUoMCk7XG4gICAgI2hlaWdodCA9ICRzdGF0ZSgwKTtcbiAgICAjZm9yY2VNb3VudDtcbiAgICBwcmVzZW50ID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy4jZm9yY2VNb3VudC5jdXJyZW50IHx8IHRoaXMuaXRlbS5pc0FjdGl2ZSk7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy4jZm9yY2VNb3VudCA9IHByb3BzLmZvcmNlTW91bnQ7XG4gICAgICAgIHRoaXMuI2lzTW91bnRBbmltYXRpb25QcmV2ZW50ZWQgPSB0aGlzLml0ZW0uaXNBY3RpdmU7XG4gICAgICAgIHRoaXMuI2lkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMuI3JlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy4jaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMuI3JlZixcbiAgICAgICAgfSk7XG4gICAgICAgICRlZmZlY3QucHJlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaXNNb3VudEFuaW1hdGlvblByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJBRik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgd2F0Y2goWygpID0+IHRoaXMucHJlc2VudCwgKCkgPT4gdGhpcy4jcmVmLmN1cnJlbnRdLCAoW18sIG5vZGVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYWZ0ZXJUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuI3JlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGhpcy4jb3JpZ2luYWxTdHlsZXMgPSB0aGlzLiNvcmlnaW5hbFN0eWxlcyB8fCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogbm9kZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IG5vZGUuc3R5bGUuYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGJsb2NrIGFueSBhbmltYXRpb25zL3RyYW5zaXRpb25zIHNvIHRoZSBlbGVtZW50IHJlbmRlcnMgYXQgZnVsbCBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb25OYW1lID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy4jd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIC8vIHVuYmxvY2sgYW55IGFuaW1hdGlvbnMvdHJhbnNpdGlvbnMgdGhhdCB3ZXJlIG9yaWdpbmFsbHkgc2V0IGlmIG5vdCB0aGUgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuI2lzTW91bnRBbmltYXRpb25QcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhbmltYXRpb25OYW1lLCB0cmFuc2l0aW9uRHVyYXRpb24gfSA9IHRoaXMuI29yaWdpbmFsU3R5bGVzO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb25OYW1lID0gYW5pbWF0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNuaXBwZXRQcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIG9wZW46IHRoaXMuaXRlbS5pc0FjdGl2ZSxcbiAgICB9KSk7XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGdldERhdGFPcGVuQ2xvc2VkKHRoaXMuaXRlbS5pc0FjdGl2ZSksXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBnZXREYXRhRGlzYWJsZWQodGhpcy5pdGVtLmlzRGlzYWJsZWQpLFxuICAgICAgICBcImRhdGEtb3JpZW50YXRpb25cIjogZ2V0RGF0YU9yaWVudGF0aW9uKHRoaXMuaXRlbS5yb290Lm9yaWVudGF0aW9uLmN1cnJlbnQpLFxuICAgICAgICBbQUNDT1JESU9OX0NPTlRFTlRfQVRUUl06IFwiXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBcIi0tYml0cy1hY2NvcmRpb24tY29udGVudC1oZWlnaHRcIjogYCR7dGhpcy4jaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIFwiLS1iaXRzLWFjY29yZGlvbi1jb250ZW50LXdpZHRoXCI6IGAke3RoaXMuI3dpZHRofXB4YCxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5jbGFzcyBBY2NvcmRpb25IZWFkZXJTdGF0ZSB7XG4gICAgI2lkO1xuICAgICNyZWY7XG4gICAgI2xldmVsO1xuICAgICNpdGVtO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBpdGVtKSB7XG4gICAgICAgIHRoaXMuI2xldmVsID0gcHJvcHMubGV2ZWw7XG4gICAgICAgIHRoaXMuI2lkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMuI3JlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy4jaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMuI3JlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2l0ZW0gPSBpdGVtO1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLiNpZC5jdXJyZW50LFxuICAgICAgICByb2xlOiBcImhlYWRpbmdcIixcbiAgICAgICAgXCJhcmlhLWxldmVsXCI6IHRoaXMuI2xldmVsLmN1cnJlbnQsXG4gICAgICAgIFwiZGF0YS1oZWFkaW5nLWxldmVsXCI6IHRoaXMuI2xldmVsLmN1cnJlbnQsXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBnZXREYXRhT3BlbkNsb3NlZCh0aGlzLiNpdGVtLmlzQWN0aXZlKSxcbiAgICAgICAgXCJkYXRhLW9yaWVudGF0aW9uXCI6IGdldERhdGFPcmllbnRhdGlvbih0aGlzLiNpdGVtLnJvb3Qub3JpZW50YXRpb24uY3VycmVudCksXG4gICAgICAgIFtBQ0NPUkRJT05fSEVBREVSX0FUVFJdOiBcIlwiLFxuICAgIH0pKTtcbn1cbmNvbnN0IFtzZXRBY2NvcmRpb25Sb290Q29udGV4dCwgZ2V0QWNjb3JkaW9uUm9vdENvbnRleHRdID0gY3JlYXRlQ29udGV4dChcIkFjY29yZGlvbi5Sb290XCIpO1xuY29uc3QgW3NldEFjY29yZGlvbkl0ZW1Db250ZXh0LCBnZXRBY2NvcmRpb25JdGVtQ29udGV4dF0gPSBjcmVhdGVDb250ZXh0KFwiQWNjb3JkaW9uLkl0ZW1cIik7XG5leHBvcnQgZnVuY3Rpb24gdXNlQWNjb3JkaW9uUm9vdChwcm9wcykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gdHlwZSA9PT0gXCJzaW5nbGVcIlxuICAgICAgICA/IG5ldyBBY2NvcmRpb25TaW5nbGVTdGF0ZShyZXN0KVxuICAgICAgICA6IG5ldyBBY2NvcmRpb25NdWx0aVN0YXRlKHJlc3QpO1xuICAgIHJldHVybiBzZXRBY2NvcmRpb25Sb290Q29udGV4dChyb290U3RhdGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjY29yZGlvbkl0ZW0ocHJvcHMpIHtcbiAgICBjb25zdCByb290U3RhdGUgPSBnZXRBY2NvcmRpb25Sb290Q29udGV4dCgpO1xuICAgIHJldHVybiBzZXRBY2NvcmRpb25JdGVtQ29udGV4dChuZXcgQWNjb3JkaW9uSXRlbVN0YXRlKHsgLi4ucHJvcHMsIHJvb3RTdGF0ZSB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQWNjb3JkaW9uVHJpZ2dlcihwcm9wcykge1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRBY2NvcmRpb25JdGVtQ29udGV4dCgpO1xuICAgIHJldHVybiBuZXcgQWNjb3JkaW9uVHJpZ2dlclN0YXRlKHByb3BzLCBpdGVtKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY2NvcmRpb25Db250ZW50KHByb3BzKSB7XG4gICAgY29uc3QgaXRlbSA9IGdldEFjY29yZGlvbkl0ZW1Db250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBBY2NvcmRpb25Db250ZW50U3RhdGUocHJvcHMsIGl0ZW0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjY29yZGlvbkhlYWRlcihwcm9wcykge1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRBY2NvcmRpb25JdGVtQ29udGV4dCgpO1xuICAgIHJldHVybiBuZXcgQWNjb3JkaW9uSGVhZGVyU3RhdGUocHJvcHMsIGl0ZW0pO1xufVxuIiwiZ2xvYmFsVGhpcy5iaXRzSWRDb3VudGVyID8/PSB7IGN1cnJlbnQ6IDAgfTtcbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElEIGJhc2VkIG9uIGEgZ2xvYmFsIGNvdW50ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJZChwcmVmaXggPSBcImJpdHNcIikge1xuICAgIGdsb2JhbFRoaXMuYml0c0lkQ291bnRlci5jdXJyZW50Kys7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0tJHtnbG9iYWxUaGlzLmJpdHNJZENvdW50ZXIuY3VycmVudH1gO1xufVxuIiwiLyoqXG4gKiBBIG5vIG9wZXJhdGlvbiBmdW5jdGlvbiAoZG9lcyBub3RoaW5nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IEFjY29yZGlvbkl0ZW1Qcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VBY2NvcmRpb25JdGVtIH0gZnJvbSBcIi4uL2FjY29yZGlvbi5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0ZGlzYWJsZWQgPSBmYWxzZSxcblx0XHR2YWx1ZSA9IHVzZUlkKCksXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBBY2NvcmRpb25JdGVtUHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCBpdGVtU3RhdGUgPSB1c2VBY2NvcmRpb25JdGVtKHtcblx0XHR2YWx1ZTogYm94LndpdGgoKCkgPT4gdmFsdWUpLFxuXHRcdGRpc2FibGVkOiBib3gud2l0aCgoKSA9PiBkaXNhYmxlZCksXG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIGl0ZW1TdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgY2hpbGR9XG5cdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuezplbHNlfVxuXHQ8ZGl2IHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgQWNjb3JkaW9uSGVhZGVyUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlQWNjb3JkaW9uSGVhZGVyIH0gZnJvbSBcIi4uL2FjY29yZGlvbi5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0bGV2ZWwgPSAyLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogQWNjb3JkaW9uSGVhZGVyUHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCBoZWFkZXJTdGF0ZSA9IHVzZUFjY29yZGlvbkhlYWRlcih7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRsZXZlbDogYm94LndpdGgoKCkgPT4gbGV2ZWwpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgaGVhZGVyU3RhdGUucHJvcHMpKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcyB9KX1cbns6ZWxzZX1cblx0PGRpdiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IEFjY29yZGlvblRyaWdnZXJQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VBY2NvcmRpb25UcmlnZ2VyIH0gZnJvbSBcIi4uL2FjY29yZGlvbi5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRkaXNhYmxlZCA9IGZhbHNlLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IEFjY29yZGlvblRyaWdnZXJQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IHRyaWdnZXJTdGF0ZSA9IHVzZUFjY29yZGlvblRyaWdnZXIoe1xuXHRcdGRpc2FibGVkOiBib3gud2l0aCgoKSA9PiBkaXNhYmxlZCksXG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIHRyaWdnZXJTdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgY2hpbGR9XG5cdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuezplbHNlfVxuXHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC9idXR0b24+XG57L2lmfVxuIiwiaW1wb3J0IHsgYm94IH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuLyoqXG4gKiBUaGUgYHVzZVN0YXRlTWFjaGluZWAgZnVuY3Rpb24gaXMgYSBUeXBlU2NyaXB0IGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHN0YXRlIG1hY2hpbmUgYW5kIHJldHVybnMgdGhlXG4gKiBjdXJyZW50IHN0YXRlIGFuZCBhIGRpc3BhdGNoIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgc3RhdGUgYmFzZWQgb24gZXZlbnRzLlxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSAtIFRoZSBgaW5pdGlhbFN0YXRlYCBwYXJhbWV0ZXIgaXMgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHN0YXRlIG1hY2hpbmUuIEl0XG4gKiByZXByZXNlbnRzIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgc3RhdGUgbWFjaGluZSdzIHN0YXRlLlxuICogQHBhcmFtIG1hY2hpbmUgLSBUaGUgYG1hY2hpbmVgIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgc3RhdGUgbWFjaGluZS4gSXQgc2hvdWxkXG4gKiBoYXZlIGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBwb3NzaWJsZSBzdGF0ZXMgb2YgdGhlIG1hY2hpbmUsIGFuZCB0aGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzXG4gKiB0aGF0IHJlcHJlc2VudCB0aGUgcG9zc2libGUgZXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG5leHQgc3RhdGVzLlxuICogQHJldHVybnMgVGhlIGB1c2VTdGF0ZU1hY2hpbmVgIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6IGBzdGF0ZWAgYW5kXG4gKiBgZGlzcGF0Y2hgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGVNYWNoaW5lKGluaXRpYWxTdGF0ZSwgbWFjaGluZSkge1xuICAgIGNvbnN0IHN0YXRlID0gYm94KGluaXRpYWxTdGF0ZSk7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihldmVudCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICBzdGF0ZS52YWx1ZSBpcyBrZXlvZiBNXG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IG1hY2hpbmVbc3RhdGUuY3VycmVudF1bZXZlbnRdO1xuICAgICAgICByZXR1cm4gbmV4dFN0YXRlID8/IHN0YXRlLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnQgPSByZWR1Y2VyKGV2ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgYWZ0ZXJUaWNrIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuaW1wb3J0IHsgUHJldmlvdXMgfSBmcm9tIFwicnVuZWRcIjtcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZU1hY2hpbmUgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLXN0YXRlLW1hY2hpbmUuc3ZlbHRlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc2VuY2UocHJlc2VudCwgaWQpIHtcbiAgICBsZXQgc3R5bGVzID0gJHN0YXRlKHt9KTtcbiAgICBsZXQgcHJldkFuaW1hdGlvbk5hbWVTdGF0ZSA9ICRzdGF0ZShcIm5vbmVcIik7XG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0gcHJlc2VudC5jdXJyZW50ID8gXCJtb3VudGVkXCIgOiBcInVubW91bnRlZFwiO1xuICAgIGxldCBub2RlID0gJHN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHByZXZQcmVzZW50ID0gbmV3IFByZXZpb3VzKCgpID0+IHByZXNlbnQuY3VycmVudCk7XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFwcmVzZW50LmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFmdGVyVGljaygoKSA9PiB7XG4gICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQuY3VycmVudCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgc3RhdGUsIGRpc3BhdGNoIH0gPSB1c2VTdGF0ZU1hY2hpbmUoaW5pdGlhbFN0YXRlLCB7XG4gICAgICAgIG1vdW50ZWQ6IHtcbiAgICAgICAgICAgIFVOTU9VTlQ6IFwidW5tb3VudGVkXCIsXG4gICAgICAgICAgICBBTklNQVRJT05fT1VUOiBcInVubW91bnRTdXNwZW5kZWRcIixcbiAgICAgICAgfSxcbiAgICAgICAgdW5tb3VudFN1c3BlbmRlZDoge1xuICAgICAgICAgICAgTU9VTlQ6IFwibW91bnRlZFwiLFxuICAgICAgICAgICAgQU5JTUFUSU9OX0VORDogXCJ1bm1vdW50ZWRcIixcbiAgICAgICAgfSxcbiAgICAgICAgdW5tb3VudGVkOiB7XG4gICAgICAgICAgICBNT1VOVDogXCJtb3VudGVkXCIsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJQcmVzZW50ID0gcHJlc2VudC5jdXJyZW50O1xuICAgICAgICB1bnRyYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZC5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBoYXNQcmVzZW50Q2hhbmdlZCA9IGN1cnJQcmVzZW50ICE9PSBwcmV2UHJlc2VudC5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFoYXNQcmVzZW50Q2hhbmdlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwcmV2QW5pbWF0aW9uTmFtZSA9IHByZXZBbmltYXRpb25OYW1lU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjdXJyQW5pbWF0aW9uTmFtZSA9IGdldEFuaW1hdGlvbk5hbWUobm9kZSk7XG4gICAgICAgICAgICBpZiAoY3VyclByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChcIk1PVU5UXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyckFuaW1hdGlvbk5hbWUgPT09IFwibm9uZVwiIHx8IHN0eWxlcy5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGV4aXQgYW5pbWF0aW9uIG9yIHRoZSBlbGVtZW50IGlzIGhpZGRlbiwgYW5pbWF0aW9ucyB3b24ndCBydW5cbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSB1bm1vdW50IGluc3RhbnRseVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKFwiVU5NT1VOVFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZW4gYHByZXNlbnRgIGNoYW5nZXMgdG8gYGZhbHNlYCwgd2UgY2hlY2sgY2hhbmdlcyB0byBhbmltYXRpb24tbmFtZSB0b1xuICAgICAgICAgICAgICAgICAqIGRldGVybWluZSB3aGV0aGVyIGFuIGFuaW1hdGlvbiBoYXMgc3RhcnRlZC4gV2UgY2hvc2UgdGhpcyBhcHByb2FjaCAocmVhZGluZ1xuICAgICAgICAgICAgICAgICAqIGNvbXB1dGVkIHN0eWxlcykgYmVjYXVzZSB0aGVyZSBpcyBubyBgYW5pbWF0aW9ucnVuYCBldmVudCBhbmQgYGFuaW1hdGlvbnN0YXJ0YFxuICAgICAgICAgICAgICAgICAqIGZpcmVzIGFmdGVyIGBhbmltYXRpb24tZGVsYXlgIGhhcyBleHBpcmVkIHdoaWNoIHdvdWxkIGJlIHRvbyBsYXRlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQW5pbWF0aW5nID0gcHJldkFuaW1hdGlvbk5hbWUgIT09IGN1cnJBbmltYXRpb25OYW1lO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2UHJlc2VudCAmJiBpc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcIkFOSU1BVElPTl9PVVRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcIlVOTU9VTlRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyaW5nIGFuIEFOSU1BVElPTl9PVVQgZHVyaW5nIGFuIEFOSU1BVElPTl9JTiB3aWxsIGZpcmUgYW4gYGFuaW1hdGlvbmNhbmNlbGBcbiAgICAgKiBldmVudCBmb3IgQU5JTUFUSU9OX0lOIGFmdGVyIHdlIGhhdmUgZW50ZXJlZCBgdW5tb3VudFN1c3BlbmRlZGAgc3RhdGUuIFNvLCB3ZVxuICAgICAqIG1ha2Ugc3VyZSB3ZSBvbmx5IHRyaWdnZXIgQU5JTUFUSU9OX0VORCBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZUFuaW1hdGlvbkVuZChldmVudCkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZC5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJBbmltYXRpb25OYW1lID0gZ2V0QW5pbWF0aW9uTmFtZShub2RlKTtcbiAgICAgICAgY29uc3QgaXNDdXJyZW50QW5pbWF0aW9uID0gY3VyckFuaW1hdGlvbk5hbWUuaW5jbHVkZXMoZXZlbnQuYW5pbWF0aW9uTmFtZSkgfHwgY3VyckFuaW1hdGlvbk5hbWUgPT09IFwibm9uZVwiO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBub2RlICYmIGlzQ3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAgICAgZGlzcGF0Y2goXCJBTklNQVRJT05fRU5EXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFuaW1hdGlvblN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcHJldkFuaW1hdGlvbk5hbWVTdGF0ZSA9IGdldEFuaW1hdGlvbk5hbWUobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnQ7XG4gICAgICAgIHVudHJhY2soKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJBbmltYXRpb25OYW1lID0gZ2V0QW5pbWF0aW9uTmFtZShub2RlKTtcbiAgICAgICAgICAgIHByZXZBbmltYXRpb25OYW1lU3RhdGUgPSBzdGF0ZS5jdXJyZW50ID09PSBcIm1vdW50ZWRcIiA/IGN1cnJBbmltYXRpb25OYW1lIDogXCJub25lXCI7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGhhbmRsZUFuaW1hdGlvblN0YXJ0KTtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uY2FuY2VsXCIsIGhhbmRsZUFuaW1hdGlvbkVuZCk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBoYW5kbGVBbmltYXRpb25FbmQpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGhhbmRsZUFuaW1hdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIG5vZGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25jYW5jZWxcIiwgaGFuZGxlQW5pbWF0aW9uRW5kKTtcbiAgICAgICAgICAgIG5vZGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgaGFuZGxlQW5pbWF0aW9uRW5kKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBpc1ByZXNlbnREZXJpdmVkID0gJGRlcml2ZWQoW1wibW91bnRlZFwiLCBcInVubW91bnRTdXNwZW5kZWRcIl0uaW5jbHVkZXMoc3RhdGUuY3VycmVudCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudERlcml2ZWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbk5hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5hbmltYXRpb25OYW1lIHx8IFwibm9uZVwiIDogXCJub25lXCI7XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3ggfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgUHJlc2VuY2VMYXllckltcGxQcm9wcyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSBcIi4vdXNlUHJlc2VuY2Uuc3ZlbHRlLmpzXCI7XG5cblx0bGV0IHsgcHJlc2VudCwgZm9yY2VNb3VudCwgcHJlc2VuY2UsIGlkIH06IFByZXNlbmNlTGF5ZXJJbXBsUHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCBpc1ByZXNlbnQgPSB1c2VQcmVzZW5jZShcblx0XHRib3gud2l0aCgoKSA9PiBwcmVzZW50KSxcblx0XHRib3gud2l0aCgoKSA9PiBpZClcblx0KTtcbjwvc2NyaXB0PlxuXG57I2lmIGZvcmNlTW91bnQgfHwgcHJlc2VudCB8fCBpc1ByZXNlbnQuY3VycmVudH1cblx0e0ByZW5kZXIgcHJlc2VuY2U/Lih7IHByZXNlbnQ6IGlzUHJlc2VudCB9KX1cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUFjY29yZGlvbkNvbnRlbnQgfSBmcm9tIFwiLi4vYWNjb3JkaW9uLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgdHlwZSB7IEFjY29yZGlvbkNvbnRlbnRQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyBQcmVzZW5jZUxheWVyIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wcmVzZW5jZS1sYXllci9pbmRleC5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Zm9yY2VNb3VudCA9IGZhbHNlLFxuXHRcdGNoaWxkcmVuLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBBY2NvcmRpb25Db250ZW50UHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCBjb250ZW50U3RhdGUgPSB1c2VBY2NvcmRpb25Db250ZW50KHtcblx0XHRmb3JjZU1vdW50OiBib3gud2l0aCgoKSA9PiBmb3JjZU1vdW50KSxcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG48L3NjcmlwdD5cblxuPFByZXNlbmNlTGF5ZXIgZm9yY2VNb3VudD17dHJ1ZX0gcHJlc2VudD17Y29udGVudFN0YXRlLnByZXNlbnR9IHtpZH0+XG5cdHsjc25pcHBldCBwcmVzZW5jZSh7IHByZXNlbnQgfSl9XG5cdFx0e0Bjb25zdCBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMocmVzdFByb3BzLCBjb250ZW50U3RhdGUucHJvcHMsIHtcblx0XHRcdGhpZGRlbjogZm9yY2VNb3VudCA/IHVuZGVmaW5lZCA6ICFwcmVzZW50LmN1cnJlbnQsXG5cdFx0fSl9XG5cdFx0eyNpZiBjaGlsZH1cblx0XHRcdHtAcmVuZGVyIGNoaWxkKHtcblx0XHRcdFx0cHJvcHM6IG1lcmdlZFByb3BzLFxuXHRcdFx0XHQuLi5jb250ZW50U3RhdGUuc25pcHBldFByb3BzLFxuXHRcdFx0fSl9XG5cdFx0ezplbHNlfVxuXHRcdFx0PGRpdiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdFx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHR7L3NuaXBwZXR9XG48L1ByZXNlbmNlTGF5ZXI+XG4iLCJpbXBvcnQgeyB1c2VSZWZCeUlkIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuaW1wb3J0IHsgZ2V0QXJpYUV4cGFuZGVkLCBnZXREYXRhT3BlbkNsb3NlZCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9hdHRycy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9jcmVhdGUtY29udGV4dC5qc1wiO1xuaW1wb3J0IHsga2JkIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2tiZC5qc1wiO1xuZnVuY3Rpb24gY3JlYXRlQXR0cnModmFyaWFudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IGBkYXRhLSR7dmFyaWFudH0tY29udGVudGAsXG4gICAgICAgIHRyaWdnZXI6IGBkYXRhLSR7dmFyaWFudH0tdHJpZ2dlcmAsXG4gICAgICAgIG92ZXJsYXk6IGBkYXRhLSR7dmFyaWFudH0tb3ZlcmxheWAsXG4gICAgICAgIHRpdGxlOiBgZGF0YS0ke3ZhcmlhbnR9LXRpdGxlYCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBkYXRhLSR7dmFyaWFudH0tZGVzY3JpcHRpb25gLFxuICAgICAgICBjbG9zZTogYGRhdGEtJHt2YXJpYW50fS1jbG9zZWAsXG4gICAgICAgIGNhbmNlbDogYGRhdGEtJHt2YXJpYW50fS1jYW5jZWxgLFxuICAgICAgICBhY3Rpb246IGBkYXRhLSR7dmFyaWFudH0tYWN0aW9uYCxcbiAgICB9O1xufVxuY2xhc3MgRGlhbG9nUm9vdFN0YXRlIHtcbiAgICBvcGVuO1xuICAgIHZhcmlhbnQ7XG4gICAgdHJpZ2dlck5vZGUgPSAkc3RhdGUobnVsbCk7XG4gICAgdGl0bGVOb2RlID0gJHN0YXRlKG51bGwpO1xuICAgIGNvbnRlbnROb2RlID0gJHN0YXRlKG51bGwpO1xuICAgIGRlc2NyaXB0aW9uTm9kZSA9ICRzdGF0ZShudWxsKTtcbiAgICBjb250ZW50SWQgPSAkc3RhdGUodW5kZWZpbmVkKTtcbiAgICB0aXRsZUlkID0gJHN0YXRlKHVuZGVmaW5lZCk7XG4gICAgdHJpZ2dlcklkID0gJHN0YXRlKHVuZGVmaW5lZCk7XG4gICAgZGVzY3JpcHRpb25JZCA9ICRzdGF0ZSh1bmRlZmluZWQpO1xuICAgIGNhbmNlbE5vZGUgPSAkc3RhdGUobnVsbCk7XG4gICAgYXR0cnMgPSAkZGVyaXZlZC5ieSgoKSA9PiBjcmVhdGVBdHRycyh0aGlzLnZhcmlhbnQuY3VycmVudCkpO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IHByb3BzLm9wZW47XG4gICAgICAgIHRoaXMudmFyaWFudCA9IHByb3BzLnZhcmlhbnQ7XG4gICAgICAgIHRoaXMuaGFuZGxlT3BlbiA9IHRoaXMuaGFuZGxlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlID0gdGhpcy5oYW5kbGVDbG9zZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVPcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5vcGVuLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub3Blbi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlQ2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub3Blbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIHNoYXJlZFByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGdldERhdGFPcGVuQ2xvc2VkKHRoaXMub3Blbi5jdXJyZW50KSxcbiAgICB9KSk7XG59XG5jbGFzcyBEaWFsb2dUcmlnZ2VyU3RhdGUge1xuICAgICNpZDtcbiAgICAjcmVmO1xuICAgICNyb290O1xuICAgICNkaXNhYmxlZDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLiNkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLm9uY2xpY2sgPSB0aGlzLm9uY2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbnBvaW50ZXJkb3duID0gdGhpcy5vbnBvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25rZXlkb3duID0gdGhpcy5vbmtleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy4jaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMuI3JlZixcbiAgICAgICAgICAgIG9uUmVmQ2hhbmdlOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QudHJpZ2dlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QudHJpZ2dlcklkID0gbm9kZT8uaWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25jbGljayA9IChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiNkaXNhYmxlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZS5idXR0b24gPiAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiNyb290LmhhbmRsZU9wZW4oKTtcbiAgICB9O1xuICAgIG9ucG9pbnRlcmRvd24gPSAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jZGlzYWJsZWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUuYnV0dG9uID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gYnkgZGVmYXVsdCwgaXQgd2lsbCBhdHRlbXB0IHRvIGZvY3VzIHRoaXMgdHJpZ2dlciBvbiBwb2ludGVyZG93blxuICAgICAgICAvLyBzaW5jZSB0aGlzIGFsc28gb3BlbnMgdGhlIGRpYWxvZyB3ZSB3YW50IHRvIHByZXZlbnQgdGhhdCBiZWhhdmlvclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBvbmtleWRvd24gPSAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jZGlzYWJsZWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUua2V5ID09PSBrYmQuU1BBQ0UgfHwgZS5rZXkgPT09IGtiZC5FTlRFUikge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy4jcm9vdC5oYW5kbGVPcGVuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBcImRpYWxvZ1wiLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogZ2V0QXJpYUV4cGFuZGVkKHRoaXMuI3Jvb3Qub3Blbi5jdXJyZW50KSxcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IHRoaXMuI3Jvb3QuY29udGVudElkLFxuICAgICAgICBbdGhpcy4jcm9vdC5hdHRycy50cmlnZ2VyXTogXCJcIixcbiAgICAgICAgb25wb2ludGVyZG93bjogdGhpcy5vbnBvaW50ZXJkb3duLFxuICAgICAgICBvbmtleWRvd246IHRoaXMub25rZXlkb3duLFxuICAgICAgICBvbmNsaWNrOiB0aGlzLm9uY2xpY2ssXG4gICAgICAgIC4uLnRoaXMuI3Jvb3Quc2hhcmVkUHJvcHMsXG4gICAgfSkpO1xufVxuY2xhc3MgRGlhbG9nQ2xvc2VTdGF0ZSB7XG4gICAgI2lkO1xuICAgICNyZWY7XG4gICAgI3Jvb3Q7XG4gICAgI3ZhcmlhbnQ7XG4gICAgI2Rpc2FibGVkO1xuICAgICNhdHRyID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy4jcm9vdC5hdHRyc1t0aGlzLiN2YXJpYW50LmN1cnJlbnRdKTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNyb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiN2YXJpYW50ID0gcHJvcHMudmFyaWFudDtcbiAgICAgICAgdGhpcy4jZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgdGhpcy5vbmNsaWNrID0gdGhpcy5vbmNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25wb2ludGVyZG93biA9IHRoaXMub25wb2ludGVyZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9ua2V5ZG93biA9IHRoaXMub25rZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLiNyb290Lm9wZW4uY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uY2xpY2soZSkge1xuICAgICAgICBpZiAodGhpcy4jZGlzYWJsZWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUuYnV0dG9uID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4jcm9vdC5oYW5kbGVDbG9zZSgpO1xuICAgIH1cbiAgICBvbnBvaW50ZXJkb3duKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Rpc2FibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlLmJ1dHRvbiA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIGl0IHdpbGwgYXR0ZW1wdCB0byBmb2N1cyB0aGlzIHRyaWdnZXIgb24gcG9pbnRlcmRvd25cbiAgICAgICAgLy8gc2luY2UgdGhpcyBhbHNvIGNsb3NlcyB0aGUgZGlhbG9nIGFuZCByZXN0b3JlcyBmb2N1cyB3ZSB3YW50IHRvIHByZXZlbnQgdGhhdCBiZWhhdmlvclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuI3Jvb3QuaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gICAgb25rZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Rpc2FibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlLmtleSA9PT0ga2JkLlNQQUNFIHx8IGUua2V5ID09PSBrYmQuRU5URVIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuI3Jvb3QuaGFuZGxlQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLiNpZC5jdXJyZW50LFxuICAgICAgICBbdGhpcy4jYXR0cl06IFwiXCIsXG4gICAgICAgIG9ucG9pbnRlcmRvd246IHRoaXMub25wb2ludGVyZG93bixcbiAgICAgICAgb25jbGljazogdGhpcy5vbmNsaWNrLFxuICAgICAgICBvbmtleWRvd246IHRoaXMub25rZXlkb3duLFxuICAgICAgICAuLi50aGlzLiNyb290LnNoYXJlZFByb3BzLFxuICAgIH0pKTtcbn1cbmNsYXNzIERpYWxvZ0FjdGlvblN0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICAjcm9vdDtcbiAgICAjYXR0ciA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMuI3Jvb3QuYXR0cnMuYWN0aW9uKTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMuI3Jvb3QgPSByb290O1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgW3RoaXMuI2F0dHJdOiBcIlwiLFxuICAgICAgICAuLi50aGlzLiNyb290LnNoYXJlZFByb3BzLFxuICAgIH0pKTtcbn1cbmNsYXNzIERpYWxvZ1RpdGxlU3RhdGUge1xuICAgICNpZDtcbiAgICAjcmVmO1xuICAgICNyb290O1xuICAgICNsZXZlbDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLiNsZXZlbCA9IHByb3BzLmxldmVsO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICAgICAgb25SZWZDaGFuZ2U6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcm9vdC50aXRsZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QudGl0bGVJZCA9IG5vZGU/LmlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlcHM6ICgpID0+IHRoaXMuI3Jvb3Qub3Blbi5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgcm9sZTogXCJoZWFkaW5nXCIsXG4gICAgICAgIFwiYXJpYS1sZXZlbFwiOiB0aGlzLiNsZXZlbC5jdXJyZW50LFxuICAgICAgICBbdGhpcy4jcm9vdC5hdHRycy50aXRsZV06IFwiXCIsXG4gICAgICAgIC4uLnRoaXMuI3Jvb3Quc2hhcmVkUHJvcHMsXG4gICAgfSkpO1xufVxuY2xhc3MgRGlhbG9nRGVzY3JpcHRpb25TdGF0ZSB7XG4gICAgI2lkO1xuICAgICNyZWY7XG4gICAgI3Jvb3Q7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jcm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuI3JlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy4jaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMuI3JlZixcbiAgICAgICAgICAgIGRlcHM6ICgpID0+IHRoaXMuI3Jvb3Qub3Blbi5jdXJyZW50LFxuICAgICAgICAgICAgb25SZWZDaGFuZ2U6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcm9vdC5kZXNjcmlwdGlvbk5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QuZGVzY3JpcHRpb25JZCA9IG5vZGU/LmlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIFt0aGlzLiNyb290LmF0dHJzLmRlc2NyaXB0aW9uXTogXCJcIixcbiAgICAgICAgLi4udGhpcy4jcm9vdC5zaGFyZWRQcm9wcyxcbiAgICB9KSk7XG59XG5jbGFzcyBEaWFsb2dDb250ZW50U3RhdGUge1xuICAgICNpZDtcbiAgICAjcmVmO1xuICAgIHJvb3Q7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICAgICAgZGVwczogKCkgPT4gdGhpcy5yb290Lm9wZW4uY3VycmVudCxcbiAgICAgICAgICAgIG9uUmVmQ2hhbmdlOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5jb250ZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmNvbnRlbnRJZCA9IG5vZGU/LmlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNuaXBwZXRQcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7IG9wZW46IHRoaXMucm9vdC5vcGVuLmN1cnJlbnQgfSkpO1xuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIHJvbGU6IHRoaXMucm9vdC52YXJpYW50LmN1cnJlbnQgPT09IFwiYWxlcnQtZGlhbG9nXCIgPyBcImFsZXJ0ZGlhbG9nXCIgOiBcImRpYWxvZ1wiLFxuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogdGhpcy5yb290LmRlc2NyaXB0aW9uSWQsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRoaXMucm9vdC50aXRsZUlkLFxuICAgICAgICBbdGhpcy5yb290LmF0dHJzLmNvbnRlbnRdOiBcIlwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCIsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLnRoaXMucm9vdC5zaGFyZWRQcm9wcyxcbiAgICB9KSk7XG59XG5jbGFzcyBEaWFsb2dPdmVybGF5U3RhdGUge1xuICAgICNpZDtcbiAgICAjcmVmO1xuICAgIHJvb3Q7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICAgICAgZGVwczogKCkgPT4gdGhpcy5yb290Lm9wZW4uY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNuaXBwZXRQcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7IG9wZW46IHRoaXMucm9vdC5vcGVuLmN1cnJlbnQgfSkpO1xuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIFt0aGlzLnJvb3QuYXR0cnMub3ZlcmxheV06IFwiXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgfSxcbiAgICAgICAgLi4udGhpcy5yb290LnNoYXJlZFByb3BzLFxuICAgIH0pKTtcbn1cbmNsYXNzIEFsZXJ0RGlhbG9nQ2FuY2VsU3RhdGUge1xuICAgICNpZDtcbiAgICAjcmVmO1xuICAgICNyb290O1xuICAgICNkaXNhYmxlZDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMuI3Jvb3QgPSByb290O1xuICAgICAgICB0aGlzLiNkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLm9uY2xpY2sgPSB0aGlzLm9uY2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbnBvaW50ZXJkb3duID0gdGhpcy5vbnBvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25rZXlkb3duID0gdGhpcy5vbmtleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy4jaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMuI3JlZixcbiAgICAgICAgICAgIGRlcHM6ICgpID0+IHRoaXMuI3Jvb3Qub3Blbi5jdXJyZW50LFxuICAgICAgICAgICAgb25SZWZDaGFuZ2U6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcm9vdC5jYW5jZWxOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbmNsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Rpc2FibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlLmJ1dHRvbiA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuI3Jvb3QuaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gICAgb25wb2ludGVyZG93bihlKSB7XG4gICAgICAgIGlmICh0aGlzLiNkaXNhYmxlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGUuYnV0dG9uID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gYnkgZGVmYXVsdCwgaXQgd2lsbCBhdHRlbXB0IHRvIGZvY3VzIHRoaXMgdHJpZ2dlciBvbiBwb2ludGVyZG93blxuICAgICAgICAvLyBzaW5jZSB0aGlzIGFsc28gb3BlbnMgdGhlIGRpYWxvZyB3ZSB3YW50IHRvIHByZXZlbnQgdGhhdCBiZWhhdmlvclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuI3Jvb3QuaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gICAgb25rZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Rpc2FibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlLmtleSA9PT0ga2JkLlNQQUNFIHx8IGUua2V5ID09PSBrYmQuRU5URVIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuI3Jvb3QuaGFuZGxlQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLiNpZC5jdXJyZW50LFxuICAgICAgICBbdGhpcy4jcm9vdC5hdHRycy5jYW5jZWxdOiBcIlwiLFxuICAgICAgICBvbnBvaW50ZXJkb3duOiB0aGlzLm9ucG9pbnRlcmRvd24sXG4gICAgICAgIG9uY2xpY2s6IHRoaXMub25jbGljayxcbiAgICAgICAgb25rZXlkb3duOiB0aGlzLm9ua2V5ZG93bixcbiAgICAgICAgLi4udGhpcy4jcm9vdC5zaGFyZWRQcm9wcyxcbiAgICB9KSk7XG59XG5jb25zdCBbc2V0RGlhbG9nUm9vdENvbnRleHQsIGdldERpYWxvZ1Jvb3RDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHQoXCJEaWFsb2cuUm9vdFwiKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VEaWFsb2dSb290KHByb3BzKSB7XG4gICAgcmV0dXJuIHNldERpYWxvZ1Jvb3RDb250ZXh0KG5ldyBEaWFsb2dSb290U3RhdGUocHJvcHMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VEaWFsb2dUcmlnZ2VyKHByb3BzKSB7XG4gICAgY29uc3Qgcm9vdCA9IGdldERpYWxvZ1Jvb3RDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBEaWFsb2dUcmlnZ2VyU3RhdGUocHJvcHMsIHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZURpYWxvZ1RpdGxlKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBEaWFsb2dUaXRsZVN0YXRlKHByb3BzLCBnZXREaWFsb2dSb290Q29udGV4dCgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VEaWFsb2dDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBEaWFsb2dDb250ZW50U3RhdGUocHJvcHMsIGdldERpYWxvZ1Jvb3RDb250ZXh0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZURpYWxvZ092ZXJsYXkocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IERpYWxvZ092ZXJsYXlTdGF0ZShwcm9wcywgZ2V0RGlhbG9nUm9vdENvbnRleHQoKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlRGlhbG9nRGVzY3JpcHRpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IERpYWxvZ0Rlc2NyaXB0aW9uU3RhdGUocHJvcHMsIGdldERpYWxvZ1Jvb3RDb250ZXh0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZURpYWxvZ0Nsb3NlKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBEaWFsb2dDbG9zZVN0YXRlKHByb3BzLCBnZXREaWFsb2dSb290Q29udGV4dCgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbGVydERpYWxvZ0NhbmNlbChwcm9wcykge1xuICAgIHJldHVybiBuZXcgQWxlcnREaWFsb2dDYW5jZWxTdGF0ZShwcm9wcywgZ2V0RGlhbG9nUm9vdENvbnRleHQoKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQWxlcnREaWFsb2dBY3Rpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IERpYWxvZ0FjdGlvblN0YXRlKHByb3BzLCBnZXREaWFsb2dSb290Q29udGV4dCgpKTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHsgdXNlRGlhbG9nVGl0bGUgfSBmcm9tIFwiLi4vZGlhbG9nLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgdHlwZSB7IERpYWxvZ1RpdGxlUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNoaWxkLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGxldmVsID0gMixcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nVGl0bGVQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IHRpdGxlU3RhdGUgPSB1c2VEaWFsb2dUaXRsZSh7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRsZXZlbDogYm94LndpdGgoKCkgPT4gbGV2ZWwpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgdGl0bGVTdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgY2hpbGR9XG5cdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuezplbHNlfVxuXHQ8ZGl2IHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRBbGxDb250ZXh0cywgbW91bnQsIHVubW91bnQsIHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCB7IERFViB9IGZyb20gXCJlc20tZW52XCI7XG5cdGltcG9ydCBQb3J0YWxDb25zdW1lciBmcm9tIFwiLi9wb3J0YWwtY29uc3VtZXIuc3ZlbHRlXCI7XG5cdGltcG9ydCB0eXBlIHsgUG9ydGFsUHJvcHMgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvaXMuanNcIjtcblxuXHRsZXQgeyB0byA9IFwiYm9keVwiLCBjaGlsZHJlbiwgZGlzYWJsZWQgfTogUG9ydGFsUHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCBjb250ZXh0ID0gZ2V0QWxsQ29udGV4dHMoKTtcblxuXHRsZXQgdGFyZ2V0ID0gJGRlcml2ZWQoZ2V0VGFyZ2V0KCkpO1xuXG5cdGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcblx0XHRpZiAoIWlzQnJvd3NlciB8fCBkaXNhYmxlZCkgcmV0dXJuIG51bGw7XG5cdFx0bGV0IGxvY2FsVGFyZ2V0OiBIVE1MRWxlbWVudCB8IG51bGwgfCBEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudCA9IG51bGw7XG5cdFx0aWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0bG9jYWxUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRvKTtcblx0XHRcdGlmIChsb2NhbFRhcmdldCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgZWxlbWVudCBcIiR7dG99XCIgbm90IGZvdW5kLmApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0byBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRvIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuXHRcdFx0bG9jYWxUYXJnZXQgPSB0bztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XHRcdGBVbmtub3duIHBvcnRhbCB0YXJnZXQgdHlwZTogJHtcblx0XHRcdFx0XHRcdHRvID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdG9cblx0XHRcdFx0XHR9LiBBbGxvd2VkIHR5cGVzOiBzdHJpbmcgKHF1ZXJ5IHNlbGVjdG9yKSwgSFRNTEVsZW1lbnQsIG9yIERvY3VtZW50RnJhZ21lbnQuYFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBsb2NhbFRhcmdldDtcblx0fVxuXG5cdGxldCBpbnN0YW5jZTogYW55O1xuXG5cdCRlZmZlY3QoKCkgPT4ge1xuXHRcdGlmICghdGFyZ2V0IHx8IGRpc2FibGVkKSB7XG5cdFx0XHRpZiAoaW5zdGFuY2UpIHtcblx0XHRcdFx0dW5tb3VudChpbnN0YW5jZSk7XG5cdFx0XHRcdGluc3RhbmNlID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dW50cmFjayhcblx0XHRcdCgpID0+XG5cdFx0XHRcdChpbnN0YW5jZSA9IG1vdW50KFBvcnRhbENvbnN1bWVyLCB7XG5cdFx0XHRcdFx0dGFyZ2V0OiB0YXJnZXQgYXMgYW55LFxuXHRcdFx0XHRcdHByb3BzOiB7IGNoaWxkcmVuIH0sXG5cdFx0XHRcdFx0Y29udGV4dCxcblx0XHRcdFx0fSkpXG5cdFx0KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRpZiAoaW5zdGFuY2UpIHtcblx0XHRcdFx0dW5tb3VudChpbnN0YW5jZSk7XG5cdFx0XHRcdGluc3RhbmNlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbjwvc2NyaXB0PlxuXG57I2lmIGRpc2FibGVkfVxuXHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG57L2lmfVxuIiwiLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGVsZW1lbnQocykgZm9yIHRoZSBnaXZlbiBldmVudChzKSwgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0byByZW1vdmUgaXQuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgZWxlbWVudChzKSB0byBhZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudChzKSB0byBsaXN0ZW4gZm9yLlxuICogQHBhcmFtIGhhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvYmplY3QgdGhhdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0IHRoZSBldmVudCBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSB0YXJnZXQgZWxlbWVudChzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnQpID8gZXZlbnQgOiBbZXZlbnRdO1xuICAgIC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gZWFjaCBzcGVjaWZpZWQgZXZlbnQgZm9yIHRoZSB0YXJnZXQgZWxlbWVudChzKS5cbiAgICBldmVudHMuZm9yRWFjaCgoX2V2ZW50KSA9PiB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihfZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpKTtcbiAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIHRhcmdldCBlbGVtZW50KHMpLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChfZXZlbnQpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKF9ldmVudCwgaGFuZGxlciwgb3B0aW9ucykpO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSB0eXBlZCBldmVudCBkaXNwYXRjaGVyIGFuZCBsaXN0ZW5lciBwYWlyIGZvciBjdXN0b20gZXZlbnRzXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIGRhdGEgdGhhdCB3aWxsIGJlIHBhc3NlZCBpbiB0aGUgZXZlbnQgZGV0YWlsXG4gKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudFxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b21FdmVudCBvcHRpb25zIChidWJibGVzLCBjYW5jZWxhYmxlLCBldGMuKVxuICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIGRpc3BhdGNoIGFuZCBsaXN0ZW4gZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIG9wdGlvbnMgPSB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkge1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKGVsZW1lbnQsIGRldGFpbCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW4oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHNoaFxuICAgICAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gW2Rpc3BhdGNoLCBsaXN0ZW5dO1xufVxuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHRzL25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZuLCB3YWl0ID0gNTAwKSB7XG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgIH07XG4gICAgZGVib3VuY2VkLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc09yQ29udGFpbnNUYXJnZXQobm9kZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5vZGUgPT09IHRhcmdldCB8fCBub2RlLmNvbnRhaW5zKHRhcmdldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudChlbCkge1xuICAgIHJldHVybiBlbD8ub3duZXJEb2N1bWVudCA/PyBkb2N1bWVudDtcbn1cbiIsImltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBhZnRlclNsZWVwLCBhZnRlclRpY2ssIGJveCwgZXhlY3V0ZUNhbGxiYWNrcywgb25EZXN0cm95RWZmZWN0LCB1c2VSZWZCeUlkLCB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcbmltcG9ydCB7IGFkZEV2ZW50TGlzdGVuZXIgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvZXZlbnRzLmpzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9ub29wLmpzXCI7XG5pbXBvcnQgeyBnZXRPd25lckRvY3VtZW50LCBpc09yQ29udGFpbnNUYXJnZXQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvZWxlbWVudHMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9pcy5qc1wiO1xuZ2xvYmFsVGhpcy5iaXRzRGlzbWlzc2FibGVMYXllcnMgPz89IG5ldyBNYXAoKTtcbmV4cG9ydCBjbGFzcyBEaXNtaXNzaWJsZUxheWVyU3RhdGUge1xuICAgICNpbnRlcmFjdE91dHNpZGVQcm9wO1xuICAgICNiZWhhdmlvclR5cGU7XG4gICAgI2ludGVyY2VwdGVkRXZlbnRzID0ge1xuICAgICAgICBwb2ludGVyZG93bjogZmFsc2UsXG4gICAgfTtcbiAgICAjaXNSZXNwb25zaWJsZUxheWVyID0gZmFsc2U7XG4gICAgbm9kZSA9IGJveChudWxsKTtcbiAgICAjZG9jdW1lbnRPYmogPSB1bmRlZmluZWQ7XG4gICAgI2VuYWJsZWQ7XG4gICAgI2lzRm9jdXNJbnNpZGVET01UcmVlID0gJHN0YXRlKGZhbHNlKTtcbiAgICAjb25Gb2N1c091dHNpZGU7XG4gICAgY3Vyck5vZGUgPSAkc3RhdGUobnVsbCk7XG4gICAgI2lzVmFsaWRFdmVudFByb3A7XG4gICAgI3Vuc3ViQ2xpY2tMaXN0ZW5lciA9IG5vb3A7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy4jZW5hYmxlZCA9IHByb3BzLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuI2lzVmFsaWRFdmVudFByb3AgPSBwcm9wcy5pc1ZhbGlkRXZlbnQ7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHByb3BzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLm5vZGUsXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLiNlbmFibGVkLmN1cnJlbnQsXG4gICAgICAgICAgICBvblJlZkNoYW5nZTogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNiZWhhdmlvclR5cGUgPSBwcm9wcy5pbnRlcmFjdE91dHNpZGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy4jaW50ZXJhY3RPdXRzaWRlUHJvcCA9IHByb3BzLm9uSW50ZXJhY3RPdXRzaWRlO1xuICAgICAgICB0aGlzLiNvbkZvY3VzT3V0c2lkZSA9IHByb3BzLm9uRm9jdXNPdXRzaWRlO1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RvY3VtZW50T2JqID0gZ2V0T3duZXJEb2N1bWVudCh0aGlzLmN1cnJOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB1bnN1YkV2ZW50cyA9IG5vb3A7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNyZXNldFN0YXRlKCk7XG4gICAgICAgICAgICBnbG9iYWxUaGlzLmJpdHNEaXNtaXNzYWJsZUxheWVycy5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiNoYW5kbGVJbnRlcmFjdE91dHNpZGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy4jZW5hYmxlZC5jdXJyZW50ICYmIHRoaXMuY3Vyck5vZGUpIHtcbiAgICAgICAgICAgICAgICBhZnRlclNsZWVwKDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmJpdHNEaXNtaXNzYWJsZUxheWVycy5zZXQodGhpcywgdW50cmFjaygoKSA9PiB0aGlzLiNiZWhhdmlvclR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJFdmVudHMgPSB0aGlzLiNhZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgb25EZXN0cm95RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3Jlc2V0U3RhdGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5iaXRzRGlzbWlzc2FibGVMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4jaGFuZGxlSW50ZXJhY3RPdXRzaWRlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuI3Vuc3ViQ2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICNoYW5kbGVGb2N1cyA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJOb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhZnRlclRpY2soKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJOb2RlIHx8IHRoaXMuI2lzVGFyZ2V0V2l0aGluTGF5ZXIoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICYmICF0aGlzLiNpc0ZvY3VzSW5zaWRlRE9NVHJlZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI29uRm9jdXNPdXRzaWRlLmN1cnJlbnQ/LihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgI2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZUNhbGxiYWNrcyhcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENBUFRVUkUgSU5URVJBQ1RJT04gU1RBUlRcbiAgICAgICAgICogbWFyayBpbnRlcmFjdGlvbi1zdGFydCBldmVudCBhcyBpbnRlcmNlcHRlZC5cbiAgICAgICAgICogbWFyayByZXNwb25zaWJsZSBsYXllciBkdXJpbmcgaW50ZXJhY3Rpb24gc3RhcnRcbiAgICAgICAgICogdG8gYXZvaWQgY2hlY2tpbmcgaWYgaXMgcmVzcG9uc2libGUgbGF5ZXIgZHVyaW5nIGludGVyYWN0aW9uIGVuZFxuICAgICAgICAgKiB3aGVuIGEgbmV3IGZsb2F0aW5nIGVsZW1lbnQgbWF5IGhhdmUgYmVlbiBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHRoaXMuI2RvY3VtZW50T2JqLCBcInBvaW50ZXJkb3duXCIsIGV4ZWN1dGVDYWxsYmFja3ModGhpcy4jbWFya0ludGVyY2VwdGVkRXZlbnQsIHRoaXMuI21hcmtSZXNwb25zaWJsZUxheWVyKSwgdHJ1ZSksIFxuICAgICAgICAvKipcbiAgICAgICAgICogQlVCQkxFIElOVEVSQUNUSU9OIFNUQVJUXG4gICAgICAgICAqIE1hcmsgaW50ZXJhY3Rpb24tc3RhcnQgZXZlbnQgYXMgbm9uLWludGVyY2VwdGVkLiBEZWJvdW5jZSBgb25JbnRlcmFjdE91dHNpZGVTdGFydGBcbiAgICAgICAgICogdG8gYXZvaWQgcHJlbWF0dXJlbHkgY2hlY2tpbmcgaWYgb3RoZXIgZXZlbnRzIHdlcmUgaW50ZXJjZXB0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHRoaXMuI2RvY3VtZW50T2JqLCBcInBvaW50ZXJkb3duXCIsIGV4ZWN1dGVDYWxsYmFja3ModGhpcy4jbWFya05vbkludGVyY2VwdGVkRXZlbnQsIHRoaXMuI2hhbmRsZUludGVyYWN0T3V0c2lkZSkpLCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhBTkRMRSBGT0NVUyBPVVRTSURFXG4gICAgICAgICAqL1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHRoaXMuI2RvY3VtZW50T2JqLCBcImZvY3VzaW5cIiwgdGhpcy4jaGFuZGxlRm9jdXMpKTtcbiAgICB9XG4gICAgI2hhbmRsZURpc21pc3MgPSAoZSkgPT4ge1xuICAgICAgICBsZXQgZXZlbnQgPSBlO1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgZXZlbnQgPSBjcmVhdGVXcmFwcGVkRXZlbnQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaW50ZXJhY3RPdXRzaWRlUHJvcC5jdXJyZW50KGUpO1xuICAgIH07XG4gICAgI2hhbmRsZUludGVyYWN0T3V0c2lkZSA9IGRlYm91bmNlKChlKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyTm9kZSkge1xuICAgICAgICAgICAgdGhpcy4jdW5zdWJDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFdmVudFZhbGlkID0gdGhpcy4jaXNWYWxpZEV2ZW50UHJvcC5jdXJyZW50KGUsIHRoaXMuY3Vyck5vZGUpIHx8IGlzVmFsaWRFdmVudChlLCB0aGlzLmN1cnJOb2RlKTtcbiAgICAgICAgaWYgKCF0aGlzLiNpc1Jlc3BvbnNpYmxlTGF5ZXIgfHwgdGhpcy4jaXNBbnlFdmVudEludGVyY2VwdGVkKCkgfHwgIWlzRXZlbnRWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy4jdW5zdWJDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50ID0gZTtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gY3JlYXRlV3JhcHBlZEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jYmVoYXZpb3JUeXBlLmN1cnJlbnQgIT09IFwiY2xvc2VcIiAmJlxuICAgICAgICAgICAgdGhpcy4jYmVoYXZpb3JUeXBlLmN1cnJlbnQgIT09IFwiZGVmZXItb3RoZXJ3aXNlLWNsb3NlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Vuc3ViQ2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI3Vuc3ViQ2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGxhdGVyXG4gICAgICAgICAgICB0aGlzLiN1bnN1YkNsaWNrTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKHRoaXMuI2RvY3VtZW50T2JqLCBcImNsaWNrXCIsIHRoaXMuI2hhbmRsZURpc21pc3MsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2ludGVyYWN0T3V0c2lkZVByb3AuY3VycmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9LCAxMCk7XG4gICAgI21hcmtJbnRlcmNlcHRlZEV2ZW50ID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy4jaW50ZXJjZXB0ZWRFdmVudHNbZS50eXBlXSA9IHRydWU7XG4gICAgfTtcbiAgICAjbWFya05vbkludGVyY2VwdGVkRXZlbnQgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRlZEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XG4gICAgfTtcbiAgICAjbWFya1Jlc3BvbnNpYmxlTGF5ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5ub2RlLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuI2lzUmVzcG9uc2libGVMYXllciA9IGlzUmVzcG9uc2libGVMYXllcih0aGlzLm5vZGUuY3VycmVudCk7XG4gICAgfTtcbiAgICAjaXNUYXJnZXRXaXRoaW5MYXllciA9ICh0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGlzT3JDb250YWluc1RhcmdldCh0aGlzLm5vZGUuY3VycmVudCwgdGFyZ2V0KTtcbiAgICB9O1xuICAgICNyZXNldFN0YXRlID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50VHlwZSBpbiB0aGlzLiNpbnRlcmNlcHRlZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy4jaW50ZXJjZXB0ZWRFdmVudHNbZXZlbnRUeXBlXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2lzUmVzcG9uc2libGVMYXllciA9IGZhbHNlO1xuICAgIH0sIDIwKTtcbiAgICAjaXNBbnlFdmVudEludGVyY2VwdGVkKCkge1xuICAgICAgICBjb25zdCBpID0gT2JqZWN0LnZhbHVlcyh0aGlzLiNpbnRlcmNlcHRlZEV2ZW50cykuc29tZShCb29sZWFuKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgICNvbmZvY3VzY2FwdHVyZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy4jaXNGb2N1c0luc2lkZURPTVRyZWUgPSB0cnVlO1xuICAgIH07XG4gICAgI29uYmx1cmNhcHR1cmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2lzRm9jdXNJbnNpZGVET01UcmVlID0gZmFsc2U7XG4gICAgfTtcbiAgICBwcm9wcyA9IHtcbiAgICAgICAgb25mb2N1c2NhcHR1cmU6IHRoaXMuI29uZm9jdXNjYXB0dXJlLFxuICAgICAgICBvbmJsdXJjYXB0dXJlOiB0aGlzLiNvbmJsdXJjYXB0dXJlLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlRGlzbWlzc2libGVMYXllcihwcm9wcykge1xuICAgIHJldHVybiBuZXcgRGlzbWlzc2libGVMYXllclN0YXRlKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGdldFRvcE1vc3RMYXllcihsYXllcnNBcnIpIHtcbiAgICByZXR1cm4gbGF5ZXJzQXJyLmZpbmRMYXN0KChbXywgeyBjdXJyZW50OiBiZWhhdmlvclR5cGUgfV0pID0+IGJlaGF2aW9yVHlwZSA9PT0gXCJjbG9zZVwiIHx8IGJlaGF2aW9yVHlwZSA9PT0gXCJpZ25vcmVcIik7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNpYmxlTGF5ZXIobm9kZSkge1xuICAgIGNvbnN0IGxheWVyc0FyciA9IFsuLi5nbG9iYWxUaGlzLmJpdHNEaXNtaXNzYWJsZUxheWVyc107XG4gICAgLyoqXG4gICAgICogV2UgZmlyc3QgY2hlY2sgaWYgd2UgY2FuIGZpbmQgYSB0b3AgbGF5ZXIgd2l0aCBgY2xvc2VgIG9yIGBpZ25vcmVgLlxuICAgICAqIElmIHRoYXQgdG9wIGxheWVyIHdhcyBmb3VuZCBhbmQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgbm9kZSwgdGhlbiB0aGUgbm9kZSBpc1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciB0aGUgb3V0c2lkZSBpbnRlcmFjdGlvbi4gT3RoZXJ3aXNlLCB3ZSBrbm93IHRoYXQgYWxsIGxheWVycyBkZWZlciBzb1xuICAgICAqIHRoZSBmaXJzdCBsYXllciBpcyB0aGUgcmVzcG9uc2libGUgb25lLlxuICAgICAqL1xuICAgIGNvbnN0IHRvcE1vc3RMYXllciA9IGdldFRvcE1vc3RMYXllcihsYXllcnNBcnIpO1xuICAgIGlmICh0b3BNb3N0TGF5ZXIpXG4gICAgICAgIHJldHVybiB0b3BNb3N0TGF5ZXJbMF0ubm9kZS5jdXJyZW50ID09PSBub2RlO1xuICAgIGNvbnN0IFtmaXJzdExheWVyTm9kZV0gPSBsYXllcnNBcnJbMF07XG4gICAgcmV0dXJuIGZpcnN0TGF5ZXJOb2RlLm5vZGUuY3VycmVudCA9PT0gbm9kZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRFdmVudChlLCBub2RlKSB7XG4gICAgaWYgKFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQodGFyZ2V0KTtcbiAgICBjb25zdCBpc1ZhbGlkID0gb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGFyZ2V0KSAmJiAhaXNPckNvbnRhaW5zVGFyZ2V0KG5vZGUsIHRhcmdldCk7XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVXcmFwcGVkRXZlbnQoZSkge1xuICAgIGNvbnN0IGNhcHR1cmVkQ3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcbiAgICBjb25zdCBjYXB0dXJlZFRhcmdldCA9IGUudGFyZ2V0O1xuICAgIGxldCBuZXdFdmVudDtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudCkge1xuICAgICAgICBuZXdFdmVudCA9IG5ldyBQb2ludGVyRXZlbnQoZS50eXBlLCBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5ld0V2ZW50ID0gbmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJkb3duXCIsIGUpO1xuICAgIH1cbiAgICAvLyB0cmFjayB0aGUgcHJldmVudGVkIHN0YXRlIHNlcGFyYXRlbHlcbiAgICBsZXQgaXNQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAvLyBDcmVhdGUgYSBwcm94eSB0byBpbnRlcmNlcHQgcHJvcGVydHkgYWNjZXNzIGFuZCBtZXRob2QgY2FsbHNcbiAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSBuZXcgUHJveHkobmV3RXZlbnQsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJjdXJyZW50VGFyZ2V0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwdHVyZWRDdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwidGFyZ2V0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwdHVyZWRUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcmV2ZW50RGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldC5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJkZWZhdWx0UHJldmVudGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmV2ZW50ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdHMvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0cy9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiBlW3Byb3BdO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVkRXZlbnQ7XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3ggfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgRGlzbWlzc2libGVMYXllckltcGxQcm9wcyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZURpc21pc3NpYmxlTGF5ZXIgfSBmcm9tIFwiLi91c2VEaXNtaXNzaWJsZUxheWVyLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyBub29wIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL25vb3AuanNcIjtcblxuXHRsZXQge1xuXHRcdGludGVyYWN0T3V0c2lkZUJlaGF2aW9yID0gXCJjbG9zZVwiLFxuXHRcdG9uSW50ZXJhY3RPdXRzaWRlID0gbm9vcCxcblx0XHRvbkZvY3VzT3V0c2lkZSA9IG5vb3AsXG5cdFx0aWQsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0ZW5hYmxlZCxcblx0XHRpc1ZhbGlkRXZlbnQgPSAoKSA9PiBmYWxzZSxcblx0fTogRGlzbWlzc2libGVMYXllckltcGxQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IGRpc21pc3NpYmxlTGF5ZXJTdGF0ZSA9IHVzZURpc21pc3NpYmxlTGF5ZXIoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0aW50ZXJhY3RPdXRzaWRlQmVoYXZpb3I6IGJveC53aXRoKCgpID0+IGludGVyYWN0T3V0c2lkZUJlaGF2aW9yKSxcblx0XHRvbkludGVyYWN0T3V0c2lkZTogYm94LndpdGgoKCkgPT4gb25JbnRlcmFjdE91dHNpZGUpLFxuXHRcdGVuYWJsZWQ6IGJveC53aXRoKCgpID0+IGVuYWJsZWQpLFxuXHRcdG9uRm9jdXNPdXRzaWRlOiBib3gud2l0aCgoKSA9PiBvbkZvY3VzT3V0c2lkZSksXG5cdFx0aXNWYWxpZEV2ZW50OiBib3gud2l0aCgoKSA9PiBpc1ZhbGlkRXZlbnQpLFxuXHR9KTtcbjwvc2NyaXB0PlxuXG57QHJlbmRlciBjaGlsZHJlbj8uKHsgcHJvcHM6IGRpc21pc3NpYmxlTGF5ZXJTdGF0ZS5wcm9wcyB9KX1cbiIsImltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2V2ZW50cy5qc1wiO1xuaW1wb3J0IHsga2JkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2tiZC5qc1wiO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9ub29wLmpzXCI7XG5nbG9iYWxUaGlzLmJpdHNFc2NhcGVMYXllcnMgPz89IG5ldyBNYXAoKTtcbmV4cG9ydCBjbGFzcyBFc2NhcGVMYXllclN0YXRlIHtcbiAgICAjb25Fc2NhcGVQcm9wO1xuICAgICNiZWhhdmlvclR5cGU7XG4gICAgI2VuYWJsZWQ7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy4jYmVoYXZpb3JUeXBlID0gcHJvcHMuZXNjYXBlS2V5ZG93bkJlaGF2aW9yO1xuICAgICAgICB0aGlzLiNvbkVzY2FwZVByb3AgPSBwcm9wcy5vbkVzY2FwZUtleWRvd247XG4gICAgICAgIHRoaXMuI2VuYWJsZWQgPSBwcm9wcy5lbmFibGVkO1xuICAgICAgICBsZXQgdW5zdWJFdmVudHMgPSBub29wO1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNlbmFibGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmJpdHNFc2NhcGVMYXllcnMuc2V0KHRoaXMsIHVudHJhY2soKCkgPT4gdGhpcy4jYmVoYXZpb3JUeXBlKSk7XG4gICAgICAgICAgICAgICAgdW5zdWJFdmVudHMgPSB0aGlzLiNhZGRFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5iaXRzRXNjYXBlTGF5ZXJzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjYWRkRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLiNvbmtleWRvd24sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICAjb25rZXlkb3duID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ICE9PSBrYmQuRVNDQVBFIHx8ICFpc1Jlc3BvbnNpYmxlRXNjYXBlTGF5ZXIodGhpcykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsb25lZEV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoZS50eXBlLCBlKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBiZWhhdmlvclR5cGUgPSB0aGlzLiNiZWhhdmlvclR5cGUuY3VycmVudDtcbiAgICAgICAgaWYgKGJlaGF2aW9yVHlwZSAhPT0gXCJjbG9zZVwiICYmIGJlaGF2aW9yVHlwZSAhPT0gXCJkZWZlci1vdGhlcndpc2UtY2xvc2VcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4jb25Fc2NhcGVQcm9wLmN1cnJlbnQoY2xvbmVkRXZlbnQpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlRXNjYXBlTGF5ZXIocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IEVzY2FwZUxheWVyU3RhdGUocHJvcHMpO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zaWJsZUVzY2FwZUxheWVyKGluc3RhbmNlKSB7XG4gICAgY29uc3QgbGF5ZXJzQXJyID0gWy4uLmdsb2JhbFRoaXMuYml0c0VzY2FwZUxheWVyc107XG4gICAgLyoqXG4gICAgICogV2UgZmlyc3QgY2hlY2sgaWYgd2UgY2FuIGZpbmQgYSB0b3AgbGF5ZXIgd2l0aCBgY2xvc2VgIG9yIGBpZ25vcmVgLlxuICAgICAqIElmIHRoYXQgdG9wIGxheWVyIHdhcyBmb3VuZCBhbmQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgbm9kZSwgdGhlbiB0aGUgbm9kZSBpc1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciB0aGUgZXNjYXBlLiBPdGhlcndpc2UsIHdlIGtub3cgdGhhdCBhbGwgbGF5ZXJzIGRlZmVyIHNvXG4gICAgICogdGhlIGZpcnN0IGxheWVyIGlzIHRoZSByZXNwb25zaWJsZSBvbmUuXG4gICAgICovXG4gICAgY29uc3QgdG9wTW9zdExheWVyID0gbGF5ZXJzQXJyLmZpbmRMYXN0KChbXywgeyBjdXJyZW50OiBiZWhhdmlvclR5cGUgfV0pID0+IGJlaGF2aW9yVHlwZSA9PT0gXCJjbG9zZVwiIHx8IGJlaGF2aW9yVHlwZSA9PT0gXCJpZ25vcmVcIik7XG4gICAgaWYgKHRvcE1vc3RMYXllcilcbiAgICAgICAgcmV0dXJuIHRvcE1vc3RMYXllclswXSA9PT0gaW5zdGFuY2U7XG4gICAgY29uc3QgW2ZpcnN0TGF5ZXJOb2RlXSA9IGxheWVyc0FyclswXTtcbiAgICByZXR1cm4gZmlyc3RMYXllck5vZGUgPT09IGluc3RhbmNlO1xufVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94IH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IEVzY2FwZUxheWVySW1wbFByb3BzIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlRXNjYXBlTGF5ZXIgfSBmcm9tIFwiLi91c2VFc2NhcGVMYXllci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHsgbm9vcCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9ub29wLmpzXCI7XG5cblx0bGV0IHtcblx0XHRlc2NhcGVLZXlkb3duQmVoYXZpb3IgPSBcImNsb3NlXCIsXG5cdFx0b25Fc2NhcGVLZXlkb3duID0gbm9vcCxcblx0XHRjaGlsZHJlbixcblx0XHRlbmFibGVkLFxuXHR9OiBFc2NhcGVMYXllckltcGxQcm9wcyA9ICRwcm9wcygpO1xuXG5cdHVzZUVzY2FwZUxheWVyKHtcblx0XHRlc2NhcGVLZXlkb3duQmVoYXZpb3I6IGJveC53aXRoKCgpID0+IGVzY2FwZUtleWRvd25CZWhhdmlvciksXG5cdFx0b25Fc2NhcGVLZXlkb3duOiBib3gud2l0aCgoKSA9PiBvbkVzY2FwZUtleWRvd24pLFxuXHRcdGVuYWJsZWQ6IGJveC53aXRoKCgpID0+IGVuYWJsZWQpLFxuXHR9KTtcbjwvc2NyaXB0PlxuXG57QHJlbmRlciBjaGlsZHJlbj8uKCl9XG4iLCJpbXBvcnQgeyBib3ggfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcbmNvbnN0IGZvY3VzU3RhY2sgPSBib3goW10pO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvY3VzU2NvcGVTdGFjaygpIHtcbiAgICBjb25zdCBzdGFjayA9IGZvY3VzU3RhY2s7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkKGZvY3VzU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIHBhdXNlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZvY3VzIHNjb3BlICh0b3Agb2YgdGhlIHN0YWNrKVxuICAgICAgICAgICAgY29uc3QgYWN0aXZlRm9jdXNTY29wZSA9IHN0YWNrLmN1cnJlbnRbMF07XG4gICAgICAgICAgICBpZiAoZm9jdXNTY29wZS5pZCAhPT0gYWN0aXZlRm9jdXNTY29wZT8uaWQpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVGb2N1c1Njb3BlPy5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGluIGNhc2UgaXQgYWxyZWFkeSBleGlzdHMgYmVjYXVzZSBpdCdsbCBiZSBhZGRlZCB0byB0aGUgdG9wXG4gICAgICAgICAgICBzdGFjay5jdXJyZW50ID0gcmVtb3ZlRnJvbUZvY3VzU2NvcGVBcnJheShzdGFjay5jdXJyZW50LCBmb2N1c1Njb3BlKTtcbiAgICAgICAgICAgIHN0YWNrLmN1cnJlbnQudW5zaGlmdChmb2N1c1Njb3BlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlKGZvY3VzU2NvcGUpIHtcbiAgICAgICAgICAgIHN0YWNrLmN1cnJlbnQgPSByZW1vdmVGcm9tRm9jdXNTY29wZUFycmF5KHN0YWNrLmN1cnJlbnQsIGZvY3VzU2NvcGUpO1xuICAgICAgICAgICAgc3RhY2suY3VycmVudFswXT8ucmVzdW1lKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb2N1c1Njb3BlQVBJKCkge1xuICAgIGxldCBwYXVzZWQgPSAkc3RhdGUoZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB1c2VJZCgpLFxuICAgICAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdXNlZDtcbiAgICAgICAgfSxcbiAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bWUoKSB7XG4gICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUZvY3VzU2NvcGVBcnJheShhcnIsIGl0ZW0pIHtcbiAgICByZXR1cm4gWy4uLmFycl0uZmlsdGVyKChpKSA9PiBpLmlkICE9PSBpdGVtLmlkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMaW5rcyhpdGVtcykge1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGFnTmFtZSAhPT0gXCJBXCIpO1xufVxuIiwiaW1wb3J0IHsgaXNCcm93c2VyLCBpc0VsZW1lbnRIaWRkZW4sIGlzU2VsZWN0YWJsZUlucHV0IH0gZnJvbSBcIi4vaXMuanNcIjtcbi8qKlxuICogSGFuZGxlcyBgaW5pdGlhbEZvY3VzYCBwcm9wIGJlaGF2aW9yIGZvciB0aGVcbiAqIENhbGVuZGFyICYgUmFuZ2VDYWxlbmRhciBjb21wb25lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ2FsZW5kYXJJbml0aWFsRm9jdXMoY2FsZW5kYXIpIHtcbiAgICBpZiAoIWlzQnJvd3NlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNlbGVjdGVkRGF5ID0gY2FsZW5kYXIucXVlcnlTZWxlY3RvcihcIltkYXRhLXNlbGVjdGVkXVwiKTtcbiAgICBpZiAoc2VsZWN0ZWREYXkpXG4gICAgICAgIHJldHVybiBmb2N1c1dpdGhvdXRTY3JvbGwoc2VsZWN0ZWREYXkpO1xuICAgIGNvbnN0IHRvZGF5ID0gY2FsZW5kYXIucXVlcnlTZWxlY3RvcihcIltkYXRhLXRvZGF5XVwiKTtcbiAgICBpZiAodG9kYXkpXG4gICAgICAgIHJldHVybiBmb2N1c1dpdGhvdXRTY3JvbGwodG9kYXkpO1xuICAgIGNvbnN0IGZpcnN0RGF5ID0gY2FsZW5kYXIucXVlcnlTZWxlY3RvcihcIltkYXRhLWNhbGVuZGFyLWRhdGVdXCIpO1xuICAgIGlmIChmaXJzdERheSlcbiAgICAgICAgcmV0dXJuIGZvY3VzV2l0aG91dFNjcm9sbChmaXJzdERheSk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGZvY3VzZXMgYW4gZWxlbWVudCB3aXRob3V0IHNjcm9sbGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvY3VzV2l0aG91dFNjcm9sbChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgfTtcbiAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFBvc2l0aW9uLngsIHNjcm9sbFBvc2l0aW9uLnkpO1xufVxuLyoqXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBmb2N1c2VzIGFuIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb2N1cyhlbGVtZW50LCB7IHNlbGVjdCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmICghKGVsZW1lbnQgJiYgZWxlbWVudC5mb2N1cykpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIC8vIHByZXZlbnQgc2Nyb2xsIG9uIGZvY3VzXG4gICAgZWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgLy8gb25seSBlbGVjdCBpZiBpdHMgbm90IHRoZSBzYW1lIGVsZW1lbnQsIGl0IHN1cHBvcnRzIHNlbGVjdGlvbiwgYW5kIHdlIG5lZWQgdG8gc2VsZWN0IGl0XG4gICAgaWYgKGVsZW1lbnQgIT09IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCAmJiBpc1NlbGVjdGFibGVJbnB1dChlbGVtZW50KSAmJiBzZWxlY3QpIHtcbiAgICAgICAgZWxlbWVudC5zZWxlY3QoKTtcbiAgICB9XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgbGlzdCBvZiBjYW5kaWRhdGVzLlxuICogU3RvcHMgd2hlbiBmb2N1cyBpcyBzdWNjZXNzZnVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9jdXNGaXJzdChjYW5kaWRhdGVzLCB7IHNlbGVjdCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICBmb2N1cyhjYW5kaWRhdGUsIHsgc2VsZWN0IH0pO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgdmlzaWJsZSBlbGVtZW50IGluIGEgbGlzdC5cbiAqIE5PVEU6IE9ubHkgY2hlY2tzIHZpc2liaWxpdHkgdXAgdG8gdGhlIGBjb250YWluZXJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFZpc2libGUoZWxlbWVudHMsIGNvbnRhaW5lcikge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyB3ZSBzdG9wIGNoZWNraW5nIGlmIGl0J3MgaGlkZGVuIGF0IHRoZSBgY29udGFpbmVyYCBsZXZlbCAoZXhjbHVkaW5nKVxuICAgICAgICBpZiAoIWlzRWxlbWVudEhpZGRlbihlbGVtZW50LCBjb250YWluZXIpKVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBwb3RlbnRpYWwgdGFiYmFibGUgY2FuZGlkYXRlcy5cbiAqXG4gKiBOT1RFOiBUaGlzIGlzIG9ubHkgYSBjbG9zZSBhcHByb3hpbWF0aW9uLiBGb3IgZXhhbXBsZSBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IGNhc2VzIGxpa2Ugd2hlblxuICogZWxlbWVudHMgYXJlIG5vdCB2aXNpYmxlLiBUaGlzIGNhbm5vdCBiZSB3b3JrZWQgb3V0IGVhc2lseSBieSBqdXN0IHJlYWRpbmcgYSBwcm9wZXJ0eSwgYnV0IHJhdGhlclxuICogbmVjZXNzaXRhdGUgcnVudGltZSBrbm93bGVkZ2UgKGNvbXB1dGVkIHN0eWxlcywgZXRjKS4gV2UgZGVhbCB3aXRoIHRoZXNlIGNhc2VzIHNlcGFyYXRlbHkuXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJlZVdhbGtlclxuICogQ3JlZGl0OiBodHRwczovL2dpdGh1Yi5jb20vZGlzY29yZC9mb2N1cy1sYXllcnMvYmxvYi9tYXN0ZXIvc3JjL3V0aWwvd3JhcEZvY3VzLnRzeCNMMVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihjb250YWluZXIsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0cy9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgYWNjZXB0Tm9kZTogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzSGlkZGVuSW5wdXQgPSBub2RlLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBub2RlLnR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5kaXNhYmxlZCB8fCBub2RlLmhpZGRlbiB8fCBpc0hpZGRlbklucHV0KVxuICAgICAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICAgICAgLy8gYC50YWJJbmRleGAgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZS4gSXQgd29ya3Mgb24gdGhlXG4gICAgICAgICAgICAvLyBydW50aW1lJ3MgdW5kZXJzdGFuZGluZyBvZiB0YWJiYWJpbGl0eSwgc28gdGhpcyBhdXRvbWF0aWNhbGx5IGFjY291bnRzXG4gICAgICAgICAgICAvLyBmb3IgYW55IGtpbmQgb2YgZWxlbWVudCB0aGF0IGNvdWxkIGJlIHRhYmJlZCB0by5cbiAgICAgICAgICAgIHJldHVybiBub2RlLnRhYkluZGV4ID49IDAgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSlcbiAgICAgICAgbm9kZXMucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpO1xuICAgIC8vIHdlIGRvIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgb3JkZXIgb2Ygbm9kZXMgd2l0aCBwb3NpdGl2ZSBgdGFiSW5kZXhgIGFzIGl0XG4gICAgLy8gaGluZGVycyBhY2Nlc3NpYmlsaXR5IHRvIGhhdmUgdGFiIG9yZGVyIGRpZmZlcmVudCBmcm9tIHZpc3VhbCBvcmRlci5cbiAgICByZXR1cm4gbm9kZXM7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnRzIHdpdGhpbiBhIGNvbnRhaW5lciB0aGF0IGFyZVxuICogdmlzaWJsZSBhbmQgZm9jdXNhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIpIHtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcik7XG4gICAgY29uc3QgZmlyc3QgPSBmaW5kVmlzaWJsZShjYW5kaWRhdGVzLCBjb250YWluZXIpO1xuICAgIGNvbnN0IGxhc3QgPSBmaW5kVmlzaWJsZShjYW5kaWRhdGVzLnJldmVyc2UoKSwgY29udGFpbmVyKTtcbiAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbn1cbiIsImltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBhZnRlclRpY2ssIGJveCwgZXhlY3V0ZUNhbGxiYWNrcywgdXNlUmVmQnlJZCB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcbmltcG9ydCB7IGNyZWF0ZUZvY3VzU2NvcGVBUEksIGNyZWF0ZUZvY3VzU2NvcGVTdGFjaywgcmVtb3ZlTGlua3MsIH0gZnJvbSBcIi4vZm9jdXMtc2NvcGUtc3RhY2suc3ZlbHRlLmpzXCI7XG5pbXBvcnQgeyBmb2N1cywgZm9jdXNGaXJzdCwgZ2V0VGFiYmFibGVDYW5kaWRhdGVzLCBnZXRUYWJiYWJsZUVkZ2VzIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2ZvY3VzLmpzXCI7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2V2ZW50cy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9pcy5qc1wiO1xuaW1wb3J0IHsga2JkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2tiZC5qc1wiO1xuY29uc3QgQVVUT0ZPQ1VTX09OX01PVU5UID0gXCJmb2N1c1Njb3BlLmF1dG9Gb2N1c09uTW91bnRcIjtcbmNvbnN0IEFVVE9GT0NVU19PTl9ERVNUUk9ZID0gXCJmb2N1c1Njb3BlLmF1dG9Gb2N1c09uRGVzdHJveVwiO1xuY29uc3QgRVZFTlRfT1BUSU9OUyA9IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IHRydWUgfTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1Njb3BlKHsgaWQsIGxvb3AsIGVuYWJsZWQsIG9uT3BlbkF1dG9Gb2N1cywgb25DbG9zZUF1dG9Gb2N1cywgZm9yY2VNb3VudCwgfSkge1xuICAgIGNvbnN0IGZvY3VzU2NvcGVTdGFjayA9IGNyZWF0ZUZvY3VzU2NvcGVTdGFjaygpO1xuICAgIGNvbnN0IGZvY3VzU2NvcGUgPSBjcmVhdGVGb2N1c1Njb3BlQVBJKCk7XG4gICAgY29uc3QgcmVmID0gYm94KG51bGwpO1xuICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICBpZCxcbiAgICAgICAgcmVmLFxuICAgICAgICBkZXBzOiAoKSA9PiBlbmFibGVkLmN1cnJlbnQsXG4gICAgfSk7XG4gICAgbGV0IGxhc3RGb2N1c2VkRWxlbWVudCA9ICRzdGF0ZShudWxsKTtcbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWVuYWJsZWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNJbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGZvY3VzU2NvcGUucGF1c2VkIHx8ICFjb250YWluZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgbGFzdEZvY3VzZWRFbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9jdXMobGFzdEZvY3VzZWRFbGVtZW50LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVGb2N1c091dChldmVudCkge1xuICAgICAgICAgICAgaWYgKGZvY3VzU2NvcGUucGF1c2VkIHx8ICFjb250YWluZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoIWlzSFRNTEVsZW1lbnQocmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQSBgZm9jdXNvdXRgIGV2ZW50IHdpdGggYSBgbnVsbGAgYHJlbGF0ZWRUYXJnZXRgIHdpbGwgaGFwcGVuIGluIGF0IGxlYXN0IHR3byBjYXNlczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAxLiBXaGVuIHRoZSB1c2VyIHN3aXRjaGVzIGFwcC90YWJzL3dpbmRvd3MvdGhlIGJyb3dzZXIgaXRzZWxmIGxvc2VzIGZvY3VzLlxuICAgICAgICAgICAgLy8gMi4gSW4gR29vZ2xlIENocm9tZSwgd2hlbiB0aGUgZm9jdXNlZCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdlIGxldCB0aGUgYnJvd3NlciBkbyBpdHMgdGhpbmcgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDEuIFRoZSBicm93c2VyIGFscmVhZHkga2VlcHMgYSBtZW1vcnkgb2Ygd2hhdCdzIGZvY3VzZWQgZm9yIHdoZW4gdGhlXG4gICAgICAgICAgICAvLyBwYWdlIGdldHMgcmVmb2N1c2VkLlxuICAgICAgICAgICAgLy8gMi4gSW4gR29vZ2xlIENocm9tZSwgaWYgd2UgdHJ5IHRvIGZvY3VzIHRoZSBkZWxldGVkIGZvY3VzZWQgZWxlbWVudCBpdCB0aHJvd3NcbiAgICAgICAgICAgIC8vIHRoZSBDUFUgdG8gMTAwJSwgc28gd2UgYXZvaWQgZG9pbmcgYW55dGhpbmcgZm9yIHRoaXMgcmVhc29uIGhlcmUgdG9vLlxuICAgICAgICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZvY3VzIGhhcyBtb3ZlZCB0byBhbiBhY3R1YWwgbGVnaXRpbWF0ZSBlbGVtZW50IChgcmVsYXRlZFRhcmdldCAhPT0gbnVsbGApXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG91dHNpZGUgdGhlIGNvbnRhaW5lciwgd2UgbW92ZSBmb2N1cyB0byB0aGUgbGFzdCB2YWxpZCBmb2N1c2VkIGVsZW1lbnQgaW5zaWRlLlxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuY29udGFpbnMocmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgZm9jdXMobGFzdEZvY3VzZWRFbGVtZW50LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBmb2N1c2VkIGVsZW1lbnQgZ2V0cyByZW1vdmVkIGZyb20gdGhlIERPTSwgYnJvd3NlcnMgbW92ZSBmb2N1c1xuICAgICAgICAvLyBiYWNrIHRvIHRoZSBkb2N1bWVudC5ib2R5LiBJbiB0aGlzIGNhc2UsIHdlIG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICAvLyB0byBrZWVwIGZvY3VzIHRyYXBwZWQgY29ycmVjdGx5LlxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGxlYW5pbmcgb24gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgd2UgdXNlIGxhc3RGb2N1c2VkRWxlbWVudCB0byBjaGVja1xuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBzdGlsbCBleGlzdHMgaW5zaWRlIHRoZSBjb250YWluZXIsXG4gICAgICAgIC8vIGlmIG5vdCB0aGVuIHdlIGZvY3VzIHRvIHRoZSBjb250YWluZXJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTXV0YXRpb25zKF8pIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RGb2N1c2VkRWxlbWVudEV4aXN0cyA9IGNvbnRhaW5lcj8uY29udGFpbnMobGFzdEZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghbGFzdEZvY3VzZWRFbGVtZW50RXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgZm9jdXMoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW50cmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bnN1YkV2ZW50cyA9IGV4ZWN1dGVDYWxsYmFja3MoYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzSW4pLCBhZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcImZvY3Vzb3V0XCIsIGhhbmRsZUZvY3VzT3V0KSk7XG4gICAgICAgICAgICBjb25zdCBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zKTtcbiAgICAgICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YkV2ZW50cygpO1xuICAgICAgICAgICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChmb3JjZU1vdW50LmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250YWluZXIgPSByZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdW50cmFjaygoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVNb3VudChjb250YWluZXIsIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlRGVzdHJveShwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWZvcmNlTW91bnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZW5hYmxlZC5jdXJyZW50O1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSByZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdW50cmFjaygoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVNb3VudChjb250YWluZXIsIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlRGVzdHJveShwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdW50KGNvbnRhaW5lciwgcHJldkZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQuY3VycmVudCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb2N1c1Njb3BlU3RhY2suYWRkKGZvY3VzU2NvcGUpO1xuICAgICAgICBjb25zdCBoYXNGb2N1c2VkQ2FuZGlkYXRlID0gY29udGFpbmVyLmNvbnRhaW5zKHByZXZGb2N1c2VkRWxlbWVudCk7XG4gICAgICAgIGlmICghaGFzRm9jdXNlZENhbmRpZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgbW91bnRFdmVudCA9IG5ldyBDdXN0b21FdmVudChBVVRPRk9DVVNfT05fTU9VTlQsIEVWRU5UX09QVElPTlMpO1xuICAgICAgICAgICAgb25PcGVuQXV0b0ZvY3VzLmN1cnJlbnQobW91bnRFdmVudCk7XG4gICAgICAgICAgICBpZiAoIW1vdW50RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIGFmdGVyVGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBmb2N1c0ZpcnN0KHJlbW92ZUxpbmtzKGdldFRhYmJhYmxlQ2FuZGlkYXRlcyhjb250YWluZXIpKSwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBwcmV2Rm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVEZXN0cm95KHByZXZGb2N1c2VkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBkZXN0cm95RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoQVVUT0ZPQ1VTX09OX0RFU1RST1ksIEVWRU5UX09QVElPTlMpO1xuICAgICAgICBvbkNsb3NlQXV0b0ZvY3VzLmN1cnJlbnQoZGVzdHJveUV2ZW50KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRlc3Ryb3lFdmVudC5kZWZhdWx0UHJldmVudGVkICYmIHByZXZGb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGZvY3VzKHByZXZGb2N1c2VkRWxlbWVudCA/PyBkb2N1bWVudC5ib2R5LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvY3VzU2NvcGVTdGFjay5yZW1vdmUoZm9jdXNTY29wZSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKCFlbmFibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghbG9vcC5jdXJyZW50ICYmICFlbmFibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNUYWJLZXkgPSBlLmtleSA9PT0ga2JkLlRBQiAmJiAhZS5jdHJsS2V5ICYmICFlLmFsdEtleSAmJiAhZS5tZXRhS2V5O1xuICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICghKGlzVGFiS2V5ICYmIGZvY3VzZWRFbGVtZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBbZmlyc3QsIGxhc3RdID0gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIpO1xuICAgICAgICBjb25zdCBoYXNUYWJiYWJsZUVsZW1lbnRzSW5zaWRlID0gZmlyc3QgJiYgbGFzdDtcbiAgICAgICAgaWYgKCFoYXNUYWJiYWJsZUVsZW1lbnRzSW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSAmJiBmb2N1c2VkRWxlbWVudCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAobG9vcC5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICBmb2N1cyhmaXJzdCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnNoaWZ0S2V5ICYmIGZvY3VzZWRFbGVtZW50ID09PSBmaXJzdCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAobG9vcC5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICBmb2N1cyhsYXN0LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiBpZC5jdXJyZW50LFxuICAgICAgICB0YWJpbmRleDogLTEsXG4gICAgICAgIG9ua2V5ZG93bjogaGFuZGxlS2V5ZG93bixcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IHByb3BzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3ggfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgRm9jdXNTY29wZUltcGxQcm9wcyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZUZvY3VzU2NvcGUgfSBmcm9tIFwiLi91c2VGb2N1c1Njb3BlLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyBub29wIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL25vb3AuanNcIjtcblxuXHRsZXQge1xuXHRcdGlkLFxuXHRcdHRyYXBGb2N1cyA9IGZhbHNlLFxuXHRcdGxvb3AgPSBmYWxzZSxcblx0XHRvbkNsb3NlQXV0b0ZvY3VzID0gbm9vcCxcblx0XHRvbk9wZW5BdXRvRm9jdXMgPSBub29wLFxuXHRcdGZvY3VzU2NvcGUsXG5cdFx0Zm9yY2VNb3VudCA9IGZhbHNlLFxuXHR9OiBGb2N1c1Njb3BlSW1wbFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgZm9jdXNTY29wZVN0YXRlID0gdXNlRm9jdXNTY29wZSh7XG5cdFx0ZW5hYmxlZDogYm94LndpdGgoKCkgPT4gdHJhcEZvY3VzKSxcblx0XHRsb29wOiBib3gud2l0aCgoKSA9PiBsb29wKSxcblx0XHRvbkNsb3NlQXV0b0ZvY3VzOiBib3gud2l0aCgoKSA9PiBvbkNsb3NlQXV0b0ZvY3VzKSxcblx0XHRvbk9wZW5BdXRvRm9jdXM6IGJveC53aXRoKCgpID0+IG9uT3BlbkF1dG9Gb2N1cyksXG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRmb3JjZU1vdW50OiBib3gud2l0aCgoKSA9PiBmb3JjZU1vdW50KSxcblx0fSk7XG48L3NjcmlwdD5cblxue0ByZW5kZXIgZm9jdXNTY29wZT8uKHsgcHJvcHM6IGZvY3VzU2NvcGVTdGF0ZS5wcm9wcyB9KX1cbiIsImltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBib3gsIGNvbXBvc2VIYW5kbGVycywgZXhlY3V0ZUNhbGxiYWNrcywgdXNlUmVmQnlJZCwgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2V2ZW50cy5qc1wiO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9ub29wLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2lzLmpzXCI7XG5pbXBvcnQgeyBpc09yQ29udGFpbnNUYXJnZXQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvZWxlbWVudHMuanNcIjtcbmdsb2JhbFRoaXMuYml0c1RleHRTZWxlY3Rpb25MYXllcnMgPz89IG5ldyBNYXAoKTtcbmV4cG9ydCBjbGFzcyBUZXh0U2VsZWN0aW9uTGF5ZXJTdGF0ZSB7XG4gICAgI2lkO1xuICAgICNvblBvaW50ZXJEb3duUHJvcDtcbiAgICAjb25Qb2ludGVyVXBQcm9wO1xuICAgICNlbmFibGVkO1xuICAgICN1bnN1YlNlbGVjdGlvbkxvY2sgPSBub29wO1xuICAgICNyZWYgPSBib3gobnVsbCk7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jZW5hYmxlZCA9IHByb3BzLnByZXZlbnRPdmVyZmxvd1RleHRTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuI29uUG9pbnRlckRvd25Qcm9wID0gcHJvcHMub25Qb2ludGVyRG93bjtcbiAgICAgICAgdGhpcy4jb25Qb2ludGVyVXBQcm9wID0gcHJvcHMub25Qb2ludGVyVXA7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLiNlbmFibGVkLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdW5zdWJFdmVudHMgPSBub29wO1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNlbmFibGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmJpdHNUZXh0U2VsZWN0aW9uTGF5ZXJzLnNldCh0aGlzLCB1bnRyYWNrKCgpID0+IHRoaXMuI2VuYWJsZWQpKTtcbiAgICAgICAgICAgICAgICB1bnN1YkV2ZW50cyA9IHRoaXMuI2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3ViRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVzZXRTZWxlY3Rpb25Mb2NrKCk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5iaXRzVGV4dFNlbGVjdGlvbkxheWVycy5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgI2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZUNhbGxiYWNrcyhhZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInBvaW50ZXJkb3duXCIsIHRoaXMuI3BvaW50ZXJkb3duKSwgYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJwb2ludGVydXBcIiwgY29tcG9zZUhhbmRsZXJzKHRoaXMuI3Jlc2V0U2VsZWN0aW9uTG9jaywgdGhpcy4jb25Qb2ludGVyVXBQcm9wKSkpO1xuICAgIH1cbiAgICAjcG9pbnRlcmRvd24gPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy4jcmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoIWlzSFRNTEVsZW1lbnQobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQodGFyZ2V0KSB8fCAhdGhpcy4jZW5hYmxlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2Ugb25seSBsb2NrIHVzZXItc2VsZWN0aW9uIG92ZXJmbG93IGlmIGxheWVyIGlzIHRoZSB0b3AgbW9zdCBsYXllciBhbmRcbiAgICAgICAgICogcG9pbnRlcmRvd24gb2NjdXJyZWQgaW5zaWRlIHRoZSBub2RlLiBZb3UgYXJlIHN0aWxsIGFsbG93ZWQgdG8gc2VsZWN0IHRleHRcbiAgICAgICAgICogb3V0c2lkZSB0aGUgbm9kZSBwcm92aWRlZCBwb2ludGVyZG93biBvY2N1cnMgb3V0c2lkZSB0aGUgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghaXNIaWdoZXN0TGF5ZXIodGhpcykgfHwgIWlzT3JDb250YWluc1RhcmdldChub2RlLCB0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiNvblBvaW50ZXJEb3duUHJvcC5jdXJyZW50KGUpO1xuICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiN1bnN1YlNlbGVjdGlvbkxvY2sgPSBwcmV2ZW50VGV4dFNlbGVjdGlvbk92ZXJmbG93KG5vZGUpO1xuICAgIH07XG4gICAgI3Jlc2V0U2VsZWN0aW9uTG9jayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy4jdW5zdWJTZWxlY3Rpb25Mb2NrKCk7XG4gICAgICAgIHRoaXMuI3Vuc3ViU2VsZWN0aW9uTG9jayA9IG5vb3A7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VUZXh0U2VsZWN0aW9uTGF5ZXIocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb25MYXllclN0YXRlKHByb3BzKTtcbn1cbmNvbnN0IGdldFVzZXJTZWxlY3QgPSAobm9kZSkgPT4gbm9kZS5zdHlsZS51c2VyU2VsZWN0IHx8IG5vZGUuc3R5bGUud2Via2l0VXNlclNlbGVjdDtcbmZ1bmN0aW9uIHByZXZlbnRUZXh0U2VsZWN0aW9uT3ZlcmZsb3cobm9kZSkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IG9yaWdpbmFsQm9keVVzZXJTZWxlY3QgPSBnZXRVc2VyU2VsZWN0KGJvZHkpO1xuICAgIGNvbnN0IG9yaWdpbmFsTm9kZVVzZXJTZWxlY3QgPSBnZXRVc2VyU2VsZWN0KG5vZGUpO1xuICAgIHNldFVzZXJTZWxlY3QoYm9keSwgXCJub25lXCIpO1xuICAgIHNldFVzZXJTZWxlY3Qobm9kZSwgXCJ0ZXh0XCIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNldFVzZXJTZWxlY3QoYm9keSwgb3JpZ2luYWxCb2R5VXNlclNlbGVjdCk7XG4gICAgICAgIHNldFVzZXJTZWxlY3Qobm9kZSwgb3JpZ2luYWxOb2RlVXNlclNlbGVjdCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNldFVzZXJTZWxlY3Qobm9kZSwgdmFsdWUpIHtcbiAgICBub2RlLnN0eWxlLnVzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgICBub2RlLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzSGlnaGVzdExheWVyKGluc3RhbmNlKSB7XG4gICAgY29uc3QgbGF5ZXJzQXJyID0gWy4uLmdsb2JhbFRoaXMuYml0c1RleHRTZWxlY3Rpb25MYXllcnNdO1xuICAgIGlmICghbGF5ZXJzQXJyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhpZ2hlc3RMYXllciA9IGxheWVyc0Fyci5hdCgtMSk7XG4gICAgaWYgKCFoaWdoZXN0TGF5ZXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaGlnaGVzdExheWVyWzBdID09PSBpbnN0YW5jZTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHR5cGUgeyBUZXh0U2VsZWN0aW9uTGF5ZXJJbXBsUHJvcHMgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VUZXh0U2VsZWN0aW9uTGF5ZXIgfSBmcm9tIFwiLi91c2VUZXh0U2VsZWN0aW9uTGF5ZXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB7IG5vb3AgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvbm9vcC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0cHJldmVudE92ZXJmbG93VGV4dFNlbGVjdGlvbiA9IHRydWUsXG5cdFx0b25Qb2ludGVyRG93biA9IG5vb3AsXG5cdFx0b25Qb2ludGVyVXAgPSBub29wLFxuXHRcdGlkLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGVuYWJsZWQsXG5cdH06IFRleHRTZWxlY3Rpb25MYXllckltcGxQcm9wcyA9ICRwcm9wcygpO1xuXG5cdHVzZVRleHRTZWxlY3Rpb25MYXllcih7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRwcmV2ZW50T3ZlcmZsb3dUZXh0U2VsZWN0aW9uOiBib3gud2l0aCgoKSA9PiBwcmV2ZW50T3ZlcmZsb3dUZXh0U2VsZWN0aW9uKSxcblx0XHRvblBvaW50ZXJEb3duOiBib3gud2l0aCgoKSA9PiBvblBvaW50ZXJEb3duKSxcblx0XHRvblBvaW50ZXJVcDogYm94LndpdGgoKCkgPT4gb25Qb2ludGVyVXApLFxuXHRcdGVuYWJsZWQ6IGJveC53aXRoKCgpID0+IGVuYWJsZWQpLFxuXHR9KTtcbjwvc2NyaXB0PlxuXG57QHJlbmRlciBjaGlsZHJlbj8uKCl9XG4iLCIvKiogQGltcG9ydCB7IFNvdXJjZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IHNldCwgc291cmNlIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpbmNyZW1lbnQgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBleHRlbmRzIHtNYXA8SywgVj59XG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVNYXAgZXh0ZW5kcyBNYXAge1xuXHQvKiogQHR5cGUge01hcDxLLCBTb3VyY2U8bnVtYmVyPj59ICovXG5cdCNzb3VyY2VzID0gbmV3IE1hcCgpO1xuXHQjdmVyc2lvbiA9IHNvdXJjZSgwKTtcblx0I3NpemUgPSBzb3VyY2UoMCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SXRlcmFibGU8cmVhZG9ubHkgW0ssIFZdPiB8IG51bGwgfCB1bmRlZmluZWR9IFt2YWx1ZV1cblx0ICovXG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8vIElmIHRoZSB2YWx1ZSBpcyBpbnZhbGlkIHRoZW4gdGhlIG5hdGl2ZSBleGNlcHRpb24gd2lsbCBmaXJlIGhlcmVcblx0XHRpZiAoREVWKSB2YWx1ZSA9IG5ldyBNYXAodmFsdWUpO1xuXG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRmb3IgKHZhciBba2V5LCB2XSBvZiB2YWx1ZSkge1xuXHRcdFx0XHRzdXBlci5zZXQoa2V5LCB2KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuI3NpemUudiA9IHN1cGVyLnNpemU7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEBwYXJhbSB7S30ga2V5ICovXG5cdGhhcyhrZXkpIHtcblx0XHR2YXIgc291cmNlcyA9IHRoaXMuI3NvdXJjZXM7XG5cdFx0dmFyIHMgPSBzb3VyY2VzLmdldChrZXkpO1xuXG5cdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIHJldCA9IHN1cGVyLmdldChrZXkpO1xuXHRcdFx0aWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHMgPSBzb3VyY2UoMCk7XG5cdFx0XHRcdHNvdXJjZXMuc2V0KGtleSwgcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIHRyYWNrIHRoZSB2ZXJzaW9uIGluIGNhc2Vcblx0XHRcdFx0Ly8gdGhlIFNldCBldmVyIGdldHMgdGhpcyB2YWx1ZSBpbiB0aGUgZnV0dXJlLlxuXHRcdFx0XHRnZXQodGhpcy4jdmVyc2lvbik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnZXQocyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHsodmFsdWU6IFYsIGtleTogSywgbWFwOiBNYXA8SywgVj4pID0+IHZvaWR9IGNhbGxiYWNrZm5cblx0ICogQHBhcmFtIHthbnl9IFt0aGlzX2FyZ11cblx0ICovXG5cdGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc19hcmcpIHtcblx0XHR0aGlzLiNyZWFkX2FsbCgpO1xuXHRcdHN1cGVyLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc19hcmcpO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7S30ga2V5ICovXG5cdGdldChrZXkpIHtcblx0XHR2YXIgc291cmNlcyA9IHRoaXMuI3NvdXJjZXM7XG5cdFx0dmFyIHMgPSBzb3VyY2VzLmdldChrZXkpO1xuXG5cdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIHJldCA9IHN1cGVyLmdldChrZXkpO1xuXHRcdFx0aWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHMgPSBzb3VyY2UoMCk7XG5cdFx0XHRcdHNvdXJjZXMuc2V0KGtleSwgcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIHRyYWNrIHRoZSB2ZXJzaW9uIGluIGNhc2Vcblx0XHRcdFx0Ly8gdGhlIFNldCBldmVyIGdldHMgdGhpcyB2YWx1ZSBpbiB0aGUgZnV0dXJlLlxuXHRcdFx0XHRnZXQodGhpcy4jdmVyc2lvbik7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2V0KHMpO1xuXHRcdHJldHVybiBzdXBlci5nZXQoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0t9IGtleVxuXHQgKiBAcGFyYW0ge1Z9IHZhbHVlXG5cdCAqICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0dmFyIHNvdXJjZXMgPSB0aGlzLiNzb3VyY2VzO1xuXHRcdHZhciBzID0gc291cmNlcy5nZXQoa2V5KTtcblx0XHR2YXIgcHJldl9yZXMgPSBzdXBlci5nZXQoa2V5KTtcblx0XHR2YXIgcmVzID0gc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuXHRcdHZhciB2ZXJzaW9uID0gdGhpcy4jdmVyc2lvbjtcblxuXHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHNvdXJjZXMuc2V0KGtleSwgc291cmNlKDApKTtcblx0XHRcdHNldCh0aGlzLiNzaXplLCBzdXBlci5zaXplKTtcblx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblx0XHR9IGVsc2UgaWYgKHByZXZfcmVzICE9PSB2YWx1ZSkge1xuXHRcdFx0aW5jcmVtZW50KHMpO1xuXG5cdFx0XHQvLyBpZiBub3QgZXZlcnkgcmVhY3Rpb24gb2YgcyBpcyBhIHJlYWN0aW9uIG9mIHZlcnNpb24gd2UgbmVlZCB0byBhbHNvIGluY2x1ZGUgdmVyc2lvblxuXHRcdFx0dmFyIHZfcmVhY3Rpb25zID0gdmVyc2lvbi5yZWFjdGlvbnMgPT09IG51bGwgPyBudWxsIDogbmV3IFNldCh2ZXJzaW9uLnJlYWN0aW9ucyk7XG5cdFx0XHR2YXIgbmVlZHNfdmVyc2lvbl9pbmNyZWFzZSA9XG5cdFx0XHRcdHZfcmVhY3Rpb25zID09PSBudWxsIHx8XG5cdFx0XHRcdCFzLnJlYWN0aW9ucz8uZXZlcnkoKHIpID0+XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2Ygdl9yZWFjdGlvbnM+fSAqLyAodl9yZWFjdGlvbnMpLmhhcyhyKVxuXHRcdFx0XHQpO1xuXHRcdFx0aWYgKG5lZWRzX3ZlcnNpb25faW5jcmVhc2UpIHtcblx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvKiogQHBhcmFtIHtLfSBrZXkgKi9cblx0ZGVsZXRlKGtleSkge1xuXHRcdHZhciBzb3VyY2VzID0gdGhpcy4jc291cmNlcztcblx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KGtleSk7XG5cdFx0dmFyIHJlcyA9IHN1cGVyLmRlbGV0ZShrZXkpO1xuXG5cdFx0aWYgKHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c291cmNlcy5kZWxldGUoa2V5KTtcblx0XHRcdHNldCh0aGlzLiNzaXplLCBzdXBlci5zaXplKTtcblx0XHRcdHNldChzLCAtMSk7XG5cdFx0XHRpbmNyZW1lbnQodGhpcy4jdmVyc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGNsZWFyKCkge1xuXHRcdGlmIChzdXBlci5zaXplID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIENsZWFyIGZpcnN0LCBzbyB3ZSBnZXQgbmljZSBjb25zb2xlLmxvZyBvdXRwdXRzIHdpdGggJGluc3BlY3Rcblx0XHRzdXBlci5jbGVhcigpO1xuXHRcdHZhciBzb3VyY2VzID0gdGhpcy4jc291cmNlcztcblx0XHRzZXQodGhpcy4jc2l6ZSwgMCk7XG5cdFx0Zm9yICh2YXIgcyBvZiBzb3VyY2VzLnZhbHVlcygpKSB7XG5cdFx0XHRzZXQocywgLTEpO1xuXHRcdH1cblx0XHRpbmNyZW1lbnQodGhpcy4jdmVyc2lvbik7XG5cdFx0c291cmNlcy5jbGVhcigpO1xuXHR9XG5cblx0I3JlYWRfYWxsKCkge1xuXHRcdGdldCh0aGlzLiN2ZXJzaW9uKTtcblxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy4jc291cmNlcztcblx0XHRpZiAodGhpcy4jc2l6ZS52ICE9PSBzb3VyY2VzLnNpemUpIHtcblx0XHRcdGZvciAodmFyIGtleSBvZiBzdXBlci5rZXlzKCkpIHtcblx0XHRcdFx0aWYgKCFzb3VyY2VzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQoa2V5LCBzb3VyY2UoMCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgWywgc10gb2YgdGhpcy4jc291cmNlcykge1xuXHRcdFx0Z2V0KHMpO1xuXHRcdH1cblx0fVxuXG5cdGtleXMoKSB7XG5cdFx0Z2V0KHRoaXMuI3ZlcnNpb24pO1xuXHRcdHJldHVybiBzdXBlci5rZXlzKCk7XG5cdH1cblxuXHR2YWx1ZXMoKSB7XG5cdFx0dGhpcy4jcmVhZF9hbGwoKTtcblx0XHRyZXR1cm4gc3VwZXIudmFsdWVzKCk7XG5cdH1cblxuXHRlbnRyaWVzKCkge1xuXHRcdHRoaXMuI3JlYWRfYWxsKCk7XG5cdFx0cmV0dXJuIHN1cGVyLmVudHJpZXMoKTtcblx0fVxuXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHJldHVybiB0aGlzLmVudHJpZXMoKTtcblx0fVxuXG5cdGdldCBzaXplKCkge1xuXHRcdGdldCh0aGlzLiNzaXplKTtcblx0XHRyZXR1cm4gc3VwZXIuc2l6ZTtcblx0fVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNoYXJlZEhvb2soZmFjdG9yeSkge1xuICAgIGxldCBzdWJzY3JpYmVycyA9IDA7XG4gICAgbGV0IHN0YXRlID0gJHN0YXRlKCk7XG4gICAgbGV0IHNjb3BlO1xuICAgIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgIHN1YnNjcmliZXJzIC09IDE7XG4gICAgICAgIGlmIChzY29wZSAmJiBzdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICAgICAgICBzY29wZSgpO1xuICAgICAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzY29wZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIHN1YnNjcmliZXJzICs9IDE7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY29wZSA9ICRlZmZlY3Qucm9vdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBmYWN0b3J5KC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBTdmVsdGVNYXAgfSBmcm9tIFwic3ZlbHRlL3JlYWN0aXZpdHlcIjtcbmltcG9ydCB7IGFmdGVyU2xlZXAsIGFmdGVyVGljaywgYm94IH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gXCJzdmVsdGVcIjtcbmltcG9ydCB7IGlzQnJvd3NlciwgaXNJT1MgfSBmcm9tIFwiLi9pcy5qc1wiO1xuaW1wb3J0IHsgYWRkRXZlbnRMaXN0ZW5lciB9IGZyb20gXCIuL2V2ZW50cy5qc1wiO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi91c2UtaWQuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVNoYXJlZEhvb2sgfSBmcm9tIFwiLi9jcmVhdGUtc2hhcmVkLWhvb2suc3ZlbHRlLmpzXCI7XG5jb25zdCB1c2VCb2R5TG9ja1N0YWNrQ291bnQgPSBjcmVhdGVTaGFyZWRIb29rKCgpID0+IHtcbiAgICBjb25zdCBtYXAgPSBuZXcgU3ZlbHRlTWFwKCk7XG4gICAgY29uc3QgbG9ja2VkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIGxldCBpbml0aWFsQm9keVN0eWxlID0gJHN0YXRlKHt9KTtcbiAgICBsZXQgc3RvcFRvdWNoTW92ZUxpc3RlbmVyID0gbnVsbDtcbiAgICBmdW5jdGlvbiByZXNldEJvZHlTdHlsZSgpIHtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gaW5pdGlhbEJvZHlTdHlsZS5wYWRkaW5nUmlnaHQgPz8gXCJcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW5SaWdodCA9IGluaXRpYWxCb2R5U3R5bGUubWFyZ2luUmlnaHQgPz8gXCJcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gaW5pdGlhbEJvZHlTdHlsZS5wb2ludGVyRXZlbnRzID8/IFwiXCI7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXNjcm9sbGJhci13aWR0aFwiKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IGluaXRpYWxCb2R5U3R5bGUub3ZlcmZsb3cgPz8gXCJcIjtcbiAgICAgICAgaXNJT1MgJiYgc3RvcFRvdWNoTW92ZUxpc3RlbmVyPy4oKTtcbiAgICB9XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBsb2NrZWQ7XG4gICAgICAgIHJldHVybiB1bnRyYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghY3Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHlTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICBpbml0aWFsQm9keVN0eWxlLm92ZXJmbG93ID0gYm9keVN0eWxlLm92ZXJmbG93O1xuICAgICAgICAgICAgaW5pdGlhbEJvZHlTdHlsZS5wYWRkaW5nUmlnaHQgPSBib2R5U3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgaW5pdGlhbEJvZHlTdHlsZS5tYXJnaW5SaWdodCA9IGJvZHlTdHlsZS5tYXJnaW5SaWdodDtcbiAgICAgICAgICAgIGluaXRpYWxCb2R5U3R5bGUucG9pbnRlckV2ZW50cyA9IGJvZHlTdHlsZS5wb2ludGVyRXZlbnRzO1xuICAgICAgICAgICAgLy8gVE9ETzogYWNjb3VudCBmb3IgUlRMIGRpcmVjdGlvbiwgZXRjLlxuICAgICAgICAgICAgY29uc3QgdmVydGljYWxTY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZ1JpZ2h0ID0gTnVtYmVyLnBhcnNlSW50KGluaXRpYWxCb2R5U3R5bGUucGFkZGluZ1JpZ2h0ID8/IFwiMFwiLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1JpZ2h0ICsgdmVydGljYWxTY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IE51bWJlci5wYXJzZUludChpbml0aWFsQm9keVN0eWxlLm1hcmdpblJpZ2h0ID8/IFwiMFwiLCAxMCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZlcnRpY2FsU2Nyb2xsYmFyV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtjb25maWcucGFkZGluZ31weGA7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW5SaWdodCA9IGAke2NvbmZpZy5tYXJnaW59cHhgO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoXCItLXNjcm9sbGJhci13aWR0aFwiLCBgJHt2ZXJ0aWNhbFNjcm9sbGJhcldpZHRofXB4YCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgICAgICAgICBzdG9wVG91Y2hNb3ZlTGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInRvdWNobW92ZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyVGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdG9wVG91Y2hNb3ZlTGlzdGVuZXI/LigpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBtYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LFxuICAgICAgICByZXNldEJvZHlTdHlsZSxcbiAgICB9O1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdXNlQm9keVNjcm9sbExvY2soaW5pdGlhbFN0YXRlLCByZXN0b3JlU2Nyb2xsRGVsYXkgPSAoKSA9PiBudWxsKSB7XG4gICAgY29uc3QgaWQgPSB1c2VJZCgpO1xuICAgIGNvbnN0IGNvdW50U3RhdGUgPSB1c2VCb2R5TG9ja1N0YWNrQ291bnQoKTtcbiAgICBjb25zdCBfcmVzdG9yZVNjcm9sbERlbGF5ID0gJGRlcml2ZWQocmVzdG9yZVNjcm9sbERlbGF5KCkpO1xuICAgIGNvdW50U3RhdGUubWFwLnNldChpZCwgaW5pdGlhbFN0YXRlID8/IGZhbHNlKTtcbiAgICBjb25zdCBsb2NrZWQgPSBib3gud2l0aCgoKSA9PiBjb3VudFN0YXRlLm1hcC5nZXQoaWQpID8/IGZhbHNlLCAodikgPT4gY291bnRTdGF0ZS5tYXAuc2V0KGlkLCB2KSk7XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb3VudFN0YXRlLm1hcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgLy8gaWYgYW55IGxvY2tzIGFyZSBzdGlsbCBhY3RpdmUsIHdlIGRvbid0IHJlc2V0IHRoZSBib2R5IHN0eWxlXG4gICAgICAgICAgICBpZiAoaXNBbnlMb2NrZWQoY291bnRTdGF0ZS5tYXApKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGlmIG5vIGxvY2tzIGFyZSBhY3RpdmUgKG1lYW5pbmcgdGhpcyB3YXMgdGhlIGxhc3QgbG9jayksIHdlIHJlc2V0IHRoZSBib2R5IHN0eWxlXG4gICAgICAgICAgICBpZiAoX3Jlc3RvcmVTY3JvbGxEZWxheSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBjb3VudFN0YXRlLnJlc2V0Qm9keVN0eWxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJTbGVlcChfcmVzdG9yZVNjcm9sbERlbGF5LCAoKSA9PiBjb3VudFN0YXRlLnJlc2V0Qm9keVN0eWxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBsb2NrZWQ7XG59XG5mdW5jdGlvbiBpc0FueUxvY2tlZChtYXApIHtcbiAgICBmb3IgKGNvbnN0IFtfLCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7IFNjcm9sbExvY2tQcm9wcyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cdGltcG9ydCB7IHVzZUJvZHlTY3JvbGxMb2NrIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1ib2R5LXNjcm9sbC1sb2NrLnN2ZWx0ZS5qc1wiO1xuXG5cdGxldCB7IHByZXZlbnRTY3JvbGwgPSB0cnVlLCByZXN0b3JlU2Nyb2xsRGVsYXkgPSBudWxsIH06IFNjcm9sbExvY2tQcm9wcyA9ICRwcm9wcygpO1xuXG5cdHVzZUJvZHlTY3JvbGxMb2NrKHByZXZlbnRTY3JvbGwsICgpID0+IHJlc3RvcmVTY3JvbGxEZWxheSk7XG48L3NjcmlwdD5cbiIsImV4cG9ydCBmdW5jdGlvbiBzaG91bGRUcmFwRm9jdXMoeyBmb3JjZU1vdW50LCBwcmVzZW50LCB0cmFwRm9jdXMsIG9wZW4sIH0pIHtcbiAgICBpZiAoZm9yY2VNb3VudCkge1xuICAgICAgICByZXR1cm4gb3BlbiAmJiB0cmFwRm9jdXM7XG4gICAgfVxuICAgIHJldHVybiBwcmVzZW50ICYmIHRyYXBGb2N1cyAmJiBvcGVuO1xufVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgeyB1c2VEaWFsb2dPdmVybGF5IH0gZnJvbSBcIi4uL2RpYWxvZy5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBEaWFsb2dPdmVybGF5UHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cdGltcG9ydCBQcmVzZW5jZUxheWVyIGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcHJlc2VuY2UtbGF5ZXIvcHJlc2VuY2UtbGF5ZXIuc3ZlbHRlXCI7XG5cblx0bGV0IHtcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Zm9yY2VNb3VudCA9IGZhbHNlLFxuXHRcdGNoaWxkLFxuXHRcdGNoaWxkcmVuLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nT3ZlcmxheVByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3Qgb3ZlcmxheVN0YXRlID0gdXNlRGlhbG9nT3ZlcmxheSh7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIG92ZXJsYXlTdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbjxQcmVzZW5jZUxheWVyIHtpZH0gcHJlc2VudD17b3ZlcmxheVN0YXRlLnJvb3Qub3Blbi5jdXJyZW50IHx8IGZvcmNlTW91bnR9PlxuXHR7I3NuaXBwZXQgcHJlc2VuY2UoKX1cblx0XHR7I2lmIGNoaWxkfVxuXHRcdFx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VQcm9wcyhtZXJnZWRQcm9wcyksIC4uLm92ZXJsYXlTdGF0ZS5zbmlwcGV0UHJvcHMgfSl9XG5cdFx0ezplbHNlfVxuXHRcdFx0PGRpdiB7Li4ubWVyZ2VQcm9wcyhtZXJnZWRQcm9wcyl9PlxuXHRcdFx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKG92ZXJsYXlTdGF0ZS5zbmlwcGV0UHJvcHMpfVxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblx0ey9zbmlwcGV0fVxuPC9QcmVzZW5jZUxheWVyPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgeyB1c2VEaWFsb2dUcmlnZ2VyIH0gZnJvbSBcIi4uL2RpYWxvZy5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBEaWFsb2dUcmlnZ2VyUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdGRpc2FibGVkID0gZmFsc2UsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IERpYWxvZ1RyaWdnZXJQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IHRyaWdnZXJTdGF0ZSA9IHVzZURpYWxvZ1RyaWdnZXIoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHRcdGRpc2FibGVkOiBib3gud2l0aCgoKSA9PiBCb29sZWFuKGRpc2FibGVkKSksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIHRyaWdnZXJTdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgY2hpbGR9XG5cdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuezplbHNlfVxuXHQ8YnV0dG9uIHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2J1dHRvbj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZURpYWxvZ0Rlc2NyaXB0aW9uIH0gZnJvbSBcIi4uL2RpYWxvZy5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBEaWFsb2dEZXNjcmlwdGlvblByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0aWQgPSB1c2VJZCgpLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nRGVzY3JpcHRpb25Qcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IGRlc2NyaXB0aW9uU3RhdGUgPSB1c2VEaWFsb2dEZXNjcmlwdGlvbih7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIGRlc2NyaXB0aW9uU3RhdGUucHJvcHMpKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcyB9KX1cbns6ZWxzZX1cblx0PGRpdiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC9kaXY+XG57L2lmfVxuIiwiaW1wb3J0IHsgc3JPbmx5U3R5bGVzU3RyaW5nIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2lzLmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgb3IgZ2V0cyBhbiBhbm5vdW5jZXIgZWxlbWVudCB3aGljaCBpcyB1c2VkIHRvIGFubm91bmNlIG1lc3NhZ2VzIHRvIHNjcmVlbiByZWFkZXJzLlxuICogV2l0aGluIHRoZSBkYXRlIGNvbXBvbmVudHMsIHdlIHVzZSB0aGlzIHRvIGFubm91bmNlIHdoZW4gdGhlIHZhbHVlcyBvZiB0aGUgaW5kaXZpZHVhbCBzZWdtZW50c1xuICogY2hhbmdlLCBhcyB3aXRob3V0IGl0IHdlIGdldCBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYWNyb3NzIHNjcmVlbiByZWFkZXJzLlxuICovXG5mdW5jdGlvbiBpbml0QW5ub3VuY2VyKCkge1xuICAgIGlmICghaXNCcm93c2VyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYml0cy1hbm5vdW5jZXJdXCIpO1xuICAgIGlmICghaXNIVE1MRWxlbWVudChlbCkpIHtcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBzck9ubHlTdHlsZXNTdHJpbmc7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWJpdHMtYW5ub3VuY2VyXCIsIFwiXCIpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoY3JlYXRlTG9nKFwiYXNzZXJ0aXZlXCIpKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGNyZWF0ZUxvZyhcInBvbGl0ZVwiKSk7XG4gICAgICAgIGVsID0gZGl2O1xuICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxvZyBlbGVtZW50IGZvciBhc3NlcnRpdmUgb3IgcG9saXRlIGFubm91bmNlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9nKGtpbmQpIHtcbiAgICAgICAgY29uc3QgbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbG9nLnJvbGUgPSBcImxvZ1wiO1xuICAgICAgICBsb2cuYXJpYUxpdmUgPSBraW5kO1xuICAgICAgICBsb2cuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLCBcImFkZGl0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIGxvZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsb2cgZWxlbWVudCBmb3IgYXNzZXJ0aXZlIG9yIHBvbGl0ZSBhbm5vdW5jZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldExvZyhraW5kKSB7XG4gICAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgbG9nID0gZWwucXVlcnlTZWxlY3RvcihgW2FyaWEtbGl2ZT1cIiR7a2luZH1cIl1gKTtcbiAgICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGxvZykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxvZztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0TG9nLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYW5ub3VuY2VyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYGFyaWEtbGl2ZWAgYW5ub3VuY2VtZW50cyB0byBzY3JlZW4gcmVhZGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFubm91bmNlcigpIHtcbiAgICBjb25zdCBhbm5vdW5jZXIgPSBpbml0QW5ub3VuY2VyKCk7XG4gICAgLyoqXG4gICAgICogQW5ub3VuY2VzIGEgbWVzc2FnZSB0byBzY3JlZW4gcmVhZGVycyB1c2luZyB0aGUgc3BlY2lmaWVkIGtpbmQgb2YgYW5ub3VuY2VtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFubm91bmNlKHZhbHVlLCBraW5kID0gXCJhc3NlcnRpdmVcIiwgdGltZW91dCA9IDc1MDApIHtcbiAgICAgICAgaWYgKCFhbm5vdW5jZXIgfHwgIWlzQnJvd3NlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbG9nID0gYW5ub3VuY2VyLmdldExvZyhraW5kKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBcIkVtcHR5XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50LmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhc3NlcnRpdmVcIikge1xuICAgICAgICAgICAgbG9nPy5yZXBsYWNlQ2hpbGRyZW4oY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2c/LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnRlbnQucmVtb3ZlKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbm5vdW5jZSxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgQ2FsZW5kYXJEYXRlLCBDYWxlbmRhckRhdGVUaW1lLCBab25lZERhdGVUaW1lLCBnZXREYXlPZldlZWssIGdldExvY2FsVGltZVpvbmUsIHBhcnNlRGF0ZSwgcGFyc2VEYXRlVGltZSwgcGFyc2Vab25lZERhdGVUaW1lLCB0b0NhbGVuZGFyLCB9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZVwiO1xuY29uc3QgZGVmYXVsdERhdGVEZWZhdWx0cyA9IHtcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0UGxhY2Vob2xkZXI6IHVuZGVmaW5lZCxcbiAgICBncmFudWxhcml0eTogXCJkYXlcIixcbn07XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHVzZWQgdGhyb3VnaG91dCB0aGUgdmFyaW91cyBkYXRlIGJ1aWxkZXJzXG4gKiB0byBnZW5lcmF0ZSBhIGRlZmF1bHQgYERhdGVWYWx1ZWAgdXNpbmcgdGhlIGBkZWZhdWx0VmFsdWVgLFxuICogYGRlZmF1bHRQbGFjZWhvbGRlcmAsIGFuZCBgZ3JhbnVsYXJpdHlgIHByb3BzLlxuICpcbiAqIEl0J3MgaW1wb3J0YW50IHRvIG1hdGNoIHRoZSBgRGF0ZVZhbHVlYCB0eXBlIGJlaW5nIHVzZWRcbiAqIGVsc2V3aGVyZSBpbiB0aGUgYnVpbGRlciwgc28gdGhleSBiZWhhdmUgYWNjb3JkaW5nIHRvIHRoZVxuICogYmVoYXZpb3IgdGhlIHVzZXIgZXhwZWN0cyBiYXNlZCBvbiB0aGUgcHJvcHMgdGhleSd2ZSBwcm92aWRlZC5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RGF0ZShwcm9wcykge1xuICAgIGNvbnN0IHdpdGhEZWZhdWx0cyA9IHsgLi4uZGVmYXVsdERhdGVEZWZhdWx0cywgLi4ucHJvcHMgfTtcbiAgICBjb25zdCB7IGRlZmF1bHRWYWx1ZSwgZGVmYXVsdFBsYWNlaG9sZGVyLCBncmFudWxhcml0eSB9ID0gd2l0aERlZmF1bHRzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgJiYgZGVmYXVsdFZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlW2RlZmF1bHRWYWx1ZS5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiAhQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZmF1bHRQbGFjZWhvbGRlcikge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF0ZVRpbWVHcmFudWxhcml0aWVzID0gW1wiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiXTtcbiAgICAgICAgaWYgKGNhbGVuZGFyRGF0ZVRpbWVHcmFudWxhcml0aWVzLmluY2x1ZGVzKGdyYW51bGFyaXR5ID8/IFwiZGF5XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGVuZGFyRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhckRhdGUoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGRhdGUgc3RyaW5nIGFuZCBhIHJlZmVyZW5jZSBgRGF0ZVZhbHVlYCBvYmplY3QsIHBhcnNlIHRoZVxuICogc3RyaW5nIHRvIHRoZSBzYW1lIHR5cGUgYXMgdGhlIHJlZmVyZW5jZSBvYmplY3QuXG4gKlxuICogVXNlZnVsIGZvciBwYXJzaW5nIHN0cmluZ3MgZnJvbSBkYXRhIGF0dHJpYnV0ZXMsIHdoaWNoIGFyZSBhbHdheXNcbiAqIHN0cmluZ3MsIHRvIHRoZSBzYW1lIHR5cGUgYmVpbmcgdXNlZCBieSB0aGUgZGF0ZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cmluZ1RvRGF0ZVZhbHVlKGRhdGVTdHIsIHJlZmVyZW5jZVZhbCkge1xuICAgIGxldCBkYXRlVmFsdWU7XG4gICAgaWYgKHJlZmVyZW5jZVZhbCBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlID0gcGFyc2Vab25lZERhdGVUaW1lKGRhdGVTdHIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWZlcmVuY2VWYWwgaW5zdGFuY2VvZiBDYWxlbmRhckRhdGVUaW1lKSB7XG4gICAgICAgIGRhdGVWYWx1ZSA9IHBhcnNlRGF0ZVRpbWUoZGF0ZVN0cik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRlVmFsdWUgPSBwYXJzZURhdGUoZGF0ZVN0cik7XG4gICAgfVxuICAgIC8vIGVuc3VyZSB0aGUgcGFyc2VkIGRhdGUgaXMgaW4gdGhlIHNhbWUgY2FsZW5kYXIgYXMgdGhlIHJlZmVyZW5jZSBkYXRlIHNldCBieSB0aGUgdXNlci5cbiAgICByZXR1cm4gZGF0ZVZhbHVlLmNhbGVuZGFyICE9PSByZWZlcmVuY2VWYWwuY2FsZW5kYXJcbiAgICAgICAgPyB0b0NhbGVuZGFyKGRhdGVWYWx1ZSwgcmVmZXJlbmNlVmFsLmNhbGVuZGFyKVxuICAgICAgICA6IGRhdGVWYWx1ZTtcbn1cbi8qKlxuICogR2l2ZW4gYSBgRGF0ZVZhbHVlYCBvYmplY3QsIGNvbnZlcnQgaXQgdG8gYSBuYXRpdmUgYERhdGVgIG9iamVjdC5cbiAqIElmIGEgdGltZXpvbmUgaXMgcHJvdmlkZWQsIHRoZSBkYXRlIHdpbGwgYmUgY29udmVydGVkIHRvIHRoYXQgdGltZXpvbmUuXG4gKiBJZiBubyB0aW1lem9uZSBpcyBwcm92aWRlZCwgdGhlIGRhdGUgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlIGxvY2FsIHRpbWV6b25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRlKGRhdGVWYWx1ZSwgdHogPSBnZXRMb2NhbFRpbWVab25lKCkpIHtcbiAgICBpZiAoZGF0ZVZhbHVlIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlLnRvRGF0ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZS50b0RhdGUodHopO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ2FsZW5kYXJEYXRlVGltZShkYXRlVmFsdWUpIHtcbiAgICByZXR1cm4gZGF0ZVZhbHVlIGluc3RhbmNlb2YgQ2FsZW5kYXJEYXRlVGltZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1pvbmVkRGF0ZVRpbWUoZGF0ZVZhbHVlKSB7XG4gICAgcmV0dXJuIGRhdGVWYWx1ZSBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzVGltZShkYXRlVmFsdWUpIHtcbiAgICByZXR1cm4gaXNDYWxlbmRhckRhdGVUaW1lKGRhdGVWYWx1ZSkgfHwgaXNab25lZERhdGVUaW1lKGRhdGVWYWx1ZSk7XG59XG4vKipcbiAqIEdpdmVuIGEgZGF0ZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXlzSW5Nb250aChkYXRlKSB7XG4gICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ5IHVzaW5nIHplcm8gYXMgdGhlIGRheSwgd2UgZ2V0IHRoZVxuICAgICAgICAgKiBsYXN0IGRheSBvZiB0aGUgcHJldmlvdXMgbW9udGgsIHdoaWNoXG4gICAgICAgICAqIGlzIHRoZSBtb250aCB3ZSBvcmlnaW5hbGx5IHBhc3NlZCBpbi5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMCkuZ2V0RGF0ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuc2V0KHsgZGF5OiAxMDAgfSkuZGF5O1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgZGF0ZSBpcyBiZWZvcmUgdGhlIHJlZmVyZW5jZSBkYXRlLlxuICogQHBhcmFtIGRhdGVUb0NvbXBhcmUgLSBpcyB0aGlzIGRhdGUgYmVmb3JlIHRoZSBgcmVmZXJlbmNlRGF0ZWBcbiAqIEBwYXJhbSByZWZlcmVuY2VEYXRlIC0gaXMgdGhlIGBkYXRlVG9Db21wYXJlYCBiZWZvcmUgdGhpcyBkYXRlXG4gKlxuICogQHNlZSB7QGxpbmsgaXNCZWZvcmVPclNhbWV9IGZvciBpbmNsdXNpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmVmb3JlKGRhdGVUb0NvbXBhcmUsIHJlZmVyZW5jZURhdGUpIHtcbiAgICByZXR1cm4gZGF0ZVRvQ29tcGFyZS5jb21wYXJlKHJlZmVyZW5jZURhdGUpIDwgMDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgZGF0ZSBpcyBhZnRlciB0aGUgcmVmZXJlbmNlIGRhdGUuXG4gKiBAcGFyYW0gZGF0ZVRvQ29tcGFyZSAtIGlzIHRoaXMgZGF0ZSBhZnRlciB0aGUgYHJlZmVyZW5jZURhdGVgXG4gKiBAcGFyYW0gcmVmZXJlbmNlRGF0ZSAtIGlzIHRoZSBgZGF0ZVRvQ29tcGFyZWAgYWZ0ZXIgdGhpcyBkYXRlXG4gKlxuICogQHNlZSB7QGxpbmsgaXNBZnRlck9yU2FtZX0gZm9yIGluY2x1c2l2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZnRlcihkYXRlVG9Db21wYXJlLCByZWZlcmVuY2VEYXRlKSB7XG4gICAgcmV0dXJuIGRhdGVUb0NvbXBhcmUuY29tcGFyZShyZWZlcmVuY2VEYXRlKSA+IDA7XG59XG4vKipcbiAqIERldGVybWluZSBpZiBhIGRhdGUgaXMgYmVmb3JlIG9yIHRoZSBzYW1lIGFzIHRoZSByZWZlcmVuY2UgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZVRvQ29tcGFyZSAtIHRoZSBkYXRlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSByZWZlcmVuY2VEYXRlIC0gdGhlIHJlZmVyZW5jZSBkYXRlIHRvIG1ha2UgdGhlIGNvbXBhcmlzb24gYWdhaW5zdFxuICpcbiAqIEBzZWUge0BsaW5rIGlzQmVmb3JlfSBmb3Igbm9uLWluY2x1c2l2ZVxuICovXG5mdW5jdGlvbiBpc0JlZm9yZU9yU2FtZShkYXRlVG9Db21wYXJlLCByZWZlcmVuY2VEYXRlKSB7XG4gICAgcmV0dXJuIGRhdGVUb0NvbXBhcmUuY29tcGFyZShyZWZlcmVuY2VEYXRlKSA8PSAwO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBkYXRlIGlzIGFmdGVyIG9yIHRoZSBzYW1lIGFzIHRoZSByZWZlcmVuY2UgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZVRvQ29tcGFyZSAtIGlzIHRoaXMgZGF0ZSBhZnRlciBvciB0aGUgc2FtZSBhcyB0aGUgYHJlZmVyZW5jZURhdGVgXG4gKiBAcGFyYW0gcmVmZXJlbmNlRGF0ZSAtIGlzIHRoZSBgZGF0ZVRvQ29tcGFyZWAgYWZ0ZXIgb3IgdGhlIHNhbWUgYXMgdGhpcyBkYXRlXG4gKlxuICogQHNlZSB7QGxpbmsgaXNBZnRlcn0gZm9yIG5vbi1pbmNsdXNpdmVcbiAqL1xuZnVuY3Rpb24gaXNBZnRlck9yU2FtZShkYXRlVG9Db21wYXJlLCByZWZlcmVuY2VEYXRlKSB7XG4gICAgcmV0dXJuIGRhdGVUb0NvbXBhcmUuY29tcGFyZShyZWZlcmVuY2VEYXRlKSA+PSAwO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBkYXRlIGlzIGluY2x1c2l2ZWx5IGJldHdlZW4gYSBzdGFydCBhbmQgZW5kIHJlZmVyZW5jZSBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gaXMgdGhpcyBkYXRlIGluY2x1c2l2ZWx5IGJldHdlZW4gdGhlIGBzdGFydGAgYW5kIGBlbmRgIGRhdGVzXG4gKiBAcGFyYW0gc3RhcnQgLSB0aGUgc3RhcnQgcmVmZXJlbmNlIGRhdGUgdG8gbWFrZSB0aGUgY29tcGFyaXNvbiBhZ2FpbnN0XG4gKiBAcGFyYW0gZW5kIC0gdGhlIGVuZCByZWZlcmVuY2UgZGF0ZSB0byBtYWtlIHRoZSBjb21wYXJpc29uIGFnYWluc3RcbiAqXG4gKiBAc2VlIHtAbGluayBpc0JldHdlZW59IGZvciBub24taW5jbHVzaXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JldHdlZW5JbmNsdXNpdmUoZGF0ZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBpc0FmdGVyT3JTYW1lKGRhdGUsIHN0YXJ0KSAmJiBpc0JlZm9yZU9yU2FtZShkYXRlLCBlbmQpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBkYXRlIGlzIGJldHdlZW4gYSBzdGFydCBhbmQgZW5kIHJlZmVyZW5jZSBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gaXMgdGhpcyBkYXRlIGJldHdlZW4gdGhlIGBzdGFydGAgYW5kIGBlbmRgIGRhdGVzXG4gKiBAcGFyYW0gc3RhcnQgLSB0aGUgc3RhcnQgcmVmZXJlbmNlIGRhdGUgdG8gbWFrZSB0aGUgY29tcGFyaXNvbiBhZ2FpbnN0XG4gKiBAcGFyYW0gZW5kIC0gdGhlIGVuZCByZWZlcmVuY2UgZGF0ZSB0byBtYWtlIHRoZSBjb21wYXJpc29uIGFnYWluc3RcbiAqXG4gKiBAc2VlIHtAbGluayBpc0JldHdlZW5JbmNsdXNpdmV9IGZvciBpbmNsdXNpdmVcbiAqL1xuZnVuY3Rpb24gaXNCZXR3ZWVuKGRhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gaXNBZnRlcihkYXRlLCBzdGFydCkgJiYgaXNCZWZvcmUoZGF0ZSwgZW5kKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXN0Rmlyc3REYXlPZldlZWsoZGF0ZSwgZmlyc3REYXlPZldlZWssIGxvY2FsZSkge1xuICAgIGNvbnN0IGRheSA9IGdldERheU9mV2VlayhkYXRlLCBsb2NhbGUpO1xuICAgIGlmIChmaXJzdERheU9mV2VlayA+IGRheSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5zdWJ0cmFjdCh7IGRheXM6IGRheSArIDcgLSBmaXJzdERheU9mV2VlayB9KTtcbiAgICB9XG4gICAgaWYgKGZpcnN0RGF5T2ZXZWVrID09PSBkYXkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBkYXRlLnN1YnRyYWN0KHsgZGF5czogZGF5IC0gZmlyc3REYXlPZldlZWsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dExhc3REYXlPZldlZWsoZGF0ZSwgZmlyc3REYXlPZldlZWssIGxvY2FsZSkge1xuICAgIGNvbnN0IGRheSA9IGdldERheU9mV2VlayhkYXRlLCBsb2NhbGUpO1xuICAgIGNvbnN0IGxhc3REYXlPZldlZWsgPSBmaXJzdERheU9mV2VlayA9PT0gMCA/IDYgOiBmaXJzdERheU9mV2VlayAtIDE7XG4gICAgaWYgKGRheSA9PT0gbGFzdERheU9mV2Vlaykge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgaWYgKGRheSA+IGxhc3REYXlPZldlZWspIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuYWRkKHsgZGF5czogNyAtIGRheSArIGxhc3REYXlPZldlZWsgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlLmFkZCh7IGRheXM6IGxhc3REYXlPZldlZWsgLSBkYXkgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJlQWxsRGF5c0JldHdlZW5WYWxpZChzdGFydCwgZW5kLCBpc1VuYXZhaWxhYmxlLCBpc0Rpc2FibGVkKSB7XG4gICAgaWYgKGlzVW5hdmFpbGFibGUgPT09IHVuZGVmaW5lZCAmJiBpc0Rpc2FibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBkQ3VycmVudCA9IHN0YXJ0LmFkZCh7IGRheXM6IDEgfSk7XG4gICAgaWYgKGlzRGlzYWJsZWQ/LihkQ3VycmVudCkgfHwgaXNVbmF2YWlsYWJsZT8uKGRDdXJyZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRFbmQgPSBlbmQ7XG4gICAgd2hpbGUgKGRDdXJyZW50LmNvbXBhcmUoZEVuZCkgPCAwKSB7XG4gICAgICAgIGRDdXJyZW50ID0gZEN1cnJlbnQuYWRkKHsgZGF5czogMSB9KTtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQ/LihkQ3VycmVudCkgfHwgaXNVbmF2YWlsYWJsZT8uKGRDdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZVwiO1xuaW1wb3J0IHsgaGFzVGltZSwgaXNab25lZERhdGVUaW1lLCB0b0RhdGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgZGVmYXVsdFBhcnRPcHRpb25zID0ge1xuICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgIG1vbnRoOiBcIm51bWVyaWNcIixcbiAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgIG1pbnV0ZTogXCJudW1lcmljXCIsXG4gICAgc2Vjb25kOiBcIm51bWVyaWNcIixcbn07XG4vKipcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgYERhdGVGb3JtYXR0ZXJgLCB3aGljaCBpc1xuICogYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiB0aGUge0BsaW5rIEludGwuRGF0ZVRpbWVGb3JtYXR9IEFQSSxcbiAqIHRoYXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSB2YXJpb3VzIGRhdGUgYnVpbGRlcnMgdG9cbiAqIGVhc2lseSBmb3JtYXQgZGF0ZXMgaW4gYSBjb25zaXN0ZW50IHdheS5cbiAqXG4gKiBAc2VlIFtEYXRlRm9ybWF0dGVyXShodHRwczovL3JlYWN0LXNwZWN0cnVtLmFkb2JlLmNvbS9pbnRlcm5hdGlvbmFsaXplZC9kYXRlL0RhdGVGb3JtYXR0ZXIuaHRtbClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihpbml0aWFsTG9jYWxlKSB7XG4gICAgbGV0IGxvY2FsZSA9IGluaXRpYWxMb2NhbGU7XG4gICAgZnVuY3Rpb24gc2V0TG9jYWxlKG5ld0xvY2FsZSkge1xuICAgICAgICBsb2NhbGUgPSBuZXdMb2NhbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3VzdG9tKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KGRhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWxlY3RlZERhdGUoZGF0ZSwgaW5jbHVkZVRpbWUgPSB0cnVlKSB7XG4gICAgICAgIGlmIChoYXNUaW1lKGRhdGUpICYmIGluY2x1ZGVUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKHRvRGF0ZShkYXRlKSwge1xuICAgICAgICAgICAgICAgIGRhdGVTdHlsZTogXCJsb25nXCIsXG4gICAgICAgICAgICAgICAgdGltZVN0eWxlOiBcImxvbmdcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSh0b0RhdGUoZGF0ZSksIHtcbiAgICAgICAgICAgICAgICBkYXRlU3R5bGU6IFwibG9uZ1wiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZnVsbE1vbnRoQW5kWWVhcihkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUZvcm1hdHRlcihsb2NhbGUsIHsgbW9udGg6IFwibG9uZ1wiLCB5ZWFyOiBcIm51bWVyaWNcIiB9KS5mb3JtYXQoZGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bGxNb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUZvcm1hdHRlcihsb2NhbGUsIHsgbW9udGg6IFwibG9uZ1wiIH0pLmZvcm1hdChkYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnVsbFllYXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVGb3JtYXR0ZXIobG9jYWxlLCB7IHllYXI6IFwibnVtZXJpY1wiIH0pLmZvcm1hdChkYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9QYXJ0cyhkYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc1pvbmVkRGF0ZVRpbWUoZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZUZvcm1hdHRlcihsb2NhbGUsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVab25lOiBkYXRlLnRpbWVab25lLFxuICAgICAgICAgICAgfSkuZm9ybWF0VG9QYXJ0cyh0b0RhdGUoZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlRm9ybWF0dGVyKGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyh0b0RhdGUoZGF0ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRheU9mV2VlayhkYXRlLCBsZW5ndGggPSBcIm5hcnJvd1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUZvcm1hdHRlcihsb2NhbGUsIHsgd2Vla2RheTogbGVuZ3RoIH0pLmZvcm1hdChkYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGF5UGVyaW9kKGRhdGUsIGhvdXJDeWNsZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IG5ldyBEYXRlRm9ybWF0dGVyKGxvY2FsZSwge1xuICAgICAgICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICAgICAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgaG91ckN5Y2xlOiBob3VyQ3ljbGUgPT09IDI0ID8gXCJoMjNcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSkuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5maW5kKChwKSA9PiBwLnR5cGUgPT09IFwiZGF5UGVyaW9kXCIpPy52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIlBNXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBNXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiQU1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydChkYXRlT2JqLCB0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4uZGVmYXVsdFBhcnRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9QYXJ0cyhkYXRlT2JqLCBvcHRzKTtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzLmZpbmQoKHApID0+IHAudHlwZSA9PT0gdHlwZSk7XG4gICAgICAgIHJldHVybiBwYXJ0ID8gcGFydC52YWx1ZSA6IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldExvY2FsZSxcbiAgICAgICAgZ2V0TG9jYWxlLFxuICAgICAgICBmdWxsTW9udGgsXG4gICAgICAgIGZ1bGxZZWFyLFxuICAgICAgICBmdWxsTW9udGhBbmRZZWFyLFxuICAgICAgICB0b1BhcnRzLFxuICAgICAgICBjdXN0b20sXG4gICAgICAgIHBhcnQsXG4gICAgICAgIGRheVBlcmlvZCxcbiAgICAgICAgc2VsZWN0ZWREYXRlLFxuICAgICAgICBkYXlPZldlZWssXG4gICAgfTtcbn1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIHR3byBhcnJheXMgYXJlIGVxdWFsIGJ5IGNvbXBhcmluZyB0aGVpciB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheXNBcmVFcXVhbChhcnIxLCBhcnIyKSB7XG4gICAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcnIxLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGlzRXF1YWwodmFsdWUsIGFycjJbaW5kZXhdKSk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHR3byB2YWx1ZXMgZm9yIGVxdWFsaXR5LlxuICovXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGEpICYmIE51bWJlci5pc05hTihiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlzQXJlRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gaXNEZWVwRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuaXMoYSwgYik7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHR3byB2YWx1ZXMgZm9yIGRlZXAgZXF1YWxpdHkuXG4gKi9cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIgfHwgYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGFLZXlzKSB7XG4gICAgICAgIGlmICghYktleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogU3BsaXRzIGFuIGFycmF5IGludG8gY2h1bmtzIG9mIGEgZ2l2ZW4gc2l6ZS5cbiAqIEBwYXJhbSBhcnIgVGhlIGFycmF5IHRvIHNwbGl0LlxuICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgZWFjaCBjaHVuay5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFycmF5cywgd2hlcmUgZWFjaCBzdWItYXJyYXkgaGFzIGBzaXplYCBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAqIEBleGFtcGxlIGBgYHRzXG4gKiBjb25zdCBhcnIgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XG4gKiBjb25zdCBjaHVua3MgPSBjaHVuayhhcnIsIDMpO1xuICogLy8gY2h1bmtzID0gW1sxLCAyLCAzXSwgWzQsIDUsIDZdLCBbNywgOF1dXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNodW5rKGFyciwgc2l6ZSkge1xuICAgIGlmIChzaXplIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgICAgICByZXN1bHQucHVzaChhcnIuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBpbmRleCBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBjaGVja1xuICogQHBhcmFtIGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEluZGV4KGluZGV4LCBhcnIpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGFyci5sZW5ndGg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIGluZGV4LCBvciB1bmRlZmluZWQgZm9yIG91dC1vZi1ib3VuZHMgb3IgZW1wdHkgYXJyYXlzLlxuICogQHBhcmFtIGFycmF5IHRoZSBhcnJheS5cbiAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSBsb29wIGxvb3AgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgaWYgdGhlIG5leHQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcz9cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSBlbGVtZW50IGFmdGVyIHRoZSBnaXZlbiBpbmRleCwgb3IgdW5kZWZpbmVkIGZvciBvdXQtb2YtYm91bmRzIG9yIGVtcHR5IGFycmF5cy5cbiAqIEZvciBzaW5nbGUtZWxlbWVudCBhcnJheXMsIHJldHVybnMgdGhlIGVsZW1lbnQgaWYgdGhlIGluZGV4IGlzIDAuXG4gKiBAcGFyYW0gYXJyYXkgdGhlIGFycmF5LlxuICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIGxvb3AgbG9vcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBpZiB0aGUgbmV4dCBpbmRleCBpcyBvdXQgb2YgYm91bmRzP1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmV4dChhcnJheSwgaW5kZXgsIGxvb3AgPSB0cnVlKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGxvb3AgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2luZGV4ICsgMV07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IGVsZW1lbnQgcHJpb3IgdG8gdGhlIGdpdmVuIGluZGV4LCBvciB1bmRlZmluZWQgZm9yIG91dC1vZi1ib3VuZHMgb3IgZW1wdHkgYXJyYXlzLlxuICogRm9yIHNpbmdsZS1lbGVtZW50IGFycmF5cywgcmV0dXJucyB0aGUgZWxlbWVudCBpZiB0aGUgaW5kZXggaXMgMC5cbiAqIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0gbG9vcCBsb29wIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IGlmIHRoZSBwcmV2aW91cyBpbmRleCBpcyBvdXQgb2YgYm91bmRzP1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldihhcnJheSwgaW5kZXgsIGxvb3AgPSB0cnVlKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGxvb3AgPyBhcnJheVthcnJheS5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2luZGV4IC0gMV07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgc29tZSBudW1iZXIgYWZ0ZXIgdGhlIGdpdmVuIGluZGV4LiBJZiB0aGUgdGFyZ2V0IGluZGV4IGlzIG91dCBvZiBib3VuZHM6XG4gKiAgIC0gSWYgbG9vcGluZyBpcyBkaXNhYmxlZCwgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCB3aWxsIGJlIHJldHVybmVkLlxuICogICAtIElmIGxvb3BpbmcgaXMgZW5hYmxlZCwgaXQgd2lsbCB3cmFwIGFyb3VuZCB0aGUgYXJyYXkuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBmb3IgZW1wdHkgYXJyYXlzIG9yIG91dC1vZi1ib3VuZHMgaW5pdGlhbCBpbmRpY2VzLlxuICogQHBhcmFtIGFycmF5IHRoZSBhcnJheS5cbiAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSBpbmNyZW1lbnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBtb3ZlIGZvcndhcmQgKGNhbiBiZSBuZWdhdGl2ZSkuXG4gKiBAcGFyYW0gbG9vcCBsb29wIGFyb3VuZCB0aGUgYXJyYXkgaWYgdGhlIHRhcmdldCBpbmRleCBpcyBvdXQgb2YgYm91bmRzP1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZChhcnJheSwgaW5kZXgsIGluY3JlbWVudCwgbG9vcCA9IHRydWUpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHRhcmdldEluZGV4ID0gaW5kZXggKyBpbmNyZW1lbnQ7XG4gICAgaWYgKGxvb3ApIHtcbiAgICAgICAgLy8gRW5zdXJlIHBvc2l0aXZlIG1vZHVsdXNcbiAgICAgICAgdGFyZ2V0SW5kZXggPSAoKHRhcmdldEluZGV4ICUgYXJyYXkubGVuZ3RoKSArIGFycmF5Lmxlbmd0aCkgJSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDbGFtcCB0byBhcnJheSBib3VuZHMgd2hlbiBub3QgbG9vcGluZ1xuICAgICAgICB0YXJnZXRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRhcmdldEluZGV4LCBhcnJheS5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVt0YXJnZXRJbmRleF07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgc29tZSBudW1iZXIgYmVmb3JlIHRoZSBnaXZlbiBpbmRleC4gSWYgdGhlIHRhcmdldCBpbmRleCBpcyBvdXQgb2YgYm91bmRzOlxuICogICAtIElmIGxvb3BpbmcgaXMgZGlzYWJsZWQsIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZC5cbiAqICAgLSBJZiBsb29waW5nIGlzIGVuYWJsZWQsIGl0IHdpbGwgd3JhcCBhcm91bmQgdGhlIGFycmF5LlxuICogUmV0dXJucyB1bmRlZmluZWQgZm9yIGVtcHR5IGFycmF5cyBvciBvdXQtb2YtYm91bmRzIGluaXRpYWwgaW5kaWNlcy5cbiAqIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gbW92ZSBiYWNrd2FyZCAoY2FuIGJlIG5lZ2F0aXZlKS5cbiAqIEBwYXJhbSBsb29wIGxvb3AgYXJvdW5kIHRoZSBhcnJheSBpZiB0aGUgdGFyZ2V0IGluZGV4IGlzIG91dCBvZiBib3VuZHM/XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZChhcnJheSwgaW5kZXgsIGRlY3JlbWVudCwgbG9vcCA9IHRydWUpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHRhcmdldEluZGV4ID0gaW5kZXggLSBkZWNyZW1lbnQ7XG4gICAgaWYgKGxvb3ApIHtcbiAgICAgICAgLy8gRW5zdXJlIHBvc2l0aXZlIG1vZHVsdXNcbiAgICAgICAgdGFyZ2V0SW5kZXggPSAoKHRhcmdldEluZGV4ICUgYXJyYXkubGVuZ3RoKSArIGFycmF5Lmxlbmd0aCkgJSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDbGFtcCB0byBhcnJheSBib3VuZHMgd2hlbiBub3QgbG9vcGluZ1xuICAgICAgICB0YXJnZXRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRhcmdldEluZGV4LCBhcnJheS5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVt0YXJnZXRJbmRleF07XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIFwibWVhdFwiIG9mIHRoZSB0eXBlYWhlYWQgbWF0Y2hpbmcgbG9naWMuIEl0IHRha2VzIGluIGFsbCB0aGUgdmFsdWVzLFxuICogdGhlIHNlYXJjaCBhbmQgdGhlIGN1cnJlbnQgbWF0Y2gsIGFuZCByZXR1cm5zIHRoZSBuZXh0IG1hdGNoIChvciBgdW5kZWZpbmVkYCkuXG4gKlxuICogV2Ugbm9ybWFsaXplIHRoZSBzZWFyY2ggYmVjYXVzZSBpZiBhIHVzZXIgaGFzIHJlcGVhdGVkbHkgcHJlc3NlZCBhIGNoYXJhY3RlcixcbiAqIHdlIHdhbnQgdGhlIGV4YWN0IHNhbWUgYmVoYXZpb3IgYXMgaWYgd2Ugb25seSBoYWQgdGhhdCBvbmUgY2hhcmFjdGVyXG4gKiAoaWUuIGN5Y2xlIHRocm91Z2ggb3B0aW9ucyBzdGFydGluZyB3aXRoIHRoYXQgY2hhcmFjdGVyKVxuICpcbiAqIFdlIGFsc28gcmVvcmRlciB0aGUgdmFsdWVzIGJ5IHdyYXBwaW5nIHRoZSBhcnJheSBhcm91bmQgdGhlIGN1cnJlbnQgbWF0Y2guXG4gKiBUaGlzIGlzIHNvIHdlIGFsd2F5cyBsb29rIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBtYXRjaCwgYW5kIHBpY2tpbmcgdGhlIGZpcnN0XG4gKiBtYXRjaCB3aWxsIGFsd2F5cyBiZSB0aGUgY29ycmVjdCBvbmUuXG4gKlxuICogRmluYWxseSwgaWYgdGhlIG5vcm1hbGl6ZWQgc2VhcmNoIGlzIGV4YWN0bHkgb25lIGNoYXJhY3Rlciwgd2UgZXhjbHVkZSB0aGVcbiAqIGN1cnJlbnQgbWF0Y2ggZnJvbSB0aGUgdmFsdWVzIGJlY2F1c2Ugb3RoZXJ3aXNlIGl0IHdvdWxkIGJlIHRoZSBmaXJzdCB0byBtYXRjaCBhbHdheXNcbiAqIGFuZCBmb2N1cyB3b3VsZCBuZXZlciBtb3ZlLiBUaGlzIGlzIGFzIG9wcG9zZWQgdG8gdGhlIHJlZ3VsYXIgY2FzZSwgd2hlcmUgd2VcbiAqIGRvbid0IHdhbnQgZm9jdXMgdG8gbW92ZSBpZiB0aGUgY3VycmVudCBtYXRjaCBzdGlsbCBtYXRjaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dE1hdGNoKHZhbHVlcywgc2VhcmNoLCBjdXJyZW50TWF0Y2gpIHtcbiAgICBjb25zdCBpc1JlcGVhdGVkID0gc2VhcmNoLmxlbmd0aCA+IDEgJiYgQXJyYXkuZnJvbShzZWFyY2gpLmV2ZXJ5KChjaGFyKSA9PiBjaGFyID09PSBzZWFyY2hbMF0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWFyY2ggPSBpc1JlcGVhdGVkID8gc2VhcmNoWzBdIDogc2VhcmNoO1xuICAgIGNvbnN0IGN1cnJlbnRNYXRjaEluZGV4ID0gY3VycmVudE1hdGNoID8gdmFsdWVzLmluZGV4T2YoY3VycmVudE1hdGNoKSA6IC0xO1xuICAgIGxldCB3cmFwcGVkVmFsdWVzID0gd3JhcEFycmF5KHZhbHVlcywgTWF0aC5tYXgoY3VycmVudE1hdGNoSW5kZXgsIDApKTtcbiAgICBjb25zdCBleGNsdWRlQ3VycmVudE1hdGNoID0gbm9ybWFsaXplZFNlYXJjaC5sZW5ndGggPT09IDE7XG4gICAgaWYgKGV4Y2x1ZGVDdXJyZW50TWF0Y2gpXG4gICAgICAgIHdyYXBwZWRWYWx1ZXMgPSB3cmFwcGVkVmFsdWVzLmZpbHRlcigodikgPT4gdiAhPT0gY3VycmVudE1hdGNoKTtcbiAgICBjb25zdCBuZXh0TWF0Y2ggPSB3cmFwcGVkVmFsdWVzLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZT8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG5vcm1hbGl6ZWRTZWFyY2gudG9Mb3dlckNhc2UoKSkpO1xuICAgIHJldHVybiBuZXh0TWF0Y2ggIT09IGN1cnJlbnRNYXRjaCA/IG5leHRNYXRjaCA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogV3JhcHMgYW4gYXJyYXkgYXJvdW5kIGl0c2VsZiBhdCBhIGdpdmVuIHN0YXJ0IGluZGV4XG4gKiBFeGFtcGxlOiBgd3JhcEFycmF5KFsnYScsICdiJywgJ2MnLCAnZCddLCAyKSA9PT0gWydjJywgJ2QnLCAnYScsICdiJ11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQXJyYXkoYXJyYXksIHN0YXJ0SW5kZXgpIHtcbiAgICByZXR1cm4gYXJyYXkubWFwKChfLCBpbmRleCkgPT4gYXJyYXlbKHN0YXJ0SW5kZXggKyBpbmRleCkgJSBhcnJheS5sZW5ndGhdKTtcbn1cbiIsImltcG9ydCB7IGVuZE9mTW9udGgsIGlzU2FtZU1vbnRoLCBzdGFydE9mTW9udGggfSBmcm9tIFwiQGludGVybmF0aW9uYWxpemVkL2RhdGVcIjtcbmltcG9ydCB7IGFmdGVyVGljaywgc3R5bGVUb1N0cmluZyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBnZXREYXlzSW5Nb250aCwgZ2V0TGFzdEZpcnN0RGF5T2ZXZWVrLCBnZXROZXh0TGFzdERheU9mV2VlaywgaXNBZnRlciwgaXNCZWZvcmUsIHBhcnNlU3RyaW5nVG9EYXRlVmFsdWUsIHRvRGF0ZSwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0RGF0YURpc2FibGVkLCBnZXREYXRhSW52YWxpZCwgZ2V0RGF0YVJlYWRvbmx5IH0gZnJvbSBcIi4uL2F0dHJzLmpzXCI7XG5pbXBvcnQgeyBjaHVuaywgaXNWYWxpZEluZGV4IH0gZnJvbSBcIi4uL2FycmF5cy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9pcy5qc1wiO1xuaW1wb3J0IHsga2JkIH0gZnJvbSBcIi4uL2tiZC5qc1wiO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBub2RlIGlzIGEgY2FsZW5kYXIgY2VsbCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGVuZGFyRGF5Tm9kZShub2RlKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtYml0cy1kYXlcIikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUmV0cmlldmVzIGFuIGFycmF5IG9mIGRhdGUgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgZGF5cyBiZXR3ZWVuXG4gKiB0aGUgcHJvdmlkZWQgc3RhcnQgYW5kIGVuZCBkYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERheXNCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBkYXlzID0gW107XG4gICAgbGV0IGRDdXJyZW50ID0gc3RhcnQuYWRkKHsgZGF5czogMSB9KTtcbiAgICBjb25zdCBkRW5kID0gZW5kO1xuICAgIHdoaWxlIChkQ3VycmVudC5jb21wYXJlKGRFbmQpIDwgMCkge1xuICAgICAgICBkYXlzLnB1c2goZEN1cnJlbnQpO1xuICAgICAgICBkQ3VycmVudCA9IGRDdXJyZW50LmFkZCh7IGRheXM6IDEgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYXlzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgY2FsZW5kYXIgbW9udGggb2JqZWN0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBHaXZlbiBhIGRhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIG5lY2Vzc2FyeSB2YWx1ZXMgdG8gcmVuZGVyIGEgY2FsZW5kYXIgbW9udGgsIGluY2x1ZGluZ1xuICogdGhlIG1vbnRoJ3MgZGF0ZSAodGhlIGZpcnN0IGRheSBvZiB0aGF0IG1vbnRoKSwgd2hpY2ggY2FuIGJlXG4gKiB1c2VkIHRvIHJlbmRlciB0aGUgbmFtZSBvZiB0aGUgbW9udGgsIGFuIGFycmF5IG9mIGFsbCBkYXRlc1xuICogaW4gdGhhdCBtb250aCwgYW5kIGFuIGFycmF5IG9mIHdlZWtzLiBFYWNoIHdlZWsgaXMgYW4gYXJyYXlcbiAqIG9mIGRhdGVzLCB1c2VmdWwgZm9yIHJlbmRlcmluZyBhbiBhY2Nlc3NpYmxlIGNhbGVuZGFyIGdyaWRcbiAqIHVzaW5nIGEgbG9vcCBhbmQgdGFibGUgZWxlbWVudHMuXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb250aChwcm9wcykge1xuICAgIGNvbnN0IHsgZGF0ZU9iaiwgd2Vla1N0YXJ0c09uLCBmaXhlZFdlZWtzLCBsb2NhbGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGgoZGF0ZU9iaik7XG4gICAgY29uc3QgZGF0ZXNBcnJheSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGRheXNJbk1vbnRoIH0sIChfLCBpKSA9PiBkYXRlT2JqLnNldCh7IGRheTogaSArIDEgfSkpO1xuICAgIGNvbnN0IGZpcnN0RGF5T2ZNb250aCA9IHN0YXJ0T2ZNb250aChkYXRlT2JqKTtcbiAgICBjb25zdCBsYXN0RGF5T2ZNb250aCA9IGVuZE9mTW9udGgoZGF0ZU9iaik7XG4gICAgY29uc3QgbGFzdFN1bmRheSA9IGdldExhc3RGaXJzdERheU9mV2VlayhmaXJzdERheU9mTW9udGgsIHdlZWtTdGFydHNPbiwgbG9jYWxlKTtcbiAgICBjb25zdCBuZXh0U2F0dXJkYXkgPSBnZXROZXh0TGFzdERheU9mV2VlayhsYXN0RGF5T2ZNb250aCwgd2Vla1N0YXJ0c09uLCBsb2NhbGUpO1xuICAgIGNvbnN0IGxhc3RNb250aERheXMgPSBnZXREYXlzQmV0d2VlbihsYXN0U3VuZGF5LnN1YnRyYWN0KHsgZGF5czogMSB9KSwgZmlyc3REYXlPZk1vbnRoKTtcbiAgICBjb25zdCBuZXh0TW9udGhEYXlzID0gZ2V0RGF5c0JldHdlZW4obGFzdERheU9mTW9udGgsIG5leHRTYXR1cmRheS5hZGQoeyBkYXlzOiAxIH0pKTtcbiAgICBjb25zdCB0b3RhbERheXMgPSBsYXN0TW9udGhEYXlzLmxlbmd0aCArIGRhdGVzQXJyYXkubGVuZ3RoICsgbmV4dE1vbnRoRGF5cy5sZW5ndGg7XG4gICAgaWYgKGZpeGVkV2Vla3MgJiYgdG90YWxEYXlzIDwgNDIpIHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXlzID0gNDIgLSB0b3RhbERheXM7XG4gICAgICAgIGxldCBzdGFydEZyb20gPSBuZXh0TW9udGhEYXlzW25leHRNb250aERheXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghc3RhcnRGcm9tKSB7XG4gICAgICAgICAgICBzdGFydEZyb20gPSBkYXRlT2JqLmFkZCh7IG1vbnRoczogMSB9KS5zZXQoeyBkYXk6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbmd0aCA9IGV4dHJhRGF5cztcbiAgICAgICAgaWYgKG5leHRNb250aERheXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBleHRyYURheXMgLSAxO1xuICAgICAgICAgICAgbmV4dE1vbnRoRGF5cy5wdXNoKHN0YXJ0RnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0cmFEYXlzQXJyYXkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmNyID0gaSArIDE7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRGcm9tLmFkZCh7IGRheXM6IGluY3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0TW9udGhEYXlzLnB1c2goLi4uZXh0cmFEYXlzQXJyYXkpO1xuICAgIH1cbiAgICBjb25zdCBhbGxEYXlzID0gbGFzdE1vbnRoRGF5cy5jb25jYXQoZGF0ZXNBcnJheSwgbmV4dE1vbnRoRGF5cyk7XG4gICAgY29uc3Qgd2Vla3MgPSBjaHVuayhhbGxEYXlzLCA3KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZGF0ZU9iaixcbiAgICAgICAgZGF0ZXM6IGFsbERheXMsXG4gICAgICAgIHdlZWtzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9udGhzKHByb3BzKSB7XG4gICAgY29uc3QgeyBudW1iZXJPZk1vbnRocywgZGF0ZU9iaiwgLi4ubW9udGhQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgbW9udGhzID0gW107XG4gICAgaWYgKCFudW1iZXJPZk1vbnRocyB8fCBudW1iZXJPZk1vbnRocyA9PT0gMSkge1xuICAgICAgICBtb250aHMucHVzaChjcmVhdGVNb250aCh7XG4gICAgICAgICAgICAuLi5tb250aFByb3BzLFxuICAgICAgICAgICAgZGF0ZU9iaixcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbW9udGhzO1xuICAgIH1cbiAgICBtb250aHMucHVzaChjcmVhdGVNb250aCh7XG4gICAgICAgIC4uLm1vbnRoUHJvcHMsXG4gICAgICAgIGRhdGVPYmosXG4gICAgfSkpO1xuICAgIC8vIENyZWF0ZSBhbGwgdGhlIG1vbnRocywgc3RhcnRpbmcgd2l0aCB0aGUgY3VycmVudCBtb250aFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtYmVyT2ZNb250aHM7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0TW9udGggPSBkYXRlT2JqLmFkZCh7IG1vbnRoczogaSB9KTtcbiAgICAgICAgbW9udGhzLnB1c2goY3JlYXRlTW9udGgoe1xuICAgICAgICAgICAgLi4ubW9udGhQcm9wcyxcbiAgICAgICAgICAgIGRhdGVPYmo6IG5leHRNb250aCxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbW9udGhzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGFibGVDZWxscyhjYWxlbmRhck5vZGUpIHtcbiAgICBpZiAoIWNhbGVuZGFyTm9kZSlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNlbGVjdGFibGVTZWxlY3RvciA9IGBbZGF0YS1iaXRzLWRheV06bm90KFtkYXRhLWRpc2FibGVkXSk6bm90KFtkYXRhLW91dHNpZGUtdmlzaWJsZS1tb250aHNdKWA7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2FsZW5kYXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0YWJsZVNlbGVjdG9yKSkuZmlsdGVyKChlbCkgPT4gaXNIVE1MRWxlbWVudChlbCkpO1xufVxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBleHRyYWN0IHRoZSBkYXRlIGZyb20gdGhlIGBkYXRhLXZhbHVlYFxuICogYXR0cmlidXRlIG9mIGEgZGF0ZSBjZWxsIGFuZCBzZXQgaXQgYXMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICpcbiAqIFNoYXJlZCBiZXR3ZWVuIHRoZSBjYWxlbmRhciBhbmQgcmFuZ2UgY2FsZW5kYXIgYnVpbGRlcnMuXG4gKlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBleHRyYWN0IHRoZSBkYXRlIGZyb20uXG4gKiBAcGFyYW0gcGxhY2Vob2xkZXIgLSBUaGUgcGxhY2Vob2xkZXIgdmFsdWUgc3RvcmUgd2hpY2ggd2lsbCBiZSBzZXQgdG8gdGhlIGV4dHJhY3RlZCBkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UGxhY2Vob2xkZXJUb05vZGVWYWx1ZShub2RlLCBwbGFjZWhvbGRlcikge1xuICAgIGNvbnN0IGNlbGxWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKTtcbiAgICBpZiAoIWNlbGxWYWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHBsYWNlaG9sZGVyLmN1cnJlbnQgPSBwYXJzZVN0cmluZ1RvRGF0ZVZhbHVlKGNlbGxWYWx1ZSwgcGxhY2Vob2xkZXIuY3VycmVudCk7XG59XG4vKipcbiAqIFNoYXJlZCBsb2dpYyBmb3Igc2hpZnRpbmcgZm9jdXMgYmV0d2VlbiBjZWxscyBpbiB0aGVcbiAqIGNhbGVuZGFyIGFuZCByYW5nZSBjYWxlbmRhci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0Q2FsZW5kYXJGb2N1cyh7IG5vZGUsIGFkZCwgcGxhY2Vob2xkZXIsIGNhbGVuZGFyTm9kZSwgaXNQcmV2QnV0dG9uRGlzYWJsZWQsIGlzTmV4dEJ1dHRvbkRpc2FibGVkLCBtb250aHMsIG51bWJlck9mTW9udGhzLCB9KSB7XG4gICAgY29uc3QgY2FuZGlkYXRlQ2VsbHMgPSBnZXRTZWxlY3RhYmxlQ2VsbHMoY2FsZW5kYXJOb2RlKTtcbiAgICBpZiAoIWNhbmRpZGF0ZUNlbGxzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gY2FuZGlkYXRlQ2VsbHMuaW5kZXhPZihub2RlKTtcbiAgICBjb25zdCBuZXh0SW5kZXggPSBpbmRleCArIGFkZDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV4dCBjZWxsIGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5ZWQgY2VsbHMsXG4gICAgICogZWFzeSBkYXksIHdlIGp1c3QgZm9jdXMgaXQuXG4gICAgICovXG4gICAgaWYgKGlzVmFsaWRJbmRleChuZXh0SW5kZXgsIGNhbmRpZGF0ZUNlbGxzKSkge1xuICAgICAgICBjb25zdCBuZXh0Q2VsbCA9IGNhbmRpZGF0ZUNlbGxzW25leHRJbmRleF07XG4gICAgICAgIHNldFBsYWNlaG9sZGVyVG9Ob2RlVmFsdWUobmV4dENlbGwsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIG5leHRDZWxsLmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIG5leHQgY2VsbCBmYWxscyBvdXRzaWRlIHRoZSBkaXNwbGF5ZWQgY2VsbHMgcmFuZ2UsXG4gICAgICogd2UgdXBkYXRlIHRoZSBmb2N1cyB0byB0aGUgcHJldmlvdXMgb3IgbmV4dCBtb250aCBiYXNlZCBvbiB0aGVcbiAgICAgKiBkaXJlY3Rpb24sIGFuZCB0aGVuIGZvY3VzIG9uIHRoZSByZWxldmFudCBjZWxsLlxuICAgICAqL1xuICAgIGlmIChuZXh0SW5kZXggPCAwKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUbyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlcywgd2UgcmV3aW5kIGJ5IG9uZSBtb250aCxcbiAgICAgICAgICogcmV0cmlldmUgY2FuZGlkYXRlIGNlbGxzIGZvciB0aGF0IG1vbnRoLCBhbmQgc2hpZnQgZm9jdXNcbiAgICAgICAgICogYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV4dEluZGV4IHN0YXJ0aW5nIGZyb20gdGhlIGVuZFxuICAgICAgICAgKiBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBzaGlmdCB0aGUgY2FsZW5kYXIgYmFjayBhIG1vbnRoIHVubGVzcyBwcmV2IG1vbnRoIGlzIGRpc2FibGVkXG4gICAgICAgIGlmIChpc1ByZXZCdXR0b25EaXNhYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZmlyc3RNb250aCA9IG1vbnRoc1swXT8udmFsdWU7XG4gICAgICAgIGlmICghZmlyc3RNb250aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGxhY2Vob2xkZXIuY3VycmVudCA9IGZpcnN0TW9udGguc3VidHJhY3QoeyBtb250aHM6IG51bWJlck9mTW9udGhzIH0pO1xuICAgICAgICAvLyBXaXRob3V0IGEgdGljayBoZXJlLCBpdCBzZWVtcyB0byBiZSB0b28gcXVpY2sgZm9yIHRoZSBET00gdG8gdXBkYXRlXG4gICAgICAgIGFmdGVyVGljaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYW5kaWRhdGVDZWxscyA9IGdldFNlbGVjdGFibGVDZWxscyhjYWxlbmRhck5vZGUpO1xuICAgICAgICAgICAgaWYgKCFuZXdDYW5kaWRhdGVDZWxscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydGluZyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSwgc2hpZnQgZm9jdXMgYnkgdGhlIGRpZmZcbiAgICAgICAgICAgICAqIGJldHdlZW4gdGhlIG5leHRJbmRleCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIHNpbmNlIHRoZVxuICAgICAgICAgICAgICogbmV4dEluZGV4IGlzIG5lZ2F0aXZlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IG5ld0NhbmRpZGF0ZUNlbGxzLmxlbmd0aCAtIE1hdGguYWJzKG5leHRJbmRleCk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEluZGV4KG5ld0luZGV4LCBuZXdDYW5kaWRhdGVDZWxscykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDZWxsID0gbmV3Q2FuZGlkYXRlQ2VsbHNbbmV3SW5kZXhdO1xuICAgICAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyVG9Ob2RlVmFsdWUobmV3Q2VsbCwgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDZWxsLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobmV4dEluZGV4ID49IGNhbmRpZGF0ZUNlbGxzLmxlbmd0aCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2luY2Ugd2UncmUgaW4gdGhlIHBvc2l0aXZlIGluZGV4IHJhbmdlLCB3ZSBuZWVkIHRvIGdvIGZvcndhcmRcbiAgICAgICAgICogYSBtb250aCwgcmVmZXRjaCB0aGUgY2FuZGlkYXRlIGNlbGxzIHdpdGhpbiB0aGF0IG1vbnRoLCBhbmQgdGhlblxuICAgICAgICAgKiBzdGFydGluZyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSwgc2hpZnQgZm9jdXMgYnkgdGhlIG5leHRJbmRleFxuICAgICAgICAgKiBhbW91bnQuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBzaGlmdCB0aGUgY2FsZW5kYXIgZm9yd2FyZCBhIG1vbnRoIHVubGVzcyBuZXh0IG1vbnRoIGlzIGRpc2FibGVkXG4gICAgICAgIGlmIChpc05leHRCdXR0b25EaXNhYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZmlyc3RNb250aCA9IG1vbnRoc1swXT8udmFsdWU7XG4gICAgICAgIGlmICghZmlyc3RNb250aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGxhY2Vob2xkZXIuY3VycmVudCA9IGZpcnN0TW9udGguYWRkKHsgbW9udGhzOiBudW1iZXJPZk1vbnRocyB9KTtcbiAgICAgICAgYWZ0ZXJUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhbmRpZGF0ZUNlbGxzID0gZ2V0U2VsZWN0YWJsZUNlbGxzKGNhbGVuZGFyTm9kZSk7XG4gICAgICAgICAgICBpZiAoIW5ld0NhbmRpZGF0ZUNlbGxzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyBmYXIgaW50byB0aGUgbmV4dCBtb250aCB3ZSBuZWVkIHRvIGdvXG4gICAgICAgICAgICAgKiB0byBnZXQgdGhlIG5leHQgaW5kZXguIFNvIGlmIHdlIG9ubHkgd2VudCBvdmVyIHRoZSBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgICogYnkgb25lLCB3ZSBuZWVkIHRvIGdvIGludG8gdGhlIG5leHQgbW9udGggYnkgMSB0byBnZXQgdGhlIHJpZ2h0IGluZGV4LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IG5leHRJbmRleCAtIGNhbmRpZGF0ZUNlbGxzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkSW5kZXgobmV3SW5kZXgsIG5ld0NhbmRpZGF0ZUNlbGxzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDZWxsID0gbmV3Q2FuZGlkYXRlQ2VsbHNbbmV3SW5kZXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2VsbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBBUlJPV19LRVlTID0gW2tiZC5BUlJPV19ET1dOLCBrYmQuQVJST1dfVVAsIGtiZC5BUlJPV19MRUZULCBrYmQuQVJST1dfUklHSFRdO1xuY29uc3QgU0VMRUNUX0tFWVMgPSBba2JkLkVOVEVSLCBrYmQuU1BBQ0VdO1xuLyoqXG4gKiBTaGFyZWQga2V5Ym9hcmQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGNhbGVuZGFyIGFuZCByYW5nZSBjYWxlbmRhci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNhbGVuZGFyS2V5ZG93bih7IGV2ZW50LCBoYW5kbGVDZWxsQ2xpY2ssIHNoaWZ0Rm9jdXMsIHBsYWNlaG9sZGVyVmFsdWUsIH0pIHtcbiAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGV2ZW50LnRhcmdldDtcbiAgICBpZiAoIWlzQ2FsZW5kYXJEYXlOb2RlKGN1cnJlbnRDZWxsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0cy9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoIUFSUk9XX0tFWVMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiAhU0VMRUNUX0tFWVMuaW5jbHVkZXMoZXZlbnQua2V5KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qga2JkRm9jdXNNYXAgPSB7XG4gICAgICAgIFtrYmQuQVJST1dfRE9XTl06IDcsXG4gICAgICAgIFtrYmQuQVJST1dfVVBdOiAtNyxcbiAgICAgICAgW2tiZC5BUlJPV19MRUZUXTogLTEsXG4gICAgICAgIFtrYmQuQVJST1dfUklHSFRdOiAxLFxuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHRzL25vLWV4cGxpY2l0LWFueVxuICAgIGlmIChBUlJPV19LRVlTLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgY29uc3QgYWRkID0ga2JkRm9jdXNNYXBbZXZlbnQua2V5XTtcbiAgICAgICAgaWYgKGFkZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGlmdEZvY3VzKGN1cnJlbnRDZWxsLCBhZGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChTRUxFQ1RfS0VZUy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIGNvbnN0IGNlbGxWYWx1ZSA9IGN1cnJlbnRDZWxsLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIik7XG4gICAgICAgIGlmICghY2VsbFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoYW5kbGVDZWxsQ2xpY2soZXZlbnQsIHBhcnNlU3RyaW5nVG9EYXRlVmFsdWUoY2VsbFZhbHVlLCBwbGFjZWhvbGRlclZhbHVlKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNhbGVuZGFyTmV4dFBhZ2UoeyBtb250aHMsIHNldE1vbnRocywgbnVtYmVyT2ZNb250aHMsIHBhZ2VkTmF2aWdhdGlvbiwgd2Vla1N0YXJ0c09uLCBsb2NhbGUsIGZpeGVkV2Vla3MsIHNldFBsYWNlaG9sZGVyLCB9KSB7XG4gICAgY29uc3QgZmlyc3RNb250aCA9IG1vbnRoc1swXT8udmFsdWU7XG4gICAgaWYgKCFmaXJzdE1vbnRoKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHBhZ2VkTmF2aWdhdGlvbikge1xuICAgICAgICBzZXRQbGFjZWhvbGRlcihmaXJzdE1vbnRoLmFkZCh7IG1vbnRoczogbnVtYmVyT2ZNb250aHMgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TW9udGhzID0gY3JlYXRlTW9udGhzKHtcbiAgICAgICAgICAgIGRhdGVPYmo6IGZpcnN0TW9udGguYWRkKHsgbW9udGhzOiAxIH0pLFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgZml4ZWRXZWVrcyxcbiAgICAgICAgICAgIG51bWJlck9mTW9udGhzLFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0TW9udGhzKG5ld01vbnRocyk7XG4gICAgICAgIGNvbnN0IGZpcnN0TmV3TW9udGggPSBuZXdNb250aHNbMF07XG4gICAgICAgIGlmICghZmlyc3ROZXdNb250aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0UGxhY2Vob2xkZXIoZmlyc3ROZXdNb250aC52YWx1ZS5zZXQoeyBkYXk6IDEgfSkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVDYWxlbmRhclByZXZQYWdlKHsgbW9udGhzLCBzZXRNb250aHMsIG51bWJlck9mTW9udGhzLCBwYWdlZE5hdmlnYXRpb24sIHdlZWtTdGFydHNPbiwgbG9jYWxlLCBmaXhlZFdlZWtzLCBzZXRQbGFjZWhvbGRlciwgfSkge1xuICAgIGNvbnN0IGZpcnN0TW9udGggPSBtb250aHNbMF0/LnZhbHVlO1xuICAgIGlmICghZmlyc3RNb250aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChwYWdlZE5hdmlnYXRpb24pIHtcbiAgICAgICAgc2V0UGxhY2Vob2xkZXIoZmlyc3RNb250aC5zdWJ0cmFjdCh7IG1vbnRoczogbnVtYmVyT2ZNb250aHMgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TW9udGhzID0gY3JlYXRlTW9udGhzKHtcbiAgICAgICAgICAgIGRhdGVPYmo6IGZpcnN0TW9udGguc3VidHJhY3QoeyBtb250aHM6IDEgfSksXG4gICAgICAgICAgICB3ZWVrU3RhcnRzT24sXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBmaXhlZFdlZWtzLFxuICAgICAgICAgICAgbnVtYmVyT2ZNb250aHMsXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRNb250aHMobmV3TW9udGhzKTtcbiAgICAgICAgY29uc3QgZmlyc3ROZXdNb250aCA9IG5ld01vbnRoc1swXTtcbiAgICAgICAgaWYgKCFmaXJzdE5ld01vbnRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRQbGFjZWhvbGRlcihmaXJzdE5ld01vbnRoLnZhbHVlLnNldCh7IGRheTogMSB9KSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlZWtkYXlzKHsgbW9udGhzLCBmb3JtYXR0ZXIsIHdlZWtkYXlGb3JtYXQgfSkge1xuICAgIGlmICghbW9udGhzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGZpcnN0TW9udGggPSBtb250aHNbMF07XG4gICAgY29uc3QgZmlyc3RXZWVrID0gZmlyc3RNb250aC53ZWVrc1swXTtcbiAgICBpZiAoIWZpcnN0V2VlaylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHJldHVybiBmaXJzdFdlZWsubWFwKChkYXRlKSA9PiBmb3JtYXR0ZXIuZGF5T2ZXZWVrKHRvRGF0ZShkYXRlKSwgd2Vla2RheUZvcm1hdCkpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBkaXNwbGF5ZWQgbW9udGhzIGJhc2VkIG9uIGNoYW5nZXMgaW4gdGhlIG9wdGlvbnMgdmFsdWVzLFxuICogd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbW9udGggdG8gc2hvdyBpbiB0aGUgY2FsZW5kYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb250aFZpZXdPcHRpb25zU3luYyhwcm9wcykge1xuICAgIGNvbnN0IHdlZWtTdGFydHNPbiA9IHByb3BzLndlZWtTdGFydHNPbi5jdXJyZW50O1xuICAgIGNvbnN0IGxvY2FsZSA9IHByb3BzLmxvY2FsZS5jdXJyZW50O1xuICAgIGNvbnN0IGZpeGVkV2Vla3MgPSBwcm9wcy5maXhlZFdlZWtzLmN1cnJlbnQ7XG4gICAgY29uc3QgbnVtYmVyT2ZNb250aHMgPSBwcm9wcy5udW1iZXJPZk1vbnRocy5jdXJyZW50O1xuICAgIHVudHJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHByb3BzLnBsYWNlaG9sZGVyLmN1cnJlbnQ7XG4gICAgICAgIGlmICghcGxhY2Vob2xkZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNb250aFByb3BzID0ge1xuICAgICAgICAgICAgd2Vla1N0YXJ0c09uLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgZml4ZWRXZWVrcyxcbiAgICAgICAgICAgIG51bWJlck9mTW9udGhzLFxuICAgICAgICB9O1xuICAgICAgICBwcm9wcy5zZXRNb250aHMoY3JlYXRlTW9udGhzKHsgLi4uZGVmYXVsdE1vbnRoUHJvcHMsIGRhdGVPYmo6IHBsYWNlaG9sZGVyIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhY2Nlc3NpYmxlIGhlYWRpbmcgZWxlbWVudCBmb3IgdGhlIGNhbGVuZGFyLlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgaGVhZGluZyBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWNjZXNzaWJsZUhlYWRpbmcoeyBjYWxlbmRhck5vZGUsIGxhYmVsLCBhY2Nlc3NpYmxlSGVhZGluZ0lkLCB9KSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IHN0eWxlVG9TdHJpbmcoe1xuICAgICAgICBib3JkZXI6IFwiMHB4XCIsXG4gICAgICAgIGNsaXA6IFwicmVjdCgwcHgsIDBweCwgMHB4LCAwcHgpXCIsXG4gICAgICAgIGNsaXBQYXRoOiBcImluc2V0KDUwJSlcIixcbiAgICAgICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgICAgICBtYXJnaW46IFwiLTFweFwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgcGFkZGluZzogXCIwcHhcIixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgd2lkdGg6IFwiMXB4XCIsXG4gICAgfSk7XG4gICAgY29uc3QgaDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGgyLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgaDIuaWQgPSBhY2Nlc3NpYmxlSGVhZGluZ0lkO1xuICAgIGgyLnJvbGUgPSBcImhlYWRpbmdcIjtcbiAgICBoMi5hcmlhTGV2ZWwgPSBcIjJcIjtcbiAgICBjYWxlbmRhck5vZGUuaW5zZXJ0QmVmb3JlKGRpdiwgY2FsZW5kYXJOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChoMik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgaDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhY2Nlc3NpYmxlSGVhZGluZ0lkKTtcbiAgICAgICAgaWYgKCFoMilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGl2LnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIGgyLnJlbW92ZSgpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlTW9udGhWaWV3UGxhY2Vob2xkZXJTeW5jKHsgcGxhY2Vob2xkZXIsIGdldFZpc2libGVNb250aHMsIHdlZWtTdGFydHNPbiwgbG9jYWxlLCBmaXhlZFdlZWtzLCBudW1iZXJPZk1vbnRocywgc2V0TW9udGhzLCB9KSB7XG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHBsYWNlaG9sZGVyLmN1cnJlbnQ7XG4gICAgICAgIHVudHJhY2soKCkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcGxhY2Vob2xkZXIncyBtb250aCBpcyBhbHJlYWR5IGluIHRoaXMgdmlzaWJsZSBtb250aHMsXG4gICAgICAgICAgICAgKiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZ2V0VmlzaWJsZU1vbnRocygpLnNvbWUoKG1vbnRoKSA9PiBpc1NhbWVNb250aChtb250aCwgcGxhY2Vob2xkZXIuY3VycmVudCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdE1vbnRoUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24uY3VycmVudCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGZpeGVkV2Vla3M6IGZpeGVkV2Vla3MuY3VycmVudCxcbiAgICAgICAgICAgICAgICBudW1iZXJPZk1vbnRoczogbnVtYmVyT2ZNb250aHMuY3VycmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRNb250aHMoY3JlYXRlTW9udGhzKHsgLi4uZGVmYXVsdE1vbnRoUHJvcHMsIGRhdGVPYmo6IHBsYWNlaG9sZGVyLmN1cnJlbnQgfSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc05leHRCdXR0b25EaXNhYmxlZCh7IG1heFZhbHVlLCBtb250aHMsIGRpc2FibGVkLCB9KSB7XG4gICAgaWYgKCFtYXhWYWx1ZSB8fCAhbW9udGhzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgbGFzdE1vbnRoSW5WaWV3ID0gbW9udGhzW21vbnRocy5sZW5ndGggLSAxXT8udmFsdWU7XG4gICAgaWYgKCFsYXN0TW9udGhJblZpZXcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBmaXJzdE1vbnRoT2ZOZXh0UGFnZSA9IGxhc3RNb250aEluVmlld1xuICAgICAgICAuYWRkKHtcbiAgICAgICAgbW9udGhzOiAxLFxuICAgIH0pXG4gICAgICAgIC5zZXQoeyBkYXk6IDEgfSk7XG4gICAgcmV0dXJuIGlzQWZ0ZXIoZmlyc3RNb250aE9mTmV4dFBhZ2UsIG1heFZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc1ByZXZCdXR0b25EaXNhYmxlZCh7IG1pblZhbHVlLCBtb250aHMsIGRpc2FibGVkLCB9KSB7XG4gICAgaWYgKCFtaW5WYWx1ZSB8fCAhbW9udGhzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgZmlyc3RNb250aEluVmlldyA9IG1vbnRoc1swXT8udmFsdWU7XG4gICAgaWYgKCFmaXJzdE1vbnRoSW5WaWV3KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGFzdE1vbnRoT2ZQcmV2UGFnZSA9IGZpcnN0TW9udGhJblZpZXdcbiAgICAgICAgLnN1YnRyYWN0KHtcbiAgICAgICAgbW9udGhzOiAxLFxuICAgIH0pXG4gICAgICAgIC5zZXQoeyBkYXk6IDM1IH0pO1xuICAgIHJldHVybiBpc0JlZm9yZShsYXN0TW9udGhPZlByZXZQYWdlLCBtaW5WYWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJIZWFkaW5nVmFsdWUoeyBtb250aHMsIGxvY2FsZSwgZm9ybWF0dGVyLCB9KSB7XG4gICAgaWYgKCFtb250aHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBpZiAobG9jYWxlICE9PSBmb3JtYXR0ZXIuZ2V0TG9jYWxlKCkpIHtcbiAgICAgICAgZm9ybWF0dGVyLnNldExvY2FsZShsb2NhbGUpO1xuICAgIH1cbiAgICBpZiAobW9udGhzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBtb250aCA9IHRvRGF0ZShtb250aHNbMF0udmFsdWUpO1xuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVyLmZ1bGxNb250aEFuZFllYXIobW9udGgpfWA7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0TW9udGggPSB0b0RhdGUobW9udGhzWzBdLnZhbHVlKTtcbiAgICBjb25zdCBlbmRNb250aCA9IHRvRGF0ZShtb250aHNbbW9udGhzLmxlbmd0aCAtIDFdLnZhbHVlKTtcbiAgICBjb25zdCBzdGFydE1vbnRoTmFtZSA9IGZvcm1hdHRlci5mdWxsTW9udGgoc3RhcnRNb250aCk7XG4gICAgY29uc3QgZW5kTW9udGhOYW1lID0gZm9ybWF0dGVyLmZ1bGxNb250aChlbmRNb250aCk7XG4gICAgY29uc3Qgc3RhcnRNb250aFllYXIgPSBmb3JtYXR0ZXIuZnVsbFllYXIoc3RhcnRNb250aCk7XG4gICAgY29uc3QgZW5kTW9udGhZZWFyID0gZm9ybWF0dGVyLmZ1bGxZZWFyKGVuZE1vbnRoKTtcbiAgICBjb25zdCBjb250ZW50ID0gc3RhcnRNb250aFllYXIgPT09IGVuZE1vbnRoWWVhclxuICAgICAgICA/IGAke3N0YXJ0TW9udGhOYW1lfSAtICR7ZW5kTW9udGhOYW1lfSAke2VuZE1vbnRoWWVhcn1gXG4gICAgICAgIDogYCR7c3RhcnRNb250aE5hbWV9ICR7c3RhcnRNb250aFllYXJ9IC0gJHtlbmRNb250aE5hbWV9ICR7ZW5kTW9udGhZZWFyfWA7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJFbGVtZW50UHJvcHMoeyBmdWxsQ2FsZW5kYXJMYWJlbCwgaWQsIGlzSW52YWxpZCwgZGlzYWJsZWQsIHJlYWRvbmx5LCB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJvbGU6IFwiYXBwbGljYXRpb25cIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGZ1bGxDYWxlbmRhckxhYmVsLFxuICAgICAgICBcImRhdGEtaW52YWxpZFwiOiBnZXREYXRhSW52YWxpZChpc0ludmFsaWQpLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKGRpc2FibGVkKSxcbiAgICAgICAgXCJkYXRhLXJlYWRvbmx5XCI6IGdldERhdGFSZWFkb25seShyZWFkb25seSksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaWNrZXJPcGVuRm9jdXMoZSkge1xuICAgIGNvbnN0IG5vZGVUb0ZvY3VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWJpdHMtZGF5XVtkYXRhLWZvY3VzZWRdXCIpO1xuICAgIGlmIChub2RlVG9Gb2N1cykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVUb0ZvY3VzPy5mb2N1cygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldExvY2FsVGltZVpvbmUsIGlzU2FtZURheSwgaXNTYW1lTW9udGgsIGlzVG9kYXksIH0gZnJvbSBcIkBpbnRlcm5hdGlvbmFsaXplZC9kYXRlXCI7XG5pbXBvcnQgeyBERVYgfSBmcm9tIFwiZXNtLWVudlwiO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gXCJzdmVsdGVcIjtcbmltcG9ydCB7IHVzZVJlZkJ5SWQgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5pbXBvcnQgeyBnZXRBcmlhRGlzYWJsZWQsIGdldEFyaWFIaWRkZW4sIGdldEFyaWFSZWFkb25seSwgZ2V0QXJpYVNlbGVjdGVkLCBnZXREYXRhRGlzYWJsZWQsIGdldERhdGFSZWFkb25seSwgZ2V0RGF0YVNlbGVjdGVkLCBnZXREYXRhVW5hdmFpbGFibGUsIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2F0dHJzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2NyZWF0ZS1jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcbmltcG9ydCB7IGdldEFubm91bmNlciB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9kYXRlLXRpbWUvYW5ub3VuY2VyLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvZGF0ZS10aW1lL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQWNjZXNzaWJsZUhlYWRpbmcsIGNyZWF0ZU1vbnRocywgZ2V0Q2FsZW5kYXJFbGVtZW50UHJvcHMsIGdldENhbGVuZGFySGVhZGluZ1ZhbHVlLCBnZXRJc05leHRCdXR0b25EaXNhYmxlZCwgZ2V0SXNQcmV2QnV0dG9uRGlzYWJsZWQsIGdldFdlZWtkYXlzLCBoYW5kbGVDYWxlbmRhcktleWRvd24sIGhhbmRsZUNhbGVuZGFyTmV4dFBhZ2UsIGhhbmRsZUNhbGVuZGFyUHJldlBhZ2UsIHNoaWZ0Q2FsZW5kYXJGb2N1cywgdXNlTW9udGhWaWV3T3B0aW9uc1N5bmMsIHVzZU1vbnRoVmlld1BsYWNlaG9sZGVyU3luYywgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvZGF0ZS10aW1lL2NhbGVuZGFyLWhlbHBlcnMuc3ZlbHRlLmpzXCI7XG5pbXBvcnQgeyBpc0JlZm9yZSwgdG9EYXRlIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2RhdGUtdGltZS91dGlscy5qc1wiO1xuZXhwb3J0IGNsYXNzIENhbGVuZGFyUm9vdFN0YXRlIHtcbiAgICByZWY7XG4gICAgaWQ7XG4gICAgdmFsdWU7XG4gICAgcGxhY2Vob2xkZXI7XG4gICAgcHJldmVudERlc2VsZWN0O1xuICAgIG1pblZhbHVlO1xuICAgIG1heFZhbHVlO1xuICAgIGRpc2FibGVkO1xuICAgIHBhZ2VkTmF2aWdhdGlvbjtcbiAgICB3ZWVrU3RhcnRzT247XG4gICAgd2Vla2RheUZvcm1hdDtcbiAgICBpc0RhdGVEaXNhYmxlZFByb3A7XG4gICAgaXNEYXRlVW5hdmFpbGFibGVQcm9wO1xuICAgIGZpeGVkV2Vla3M7XG4gICAgbnVtYmVyT2ZNb250aHM7XG4gICAgbG9jYWxlO1xuICAgIGNhbGVuZGFyTGFiZWw7XG4gICAgdHlwZTtcbiAgICByZWFkb25seTtcbiAgICBkaXNhYmxlRGF5c091dHNpZGVNb250aDtcbiAgICBvbkRhdGVTZWxlY3Q7XG4gICAgaW5pdGlhbEZvY3VzO1xuICAgIG1vbnRocyA9ICRzdGF0ZShbXSk7XG4gICAgdmlzaWJsZU1vbnRocyA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMubW9udGhzLm1hcCgobW9udGgpID0+IG1vbnRoLnZhbHVlKSk7XG4gICAgYW5ub3VuY2VyO1xuICAgIGZvcm1hdHRlcjtcbiAgICBhY2Nlc3NpYmxlSGVhZGluZ0lkID0gdXNlSWQoKTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVzZWxlY3QgPSBwcm9wcy5wcmV2ZW50RGVzZWxlY3Q7XG4gICAgICAgIHRoaXMubWluVmFsdWUgPSBwcm9wcy5taW5WYWx1ZTtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IHByb3BzLm1heFZhbHVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMucGFnZWROYXZpZ2F0aW9uID0gcHJvcHMucGFnZWROYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLndlZWtTdGFydHNPbiA9IHByb3BzLndlZWtTdGFydHNPbjtcbiAgICAgICAgdGhpcy53ZWVrZGF5Rm9ybWF0ID0gcHJvcHMud2Vla2RheUZvcm1hdDtcbiAgICAgICAgdGhpcy5pc0RhdGVEaXNhYmxlZFByb3AgPSBwcm9wcy5pc0RhdGVEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5pc0RhdGVVbmF2YWlsYWJsZVByb3AgPSBwcm9wcy5pc0RhdGVVbmF2YWlsYWJsZTtcbiAgICAgICAgdGhpcy5maXhlZFdlZWtzID0gcHJvcHMuZml4ZWRXZWVrcztcbiAgICAgICAgdGhpcy5udW1iZXJPZk1vbnRocyA9IHByb3BzLm51bWJlck9mTW9udGhzO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICAgICAgdGhpcy5jYWxlbmRhckxhYmVsID0gcHJvcHMuY2FsZW5kYXJMYWJlbDtcbiAgICAgICAgdGhpcy50eXBlID0gcHJvcHMudHlwZTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHByb3BzLnJlYWRvbmx5O1xuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLmRpc2FibGVEYXlzT3V0c2lkZU1vbnRoID0gcHJvcHMuZGlzYWJsZURheXNPdXRzaWRlTW9udGg7XG4gICAgICAgIHRoaXMub25EYXRlU2VsZWN0ID0gcHJvcHMub25EYXRlU2VsZWN0O1xuICAgICAgICB0aGlzLmluaXRpYWxGb2N1cyA9IHByb3BzLmluaXRpYWxGb2N1cztcbiAgICAgICAgdGhpcy5hbm5vdW5jZXIgPSBnZXRBbm5vdW5jZXIoKTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIodGhpcy5sb2NhbGUuY3VycmVudCk7XG4gICAgICAgIHRoaXMuc2V0TW9udGhzID0gdGhpcy5zZXRNb250aHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXh0UGFnZSA9IHRoaXMubmV4dFBhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcmV2UGFnZSA9IHRoaXMucHJldlBhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcmV2WWVhciA9IHRoaXMucHJldlllYXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXh0WWVhciA9IHRoaXMubmV4dFllYXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRZZWFyID0gdGhpcy5zZXRZZWFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TW9udGggPSB0aGlzLnNldE1vbnRoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPdXRzaWRlVmlzaWJsZU1vbnRocyA9IHRoaXMuaXNPdXRzaWRlVmlzaWJsZU1vbnRocy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzRGF0ZURpc2FibGVkID0gdGhpcy5pc0RhdGVEaXNhYmxlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzRGF0ZVNlbGVjdGVkID0gdGhpcy5pc0RhdGVTZWxlY3RlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNoaWZ0Rm9jdXMgPSB0aGlzLnNoaWZ0Rm9jdXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDZWxsQ2xpY2sgPSB0aGlzLmhhbmRsZUNlbGxDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZU11bHRpcGxlVXBkYXRlID0gdGhpcy5oYW5kbGVNdWx0aXBsZVVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZVVwZGF0ZSA9IHRoaXMuaGFuZGxlU2luZ2xlVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25rZXlkb3duID0gdGhpcy5vbmtleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRCaXRzQXR0ciA9IHRoaXMuZ2V0Qml0c0F0dHIuYmluZCh0aGlzKTtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vbnRocyA9IGNyZWF0ZU1vbnRocyh7XG4gICAgICAgICAgICBkYXRlT2JqOiB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQsXG4gICAgICAgICAgICB3ZWVrU3RhcnRzT246IHRoaXMud2Vla1N0YXJ0c09uLmN1cnJlbnQsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgICAgICBmaXhlZFdlZWtzOiB0aGlzLmZpeGVkV2Vla3MuY3VycmVudCxcbiAgICAgICAgICAgIG51bWJlck9mTW9udGhzOiB0aGlzLm51bWJlck9mTW9udGhzLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxGb2N1cyA9IHVudHJhY2soKCkgPT4gdGhpcy5pbml0aWFsRm9jdXMuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9jdXMgdGhlIGZpcnN0IGBkYXRhLWZvY3VzZWRgIGRheSBub2RlXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RGb2N1c2VkRGF5ID0gdGhpcy5yZWYuY3VycmVudD8ucXVlcnlTZWxlY3RvcihgW2RhdGEtZm9jdXNlZF1gKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RGb2N1c2VkRGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Rm9jdXNlZERheS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUhlYWRpbmcgPSBjcmVhdGVBY2Nlc3NpYmxlSGVhZGluZyh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJOb2RlOiB0aGlzLnJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmZ1bGxDYWxlbmRhckxhYmVsLFxuICAgICAgICAgICAgICAgIGFjY2Vzc2libGVIZWFkaW5nSWQ6IHRoaXMuYWNjZXNzaWJsZUhlYWRpbmdJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUhlYWRpbmc7XG4gICAgICAgIH0pO1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdHRlci5nZXRMb2NhbGUoKSA9PT0gdGhpcy5sb2NhbGUuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlci5zZXRMb2NhbGUodGhpcy5sb2NhbGUuY3VycmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZGlzcGxheWVkIG1vbnRocyBiYXNlZCBvbiBjaGFuZ2VzIGluIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHVzZU1vbnRoVmlld1BsYWNlaG9sZGVyU3luYyh7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogdGhpcy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgIGdldFZpc2libGVNb250aHM6ICgpID0+IHRoaXMudmlzaWJsZU1vbnRocyxcbiAgICAgICAgICAgIHdlZWtTdGFydHNPbjogdGhpcy53ZWVrU3RhcnRzT24sXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLFxuICAgICAgICAgICAgbnVtYmVyT2ZNb250aHM6IHRoaXMubnVtYmVyT2ZNb250aHMsXG4gICAgICAgICAgICBzZXRNb250aHM6IChtb250aHMpID0+ICh0aGlzLm1vbnRocyA9IG1vbnRocyksXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZGlzcGxheWVkIG1vbnRocyBiYXNlZCBvbiBjaGFuZ2VzIGluIHRoZSBvcHRpb25zIHZhbHVlcyxcbiAgICAgICAgICogd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbW9udGggdG8gc2hvdyBpbiB0aGUgY2FsZW5kYXIuXG4gICAgICAgICAqL1xuICAgICAgICB1c2VNb250aFZpZXdPcHRpb25zU3luYyh7XG4gICAgICAgICAgICBmaXhlZFdlZWtzOiB0aGlzLmZpeGVkV2Vla3MsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgbnVtYmVyT2ZNb250aHM6IHRoaXMubnVtYmVyT2ZNb250aHMsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogdGhpcy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgIHNldE1vbnRoczogdGhpcy5zZXRNb250aHMsXG4gICAgICAgICAgICB3ZWVrU3RhcnRzT246IHRoaXMud2Vla1N0YXJ0c09uLFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgYWNjZXNzaWJsZSBoZWFkaW5nJ3MgdGV4dCBjb250ZW50IHdoZW4gdGhlIGBmdWxsQ2FsZW5kYXJMYWJlbGBcbiAgICAgICAgICogY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuYWNjZXNzaWJsZUhlYWRpbmdJZCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHRoaXMuZnVsbENhbGVuZGFyTGFiZWw7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3luY2hyb25pemUgdGhlIHBsYWNlaG9sZGVyIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuY3VycmVudDtcbiAgICAgICAgICAgIHVudHJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VmFsdWUgJiYgdGhpcy5wbGFjZWhvbGRlci5jdXJyZW50ICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGxhc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUgJiYgdGhpcy5wbGFjZWhvbGRlci5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE1vbnRocyhtb250aHMpIHtcbiAgICAgICAgdGhpcy5tb250aHMgPSBtb250aHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZGVyaXZlZCBzdGF0ZSBob2xkcyBhbiBhcnJheSBvZiBsb2NhbGl6ZWQgZGF5IG5hbWVzIGZvciB0aGUgY3VycmVudFxuICAgICAqIGxvY2FsZSBhbmQgY2FsZW5kYXIgdmlldy4gSXQgZHluYW1pY2FsbHkgc3luY3Mgd2l0aCB0aGUgJ3dlZWtTdGFydHNPbicgb3B0aW9uLFxuICAgICAqIHVwZGF0aW5nIGl0cyBjb250ZW50IHdoZW4gdGhlIG9wdGlvbiBjaGFuZ2VzLiBVc2luZyB0aGlzIHN0YXRlIHRvIHJlbmRlciB0aGVcbiAgICAgKiBjYWxlbmRhcidzIGRheXMgb2YgdGhlIHdlZWsgaXMgc3Ryb25nbHkgcmVjb21tZW5kZWQsIGFzIGl0IGd1YXJhbnRlZXMgdGhhdFxuICAgICAqIHRoZSBkYXlzIGFyZSBjb3JyZWN0bHkgZm9ybWF0dGVkIGZvciB0aGUgY3VycmVudCBsb2NhbGUgYW5kIGNhbGVuZGFyIHZpZXcuXG4gICAgICovXG4gICAgd2Vla2RheXMgPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRXZWVrZGF5cyh7XG4gICAgICAgICAgICBtb250aHM6IHRoaXMubW9udGhzLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiB0aGlzLmZvcm1hdHRlcixcbiAgICAgICAgICAgIHdlZWtkYXlGb3JtYXQ6IHRoaXMud2Vla2RheUZvcm1hdC5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIG5leHQgcGFnZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAgICovXG4gICAgbmV4dFBhZ2UoKSB7XG4gICAgICAgIGhhbmRsZUNhbGVuZGFyTmV4dFBhZ2Uoe1xuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLmN1cnJlbnQsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRoczogdGhpcy5udW1iZXJPZk1vbnRocy5jdXJyZW50LFxuICAgICAgICAgICAgcGFnZWROYXZpZ2F0aW9uOiB0aGlzLnBhZ2VkTmF2aWdhdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgc2V0TW9udGhzOiB0aGlzLnNldE1vbnRocyxcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyOiAoZGF0ZSkgPT4gKHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGRhdGUpLFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB0aGlzLndlZWtTdGFydHNPbi5jdXJyZW50LFxuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyB0byB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAgICovXG4gICAgcHJldlBhZ2UoKSB7XG4gICAgICAgIGhhbmRsZUNhbGVuZGFyUHJldlBhZ2Uoe1xuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLmN1cnJlbnQsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRoczogdGhpcy5udW1iZXJPZk1vbnRocy5jdXJyZW50LFxuICAgICAgICAgICAgcGFnZWROYXZpZ2F0aW9uOiB0aGlzLnBhZ2VkTmF2aWdhdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgc2V0TW9udGhzOiB0aGlzLnNldE1vbnRocyxcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyOiAoZGF0ZSkgPT4gKHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGRhdGUpLFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB0aGlzLndlZWtTdGFydHNPbi5jdXJyZW50LFxuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHRZZWFyKCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQuYWRkKHsgeWVhcnM6IDEgfSk7XG4gICAgfVxuICAgIHByZXZZZWFyKCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQuc3VidHJhY3QoeyB5ZWFyczogMSB9KTtcbiAgICB9XG4gICAgc2V0WWVhcih5ZWFyKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IHRoaXMucGxhY2Vob2xkZXIuY3VycmVudC5zZXQoeyB5ZWFyIH0pO1xuICAgIH1cbiAgICBzZXRNb250aChtb250aCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQuc2V0KHsgbW9udGggfSk7XG4gICAgfVxuICAgIGlzTmV4dEJ1dHRvbkRpc2FibGVkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0SXNOZXh0QnV0dG9uRGlzYWJsZWQoe1xuICAgICAgICAgICAgbWF4VmFsdWU6IHRoaXMubWF4VmFsdWUuY3VycmVudCxcbiAgICAgICAgICAgIG1vbnRoczogdGhpcy5tb250aHMsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZC5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpc1ByZXZCdXR0b25EaXNhYmxlZCA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldElzUHJldkJ1dHRvbkRpc2FibGVkKHtcbiAgICAgICAgICAgIG1pblZhbHVlOiB0aGlzLm1pblZhbHVlLmN1cnJlbnQsXG4gICAgICAgICAgICBtb250aHM6IHRoaXMubW9udGhzLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQuY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXNJbnZhbGlkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWUuY3VycmVudDtcbiAgICAgICAgY29uc3QgaXNEYXRlRGlzYWJsZWQgPSB0aGlzLmlzRGF0ZURpc2FibGVkUHJvcC5jdXJyZW50O1xuICAgICAgICBjb25zdCBpc0RhdGVVbmF2YWlsYWJsZSA9IHRoaXMuaXNEYXRlVW5hdmFpbGFibGVQcm9wLmN1cnJlbnQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYXRlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZURpc2FibGVkKGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlVW5hdmFpbGFibGUoZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXNEYXRlRGlzYWJsZWQodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGlzRGF0ZVVuYXZhaWxhYmxlKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgaGVhZGluZ1ZhbHVlID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0Q2FsZW5kYXJIZWFkaW5nVmFsdWUoe1xuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdGhpcy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZ1bGxDYWxlbmRhckxhYmVsID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jYWxlbmRhckxhYmVsLmN1cnJlbnR9ICR7dGhpcy5oZWFkaW5nVmFsdWV9YDtcbiAgICB9KTtcbiAgICBpc091dHNpZGVWaXNpYmxlTW9udGhzKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnZpc2libGVNb250aHMuc29tZSgobW9udGgpID0+IGlzU2FtZU1vbnRoKGRhdGUsIG1vbnRoKSk7XG4gICAgfVxuICAgIGlzRGF0ZURpc2FibGVkKGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlRGlzYWJsZWRQcm9wLmN1cnJlbnQoZGF0ZSkgfHwgdGhpcy5kaXNhYmxlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IG1pblZhbHVlID0gdGhpcy5taW5WYWx1ZS5jdXJyZW50O1xuICAgICAgICBjb25zdCBtYXhWYWx1ZSA9IHRoaXMubWF4VmFsdWUuY3VycmVudDtcbiAgICAgICAgaWYgKG1pblZhbHVlICYmIGlzQmVmb3JlKGRhdGUsIG1pblZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWF4VmFsdWUgJiYgaXNCZWZvcmUobWF4VmFsdWUsIGRhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNEYXRlU2VsZWN0ZWQoZGF0ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWUuY3VycmVudDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc29tZSgoZCkgPT4gaXNTYW1lRGF5KGQsIGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkodmFsdWUsIGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNoaWZ0Rm9jdXMobm9kZSwgYWRkKSB7XG4gICAgICAgIHJldHVybiBzaGlmdENhbGVuZGFyRm9jdXMoe1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGFkZCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgY2FsZW5kYXJOb2RlOiB0aGlzLnJlZi5jdXJyZW50LFxuICAgICAgICAgICAgaXNQcmV2QnV0dG9uRGlzYWJsZWQ6IHRoaXMuaXNQcmV2QnV0dG9uRGlzYWJsZWQsXG4gICAgICAgICAgICBpc05leHRCdXR0b25EaXNhYmxlZDogdGhpcy5pc05leHRCdXR0b25EaXNhYmxlZCxcbiAgICAgICAgICAgIG1vbnRoczogdGhpcy5tb250aHMsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRoczogdGhpcy5udW1iZXJPZk1vbnRocy5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ2VsbENsaWNrKF8sIGRhdGUpIHtcbiAgICAgICAgY29uc3QgcmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmN1cnJlbnQ7XG4gICAgICAgIGlmIChyZWFkb25seSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNEYXRlRGlzYWJsZWQgPSB0aGlzLmlzRGF0ZURpc2FibGVkUHJvcC5jdXJyZW50O1xuICAgICAgICBjb25zdCBpc0RhdGVVbmF2YWlsYWJsZSA9IHRoaXMuaXNEYXRlVW5hdmFpbGFibGVQcm9wLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpc0RhdGVEaXNhYmxlZD8uKGRhdGUpIHx8IGlzRGF0ZVVuYXZhaWxhYmxlPy4oZGF0ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLnZhbHVlLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG11bHRpcGxlID0gdGhpcy50eXBlLmN1cnJlbnQgPT09IFwibXVsdGlwbGVcIjtcbiAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcmV2KSB8fCBwcmV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmN1cnJlbnQgPSB0aGlzLmhhbmRsZU11bHRpcGxlVXBkYXRlKHByZXYsIGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaGFuZGxlU2luZ2xlVXBkYXRlKHByZXYsIGRhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlci5hbm5vdW5jZShcIlNlbGVjdGVkIGRhdGUgaXMgbm93IGVtcHR5LlwiLCBcInBvbGl0ZVwiLCA1MDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VyLmFubm91bmNlKGBTZWxlY3RlZCBEYXRlOiAke3RoaXMuZm9ybWF0dGVyLnNlbGVjdGVkRGF0ZShuZXh0LCBmYWxzZSl9YCwgXCJwb2xpdGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0ZVNlbGVjdD8uY3VycmVudD8uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU11bHRpcGxlVXBkYXRlKHByZXYsIGRhdGUpIHtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgcmV0dXJuIFtkYXRlXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKSB7XG4gICAgICAgICAgICBpZiAoREVWKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIG11bHRpcGxlIHByb3AuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcHJldi5maW5kSW5kZXgoKGQpID0+IGlzU2FtZURheShkLCBkYXRlKSk7XG4gICAgICAgIGNvbnN0IHByZXZlbnREZXNlbGVjdCA9IHRoaXMucHJldmVudERlc2VsZWN0LmN1cnJlbnQ7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgZGF0ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmVudERlc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcmV2LmZpbHRlcigoZCkgPT4gIWlzU2FtZURheShkLCBkYXRlKSk7XG4gICAgICAgICAgICBpZiAoIW5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5jdXJyZW50ID0gZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU2luZ2xlVXBkYXRlKHByZXYsIGRhdGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJldikpIHtcbiAgICAgICAgICAgIGlmIChERVYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3Igc2luZ2xlIHByb3AuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldilcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICBjb25zdCBwcmV2ZW50RGVzZWxlY3QgPSB0aGlzLnByZXZlbnREZXNlbGVjdC5jdXJyZW50O1xuICAgICAgICBpZiAoIXByZXZlbnREZXNlbGVjdCAmJiBpc1NhbWVEYXkocHJldiwgZGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGRhdGU7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBvbmtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgaGFuZGxlQ2FsZW5kYXJLZXlkb3duKHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgaGFuZGxlQ2VsbENsaWNrOiB0aGlzLmhhbmRsZUNlbGxDbGljayxcbiAgICAgICAgICAgIHNoaWZ0Rm9jdXM6IHRoaXMuc2hpZnRGb2N1cyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyVmFsdWU6IHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNuaXBwZXRQcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIG1vbnRoczogdGhpcy5tb250aHMsXG4gICAgICAgIHdlZWtkYXlzOiB0aGlzLndlZWtkYXlzLFxuICAgIH0pKTtcbiAgICBnZXRCaXRzQXR0cihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBgZGF0YS1iaXRzLWNhbGVuZGFyLSR7cGFydH1gO1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIC4uLmdldENhbGVuZGFyRWxlbWVudFByb3BzKHtcbiAgICAgICAgICAgIGZ1bGxDYWxlbmRhckxhYmVsOiB0aGlzLmZ1bGxDYWxlbmRhckxhYmVsLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQuY3VycmVudCxcbiAgICAgICAgICAgIGlzSW52YWxpZDogdGhpcy5pc0ludmFsaWQsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZC5jdXJyZW50LFxuICAgICAgICAgICAgcmVhZG9ubHk6IHRoaXMucmVhZG9ubHkuY3VycmVudCxcbiAgICAgICAgfSksXG4gICAgICAgIFt0aGlzLmdldEJpdHNBdHRyKFwicm9vdFwiKV06IFwiXCIsXG4gICAgICAgIC8vXG4gICAgICAgIG9ua2V5ZG93bjogdGhpcy5vbmtleWRvd24sXG4gICAgfSkpO1xufVxuZXhwb3J0IGNsYXNzIENhbGVuZGFySGVhZGluZ1N0YXRlIHtcbiAgICByb290O1xuICAgIGlkO1xuICAgIHJlZjtcbiAgICBoZWFkaW5nVmFsdWUgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLnJvb3QuaGVhZGluZ1ZhbHVlKTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuaWQuY3VycmVudCxcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBnZXRBcmlhSGlkZGVuKHRydWUpLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMucm9vdC5kaXNhYmxlZC5jdXJyZW50KSxcbiAgICAgICAgXCJkYXRhLXJlYWRvbmx5XCI6IGdldERhdGFSZWFkb25seSh0aGlzLnJvb3QucmVhZG9ubHkuY3VycmVudCksXG4gICAgICAgIFt0aGlzLnJvb3QuZ2V0Qml0c0F0dHIoXCJoZWFkaW5nXCIpXTogXCJcIixcbiAgICB9KSk7XG59XG5jbGFzcyBDYWxlbmRhckNlbGxTdGF0ZSB7XG4gICAgcm9vdDtcbiAgICBpZDtcbiAgICByZWY7XG4gICAgZGF0ZTtcbiAgICBtb250aDtcbiAgICBjZWxsRGF0ZSA9ICRkZXJpdmVkLmJ5KCgpID0+IHRvRGF0ZSh0aGlzLmRhdGUuY3VycmVudCkpO1xuICAgIGlzRGlzYWJsZWQgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLnJvb3QuaXNEYXRlRGlzYWJsZWQodGhpcy5kYXRlLmN1cnJlbnQpKTtcbiAgICBpc1VuYXZhaWxhYmxlID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmlzRGF0ZVVuYXZhaWxhYmxlUHJvcC5jdXJyZW50KHRoaXMuZGF0ZS5jdXJyZW50KSk7XG4gICAgaXNEYXRlVG9kYXkgPSAkZGVyaXZlZC5ieSgoKSA9PiBpc1RvZGF5KHRoaXMuZGF0ZS5jdXJyZW50LCBnZXRMb2NhbFRpbWVab25lKCkpKTtcbiAgICBpc091dHNpZGVNb250aCA9ICRkZXJpdmVkLmJ5KCgpID0+ICFpc1NhbWVNb250aCh0aGlzLmRhdGUuY3VycmVudCwgdGhpcy5tb250aC5jdXJyZW50KSk7XG4gICAgaXNPdXRzaWRlVmlzaWJsZU1vbnRocyA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMucm9vdC5pc091dHNpZGVWaXNpYmxlTW9udGhzKHRoaXMuZGF0ZS5jdXJyZW50KSk7XG4gICAgaXNGb2N1c2VkRGF0ZSA9ICRkZXJpdmVkLmJ5KCgpID0+IGlzU2FtZURheSh0aGlzLmRhdGUuY3VycmVudCwgdGhpcy5yb290LnBsYWNlaG9sZGVyLmN1cnJlbnQpKTtcbiAgICBpc1NlbGVjdGVkRGF0ZSA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMucm9vdC5pc0RhdGVTZWxlY3RlZCh0aGlzLmRhdGUuY3VycmVudCkpO1xuICAgIGxhYmVsVGV4dCA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMucm9vdC5mb3JtYXR0ZXIuY3VzdG9tKHRoaXMuY2VsbERhdGUsIHtcbiAgICAgICAgd2Vla2RheTogXCJsb25nXCIsXG4gICAgICAgIG1vbnRoOiBcImxvbmdcIixcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgfSkpO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCByb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHByb3BzLmRhdGU7XG4gICAgICAgIHRoaXMubW9udGggPSBwcm9wcy5tb250aDtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzbmlwcGV0UHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkLFxuICAgICAgICB1bmF2YWlsYWJsZTogdGhpcy5pc1VuYXZhaWxhYmxlLFxuICAgICAgICBzZWxlY3RlZDogdGhpcy5pc1NlbGVjdGVkRGF0ZSxcbiAgICB9KSk7XG4gICAgYXJpYURpc2FibGVkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNEaXNhYmxlZCB8fFxuICAgICAgICAgICAgKHRoaXMuaXNPdXRzaWRlTW9udGggJiYgdGhpcy5yb290LmRpc2FibGVEYXlzT3V0c2lkZU1vbnRoLmN1cnJlbnQpIHx8XG4gICAgICAgICAgICB0aGlzLmlzVW5hdmFpbGFibGUpO1xuICAgIH0pO1xuICAgIHNoYXJlZERhdGFBdHRycyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIFwiZGF0YS11bmF2YWlsYWJsZVwiOiBnZXREYXRhVW5hdmFpbGFibGUodGhpcy5pc1VuYXZhaWxhYmxlKSxcbiAgICAgICAgXCJkYXRhLXRvZGF5XCI6IHRoaXMuaXNEYXRlVG9kYXkgPyBcIlwiIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtb3V0c2lkZS1tb250aFwiOiB0aGlzLmlzT3V0c2lkZU1vbnRoID8gXCJcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJkYXRhLW91dHNpZGUtdmlzaWJsZS1tb250aHNcIjogdGhpcy5pc091dHNpZGVWaXNpYmxlTW9udGhzID8gXCJcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJkYXRhLWZvY3VzZWRcIjogdGhpcy5pc0ZvY3VzZWREYXRlID8gXCJcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJkYXRhLXNlbGVjdGVkXCI6IGdldERhdGFTZWxlY3RlZCh0aGlzLmlzU2VsZWN0ZWREYXRlKSxcbiAgICAgICAgXCJkYXRhLXZhbHVlXCI6IHRoaXMuZGF0ZS5jdXJyZW50LnRvU3RyaW5nKCksXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBnZXREYXRhRGlzYWJsZWQodGhpcy5pc0Rpc2FibGVkIHx8XG4gICAgICAgICAgICAodGhpcy5pc091dHNpZGVNb250aCAmJiB0aGlzLnJvb3QuZGlzYWJsZURheXNPdXRzaWRlTW9udGguY3VycmVudCkpLFxuICAgIH0pKTtcbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLmlkLmN1cnJlbnQsXG4gICAgICAgIHJvbGU6IFwiZ3JpZGNlbGxcIixcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IGdldEFyaWFTZWxlY3RlZCh0aGlzLmlzU2VsZWN0ZWREYXRlKSxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGdldEFyaWFEaXNhYmxlZCh0aGlzLmFyaWFEaXNhYmxlZCksXG4gICAgICAgIC4uLnRoaXMuc2hhcmVkRGF0YUF0dHJzLFxuICAgICAgICBbdGhpcy5yb290LmdldEJpdHNBdHRyKFwiY2VsbFwiKV06IFwiXCIsXG4gICAgfSkpO1xufVxuY2xhc3MgQ2FsZW5kYXJEYXlTdGF0ZSB7XG4gICAgY2VsbDtcbiAgICBpZDtcbiAgICByZWY7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNlbGwpIHtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLnJlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdGhpcy5vbmNsaWNrID0gdGhpcy5vbmNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3RhYmluZGV4ID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5jZWxsLmlzRm9jdXNlZERhdGVcbiAgICAgICAgPyAwXG4gICAgICAgIDogKHRoaXMuY2VsbC5pc091dHNpZGVNb250aCAmJiB0aGlzLmNlbGwucm9vdC5kaXNhYmxlRGF5c091dHNpZGVNb250aC5jdXJyZW50KSB8fFxuICAgICAgICAgICAgdGhpcy5jZWxsLmlzRGlzYWJsZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IC0xKTtcbiAgICBvbmNsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbC5pc0Rpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNlbGwucm9vdC5oYW5kbGVDZWxsQ2xpY2soZSwgdGhpcy5jZWxsLmRhdGUuY3VycmVudCk7XG4gICAgfVxuICAgIHNuaXBwZXRQcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmNlbGwuaXNEaXNhYmxlZCxcbiAgICAgICAgdW5hdmFpbGFibGU6IHRoaXMuY2VsbC5pc1VuYXZhaWxhYmxlLFxuICAgICAgICBzZWxlY3RlZDogdGhpcy5jZWxsLmlzU2VsZWN0ZWREYXRlLFxuICAgICAgICBkYXk6IGAke3RoaXMuY2VsbC5kYXRlLmN1cnJlbnQuZGF5fWAsXG4gICAgfSkpO1xuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuaWQuY3VycmVudCxcbiAgICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMuY2VsbC5sYWJlbFRleHQsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBnZXRBcmlhRGlzYWJsZWQodGhpcy5jZWxsLmFyaWFEaXNhYmxlZCksXG4gICAgICAgIC4uLnRoaXMuY2VsbC5zaGFyZWREYXRhQXR0cnMsXG4gICAgICAgIHRhYmluZGV4OiB0aGlzLiN0YWJpbmRleCxcbiAgICAgICAgW3RoaXMuY2VsbC5yb290LmdldEJpdHNBdHRyKFwiZGF5XCIpXTogXCJcIixcbiAgICAgICAgLy8gU2hhcmVkIGxvZ2ljIGZvciByYW5nZSBjYWxlbmRhciBhbmQgY2FsZW5kYXJcbiAgICAgICAgXCJkYXRhLWJpdHMtZGF5XCI6IFwiXCIsXG4gICAgICAgIC8vXG4gICAgICAgIG9uY2xpY2s6IHRoaXMub25jbGljayxcbiAgICB9KSk7XG59XG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJOZXh0QnV0dG9uU3RhdGUge1xuICAgIHJvb3Q7XG4gICAgaWQ7XG4gICAgcmVmO1xuICAgIGlzRGlzYWJsZWQgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLnJvb3QuaXNOZXh0QnV0dG9uRGlzYWJsZWQpO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCByb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMub25jbGljayA9IHRoaXMub25jbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uY2xpY2soXykge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJvb3QubmV4dFBhZ2UoKTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy5pZC5jdXJyZW50LFxuICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogXCJOZXh0XCIsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBnZXRBcmlhRGlzYWJsZWQodGhpcy5pc0Rpc2FibGVkKSxcbiAgICAgICAgXCJkYXRhLWRpc2FibGVkXCI6IGdldERhdGFEaXNhYmxlZCh0aGlzLmlzRGlzYWJsZWQpLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkLFxuICAgICAgICBbdGhpcy5yb290LmdldEJpdHNBdHRyKFwibmV4dC1idXR0b25cIildOiBcIlwiLFxuICAgICAgICAvL1xuICAgICAgICBvbmNsaWNrOiB0aGlzLm9uY2xpY2ssXG4gICAgfSkpO1xufVxuZXhwb3J0IGNsYXNzIENhbGVuZGFyUHJldkJ1dHRvblN0YXRlIHtcbiAgICByb290O1xuICAgIGlkO1xuICAgIHJlZjtcbiAgICBpc0Rpc2FibGVkID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmlzUHJldkJ1dHRvbkRpc2FibGVkKTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICB0aGlzLm9uY2xpY2sgPSB0aGlzLm9uY2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbmNsaWNrKF8pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yb290LnByZXZQYWdlKCk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuaWQuY3VycmVudCxcbiAgICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiUHJldmlvdXNcIixcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGdldEFyaWFEaXNhYmxlZCh0aGlzLmlzRGlzYWJsZWQpLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMuaXNEaXNhYmxlZCksXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQsXG4gICAgICAgIFt0aGlzLnJvb3QuZ2V0Qml0c0F0dHIoXCJwcmV2LWJ1dHRvblwiKV06IFwiXCIsXG4gICAgICAgIC8vXG4gICAgICAgIG9uY2xpY2s6IHRoaXMub25jbGljayxcbiAgICB9KSk7XG59XG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJHcmlkU3RhdGUge1xuICAgIHJvb3Q7XG4gICAgaWQ7XG4gICAgcmVmO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCByb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy5pZC5jdXJyZW50LFxuICAgICAgICB0YWJpbmRleDogLTEsXG4gICAgICAgIHJvbGU6IFwiZ3JpZFwiLFxuICAgICAgICBcImFyaWEtcmVhZG9ubHlcIjogZ2V0QXJpYVJlYWRvbmx5KHRoaXMucm9vdC5yZWFkb25seS5jdXJyZW50KSxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGdldEFyaWFEaXNhYmxlZCh0aGlzLnJvb3QuZGlzYWJsZWQuY3VycmVudCksXG4gICAgICAgIFwiZGF0YS1yZWFkb25seVwiOiBnZXREYXRhUmVhZG9ubHkodGhpcy5yb290LnJlYWRvbmx5LmN1cnJlbnQpLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMucm9vdC5kaXNhYmxlZC5jdXJyZW50KSxcbiAgICAgICAgW3RoaXMucm9vdC5nZXRCaXRzQXR0cihcImdyaWRcIildOiBcIlwiLFxuICAgIH0pKTtcbn1cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckdyaWRCb2R5U3RhdGUge1xuICAgIHJvb3Q7XG4gICAgaWQ7XG4gICAgcmVmO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCByb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy5pZC5jdXJyZW50LFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMucm9vdC5kaXNhYmxlZC5jdXJyZW50KSxcbiAgICAgICAgXCJkYXRhLXJlYWRvbmx5XCI6IGdldERhdGFSZWFkb25seSh0aGlzLnJvb3QucmVhZG9ubHkuY3VycmVudCksXG4gICAgICAgIFt0aGlzLnJvb3QuZ2V0Qml0c0F0dHIoXCJncmlkLWJvZHlcIildOiBcIlwiLFxuICAgIH0pKTtcbn1cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckdyaWRIZWFkU3RhdGUge1xuICAgIHJvb3Q7XG4gICAgaWQ7XG4gICAgcmVmO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCByb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy5pZC5jdXJyZW50LFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMucm9vdC5kaXNhYmxlZC5jdXJyZW50KSxcbiAgICAgICAgXCJkYXRhLXJlYWRvbmx5XCI6IGdldERhdGFSZWFkb25seSh0aGlzLnJvb3QucmVhZG9ubHkuY3VycmVudCksXG4gICAgICAgIFt0aGlzLnJvb3QuZ2V0Qml0c0F0dHIoXCJncmlkLWhlYWRcIildOiBcIlwiLFxuICAgIH0pKTtcbn1cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckdyaWRSb3dTdGF0ZSB7XG4gICAgcm9vdDtcbiAgICBpZDtcbiAgICByZWY7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLnJlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLmlkLmN1cnJlbnQsXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBnZXREYXRhRGlzYWJsZWQodGhpcy5yb290LmRpc2FibGVkLmN1cnJlbnQpLFxuICAgICAgICBcImRhdGEtcmVhZG9ubHlcIjogZ2V0RGF0YVJlYWRvbmx5KHRoaXMucm9vdC5yZWFkb25seS5jdXJyZW50KSxcbiAgICAgICAgW3RoaXMucm9vdC5nZXRCaXRzQXR0cihcImdyaWQtcm93XCIpXTogXCJcIixcbiAgICB9KSk7XG59XG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJIZWFkQ2VsbFN0YXRlIHtcbiAgICByb290O1xuICAgIGlkO1xuICAgIHJlZjtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuaWQuY3VycmVudCxcbiAgICAgICAgXCJkYXRhLWRpc2FibGVkXCI6IGdldERhdGFEaXNhYmxlZCh0aGlzLnJvb3QuZGlzYWJsZWQuY3VycmVudCksXG4gICAgICAgIFwiZGF0YS1yZWFkb25seVwiOiBnZXREYXRhUmVhZG9ubHkodGhpcy5yb290LnJlYWRvbmx5LmN1cnJlbnQpLFxuICAgICAgICBbdGhpcy5yb290LmdldEJpdHNBdHRyKFwiaGVhZC1jZWxsXCIpXTogXCJcIixcbiAgICB9KSk7XG59XG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJIZWFkZXJTdGF0ZSB7XG4gICAgcm9vdDtcbiAgICBpZDtcbiAgICByZWY7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLnJlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLmlkLmN1cnJlbnQsXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBnZXREYXRhRGlzYWJsZWQodGhpcy5yb290LmRpc2FibGVkLmN1cnJlbnQpLFxuICAgICAgICBcImRhdGEtcmVhZG9ubHlcIjogZ2V0RGF0YVJlYWRvbmx5KHRoaXMucm9vdC5yZWFkb25seS5jdXJyZW50KSxcbiAgICAgICAgW3RoaXMucm9vdC5nZXRCaXRzQXR0cihcImhlYWRlclwiKV06IFwiXCIsXG4gICAgfSkpO1xufVxuY29uc3QgW3NldENhbGVuZGFyUm9vdENvbnRleHQsIGdldENhbGVuZGFyUm9vdENvbnRleHRdID0gY3JlYXRlQ29udGV4dChbXCJDYWxlbmRhci5Sb290XCIsIFwiUmFuZ2VDYWxlbmRhci5Sb290XCJdLCBcIkNhbGVuZGFyLlJvb3RcIiwgZmFsc2UpO1xuY29uc3QgW3NldENhbGVuZGFyQ2VsbENvbnRleHQsIGdldENhbGVuZGFyQ2VsbENvbnRleHRdID0gY3JlYXRlQ29udGV4dChcIkNhbGVuZGFyLkNlbGxcIik7XG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsZW5kYXJSb290KHByb3BzKSB7XG4gICAgcmV0dXJuIHNldENhbGVuZGFyUm9vdENvbnRleHQobmV3IENhbGVuZGFyUm9vdFN0YXRlKHByb3BzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsZW5kYXJHcmlkKHByb3BzKSB7XG4gICAgY29uc3Qgcm9vdCA9IGdldENhbGVuZGFyUm9vdENvbnRleHQoKTtcbiAgICByZXR1cm4gbmV3IENhbGVuZGFyR3JpZFN0YXRlKHByb3BzLCByb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxlbmRhckNlbGwocHJvcHMpIHtcbiAgICBjb25zdCByb290ID0gZ2V0Q2FsZW5kYXJSb290Q29udGV4dCgpO1xuICAgIHJldHVybiBzZXRDYWxlbmRhckNlbGxDb250ZXh0KG5ldyBDYWxlbmRhckNlbGxTdGF0ZShwcm9wcywgcm9vdCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGVuZGFyTmV4dEJ1dHRvbihwcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBnZXRDYWxlbmRhclJvb3RDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhck5leHRCdXR0b25TdGF0ZShwcm9wcywgcm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsZW5kYXJQcmV2QnV0dG9uKHByb3BzKSB7XG4gICAgY29uc3Qgcm9vdCA9IGdldENhbGVuZGFyUm9vdENvbnRleHQoKTtcbiAgICByZXR1cm4gbmV3IENhbGVuZGFyUHJldkJ1dHRvblN0YXRlKHByb3BzLCByb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxlbmRhckRheShwcm9wcykge1xuICAgIGNvbnN0IGNlbGwgPSBnZXRDYWxlbmRhckNlbGxDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhckRheVN0YXRlKHByb3BzLCBjZWxsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxlbmRhckdyaWRCb2R5KHByb3BzKSB7XG4gICAgY29uc3Qgcm9vdCA9IGdldENhbGVuZGFyUm9vdENvbnRleHQoKTtcbiAgICByZXR1cm4gbmV3IENhbGVuZGFyR3JpZEJvZHlTdGF0ZShwcm9wcywgcm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsZW5kYXJHcmlkSGVhZChwcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBnZXRDYWxlbmRhclJvb3RDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhckdyaWRIZWFkU3RhdGUocHJvcHMsIHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGVuZGFyR3JpZFJvdyhwcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBnZXRDYWxlbmRhclJvb3RDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhckdyaWRSb3dTdGF0ZShwcm9wcywgcm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsZW5kYXJIZWFkQ2VsbChwcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBnZXRDYWxlbmRhclJvb3RDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhckhlYWRDZWxsU3RhdGUocHJvcHMsIHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGVuZGFySGVhZGVyKHByb3BzKSB7XG4gICAgY29uc3Qgcm9vdCA9IGdldENhbGVuZGFyUm9vdENvbnRleHQoKTtcbiAgICByZXR1cm4gbmV3IENhbGVuZGFySGVhZGVyU3RhdGUocHJvcHMsIHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGVuZGFySGVhZGluZyhwcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBnZXRDYWxlbmRhclJvb3RDb250ZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhckhlYWRpbmdTdGF0ZShwcm9wcywgcm9vdCk7XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUNhbGVuZGFyR3JpZCB9IGZyb20gXCIuLi9jYWxlbmRhci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBDYWxlbmRhckdyaWRQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IENhbGVuZGFyR3JpZFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgZ3JpZFN0YXRlID0gdXNlQ2FsZW5kYXJHcmlkKHtcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgZ3JpZFN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDx0YWJsZSB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC90YWJsZT5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgQ2FsZW5kYXJHcmlkQm9keVByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZUNhbGVuZGFyR3JpZEJvZHkgfSBmcm9tIFwiLi4vY2FsZW5kYXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogQ2FsZW5kYXJHcmlkQm9keVByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgZ3JpZEJvZHlTdGF0ZSA9IHVzZUNhbGVuZGFyR3JpZEJvZHkoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBncmlkQm9keVN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDx0Ym9keSB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC90Ym9keT5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUNhbGVuZGFyR3JpZEhlYWQgfSBmcm9tIFwiLi4vY2FsZW5kYXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgQ2FsZW5kYXJHcmlkSGVhZFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogQ2FsZW5kYXJHcmlkSGVhZFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgZ3JpZEhlYWRTdGF0ZSA9IHVzZUNhbGVuZGFyR3JpZEhlYWQoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBncmlkSGVhZFN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDx0aGVhZCB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC90aGVhZD5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUNhbGVuZGFySGVhZENlbGwgfSBmcm9tIFwiLi4vY2FsZW5kYXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgQ2FsZW5kYXJIZWFkQ2VsbFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogQ2FsZW5kYXJIZWFkQ2VsbFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgaGVhZENlbGxTdGF0ZSA9IHVzZUNhbGVuZGFySGVhZENlbGwoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBoZWFkQ2VsbFN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDx0aCB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC90aD5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUNhbGVuZGFyR3JpZFJvdyB9IGZyb20gXCIuLi9jYWxlbmRhci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBDYWxlbmRhckdyaWRSb3dQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IENhbGVuZGFyR3JpZFJvd1Byb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgZ3JpZFJvd1N0YXRlID0gdXNlQ2FsZW5kYXJHcmlkUm93KHtcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgZ3JpZFJvd1N0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDx0ciB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC90cj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUNhbGVuZGFySGVhZGVyIH0gZnJvbSBcIi4uL2NhbGVuZGFyLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgdHlwZSB7IENhbGVuZGFySGVhZGVyUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRjaGlsZHJlbixcblx0XHRjaGlsZCxcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0aWQgPSB1c2VJZCgpLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBDYWxlbmRhckhlYWRlclByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgaGVhZGVyU3RhdGUgPSB1c2VDYWxlbmRhckhlYWRlcih7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIGhlYWRlclN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDxoZWFkZXIgey4uLm1lcmdlZFByb3BzfT5cblx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdDwvaGVhZGVyPlxuey9pZn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHR5cGUgeyBDYWxlbmRhckhlYWRpbmdQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VDYWxlbmRhckhlYWRpbmcgfSBmcm9tIFwiLi4vY2FsZW5kYXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogQ2FsZW5kYXJIZWFkaW5nUHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCBoZWFkaW5nU3RhdGUgPSB1c2VDYWxlbmRhckhlYWRpbmcoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBoZWFkaW5nU3RhdGUucHJvcHMpKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcywgaGVhZGluZ1ZhbHVlOiBoZWFkaW5nU3RhdGUuaGVhZGluZ1ZhbHVlIH0pfVxuezplbHNlfVxuXHQ8ZGl2IHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0eyNpZiBjaGlsZHJlbn1cblx0XHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oeyBoZWFkaW5nVmFsdWU6IGhlYWRpbmdTdGF0ZS5oZWFkaW5nVmFsdWUgfSl9XG5cdFx0ezplbHNlfVxuXHRcdFx0e2hlYWRpbmdTdGF0ZS5oZWFkaW5nVmFsdWV9XG5cdFx0ey9pZn1cblx0PC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgeyB1c2VDYWxlbmRhck5leHRCdXR0b24gfSBmcm9tIFwiLi4vY2FsZW5kYXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgQ2FsZW5kYXJOZXh0QnV0dG9uUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRjaGlsZHJlbixcblx0XHRjaGlsZCxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBDYWxlbmRhck5leHRCdXR0b25Qcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IG5leHRCdXR0b25TdGF0ZSA9IHVzZUNhbGVuZGFyTmV4dEJ1dHRvbih7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIG5leHRCdXR0b25TdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgY2hpbGR9XG5cdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuezplbHNlfVxuXHQ8YnV0dG9uIHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2J1dHRvbj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgQ2FsZW5kYXJQcmV2QnV0dG9uUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlQ2FsZW5kYXJQcmV2QnV0dG9uIH0gZnJvbSBcIi4uL2NhbGVuZGFyLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IENhbGVuZGFyUHJldkJ1dHRvblByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgcHJldkJ1dHRvblN0YXRlID0gdXNlQ2FsZW5kYXJQcmV2QnV0dG9uKHtcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgcHJldkJ1dHRvblN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDxidXR0b24gey4uLm1lcmdlZFByb3BzfT5cblx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdDwvYnV0dG9uPlxuey9pZn1cbiIsIi8qKlxuICogQ3VzdG9tIHBvc2l0aW9uaW5nIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3ZpcnR1YWwtZWxlbWVudHNcbiAqL1xuXG5jb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBnZXRPcHBvc2l0ZUF4aXMoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IGFsaWdubWVudEF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBhbGlnbm1lbnQgPT4gb3Bwb3NpdGVBbGlnbm1lbnRNYXBbYWxpZ25tZW50XSk7XG59XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiIsImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoLFxuICAgIGhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtaWRkbGV3YXJlRGF0YVxuICAgIH0gPSBzdGF0ZTtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZS5cbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgcGFkZGluZyA9IDBcbiAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpIHx8IHt9O1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzWUF4aXMgPSBheGlzID09PSAneSc7XG4gICAgY29uc3QgbWluUHJvcCA9IGlzWUF4aXMgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gaXNZQXhpcyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBjbGllbnRQcm9wID0gaXNZQXhpcyA/ICdjbGllbnRIZWlnaHQnIDogJ2NsaWVudFdpZHRoJztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGFycm93T2Zmc2V0UGFyZW50W2NsaWVudFByb3BdIDogMDtcblxuICAgIC8vIERPTSBwbGF0Zm9ybSBjYW4gcmV0dXJuIGB3aW5kb3dgIGFzIHRoZSBgb2Zmc2V0UGFyZW50YC5cbiAgICBpZiAoIWNsaWVudFNpemUgfHwgIShhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoYXJyb3dPZmZzZXRQYXJlbnQpKSkpIHtcbiAgICAgIGNsaWVudFNpemUgPSBlbGVtZW50cy5mbG9hdGluZ1tjbGllbnRQcm9wXSB8fCByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAgIC8vIElmIHRoZSBwYWRkaW5nIGlzIGxhcmdlIGVub3VnaCB0aGF0IGl0IGNhdXNlcyB0aGUgYXJyb3cgdG8gbm8gbG9uZ2VyIGJlXG4gICAgLy8gY2VudGVyZWQsIG1vZGlmeSB0aGUgcGFkZGluZyBzbyB0aGF0IGl0IGlzIGNlbnRlcmVkLlxuICAgIGNvbnN0IGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiAtIDE7XG4gICAgY29uc3QgbWluUGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21pblByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWF4UHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiQxID0gbWluUGFkZGluZztcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBtYXhQYWRkaW5nO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gY2xhbXAobWluJDEsIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRvIGVuc3VyZSBgc2hpZnQoKWAgY29udGludWVzIHRvIHRha2UgYWN0aW9uLFxuICAgIC8vIGEgc2luZ2xlIHJlc2V0IGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgaXMgdHJ1ZS5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSAhbWlkZGxld2FyZURhdGEuYXJyb3cgJiYgZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT09IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsU2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhpbml0aWFsUGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJztcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZS5tYWluQXhpcyB8fCAwLFxuICAgIGNyb3NzQXhpczogcmF3VmFsdWUuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogcmF3VmFsdWUuYWxpZ25tZW50QXhpc1xuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfc3RhdGUkbWlkZGxld2FyZURhdGEsIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gbWluKGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54KSB7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSkge1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iLCJmdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVsnaW5saW5lJywgJ2NvbnRlbnRzJ10uaW5jbHVkZXMoZGlzcGxheSk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNUb3BMYXllcihlbGVtZW50KSB7XG4gIHJldHVybiBbJzpwb3BvdmVyLW9wZW4nLCAnOm1vZGFsJ10uc29tZShzZWxlY3RvciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudE9yQ3NzKSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGlzRWxlbWVudChlbGVtZW50T3JDc3MpID8gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50T3JDc3MpIDogZWxlbWVudE9yQ3NzO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KHdpbik7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIGZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhmcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbikge1xuICByZXR1cm4gd2luLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yod2luLnBhcmVudCkgPyB3aW4uZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldEZyYW1lRWxlbWVudCwgZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IsIGdldE5vZGVOYW1lLCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgZ2V0V2luZG93LCBpc0NvbnRhaW5pbmdCbG9jaywgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzTm9kZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGlzU2hhZG93Um9vdCwgaXNUYWJsZUVsZW1lbnQsIGlzVG9wTGF5ZXIsIGlzV2ViS2l0IH07XG4iLCJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBkZXRlY3RPdmVyZmxvdyBhcyBkZXRlY3RPdmVyZmxvdyQxLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBmbGlwIGFzIGZsaXAkMSwgc2l6ZSBhcyBzaXplJDEsIGhpZGUgYXMgaGlkZSQxLCBhcnJvdyBhcyBhcnJvdyQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldERvY3VtZW50RWxlbWVudCwgaXNUb3BMYXllciwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRXaW4gPSB3aW47XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRXaW4gPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSk7XG4gICAgICBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuLy8gaW5jb3JyZWN0IGZvciBSVEwuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQsIHJlY3QpIHtcbiAgY29uc3QgbGVmdFNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBsZWZ0U2Nyb2xsO1xuICB9XG4gIHJldHVybiByZWN0LmxlZnQgKyBsZWZ0U2Nyb2xsO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCBpZ25vcmVTY3JvbGxiYXJYKSB7XG4gIGlmIChpZ25vcmVTY3JvbGxiYXJYID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVTY3JvbGxiYXJYID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHRtbFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSBodG1sUmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSAoaWdub3JlU2Nyb2xsYmFyWCA/IDAgOlxuICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cbiAgZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQsIGh0bWxSZWN0KSk7XG4gIGNvbnN0IHkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHRvcExheWVyID0gZWxlbWVudHMgPyBpc1RvcExheWVyKGVsZW1lbnRzLmZsb2F0aW5nKSA6IGZhbHNlO1xuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgdG9wTGF5ZXIgJiYgaXNGaXhlZCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgdHJ1ZSkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLnggKyBodG1sT2Zmc2V0LngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55ICsgaHRtbE9mZnNldC55XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgeDogY2xpcHBpbmdBbmNlc3Rvci54IC0gdmlzdWFsT2Zmc2V0cy54LFxuICAgICAgeTogY2xpcHBpbmdBbmNlc3Rvci55IC0gdmlzdWFsT2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IGNsaXBwaW5nQW5jZXN0b3Iud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaXBwaW5nQW5jZXN0b3IuaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChyZWN0KTtcbn1cbmZ1bmN0aW9uIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBzdG9wTm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKHBhcmVudE5vZGUgPT09IHN0b3BOb2RlIHx8ICFpc0VsZW1lbnQocGFyZW50Tm9kZSkgfHwgaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSAnZml4ZWQnIHx8IGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihwYXJlbnROb2RlLCBzdG9wTm9kZSk7XG59XG5cbi8vIEEgXCJjbGlwcGluZyBhbmNlc3RvclwiIGlzIGFuIGBvdmVyZmxvd2AgZWxlbWVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgY2hpbGQgZWxlbWVudHMuIFRoaXMgcmV0dXJucyBhbGwgY2xpcHBpbmcgYW5jZXN0b3JzXG4vLyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCB1cCB0aGUgdHJlZS5cbmZ1bmN0aW9uIGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCBjYWNoZSkge1xuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgZmFsc2UpLmZpbHRlcihlbCA9PiBpc0VsZW1lbnQoZWwpICYmIGdldE5vZGVOYW1lKGVsKSAhPT0gJ2JvZHknKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuICBsZXQgY3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/IGdldFBhcmVudE5vZGUoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHdoaWxlIChpc0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSXNDb250YWluaW5nID0gaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpO1xuICAgIGlmICghY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGREcm9wQ3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiAhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgOiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgISFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSAmJiBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5jbHVkZXMoY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUucG9zaXRpb24pIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIGN1cnJlbnROb2RlKTtcbiAgICBpZiAoc2hvdWxkRHJvcEN1cnJlbnROb2RlKSB7XG4gICAgICAvLyBEcm9wIG5vbi1jb250YWluaW5nIGJsb2Nrcy5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoYW5jZXN0b3IgPT4gYW5jZXN0b3IgIT09IGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVjb3JkIGxhc3QgY29udGFpbmluZyBibG9jayBmb3IgbmV4dCBpdGVyYXRpb24uXG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgY2FjaGUuc2V0KGVsZW1lbnQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIGFuY2VzdG9ycy5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdBbmNlc3RvcnMnID8gaXNUb3BMYXllcihlbGVtZW50KSA/IFtdIDogZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIHRoaXMuX2MpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBbLi4uZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nQW5jZXN0b3IgPSBjbGlwcGluZ0FuY2VzdG9yc1swXTtcbiAgY29uc3QgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdBbmNlc3RvcnMucmVkdWNlKChhY2NSZWN0LCBjbGlwcGluZ0FuY2VzdG9yKSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcCxcbiAgICB4OiBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICB5OiBjbGlwcGluZ1JlY3QudG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAvLyBJZiB0aGUgPGJvZHk+IHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IChlLmcuIFJUTCBzeXN0ZW1zKS4gVXNlXG4gICAgICAvLyBGaXJlZm94IHdpdGggbGF5b3V0LnNjcm9sbGJhci5zaWRlID0gMyBpbiBhYm91dDpjb25maWcgdG8gdGVzdCB0aGlzLlxuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLnggLSBodG1sT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnkgLSBodG1sT2Zmc2V0Lnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGNsaXBwZWQsIHRoZSByYXRpbyBpcyAwLiBUaHJvdHRsZSB0aGUgcmVmcmVzaFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiB1cGRhdGVzLlxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAobmV4dFJlZlJlY3QueCAhPT0gcHJldlJlZlJlY3QueCB8fCBuZXh0UmVmUmVjdC55ICE9PSBwcmV2UmVmUmVjdC55IHx8IG5leHRSZWZSZWN0LndpZHRoICE9PSBwcmV2UmVmUmVjdC53aWR0aCB8fCBuZXh0UmVmUmVjdC5oZWlnaHQgIT09IHByZXZSZWZSZWN0LmhlaWdodCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX3Jlc2l6ZU9ic2VydmVyMjtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICBjbGVhbnVwSW8gPT0gbnVsbCB8fCBjbGVhbnVwSW8oKTtcbiAgICAoX3Jlc2l6ZU9ic2VydmVyMiA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlcjIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmNvbnN0IGRldGVjdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3ckMTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gYXV0b1BsYWNlbWVudCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gc2l6ZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGhpZGUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBhcnJvdyQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBpbmxpbmUkMTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGxpbWl0U2hpZnQkMTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXQodmFsdWVPckdldFZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZU9yR2V0VmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHZhbHVlT3JHZXRWYWx1ZSgpXG4gICAgICAgIDogdmFsdWVPckdldFZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERQUihlbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgcmV0dXJuIHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5leHBvcnQgZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICAgIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRwcikgLyBkcHI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RmxvYXRpbmdDb250ZW50Q1NTVmFycyhuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW2AtLWJpdHMtJHtuYW1lfS1jb250ZW50LXRyYW5zZm9ybS1vcmlnaW5gXTogYHZhcigtLWJpdHMtZmxvYXRpbmctdHJhbnNmb3JtLW9yaWdpbilgLFxuICAgICAgICBbYC0tYml0cy0ke25hbWV9LWNvbnRlbnQtYXZhaWxhYmxlLXdpZHRoYF06IGB2YXIoLS1iaXRzLWZsb2F0aW5nLWF2YWlsYWJsZS13aWR0aClgLFxuICAgICAgICBbYC0tYml0cy0ke25hbWV9LWNvbnRlbnQtYXZhaWxhYmxlLWhlaWdodGBdOiBgdmFyKC0tYml0cy1mbG9hdGluZy1hdmFpbGFibGUtaGVpZ2h0KWAsXG4gICAgICAgIFtgLS1iaXRzLSR7bmFtZX0tYW5jaG9yLXdpZHRoYF06IGB2YXIoLS1iaXRzLWZsb2F0aW5nLWFuY2hvci13aWR0aClgLFxuICAgICAgICBbYC0tYml0cy0ke25hbWV9LWFuY2hvci1oZWlnaHRgXTogYHZhcigtLWJpdHMtZmxvYXRpbmctYW5jaG9yLWhlaWdodClgLFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24gfSBmcm9tIFwiQGZsb2F0aW5nLXVpL2RvbVwiO1xuaW1wb3J0IHsgYm94IH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuaW1wb3J0IHsgZ2V0LCBnZXREUFIsIHJvdW5kQnlEUFIgfSBmcm9tIFwiLi9mbG9hdGluZy11dGlscy5zdmVsdGUuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gICAgLyoqIE9wdGlvbnMgKi9cbiAgICBjb25zdCB3aGlsZUVsZW1lbnRzTW91bnRlZE9wdGlvbiA9IG9wdGlvbnMud2hpbGVFbGVtZW50c01vdW50ZWQ7XG4gICAgY29uc3Qgb3Blbk9wdGlvbiA9ICRkZXJpdmVkKGdldChvcHRpb25zLm9wZW4pID8/IHRydWUpO1xuICAgIGNvbnN0IG1pZGRsZXdhcmVPcHRpb24gPSAkZGVyaXZlZChnZXQob3B0aW9ucy5taWRkbGV3YXJlKSk7XG4gICAgY29uc3QgdHJhbnNmb3JtT3B0aW9uID0gJGRlcml2ZWQoZ2V0KG9wdGlvbnMudHJhbnNmb3JtKSA/PyB0cnVlKTtcbiAgICBjb25zdCBwbGFjZW1lbnRPcHRpb24gPSAkZGVyaXZlZChnZXQob3B0aW9ucy5wbGFjZW1lbnQpID8/IFwiYm90dG9tXCIpO1xuICAgIGNvbnN0IHN0cmF0ZWd5T3B0aW9uID0gJGRlcml2ZWQoZ2V0KG9wdGlvbnMuc3RyYXRlZ3kpID8/IFwiYWJzb2x1dGVcIik7XG4gICAgY29uc3QgcmVmZXJlbmNlID0gb3B0aW9ucy5yZWZlcmVuY2U7XG4gICAgLyoqIFN0YXRlICovXG4gICAgbGV0IHggPSAkc3RhdGUoMCk7XG4gICAgbGV0IHkgPSAkc3RhdGUoMCk7XG4gICAgY29uc3QgZmxvYXRpbmcgPSBib3gobnVsbCk7XG4gICAgbGV0IHN0cmF0ZWd5ID0gJHN0YXRlKHN0cmF0ZWd5T3B0aW9uKTtcbiAgICBsZXQgcGxhY2VtZW50ID0gJHN0YXRlKHBsYWNlbWVudE9wdGlvbik7XG4gICAgbGV0IG1pZGRsZXdhcmVEYXRhID0gJHN0YXRlKHt9KTtcbiAgICBsZXQgaXNQb3NpdGlvbmVkID0gJHN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgICAgICAgIGxlZnQ6IFwiMFwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFmbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4VmFsID0gcm91bmRCeURQUihmbG9hdGluZy5jdXJyZW50LCB4KTtcbiAgICAgICAgY29uc3QgeVZhbCA9IHJvdW5kQnlEUFIoZmxvYXRpbmcuY3VycmVudCwgeSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4VmFsfXB4LCAke3lWYWx9cHgpYCxcbiAgICAgICAgICAgICAgICAuLi4oZ2V0RFBSKGZsb2F0aW5nLmN1cnJlbnQpID49IDEuNSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2U6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICBsZWZ0OiBgJHt4VmFsfXB4YCxcbiAgICAgICAgICAgIHRvcDogYCR7eVZhbH1weGAsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLyoqIEVmZmVjdHMgKi9cbiAgICBsZXQgd2hpbGVFbGVtZW50c01vdW50ZWRDbGVhbnVwO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZS5jdXJyZW50ID09PSBudWxsIHx8IGZsb2F0aW5nLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2UuY3VycmVudCwgZmxvYXRpbmcuY3VycmVudCwge1xuICAgICAgICAgICAgbWlkZGxld2FyZTogbWlkZGxld2FyZU9wdGlvbixcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50T3B0aW9uLFxuICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5T3B0aW9uLFxuICAgICAgICB9KS50aGVuKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgeCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICB5ID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIHN0cmF0ZWd5ID0gcG9zaXRpb24uc3RyYXRlZ3k7XG4gICAgICAgICAgICBwbGFjZW1lbnQgPSBwb3NpdGlvbi5wbGFjZW1lbnQ7XG4gICAgICAgICAgICBtaWRkbGV3YXJlRGF0YSA9IHBvc2l0aW9uLm1pZGRsZXdhcmVEYXRhO1xuICAgICAgICAgICAgaXNQb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2hpbGVFbGVtZW50c01vdW50ZWRDbGVhbnVwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkQ2xlYW51cCgpO1xuICAgICAgICAgICAgd2hpbGVFbGVtZW50c01vdW50ZWRDbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRPcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZS5jdXJyZW50ID09PSBudWxsIHx8IGZsb2F0aW5nLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkQ2xlYW51cCA9IHdoaWxlRWxlbWVudHNNb3VudGVkT3B0aW9uKHJlZmVyZW5jZS5jdXJyZW50LCBmbG9hdGluZy5jdXJyZW50LCB1cGRhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgaWYgKCFvcGVuT3B0aW9uKSB7XG4gICAgICAgICAgICBpc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkZWZmZWN0KHVwZGF0ZSk7XG4gICAgJGVmZmVjdChhdHRhY2gpO1xuICAgICRlZmZlY3QocmVzZXQpO1xuICAgICRlZmZlY3QoKCkgPT4gY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZ2V0IHN0cmF0ZWd5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgcGxhY2VtZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IG1pZGRsZXdhcmVEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmVEYXRhO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNQb3NpdGlvbmVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUG9zaXRpb25lZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGZsb2F0aW5nU3R5bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0aW5nU3R5bGVzO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdXBkYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgdW50cmFjayB9IGZyb20gXCJzdmVsdGVcIjtcbmltcG9ydCB7IGFycm93LCBhdXRvVXBkYXRlLCBmbGlwLCBoaWRlLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplLCB9IGZyb20gXCJAZmxvYXRpbmctdWkvZG9tXCI7XG5pbXBvcnQgeyBib3gsIGNzc1RvU3R5bGVPYmosIHN0eWxlVG9TdHJpbmcsIHVzZVJlZkJ5SWQgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5pbXBvcnQgeyBFbGVtZW50U2l6ZSB9IGZyb20gXCJydW5lZFwiO1xuaW1wb3J0IHsgaXNOb3ROdWxsIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2lzLmpzXCI7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcbmltcG9ydCB7IHVzZUZsb2F0aW5nIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2Zsb2F0aW5nLXN2ZWx0ZS91c2UtZmxvYXRpbmcuc3ZlbHRlLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2NyZWF0ZS1jb250ZXh0LmpzXCI7XG5leHBvcnQgY29uc3QgU0lERV9PUFRJT05TID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xuZXhwb3J0IGNvbnN0IEFMSUdOX09QVElPTlMgPSBbXCJzdGFydFwiLCBcImNlbnRlclwiLCBcImVuZFwiXTtcbmNvbnN0IE9QUE9TSVRFX1NJREUgPSB7XG4gICAgdG9wOiBcImJvdHRvbVwiLFxuICAgIHJpZ2h0OiBcImxlZnRcIixcbiAgICBib3R0b206IFwidG9wXCIsXG4gICAgbGVmdDogXCJyaWdodFwiLFxufTtcbmNsYXNzIEZsb2F0aW5nUm9vdFN0YXRlIHtcbiAgICBhbmNob3JOb2RlID0gYm94KG51bGwpO1xuICAgIGN1c3RvbUFuY2hvck5vZGUgPSBib3gobnVsbCk7XG4gICAgdHJpZ2dlck5vZGUgPSBib3gobnVsbCk7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tQW5jaG9yTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmN1c3RvbUFuY2hvck5vZGUuY3VycmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvck5vZGUuY3VycmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5jdXN0b21BbmNob3JOb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3JOb2RlLmN1cnJlbnQgPSB0aGlzLmN1c3RvbUFuY2hvck5vZGUuY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvck5vZGUuY3VycmVudCA9IHRoaXMudHJpZ2dlck5vZGUuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgRmxvYXRpbmdDb250ZW50U3RhdGUge1xuICAgIC8vIHN0YXRlXG4gICAgcm9vdDtcbiAgICAvLyBub2Rlc1xuICAgIGNvbnRlbnRSZWYgPSBib3gobnVsbCk7XG4gICAgd3JhcHBlclJlZiA9IGJveChudWxsKTtcbiAgICBhcnJvd1JlZiA9IGJveChudWxsKTtcbiAgICAvLyBpZHNcbiAgICBhcnJvd0lkID0gYm94KHVzZUlkKCkpO1xuICAgIGlkO1xuICAgIHdyYXBwZXJJZDtcbiAgICBzdHlsZTtcbiAgICAjdHJhbnNmb3JtZWRTdHlsZSA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0eWxlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGNzc1RvU3R5bGVPYmoodGhpcy5zdHlsZSk7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZSlcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICB9KTtcbiAgICAjZGlyO1xuICAgICNzaWRlO1xuICAgICNzaWRlT2Zmc2V0O1xuICAgICNhbGlnbjtcbiAgICAjYWxpZ25PZmZzZXQ7XG4gICAgI2Fycm93UGFkZGluZztcbiAgICAjYXZvaWRDb2xsaXNpb25zO1xuICAgICNjb2xsaXNpb25Cb3VuZGFyeTtcbiAgICAjY29sbGlzaW9uUGFkZGluZztcbiAgICAjc3RpY2t5O1xuICAgICNoaWRlV2hlbkRldGFjaGVkO1xuICAgICNzdHJhdGVneTtcbiAgICAjdXBkYXRlUG9zaXRpb25TdHJhdGVneSA9IHVuZGVmaW5lZDtcbiAgICBvblBsYWNlZDtcbiAgICBlbmFibGVkO1xuICAgICNhcnJvd1NpemUgPSBuZXcgRWxlbWVudFNpemUoKCkgPT4gdGhpcy5hcnJvd1JlZi5jdXJyZW50ID8/IHVuZGVmaW5lZCk7XG4gICAgI2Fycm93V2lkdGggPSAkZGVyaXZlZCh0aGlzLiNhcnJvd1NpemU/LndpZHRoID8/IDApO1xuICAgICNhcnJvd0hlaWdodCA9ICRkZXJpdmVkKHRoaXMuI2Fycm93U2l6ZT8uaGVpZ2h0ID8/IDApO1xuICAgICNkZXNpcmVkUGxhY2VtZW50ID0gJGRlcml2ZWQuYnkoKCkgPT4gKHRoaXMuI3NpZGU/LmN1cnJlbnQgK1xuICAgICAgICAodGhpcy4jYWxpZ24uY3VycmVudCAhPT0gXCJjZW50ZXJcIiA/IGAtJHt0aGlzLiNhbGlnbi5jdXJyZW50fWAgOiBcIlwiKSkpO1xuICAgICNib3VuZGFyeSA9ICRkZXJpdmVkLmJ5KCgpID0+IEFycmF5LmlzQXJyYXkodGhpcy4jY29sbGlzaW9uQm91bmRhcnkuY3VycmVudClcbiAgICAgICAgPyB0aGlzLiNjb2xsaXNpb25Cb3VuZGFyeS5jdXJyZW50XG4gICAgICAgIDogW3RoaXMuI2NvbGxpc2lvbkJvdW5kYXJ5LmN1cnJlbnRdKTtcbiAgICBoYXNFeHBsaWNpdEJvdW5kYXJpZXMgPSAkZGVyaXZlZCh0aGlzLiNib3VuZGFyeS5sZW5ndGggPiAwKTtcbiAgICBkZXRlY3RPdmVyZmxvd09wdGlvbnMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBwYWRkaW5nOiB0aGlzLiNjb2xsaXNpb25QYWRkaW5nLmN1cnJlbnQsXG4gICAgICAgIGJvdW5kYXJ5OiB0aGlzLiNib3VuZGFyeS5maWx0ZXIoaXNOb3ROdWxsKSxcbiAgICAgICAgYWx0Qm91bmRhcnk6IHRoaXMuaGFzRXhwbGljaXRCb3VuZGFyaWVzLFxuICAgIH0pKTtcbiAgICAjYXZhaWxhYmxlV2lkdGggPSAkc3RhdGUodW5kZWZpbmVkKTtcbiAgICAjYXZhaWxhYmxlSGVpZ2h0ID0gJHN0YXRlKHVuZGVmaW5lZCk7XG4gICAgI2FuY2hvcldpZHRoID0gJHN0YXRlKHVuZGVmaW5lZCk7XG4gICAgI2FuY2hvckhlaWdodCA9ICRzdGF0ZSh1bmRlZmluZWQpO1xuICAgIG1pZGRsZXdhcmUgPSAkZGVyaXZlZC5ieSgoKSA9PiBbXG4gICAgICAgIG9mZnNldCh7XG4gICAgICAgICAgICBtYWluQXhpczogdGhpcy4jc2lkZU9mZnNldC5jdXJyZW50ICsgdGhpcy4jYXJyb3dIZWlnaHQsXG4gICAgICAgICAgICBhbGlnbm1lbnRBeGlzOiB0aGlzLiNhbGlnbk9mZnNldC5jdXJyZW50LFxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy4jYXZvaWRDb2xsaXNpb25zLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIHNoaWZ0KHtcbiAgICAgICAgICAgICAgICBtYWluQXhpczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcm9zc0F4aXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxpbWl0ZXI6IHRoaXMuI3N0aWNreS5jdXJyZW50ID09PSBcInBhcnRpYWxcIiA/IGxpbWl0U2hpZnQoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB0aGlzLiNhdm9pZENvbGxpc2lvbnMuY3VycmVudCAmJiBmbGlwKHsgLi4udGhpcy5kZXRlY3RPdmVyZmxvd09wdGlvbnMgfSksXG4gICAgICAgIHNpemUoe1xuICAgICAgICAgICAgLi4udGhpcy5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICBhcHBseTogKHsgcmVjdHMsIGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IGFuY2hvcldpZHRoLCBoZWlnaHQ6IGFuY2hvckhlaWdodCB9ID0gcmVjdHMucmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVdpZHRoID0gYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy4jYXZhaWxhYmxlSGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuI2FuY2hvcldpZHRoID0gYW5jaG9yV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy4jYW5jaG9ySGVpZ2h0ID0gYW5jaG9ySGVpZ2h0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHRoaXMuYXJyb3dSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgYXJyb3coeyBlbGVtZW50OiB0aGlzLmFycm93UmVmLmN1cnJlbnQsIHBhZGRpbmc6IHRoaXMuI2Fycm93UGFkZGluZy5jdXJyZW50IH0pLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4oeyBhcnJvd1dpZHRoOiB0aGlzLiNhcnJvd1dpZHRoLCBhcnJvd0hlaWdodDogdGhpcy4jYXJyb3dIZWlnaHQgfSksXG4gICAgICAgIHRoaXMuI2hpZGVXaGVuRGV0YWNoZWQuY3VycmVudCAmJlxuICAgICAgICAgICAgaGlkZSh7IHN0cmF0ZWd5OiBcInJlZmVyZW5jZUhpZGRlblwiLCAuLi50aGlzLmRldGVjdE92ZXJmbG93T3B0aW9ucyB9KSxcbiAgICBdLmZpbHRlcihCb29sZWFuKSk7XG4gICAgZmxvYXRpbmc7XG4gICAgcGxhY2VkU2lkZSA9ICRkZXJpdmVkLmJ5KCgpID0+IGdldFNpZGVGcm9tUGxhY2VtZW50KHRoaXMuZmxvYXRpbmcucGxhY2VtZW50KSk7XG4gICAgcGxhY2VkQWxpZ24gPSAkZGVyaXZlZC5ieSgoKSA9PiBnZXRBbGlnbkZyb21QbGFjZW1lbnQodGhpcy5mbG9hdGluZy5wbGFjZW1lbnQpKTtcbiAgICBhcnJvd1ggPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLmZsb2F0aW5nLm1pZGRsZXdhcmVEYXRhLmFycm93Py54ID8/IDApO1xuICAgIGFycm93WSA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMuZmxvYXRpbmcubWlkZGxld2FyZURhdGEuYXJyb3c/LnkgPz8gMCk7XG4gICAgY2Fubm90Q2VudGVyQXJyb3cgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLmZsb2F0aW5nLm1pZGRsZXdhcmVEYXRhLmFycm93Py5jZW50ZXJPZmZzZXQgIT09IDApO1xuICAgIGNvbnRlbnRaSW5kZXggPSAkc3RhdGUoKTtcbiAgICBhcnJvd0Jhc2VTaWRlID0gJGRlcml2ZWQoT1BQT1NJVEVfU0lERVt0aGlzLnBsYWNlZFNpZGVdKTtcbiAgICB3cmFwcGVyUHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy53cmFwcGVySWQuY3VycmVudCxcbiAgICAgICAgXCJkYXRhLWJpdHMtZmxvYXRpbmctY29udGVudC13cmFwcGVyXCI6IFwiXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi50aGlzLmZsb2F0aW5nLmZsb2F0aW5nU3R5bGVzLFxuICAgICAgICAgICAgLy8ga2VlcCBvZmYgcGFnZSB3aGVuIG1lYXN1cmluZ1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmZsb2F0aW5nLmlzUG9zaXRpb25lZFxuICAgICAgICAgICAgICAgID8gdGhpcy5mbG9hdGluZy5mbG9hdGluZ1N0eWxlcy50cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICA6IFwidHJhbnNsYXRlKDAsIC0yMDAlKVwiLFxuICAgICAgICAgICAgbWluV2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgICAgIHpJbmRleDogdGhpcy5jb250ZW50WkluZGV4LFxuICAgICAgICAgICAgXCItLWJpdHMtZmxvYXRpbmctdHJhbnNmb3JtLW9yaWdpblwiOiBgJHt0aGlzLmZsb2F0aW5nLm1pZGRsZXdhcmVEYXRhLnRyYW5zZm9ybU9yaWdpbj8ueH0gJHt0aGlzLmZsb2F0aW5nLm1pZGRsZXdhcmVEYXRhLnRyYW5zZm9ybU9yaWdpbj8ueX1gLFxuICAgICAgICAgICAgXCItLWJpdHMtZmxvYXRpbmctYXZhaWxhYmxlLXdpZHRoXCI6IGAke3RoaXMuI2F2YWlsYWJsZVdpZHRofXB4YCxcbiAgICAgICAgICAgIFwiLS1iaXRzLWZsb2F0aW5nLWF2YWlsYWJsZS1oZWlnaHRcIjogYCR7dGhpcy4jYXZhaWxhYmxlSGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIFwiLS1iaXRzLWZsb2F0aW5nLWFuY2hvci13aWR0aFwiOiBgJHt0aGlzLiNhbmNob3JXaWR0aH1weGAsXG4gICAgICAgICAgICBcIi0tYml0cy1mbG9hdGluZy1hbmNob3ItaGVpZ2h0XCI6IGAke3RoaXMuI2FuY2hvckhlaWdodH1weGAsXG4gICAgICAgICAgICAvLyBoaWRlIHRoZSBjb250ZW50IGlmIHVzaW5nIHRoZSBoaWRlIG1pZGRsZXdhcmUgYW5kIHNob3VsZCBiZSBoaWRkZW5cbiAgICAgICAgICAgIC4uLih0aGlzLmZsb2F0aW5nLm1pZGRsZXdhcmVEYXRhLmhpZGU/LnJlZmVyZW5jZUhpZGRlbiAmJiB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi50aGlzLiN0cmFuc2Zvcm1lZFN0eWxlLFxuICAgICAgICB9LFxuICAgICAgICAvLyBGbG9hdGluZyBVSSBjYWxjdWxhdGVzIGxvZ2ljYWwgYWxpZ25tZW50IGJhc2VkIHRoZSBgZGlyYCBhdHRyaWJ1dGVcbiAgICAgICAgZGlyOiB0aGlzLiNkaXIuY3VycmVudCxcbiAgICB9KSk7XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBcImRhdGEtc2lkZVwiOiB0aGlzLnBsYWNlZFNpZGUsXG4gICAgICAgIFwiZGF0YS1hbGlnblwiOiB0aGlzLnBsYWNlZEFsaWduLFxuICAgICAgICBzdHlsZTogc3R5bGVUb1N0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLiN0cmFuc2Zvcm1lZFN0eWxlLFxuICAgICAgICAgICAgLy8gaWYgdGhlIEZsb2F0aW5nQ29udGVudCBoYXNuJ3QgYmVlbiBwbGFjZWQgeWV0IChub3QgYWxsIG1lYXN1cmVtZW50cyBkb25lKVxuICAgICAgICAgICAgLy8gd2UgcHJldmVudCBhbmltYXRpb25zIHNvIHRoYXQgdXNlcnMncyBhbmltYXRpb24gZG9uJ3Qga2ljayBpbiB0b28gZWFybHkgcmVmZXJyaW5nIHdyb25nIHNpZGVzXG4gICAgICAgICAgICAvLyBhbmltYXRpb246ICF0aGlzLmZsb2F0aW5nLmlzUG9zaXRpb25lZCA/IFwibm9uZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICB9KSxcbiAgICB9KSk7XG4gICAgYXJyb3dTdHlsZSA9ICRkZXJpdmVkKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgbGVmdDogdGhpcy5hcnJvd1ggPyBgJHt0aGlzLmFycm93WH1weGAgOiB1bmRlZmluZWQsXG4gICAgICAgIHRvcDogdGhpcy5hcnJvd1kgPyBgJHt0aGlzLmFycm93WX1weGAgOiB1bmRlZmluZWQsXG4gICAgICAgIFt0aGlzLmFycm93QmFzZVNpZGVdOiAwLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjoge1xuICAgICAgICAgICAgdG9wOiBcIlwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMCAwXCIsXG4gICAgICAgICAgICBib3R0b206IFwiY2VudGVyIDBcIixcbiAgICAgICAgICAgIGxlZnQ6IFwiMTAwJSAwXCIsXG4gICAgICAgIH1bdGhpcy5wbGFjZWRTaWRlXSxcbiAgICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgICAgICB0b3A6IFwidHJhbnNsYXRlWSgxMDAlKVwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwidHJhbnNsYXRlWSg1MCUpIHJvdGF0ZSg5MGRlZykgdHJhbnNsYXRlWCgtNTAlKVwiLFxuICAgICAgICAgICAgYm90dG9tOiBcInJvdGF0ZSgxODBkZWcpXCIsXG4gICAgICAgICAgICBsZWZ0OiBcInRyYW5zbGF0ZVkoNTAlKSByb3RhdGUoLTkwZGVnKSB0cmFuc2xhdGVYKDUwJSlcIixcbiAgICAgICAgfVt0aGlzLnBsYWNlZFNpZGVdLFxuICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLmNhbm5vdENlbnRlckFycm93ID8gXCJoaWRkZW5cIiA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMuI3NpZGUgPSBwcm9wcy5zaWRlO1xuICAgICAgICB0aGlzLiNzaWRlT2Zmc2V0ID0gcHJvcHMuc2lkZU9mZnNldDtcbiAgICAgICAgdGhpcy4jYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICAgICAgdGhpcy4jYWxpZ25PZmZzZXQgPSBwcm9wcy5hbGlnbk9mZnNldDtcbiAgICAgICAgdGhpcy4jYXJyb3dQYWRkaW5nID0gcHJvcHMuYXJyb3dQYWRkaW5nO1xuICAgICAgICB0aGlzLiNhdm9pZENvbGxpc2lvbnMgPSBwcm9wcy5hdm9pZENvbGxpc2lvbnM7XG4gICAgICAgIHRoaXMuI2NvbGxpc2lvbkJvdW5kYXJ5ID0gcHJvcHMuY29sbGlzaW9uQm91bmRhcnk7XG4gICAgICAgIHRoaXMuI2NvbGxpc2lvblBhZGRpbmcgPSBwcm9wcy5jb2xsaXNpb25QYWRkaW5nO1xuICAgICAgICB0aGlzLiNzdGlja3kgPSBwcm9wcy5zdGlja3k7XG4gICAgICAgIHRoaXMuI2hpZGVXaGVuRGV0YWNoZWQgPSBwcm9wcy5oaWRlV2hlbkRldGFjaGVkO1xuICAgICAgICB0aGlzLiN1cGRhdGVQb3NpdGlvblN0cmF0ZWd5ID0gcHJvcHMudXBkYXRlUG9zaXRpb25TdHJhdGVneTtcbiAgICAgICAgdGhpcy5vblBsYWNlZCA9IHByb3BzLm9uUGxhY2VkO1xuICAgICAgICB0aGlzLiNzdHJhdGVneSA9IHByb3BzLnN0cmF0ZWd5O1xuICAgICAgICB0aGlzLiNkaXIgPSBwcm9wcy5kaXI7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBwcm9wcy5zdHlsZTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gcHJvcHMuZW5hYmxlZDtcbiAgICAgICAgdGhpcy53cmFwcGVySWQgPSBwcm9wcy53cmFwcGVySWQ7XG4gICAgICAgIGlmIChwcm9wcy5jdXN0b21BbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5jdXN0b21BbmNob3JOb2RlLmN1cnJlbnQgPSBwcm9wcy5jdXN0b21BbmNob3IuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHByb3BzLmN1c3RvbUFuY2hvci5jdXJyZW50O1xuICAgICAgICAgICAgdW50cmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmN1c3RvbUFuY2hvck5vZGUuY3VycmVudCA9IHByb3BzLmN1c3RvbUFuY2hvci5jdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLndyYXBwZXJJZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy53cmFwcGVyUmVmLFxuICAgICAgICAgICAgZGVwczogKCkgPT4gdGhpcy5lbmFibGVkLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLmNvbnRlbnRSZWYsXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLmVuYWJsZWQuY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmxvYXRpbmcgPSB1c2VGbG9hdGluZyh7XG4gICAgICAgICAgICBzdHJhdGVneTogKCkgPT4gdGhpcy4jc3RyYXRlZ3kuY3VycmVudCxcbiAgICAgICAgICAgIHBsYWNlbWVudDogKCkgPT4gdGhpcy4jZGVzaXJlZFBsYWNlbWVudCxcbiAgICAgICAgICAgIG1pZGRsZXdhcmU6ICgpID0+IHRoaXMubWlkZGxld2FyZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogdGhpcy5yb290LmFuY2hvck5vZGUsXG4gICAgICAgICAgICB3aGlsZUVsZW1lbnRzTW91bnRlZDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gYXV0b1VwZGF0ZSguLi5hcmdzLCB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lOiB0aGlzLiN1cGRhdGVQb3NpdGlvblN0cmF0ZWd5Py5jdXJyZW50ID09PSBcImFsd2F5c1wiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW46ICgpID0+IHRoaXMuZW5hYmxlZC5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmxvYXRpbmcuaXNQb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMub25QbGFjZWQ/LmN1cnJlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudE5vZGUgPSB0aGlzLmNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghY29udGVudE5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdW50cmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50WkluZGV4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudE5vZGUpLnpJbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0aW5nLmZsb2F0aW5nLmN1cnJlbnQgPSB0aGlzLndyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgRmxvYXRpbmdBcnJvd1N0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICAjY29udGVudDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGVudCkge1xuICAgICAgICB0aGlzLiNjb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICAgICAgb25SZWZDaGFuZ2U6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY29udGVudC5hcnJvd1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLiNjb250ZW50LmVuYWJsZWQuY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIHN0eWxlOiB0aGlzLiNjb250ZW50LmFycm93U3R5bGUsXG4gICAgICAgIFwiZGF0YS1zaWRlXCI6IHRoaXMuI2NvbnRlbnQucGxhY2VkU2lkZSxcbiAgICB9KSk7XG59XG5jbGFzcyBGbG9hdGluZ0FuY2hvclN0YXRlIHtcbiAgICByZWYgPSBib3gobnVsbCk7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgaWYgKHByb3BzLnZpcnR1YWxFbCAmJiBwcm9wcy52aXJ0dWFsRWwuY3VycmVudCkge1xuICAgICAgICAgICAgcm9vdC50cmlnZ2VyTm9kZSA9IGJveC5mcm9tKHByb3BzLnZpcnR1YWxFbC5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgICAgIGlkOiBwcm9wcy5pZCxcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICAgICAgICAgIG9uUmVmQ2hhbmdlOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByb290LnRyaWdnZXJOb2RlLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vXG4vLyBDT05URVhUIE1FVEhPRFNcbi8vXG5jb25zdCBbc2V0RmxvYXRpbmdSb290Q29udGV4dCwgZ2V0RmxvYXRpbmdSb290Q29udGV4dF0gPSBjcmVhdGVDb250ZXh0KFwiRmxvYXRpbmcuUm9vdFwiKTtcbmNvbnN0IFtzZXRGbG9hdGluZ0NvbnRlbnRDb250ZXh0LCBnZXRGbG9hdGluZ0NvbnRlbnRDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHQoXCJGbG9hdGluZy5Db250ZW50XCIpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsb2F0aW5nUm9vdFN0YXRlKCkge1xuICAgIHJldHVybiBzZXRGbG9hdGluZ1Jvb3RDb250ZXh0KG5ldyBGbG9hdGluZ1Jvb3RTdGF0ZSgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VGbG9hdGluZ0NvbnRlbnRTdGF0ZShwcm9wcykge1xuICAgIHJldHVybiBzZXRGbG9hdGluZ0NvbnRlbnRDb250ZXh0KG5ldyBGbG9hdGluZ0NvbnRlbnRTdGF0ZShwcm9wcywgZ2V0RmxvYXRpbmdSb290Q29udGV4dCgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlRmxvYXRpbmdBcnJvd1N0YXRlKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdGluZ0Fycm93U3RhdGUocHJvcHMsIGdldEZsb2F0aW5nQ29udGVudENvbnRleHQoKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlRmxvYXRpbmdBbmNob3JTdGF0ZShwcm9wcykge1xuICAgIHJldHVybiBuZXcgRmxvYXRpbmdBbmNob3JTdGF0ZShwcm9wcywgZ2V0RmxvYXRpbmdSb290Q29udGV4dCgpKTtcbn1cbi8vXG4vLyBIRUxQRVJTXG4vL1xuZnVuY3Rpb24gdHJhbnNmb3JtT3JpZ2luKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmbihkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBsYWNlbWVudCwgcmVjdHMsIG1pZGRsZXdhcmVEYXRhIH0gPSBkYXRhO1xuICAgICAgICAgICAgY29uc3QgY2Fubm90Q2VudGVyQXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8uY2VudGVyT2Zmc2V0ICE9PSAwO1xuICAgICAgICAgICAgY29uc3QgaXNBcnJvd0hpZGRlbiA9IGNhbm5vdENlbnRlckFycm93O1xuICAgICAgICAgICAgY29uc3QgYXJyb3dXaWR0aCA9IGlzQXJyb3dIaWRkZW4gPyAwIDogb3B0aW9ucy5hcnJvd1dpZHRoO1xuICAgICAgICAgICAgY29uc3QgYXJyb3dIZWlnaHQgPSBpc0Fycm93SGlkZGVuID8gMCA6IG9wdGlvbnMuYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBbcGxhY2VkU2lkZSwgcGxhY2VkQWxpZ25dID0gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgbm9BcnJvd0FsaWduID0geyBzdGFydDogXCIwJVwiLCBjZW50ZXI6IFwiNTAlXCIsIGVuZDogXCIxMDAlXCIgfVtwbGFjZWRBbGlnbl07XG4gICAgICAgICAgICBjb25zdCBhcnJvd1hDZW50ZXIgPSAobWlkZGxld2FyZURhdGEuYXJyb3c/LnggPz8gMCkgKyBhcnJvd1dpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGFycm93WUNlbnRlciA9IChtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueSA/PyAwKSArIGFycm93SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGxldCB4ID0gXCJcIjtcbiAgICAgICAgICAgIGxldCB5ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChwbGFjZWRTaWRlID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1hDZW50ZXJ9cHhgO1xuICAgICAgICAgICAgICAgIHkgPSBgJHstYXJyb3dIZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIHggPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dYQ2VudGVyfXB4YDtcbiAgICAgICAgICAgICAgICB5ID0gYCR7cmVjdHMuZmxvYXRpbmcuaGVpZ2h0ICsgYXJyb3dIZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IGAkey1hcnJvd0hlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgeSA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1lDZW50ZXJ9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICB4ID0gYCR7cmVjdHMuZmxvYXRpbmcud2lkdGggKyBhcnJvd0hlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgeSA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1lDZW50ZXJ9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB4LCB5IH0gfTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICBjb25zdCBbc2lkZSwgYWxpZ24gPSBcImNlbnRlclwiXSA9IHBsYWNlbWVudC5zcGxpdChcIi1cIik7XG4gICAgcmV0dXJuIFtzaWRlLCBhbGlnbl07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lkZUZyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KVsxXTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgU25pcHBldCB9IGZyb20gXCJzdmVsdGVcIjtcblx0aW1wb3J0IHsgdXNlRmxvYXRpbmdSb290U3RhdGUgfSBmcm9tIFwiLi4vdXNlRmxvYXRpbmdMYXllci5zdmVsdGUuanNcIjtcblxuXHRsZXQgeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuPzogU25pcHBldCB9ID0gJHByb3BzKCk7XG5cblx0dXNlRmxvYXRpbmdSb290U3RhdGUoKTtcbjwvc2NyaXB0PlxuXG57QHJlbmRlciBjaGlsZHJlbj8uKCl9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3ggfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB7IHVzZUZsb2F0aW5nQW5jaG9yU3RhdGUgfSBmcm9tIFwiLi4vdXNlRmxvYXRpbmdMYXllci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBBbmNob3JQcm9wcyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgTWVhc3VyYWJsZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9pbnRlcm5hbC9mbG9hdGluZy1zdmVsdGUvdHlwZXMuanNcIjtcblxuXHRsZXQgeyBpZCwgY2hpbGRyZW4sIHZpcnR1YWxFbCB9OiBBbmNob3JQcm9wcyA9ICRwcm9wcygpO1xuXG5cdHVzZUZsb2F0aW5nQW5jaG9yU3RhdGUoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0dmlydHVhbEVsOiBib3gud2l0aCgoKSA9PiB2aXJ0dWFsRWwgYXMgdW5rbm93biBhcyBNZWFzdXJhYmxlIHwgbnVsbCksXG5cdH0pO1xuPC9zY3JpcHQ+XG5cbntAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHsgdXNlRmxvYXRpbmdDb250ZW50U3RhdGUgfSBmcm9tIFwiLi4vdXNlRmxvYXRpbmdMYXllci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHR5cGUgeyBDb250ZW50SW1wbFByb3BzIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRjb250ZW50LFxuXHRcdHNpZGUgPSBcImJvdHRvbVwiLFxuXHRcdHNpZGVPZmZzZXQgPSAwLFxuXHRcdGFsaWduID0gXCJjZW50ZXJcIixcblx0XHRhbGlnbk9mZnNldCA9IDAsXG5cdFx0aWQsXG5cdFx0YXJyb3dQYWRkaW5nID0gMCxcblx0XHRhdm9pZENvbGxpc2lvbnMgPSB0cnVlLFxuXHRcdGNvbGxpc2lvbkJvdW5kYXJ5ID0gW10sXG5cdFx0Y29sbGlzaW9uUGFkZGluZyA9IDAsXG5cdFx0aGlkZVdoZW5EZXRhY2hlZCA9IGZhbHNlLFxuXHRcdG9uUGxhY2VkID0gKCkgPT4ge30sXG5cdFx0c3RpY2t5ID0gXCJwYXJ0aWFsXCIsXG5cdFx0dXBkYXRlUG9zaXRpb25TdHJhdGVneSA9IFwib3B0aW1pemVkXCIsXG5cdFx0c3RyYXRlZ3kgPSBcImZpeGVkXCIsXG5cdFx0ZGlyID0gXCJsdHJcIixcblx0XHRzdHlsZSA9IHt9LFxuXHRcdHdyYXBwZXJJZCA9IHVzZUlkKCksXG5cdFx0Y3VzdG9tQW5jaG9yID0gbnVsbCxcblx0fTogQ29udGVudEltcGxQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IGNvbnRlbnRTdGF0ZSA9IHVzZUZsb2F0aW5nQ29udGVudFN0YXRlKHtcblx0XHRzaWRlOiBib3gud2l0aCgoKSA9PiBzaWRlKSxcblx0XHRzaWRlT2Zmc2V0OiBib3gud2l0aCgoKSA9PiBzaWRlT2Zmc2V0KSxcblx0XHRhbGlnbjogYm94LndpdGgoKCkgPT4gYWxpZ24pLFxuXHRcdGFsaWduT2Zmc2V0OiBib3gud2l0aCgoKSA9PiBhbGlnbk9mZnNldCksXG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRhcnJvd1BhZGRpbmc6IGJveC53aXRoKCgpID0+IGFycm93UGFkZGluZyksXG5cdFx0YXZvaWRDb2xsaXNpb25zOiBib3gud2l0aCgoKSA9PiBhdm9pZENvbGxpc2lvbnMpLFxuXHRcdGNvbGxpc2lvbkJvdW5kYXJ5OiBib3gud2l0aCgoKSA9PiBjb2xsaXNpb25Cb3VuZGFyeSksXG5cdFx0Y29sbGlzaW9uUGFkZGluZzogYm94LndpdGgoKCkgPT4gY29sbGlzaW9uUGFkZGluZyksXG5cdFx0aGlkZVdoZW5EZXRhY2hlZDogYm94LndpdGgoKCkgPT4gaGlkZVdoZW5EZXRhY2hlZCksXG5cdFx0b25QbGFjZWQ6IGJveC53aXRoKCgpID0+IG9uUGxhY2VkKSxcblx0XHRzdGlja3k6IGJveC53aXRoKCgpID0+IHN0aWNreSksXG5cdFx0dXBkYXRlUG9zaXRpb25TdHJhdGVneTogYm94LndpdGgoKCkgPT4gdXBkYXRlUG9zaXRpb25TdHJhdGVneSksXG5cdFx0c3RyYXRlZ3k6IGJveC53aXRoKCgpID0+IHN0cmF0ZWd5KSxcblx0XHRkaXI6IGJveC53aXRoKCgpID0+IGRpciksXG5cdFx0c3R5bGU6IGJveC53aXRoKCgpID0+IHN0eWxlKSxcblx0XHRlbmFibGVkOiBib3gud2l0aCgoKSA9PiBmYWxzZSksXG5cdFx0d3JhcHBlcklkOiBib3gud2l0aCgoKSA9PiB3cmFwcGVySWQpLFxuXHRcdGN1c3RvbUFuY2hvcjogYm94LndpdGgoKCkgPT4gY3VzdG9tQW5jaG9yKSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChcblx0XHRtZXJnZVByb3BzKGNvbnRlbnRTdGF0ZS53cmFwcGVyUHJvcHMsIHtcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuXHRcdFx0fSxcblx0XHR9KVxuXHQpO1xuPC9zY3JpcHQ+XG5cbntAcmVuZGVyIGNvbnRlbnQ/Lih7IHByb3BzOiBjb250ZW50U3RhdGUucHJvcHMsIHdyYXBwZXJQcm9wczogbWVyZ2VkUHJvcHMgfSl9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyB0eXBlIFNuaXBwZXQsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cblx0bGV0IHtcblx0XHRjb250ZW50LFxuXHRcdG9uUGxhY2VkLFxuXHR9OiB7XG5cdFx0Y29udGVudD86IFNuaXBwZXQ8XG5cdFx0XHRbeyBwcm9wczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47IHdyYXBwZXJQcm9wczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfV1cblx0XHQ+O1xuXHRcdG9uUGxhY2VkPzogKCkgPT4gdm9pZDtcblx0fSA9ICRwcm9wcygpO1xuXG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdG9uUGxhY2VkPy4oKTtcblx0fSk7XG48L3NjcmlwdD5cblxue0ByZW5kZXIgY29udGVudD8uKHsgcHJvcHM6IHt9LCB3cmFwcGVyUHJvcHM6IHt9IH0pfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IEZsb2F0aW5nTGF5ZXJDb250ZW50U3RhdGljIGZyb20gXCIuLi9mbG9hdGluZy1sYXllci9jb21wb25lbnRzL2Zsb2F0aW5nLWxheWVyLWNvbnRlbnQtc3RhdGljLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgRmxvYXRpbmdMYXllckNvbnRlbnQgZnJvbSBcIi4uL2Zsb2F0aW5nLWxheWVyL2NvbXBvbmVudHMvZmxvYXRpbmctbGF5ZXItY29udGVudC5zdmVsdGVcIjtcblx0aW1wb3J0IHR5cGUgeyBGbG9hdGluZ0xheWVyQ29udGVudEltcGxQcm9wcyB9IGZyb20gXCIuLi9mbG9hdGluZy1sYXllci90eXBlcy5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y29udGVudCxcblx0XHRpc1N0YXRpYyA9IGZhbHNlLFxuXHRcdG9uUGxhY2VkLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBGbG9hdGluZ0xheWVyQ29udGVudEltcGxQcm9wcyAmIHsgaXNTdGF0aWM6IGJvb2xlYW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXNTdGF0aWN9XG5cdDxGbG9hdGluZ0xheWVyQ29udGVudFN0YXRpYyB7Y29udGVudH0ge29uUGxhY2VkfSAvPlxuezplbHNlfVxuXHQ8RmxvYXRpbmdMYXllckNvbnRlbnQge2NvbnRlbnR9IHtvblBsYWNlZH0gey4uLnJlc3RQcm9wc30gLz5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgU2Nyb2xsTG9jayBmcm9tIFwiLi4vc2Nyb2xsLWxvY2svc2Nyb2xsLWxvY2suc3ZlbHRlXCI7XG5cdGltcG9ydCB0eXBlIHsgUG9wcGVyTGF5ZXJJbXBsUHJvcHMgfSBmcm9tIFwiLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgUG9wcGVyQ29udGVudCBmcm9tIFwiLi9wb3BwZXItY29udGVudC5zdmVsdGVcIjtcblx0aW1wb3J0IEVzY2FwZUxheWVyIGZyb20gXCIuLi9lc2NhcGUtbGF5ZXIvZXNjYXBlLWxheWVyLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgRGlzbWlzc2libGVMYXllciBmcm9tIFwiLi4vZGlzbWlzc2libGUtbGF5ZXIvZGlzbWlzc2libGUtbGF5ZXIuc3ZlbHRlXCI7XG5cdGltcG9ydCBUZXh0U2VsZWN0aW9uTGF5ZXIgZnJvbSBcIi4uL3RleHQtc2VsZWN0aW9uLWxheWVyL3RleHQtc2VsZWN0aW9uLWxheWVyLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgRm9jdXNTY29wZSBmcm9tIFwiLi4vZm9jdXMtc2NvcGUvZm9jdXMtc2NvcGUuc3ZlbHRlXCI7XG5cblx0bGV0IHtcblx0XHRwb3BwZXIsXG5cdFx0b25Fc2NhcGVLZXlkb3duLFxuXHRcdGVzY2FwZUtleWRvd25CZWhhdmlvcixcblx0XHRwcmV2ZW50T3ZlcmZsb3dUZXh0U2VsZWN0aW9uLFxuXHRcdGlkLFxuXHRcdG9uUG9pbnRlckRvd24sXG5cdFx0b25Qb2ludGVyVXAsXG5cdFx0c2lkZSxcblx0XHRzaWRlT2Zmc2V0LFxuXHRcdGFsaWduLFxuXHRcdGFsaWduT2Zmc2V0LFxuXHRcdGFycm93UGFkZGluZyxcblx0XHRhdm9pZENvbGxpc2lvbnMsXG5cdFx0Y29sbGlzaW9uQm91bmRhcnksXG5cdFx0Y29sbGlzaW9uUGFkZGluZyxcblx0XHRzdGlja3ksXG5cdFx0aGlkZVdoZW5EZXRhY2hlZCxcblx0XHR1cGRhdGVQb3NpdGlvblN0cmF0ZWd5LFxuXHRcdHN0cmF0ZWd5LFxuXHRcdGRpcixcblx0XHRwcmV2ZW50U2Nyb2xsLFxuXHRcdHdyYXBwZXJJZCxcblx0XHRzdHlsZSxcblx0XHRvblBsYWNlZCxcblx0XHRvbkludGVyYWN0T3V0c2lkZSxcblx0XHRvbkNsb3NlQXV0b0ZvY3VzLFxuXHRcdG9uT3BlbkF1dG9Gb2N1cyxcblx0XHRvbkZvY3VzT3V0c2lkZSxcblx0XHRpbnRlcmFjdE91dHNpZGVCZWhhdmlvciA9IFwiY2xvc2VcIixcblx0XHRsb29wLFxuXHRcdHRyYXBGb2N1cyA9IHRydWUsXG5cdFx0aXNWYWxpZEV2ZW50ID0gKCkgPT4gZmFsc2UsXG5cdFx0Y3VzdG9tQW5jaG9yID0gbnVsbCxcblx0XHRpc1N0YXRpYyA9IGZhbHNlLFxuXHRcdGVuYWJsZWQsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IE9taXQ8UG9wcGVyTGF5ZXJJbXBsUHJvcHMsIFwicHJlc2VudFwiIHwgXCJjaGlsZHJlblwiPiAmIHtcblx0XHRlbmFibGVkOiBib29sZWFuO1xuXHR9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFBvcHBlckNvbnRlbnRcblx0e2lzU3RhdGljfVxuXHR7aWR9XG5cdHtzaWRlfVxuXHR7c2lkZU9mZnNldH1cblx0e2FsaWdufVxuXHR7YWxpZ25PZmZzZXR9XG5cdHthcnJvd1BhZGRpbmd9XG5cdHthdm9pZENvbGxpc2lvbnN9XG5cdHtjb2xsaXNpb25Cb3VuZGFyeX1cblx0e2NvbGxpc2lvblBhZGRpbmd9XG5cdHtzdGlja3l9XG5cdHtoaWRlV2hlbkRldGFjaGVkfVxuXHR7dXBkYXRlUG9zaXRpb25TdHJhdGVneX1cblx0e3N0cmF0ZWd5fVxuXHR7ZGlyfVxuXHR7d3JhcHBlcklkfVxuXHR7c3R5bGV9XG5cdHtvblBsYWNlZH1cblx0e2N1c3RvbUFuY2hvcn1cbj5cblx0eyNzbmlwcGV0IGNvbnRlbnQoeyBwcm9wczogZmxvYXRpbmdQcm9wcywgd3JhcHBlclByb3BzIH0pfVxuXHRcdHsjaWYgcmVzdFByb3BzLmZvcmNlTW91bnQgJiYgZW5hYmxlZH1cblx0XHRcdDxTY3JvbGxMb2NrIHtwcmV2ZW50U2Nyb2xsfSAvPlxuXHRcdHs6ZWxzZSBpZiAhcmVzdFByb3BzLmZvcmNlTW91bnR9XG5cdFx0XHQ8U2Nyb2xsTG9jayB7cHJldmVudFNjcm9sbH0gLz5cblx0XHR7L2lmfVxuXHRcdDxGb2N1c1Njb3BlXG5cdFx0XHR7aWR9XG5cdFx0XHR7b25PcGVuQXV0b0ZvY3VzfVxuXHRcdFx0e29uQ2xvc2VBdXRvRm9jdXN9XG5cdFx0XHR7bG9vcH1cblx0XHRcdHRyYXBGb2N1cz17ZW5hYmxlZCAmJiB0cmFwRm9jdXN9XG5cdFx0XHRmb3JjZU1vdW50PXtyZXN0UHJvcHMuZm9yY2VNb3VudH1cblx0XHQ+XG5cdFx0XHR7I3NuaXBwZXQgZm9jdXNTY29wZSh7IHByb3BzOiBmb2N1c1Njb3BlUHJvcHMgfSl9XG5cdFx0XHRcdDxFc2NhcGVMYXllciB7b25Fc2NhcGVLZXlkb3dufSB7ZXNjYXBlS2V5ZG93bkJlaGF2aW9yfSB7ZW5hYmxlZH0+XG5cdFx0XHRcdFx0PERpc21pc3NpYmxlTGF5ZXJcblx0XHRcdFx0XHRcdHtpZH1cblx0XHRcdFx0XHRcdHtvbkludGVyYWN0T3V0c2lkZX1cblx0XHRcdFx0XHRcdHtvbkZvY3VzT3V0c2lkZX1cblx0XHRcdFx0XHRcdHtpbnRlcmFjdE91dHNpZGVCZWhhdmlvcn1cblx0XHRcdFx0XHRcdHtpc1ZhbGlkRXZlbnR9XG5cdFx0XHRcdFx0XHR7ZW5hYmxlZH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7I3NuaXBwZXQgY2hpbGRyZW4oeyBwcm9wczogZGlzbWlzc2libGVQcm9wcyB9KX1cblx0XHRcdFx0XHRcdFx0PFRleHRTZWxlY3Rpb25MYXllclxuXHRcdFx0XHRcdFx0XHRcdHtpZH1cblx0XHRcdFx0XHRcdFx0XHR7cHJldmVudE92ZXJmbG93VGV4dFNlbGVjdGlvbn1cblx0XHRcdFx0XHRcdFx0XHR7b25Qb2ludGVyRG93bn1cblx0XHRcdFx0XHRcdFx0XHR7b25Qb2ludGVyVXB9XG5cdFx0XHRcdFx0XHRcdFx0e2VuYWJsZWR9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHR7QHJlbmRlciBwb3BwZXI/Lih7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9wczogbWVyZ2VQcm9wcyhcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdFByb3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbG9hdGluZ1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXNtaXNzaWJsZVByb3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb2N1c1Njb3BlUHJvcHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRlckV2ZW50czogXCJhdXRvXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyYXBwZXJQcm9wcyxcblx0XHRcdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHRcdFx0PC9UZXh0U2VsZWN0aW9uTGF5ZXI+XG5cdFx0XHRcdFx0XHR7L3NuaXBwZXR9XG5cdFx0XHRcdFx0PC9EaXNtaXNzaWJsZUxheWVyPlxuXHRcdFx0XHQ8L0VzY2FwZUxheWVyPlxuXHRcdFx0ey9zbmlwcGV0fVxuXHRcdDwvRm9jdXNTY29wZT5cblx0ey9zbmlwcGV0fVxuPC9Qb3BwZXJDb250ZW50PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBQb3BwZXJMYXllckltcGxQcm9wcyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cdGltcG9ydCBQb3BwZXJMYXllcklubmVyIGZyb20gXCIuL3BvcHBlci1sYXllci1pbm5lci5zdmVsdGVcIjtcblx0aW1wb3J0IFByZXNlbmNlTGF5ZXIgZnJvbSBcIi4uL3ByZXNlbmNlLWxheWVyL3ByZXNlbmNlLWxheWVyLnN2ZWx0ZVwiO1xuXG5cdGxldCB7XG5cdFx0cG9wcGVyLFxuXHRcdHByZXNlbnQsXG5cdFx0b25Fc2NhcGVLZXlkb3duLFxuXHRcdGVzY2FwZUtleWRvd25CZWhhdmlvcixcblx0XHRwcmV2ZW50T3ZlcmZsb3dUZXh0U2VsZWN0aW9uLFxuXHRcdGlkLFxuXHRcdG9uUG9pbnRlckRvd24sXG5cdFx0b25Qb2ludGVyVXAsXG5cdFx0c2lkZSxcblx0XHRzaWRlT2Zmc2V0LFxuXHRcdGFsaWduLFxuXHRcdGFsaWduT2Zmc2V0LFxuXHRcdGFycm93UGFkZGluZyxcblx0XHRhdm9pZENvbGxpc2lvbnMsXG5cdFx0Y29sbGlzaW9uQm91bmRhcnksXG5cdFx0Y29sbGlzaW9uUGFkZGluZyxcblx0XHRzdGlja3ksXG5cdFx0aGlkZVdoZW5EZXRhY2hlZCxcblx0XHR1cGRhdGVQb3NpdGlvblN0cmF0ZWd5LFxuXHRcdHN0cmF0ZWd5LFxuXHRcdGRpcixcblx0XHRwcmV2ZW50U2Nyb2xsLFxuXHRcdHdyYXBwZXJJZCxcblx0XHRzdHlsZSxcblx0XHRvblBsYWNlZCxcblx0XHRvbkludGVyYWN0T3V0c2lkZSxcblx0XHRvbkNsb3NlQXV0b0ZvY3VzLFxuXHRcdG9uT3BlbkF1dG9Gb2N1cyxcblx0XHRvbkZvY3VzT3V0c2lkZSxcblx0XHRpbnRlcmFjdE91dHNpZGVCZWhhdmlvciA9IFwiY2xvc2VcIixcblx0XHRsb29wLFxuXHRcdHRyYXBGb2N1cyA9IHRydWUsXG5cdFx0aXNWYWxpZEV2ZW50ID0gKCkgPT4gZmFsc2UsXG5cdFx0Y3VzdG9tQW5jaG9yID0gbnVsbCxcblx0XHRpc1N0YXRpYyA9IGZhbHNlLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBQb3BwZXJMYXllckltcGxQcm9wcyA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxQcmVzZW5jZUxheWVyIHtpZH0ge3ByZXNlbnR9IHsuLi5yZXN0UHJvcHN9PlxuXHR7I3NuaXBwZXQgcHJlc2VuY2UoeyBwcmVzZW50IH0pfVxuXHRcdDxQb3BwZXJMYXllcklubmVyXG5cdFx0XHR7cG9wcGVyfVxuXHRcdFx0e29uRXNjYXBlS2V5ZG93bn1cblx0XHRcdHtlc2NhcGVLZXlkb3duQmVoYXZpb3J9XG5cdFx0XHR7cHJldmVudE92ZXJmbG93VGV4dFNlbGVjdGlvbn1cblx0XHRcdHtpZH1cblx0XHRcdHtvblBvaW50ZXJEb3dufVxuXHRcdFx0e29uUG9pbnRlclVwfVxuXHRcdFx0e3NpZGV9XG5cdFx0XHR7c2lkZU9mZnNldH1cblx0XHRcdHthbGlnbn1cblx0XHRcdHthbGlnbk9mZnNldH1cblx0XHRcdHthcnJvd1BhZGRpbmd9XG5cdFx0XHR7YXZvaWRDb2xsaXNpb25zfVxuXHRcdFx0e2NvbGxpc2lvbkJvdW5kYXJ5fVxuXHRcdFx0e2NvbGxpc2lvblBhZGRpbmd9XG5cdFx0XHR7c3RpY2t5fVxuXHRcdFx0e2hpZGVXaGVuRGV0YWNoZWR9XG5cdFx0XHR7dXBkYXRlUG9zaXRpb25TdHJhdGVneX1cblx0XHRcdHtzdHJhdGVneX1cblx0XHRcdHtkaXJ9XG5cdFx0XHR7cHJldmVudFNjcm9sbH1cblx0XHRcdHt3cmFwcGVySWR9XG5cdFx0XHR7c3R5bGV9XG5cdFx0XHR7b25QbGFjZWR9XG5cdFx0XHR7Y3VzdG9tQW5jaG9yfVxuXHRcdFx0e2lzU3RhdGljfVxuXHRcdFx0ZW5hYmxlZD17cHJlc2VudC5jdXJyZW50fVxuXHRcdFx0e29uSW50ZXJhY3RPdXRzaWRlfVxuXHRcdFx0e29uQ2xvc2VBdXRvRm9jdXN9XG5cdFx0XHR7b25PcGVuQXV0b0ZvY3VzfVxuXHRcdFx0e2ludGVyYWN0T3V0c2lkZUJlaGF2aW9yfVxuXHRcdFx0e2xvb3B9XG5cdFx0XHR7dHJhcEZvY3VzfVxuXHRcdFx0e2lzVmFsaWRFdmVudH1cblx0XHRcdHtvbkZvY3VzT3V0c2lkZX1cblx0XHRcdGZvcmNlTW91bnQ9e2ZhbHNlfVxuXHRcdFx0ey4uLnJlc3RQcm9wc31cblx0XHQvPlxuXHR7L3NuaXBwZXR9XG48L1ByZXNlbmNlTGF5ZXI+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7IFBvcHBlckxheWVySW1wbFByb3BzIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IFBvcHBlckxheWVySW5uZXIgZnJvbSBcIi4vcG9wcGVyLWxheWVyLWlubmVyLnN2ZWx0ZVwiO1xuXG5cdGxldCB7XG5cdFx0cG9wcGVyLFxuXHRcdG9uRXNjYXBlS2V5ZG93bixcblx0XHRlc2NhcGVLZXlkb3duQmVoYXZpb3IsXG5cdFx0cHJldmVudE92ZXJmbG93VGV4dFNlbGVjdGlvbixcblx0XHRpZCxcblx0XHRvblBvaW50ZXJEb3duLFxuXHRcdG9uUG9pbnRlclVwLFxuXHRcdHNpZGUsXG5cdFx0c2lkZU9mZnNldCxcblx0XHRhbGlnbixcblx0XHRhbGlnbk9mZnNldCxcblx0XHRhcnJvd1BhZGRpbmcsXG5cdFx0YXZvaWRDb2xsaXNpb25zLFxuXHRcdGNvbGxpc2lvbkJvdW5kYXJ5LFxuXHRcdGNvbGxpc2lvblBhZGRpbmcsXG5cdFx0c3RpY2t5LFxuXHRcdGhpZGVXaGVuRGV0YWNoZWQsXG5cdFx0dXBkYXRlUG9zaXRpb25TdHJhdGVneSxcblx0XHRzdHJhdGVneSxcblx0XHRkaXIsXG5cdFx0cHJldmVudFNjcm9sbCxcblx0XHR3cmFwcGVySWQsXG5cdFx0c3R5bGUsXG5cdFx0b25QbGFjZWQsXG5cdFx0b25JbnRlcmFjdE91dHNpZGUsXG5cdFx0b25DbG9zZUF1dG9Gb2N1cyxcblx0XHRvbk9wZW5BdXRvRm9jdXMsXG5cdFx0b25Gb2N1c091dHNpZGUsXG5cdFx0aW50ZXJhY3RPdXRzaWRlQmVoYXZpb3IgPSBcImNsb3NlXCIsXG5cdFx0bG9vcCxcblx0XHR0cmFwRm9jdXMgPSB0cnVlLFxuXHRcdGlzVmFsaWRFdmVudCA9ICgpID0+IGZhbHNlLFxuXHRcdGN1c3RvbUFuY2hvciA9IG51bGwsXG5cdFx0aXNTdGF0aWMgPSBmYWxzZSxcblx0XHRlbmFibGVkLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBPbWl0PFBvcHBlckxheWVySW1wbFByb3BzLCBcInByZXNlbnRcIj4gJiB7XG5cdFx0ZW5hYmxlZDogYm9vbGVhbjtcblx0fSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxQb3BwZXJMYXllcklubmVyXG5cdHtwb3BwZXJ9XG5cdHtvbkVzY2FwZUtleWRvd259XG5cdHtlc2NhcGVLZXlkb3duQmVoYXZpb3J9XG5cdHtwcmV2ZW50T3ZlcmZsb3dUZXh0U2VsZWN0aW9ufVxuXHR7aWR9XG5cdHtvblBvaW50ZXJEb3dufVxuXHR7b25Qb2ludGVyVXB9XG5cdHtzaWRlfVxuXHR7c2lkZU9mZnNldH1cblx0e2FsaWdufVxuXHR7YWxpZ25PZmZzZXR9XG5cdHthcnJvd1BhZGRpbmd9XG5cdHthdm9pZENvbGxpc2lvbnN9XG5cdHtjb2xsaXNpb25Cb3VuZGFyeX1cblx0e2NvbGxpc2lvblBhZGRpbmd9XG5cdHtzdGlja3l9XG5cdHtoaWRlV2hlbkRldGFjaGVkfVxuXHR7dXBkYXRlUG9zaXRpb25TdHJhdGVneX1cblx0e3N0cmF0ZWd5fVxuXHR7ZGlyfVxuXHR7cHJldmVudFNjcm9sbH1cblx0e3dyYXBwZXJJZH1cblx0e3N0eWxlfVxuXHR7b25QbGFjZWR9XG5cdHtjdXN0b21BbmNob3J9XG5cdHtpc1N0YXRpY31cblx0e2VuYWJsZWR9XG5cdHtvbkludGVyYWN0T3V0c2lkZX1cblx0e29uQ2xvc2VBdXRvRm9jdXN9XG5cdHtvbk9wZW5BdXRvRm9jdXN9XG5cdHtpbnRlcmFjdE91dHNpZGVCZWhhdmlvcn1cblx0e2xvb3B9XG5cdHt0cmFwRm9jdXN9XG5cdHtpc1ZhbGlkRXZlbnR9XG5cdHtvbkZvY3VzT3V0c2lkZX1cblx0ey4uLnJlc3RQcm9wc31cblx0Zm9yY2VNb3VudD17dHJ1ZX1cbi8+XG4iLCJpbXBvcnQgeyBhZnRlclNsZWVwLCBhZnRlclRpY2ssIHVzZVJlZkJ5SWQgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5pbXBvcnQgeyBrYmQgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwva2JkLmpzXCI7XG5pbXBvcnQgeyBnZXRBcmlhRXhwYW5kZWQsIGdldERhdGFPcGVuQ2xvc2VkIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2F0dHJzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2NyZWF0ZS1jb250ZXh0LmpzXCI7XG5jbGFzcyBQb3BvdmVyUm9vdFN0YXRlIHtcbiAgICBvcGVuO1xuICAgIGNvbnRlbnROb2RlID0gJHN0YXRlKG51bGwpO1xuICAgIGNvbnRlbnRJZCA9ICRzdGF0ZSh1bmRlZmluZWQpO1xuICAgIHRyaWdnZXJOb2RlID0gJHN0YXRlKG51bGwpO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IHByb3BzLm9wZW47XG4gICAgfVxuICAgIHRvZ2dsZU9wZW4oKSB7XG4gICAgICAgIHRoaXMub3Blbi5jdXJyZW50ID0gIXRoaXMub3Blbi5jdXJyZW50O1xuICAgIH1cbiAgICBoYW5kbGVDbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW4uY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vcGVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBQb3BvdmVyVHJpZ2dlclN0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICAjZGlzYWJsZWQ7XG4gICAgI3Jvb3Q7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jcm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuI3JlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdGhpcy4jZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgdXNlUmVmQnlJZCh7XG4gICAgICAgICAgICBpZDogdGhpcy4jaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMuI3JlZixcbiAgICAgICAgICAgIG9uUmVmQ2hhbmdlOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QudHJpZ2dlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jbGljayA9IHRoaXMub25jbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9ucG9pbnRlcmRvd24gPSB0aGlzLm9ucG9pbnRlcmRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmtleWRvd24gPSB0aGlzLm9ua2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBvbmNsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Rpc2FibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4jcm9vdC50b2dnbGVPcGVuKCk7XG4gICAgfVxuICAgIG9ucG9pbnRlcmRvd24oZSkge1xuICAgICAgICBpZiAodGhpcy4jZGlzYWJsZWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBXZSBwcmV2ZW50IGRlZmF1bHQgdG8gcHJldmVudCBmb2N1cyBmcm9tIG1vdmluZyB0byB0aGUgdHJpZ2dlclxuICAgICAgICAvLyBzaW5jZSB0aGlzIGFjdGlvbiB3aWxsIG9wZW4gdGhlIHBvcG92ZXIgYW5kIGZvY3VzIHdpbGwgbW92ZSB0byB0aGUgY29udGVudFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9ua2V5ZG93bihlKSB7XG4gICAgICAgIGlmICh0aGlzLiNkaXNhYmxlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIShlLmtleSA9PT0ga2JkLkVOVEVSIHx8IGUua2V5ID09PSBrYmQuU1BBQ0UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuI3Jvb3QudG9nZ2xlT3BlbigpO1xuICAgIH1cbiAgICAjZ2V0QXJpYUNvbnRyb2xzKCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdC5vcGVuLmN1cnJlbnQgJiYgdGhpcy4jcm9vdC5jb250ZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb290LmNvbnRlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLiNpZC5jdXJyZW50LFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJkaWFsb2dcIixcbiAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IGdldEFyaWFFeHBhbmRlZCh0aGlzLiNyb290Lm9wZW4uY3VycmVudCksXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBnZXREYXRhT3BlbkNsb3NlZCh0aGlzLiNyb290Lm9wZW4uY3VycmVudCksXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiB0aGlzLiNnZXRBcmlhQ29udHJvbHMoKSxcbiAgICAgICAgXCJkYXRhLXBvcG92ZXItdHJpZ2dlclwiOiBcIlwiLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy4jZGlzYWJsZWQuY3VycmVudCxcbiAgICAgICAgLy9cbiAgICAgICAgb25wb2ludGVyZG93bjogdGhpcy5vbnBvaW50ZXJkb3duLFxuICAgICAgICBvbmtleWRvd246IHRoaXMub25rZXlkb3duLFxuICAgICAgICBvbmNsaWNrOiB0aGlzLm9uY2xpY2ssXG4gICAgfSkpO1xufVxuY2xhc3MgUG9wb3ZlckNvbnRlbnRTdGF0ZSB7XG4gICAgI2lkO1xuICAgICNyZWY7XG4gICAgcm9vdDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgICAgICBkZXBzOiAoKSA9PiB0aGlzLnJvb3Qub3Blbi5jdXJyZW50LFxuICAgICAgICAgICAgb25SZWZDaGFuZ2U6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmNvbnRlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QuY29udGVudElkID0gbm9kZT8uaWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc25pcHBldFByb3BzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHsgb3BlbjogdGhpcy5yb290Lm9wZW4uY3VycmVudCB9KSk7XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgdGFiaW5kZXg6IC0xLFxuICAgICAgICBcImRhdGEtc3RhdGVcIjogZ2V0RGF0YU9wZW5DbG9zZWQodGhpcy5yb290Lm9wZW4uY3VycmVudCksXG4gICAgICAgIFwiZGF0YS1wb3BvdmVyLWNvbnRlbnRcIjogXCJcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbmNsYXNzIFBvcG92ZXJDbG9zZVN0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICAjcm9vdDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLiNyb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy4jaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy4jcmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy4jcmVmLFxuICAgICAgICAgICAgZGVwczogKCkgPT4gdGhpcy4jcm9vdC5vcGVuLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uY2xpY2sgPSB0aGlzLm9uY2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmtleWRvd24gPSB0aGlzLm9ua2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBvbmNsaWNrKF8pIHtcbiAgICAgICAgdGhpcy4jcm9vdC5oYW5kbGVDbG9zZSgpO1xuICAgIH1cbiAgICBvbmtleWRvd24oZSkge1xuICAgICAgICBpZiAoIShlLmtleSA9PT0ga2JkLkVOVEVSIHx8IGUua2V5ID09PSBrYmQuU1BBQ0UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuI3Jvb3QuaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgb25jbGljazogdGhpcy5vbmNsaWNrLFxuICAgICAgICBvbmtleWRvd246IHRoaXMub25rZXlkb3duLFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBcImRhdGEtcG9wb3Zlci1jbG9zZVwiOiBcIlwiLFxuICAgIH0pKTtcbn1cbi8vXG4vLyBDT05URVhUIE1FVEhPRFNcbi8vXG5jb25zdCBbc2V0UG9wb3ZlclJvb3RDb250ZXh0LCBnZXRQb3BvdmVyUm9vdENvbnRleHRdID0gY3JlYXRlQ29udGV4dChcIlBvcG92ZXIuUm9vdFwiKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BvdmVyUm9vdChwcm9wcykge1xuICAgIHJldHVybiBzZXRQb3BvdmVyUm9vdENvbnRleHQobmV3IFBvcG92ZXJSb290U3RhdGUocHJvcHMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VQb3BvdmVyVHJpZ2dlcihwcm9wcykge1xuICAgIHJldHVybiBuZXcgUG9wb3ZlclRyaWdnZXJTdGF0ZShwcm9wcywgZ2V0UG9wb3ZlclJvb3RDb250ZXh0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBvcG92ZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBQb3BvdmVyQ29udGVudFN0YXRlKHByb3BzLCBnZXRQb3BvdmVyUm9vdENvbnRleHQoKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlUG9wb3ZlckNsb3NlKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBQb3BvdmVyQ2xvc2VTdGF0ZShwcm9wcywgZ2V0UG9wb3ZlclJvb3RDb250ZXh0KCkpO1xufVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IFBvcG92ZXJDb250ZW50UHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlUG9wb3ZlckNvbnRlbnQgfSBmcm9tIFwiLi4vcG9wb3Zlci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IFBvcHBlckxheWVyIGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcG9wcGVyLWxheWVyL3BvcHBlci1sYXllci5zdmVsdGVcIjtcblx0aW1wb3J0IHsgbm9vcCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9ub29wLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXHRpbXBvcnQgeyBnZXRGbG9hdGluZ0NvbnRlbnRDU1NWYXJzIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2Zsb2F0aW5nLXN2ZWx0ZS9mbG9hdGluZy11dGlscy5zdmVsdGUuanNcIjtcblx0aW1wb3J0IFBvcHBlckxheWVyRm9yY2VNb3VudCBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3BvcHBlci1sYXllci9wb3BwZXItbGF5ZXItZm9yY2UtbW91bnQuc3ZlbHRlXCI7XG5cdGltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvaXMuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkLFxuXHRcdGNoaWxkcmVuLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Zm9yY2VNb3VudCA9IGZhbHNlLFxuXHRcdG9uQ2xvc2VBdXRvRm9jdXMgPSBub29wLFxuXHRcdG9uRXNjYXBlS2V5ZG93biA9IG5vb3AsXG5cdFx0b25JbnRlcmFjdE91dHNpZGUgPSBub29wLFxuXHRcdHRyYXBGb2N1cyA9IHRydWUsXG5cdFx0cHJldmVudFNjcm9sbCA9IGZhbHNlLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBQb3BvdmVyQ29udGVudFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgY29udGVudFN0YXRlID0gdXNlUG9wb3ZlckNvbnRlbnQoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBjb250ZW50U3RhdGUucHJvcHMpKTtcblxuXHRmdW5jdGlvbiBoYW5kbGVJbnRlcmFjdE91dHNpZGUoZTogUG9pbnRlckV2ZW50KSB7XG5cdFx0b25JbnRlcmFjdE91dHNpZGUoZSk7XG5cdFx0aWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXHRcdGlmIChpc0hUTUxFbGVtZW50KGUudGFyZ2V0KSAmJiBlLnRhcmdldC5jbG9zZXN0KFwiW2RhdGEtcG9wb3Zlci10cmlnZ2VyXCIpKSByZXR1cm47XG5cdFx0Y29udGVudFN0YXRlLnJvb3QuaGFuZGxlQ2xvc2UoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUVzY2FwZUtleWRvd24oZTogS2V5Ym9hcmRFdmVudCkge1xuXHRcdG9uRXNjYXBlS2V5ZG93bihlKTtcblx0XHRpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cdFx0Y29udGVudFN0YXRlLnJvb3QuaGFuZGxlQ2xvc2UoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUNsb3NlQXV0b0ZvY3VzKGU6IEV2ZW50KSB7XG5cdFx0b25DbG9zZUF1dG9Gb2N1cyhlKTtcblx0XHRpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGNvbnRlbnRTdGF0ZS5yb290LnRyaWdnZXJOb2RlPy5mb2N1cygpO1xuXHR9XG48L3NjcmlwdD5cblxueyNpZiBmb3JjZU1vdW50fVxuXHQ8UG9wcGVyTGF5ZXJGb3JjZU1vdW50XG5cdFx0ey4uLm1lcmdlZFByb3BzfVxuXHRcdGVuYWJsZWQ9e2NvbnRlbnRTdGF0ZS5yb290Lm9wZW4uY3VycmVudH1cblx0XHR7aWR9XG5cdFx0b25JbnRlcmFjdE91dHNpZGU9e2hhbmRsZUludGVyYWN0T3V0c2lkZX1cblx0XHRvbkVzY2FwZUtleWRvd249e2hhbmRsZUVzY2FwZUtleWRvd259XG5cdFx0b25DbG9zZUF1dG9Gb2N1cz17aGFuZGxlQ2xvc2VBdXRvRm9jdXN9XG5cdFx0e3RyYXBGb2N1c31cblx0XHR7cHJldmVudFNjcm9sbH1cblx0XHRsb29wXG5cdFx0Zm9yY2VNb3VudD17dHJ1ZX1cblx0PlxuXHRcdHsjc25pcHBldCBwb3BwZXIoeyBwcm9wcywgd3JhcHBlclByb3BzIH0pfVxuXHRcdFx0e0Bjb25zdCBmaW5hbFByb3BzID0gbWVyZ2VQcm9wcyhwcm9wcywge1xuXHRcdFx0XHRzdHlsZTogZ2V0RmxvYXRpbmdDb250ZW50Q1NTVmFycyhcInBvcG92ZXJcIiksXG5cdFx0XHR9KX1cblx0XHRcdHsjaWYgY2hpbGR9XG5cdFx0XHRcdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IGZpbmFsUHJvcHMsIHdyYXBwZXJQcm9wcywgLi4uY29udGVudFN0YXRlLnNuaXBwZXRQcm9wcyB9KX1cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0PGRpdiB7Li4ud3JhcHBlclByb3BzfT5cblx0XHRcdFx0XHQ8ZGl2IHsuLi5maW5hbFByb3BzfT5cblx0XHRcdFx0XHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdHsvc25pcHBldH1cblx0PC9Qb3BwZXJMYXllckZvcmNlTW91bnQ+XG57OmVsc2UgaWYgIWZvcmNlTW91bnR9XG5cdDxQb3BwZXJMYXllclxuXHRcdHsuLi5tZXJnZWRQcm9wc31cblx0XHRwcmVzZW50PXtjb250ZW50U3RhdGUucm9vdC5vcGVuLmN1cnJlbnR9XG5cdFx0e2lkfVxuXHRcdG9uSW50ZXJhY3RPdXRzaWRlPXtoYW5kbGVJbnRlcmFjdE91dHNpZGV9XG5cdFx0b25Fc2NhcGVLZXlkb3duPXtoYW5kbGVFc2NhcGVLZXlkb3dufVxuXHRcdG9uQ2xvc2VBdXRvRm9jdXM9e2hhbmRsZUNsb3NlQXV0b0ZvY3VzfVxuXHRcdHt0cmFwRm9jdXN9XG5cdFx0e3ByZXZlbnRTY3JvbGx9XG5cdFx0bG9vcFxuXHRcdGZvcmNlTW91bnQ9e2ZhbHNlfVxuXHQ+XG5cdFx0eyNzbmlwcGV0IHBvcHBlcih7IHByb3BzLCB3cmFwcGVyUHJvcHMgfSl9XG5cdFx0XHR7QGNvbnN0IGZpbmFsUHJvcHMgPSBtZXJnZVByb3BzKHByb3BzLCB7XG5cdFx0XHRcdHN0eWxlOiBnZXRGbG9hdGluZ0NvbnRlbnRDU1NWYXJzKFwicG9wb3ZlclwiKSxcblx0XHRcdH0pfVxuXHRcdFx0eyNpZiBjaGlsZH1cblx0XHRcdFx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogZmluYWxQcm9wcywgd3JhcHBlclByb3BzLCAuLi5jb250ZW50U3RhdGUuc25pcHBldFByb3BzIH0pfVxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8ZGl2IHsuLi53cmFwcGVyUHJvcHN9PlxuXHRcdFx0XHRcdDxkaXYgey4uLmZpbmFsUHJvcHN9PlxuXHRcdFx0XHRcdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cdFx0ey9zbmlwcGV0fVxuXHQ8L1BvcHBlckxheWVyPlxuey9pZn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHR5cGUgeyBQb3BvdmVyVHJpZ2dlclByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZVBvcG92ZXJUcmlnZ2VyIH0gZnJvbSBcIi4uL3BvcG92ZXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXHRpbXBvcnQgRmxvYXRpbmdMYXllckFuY2hvciBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2Zsb2F0aW5nLWxheWVyL2NvbXBvbmVudHMvZmxvYXRpbmctbGF5ZXItYW5jaG9yLnN2ZWx0ZVwiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0aWQgPSB1c2VJZCgpLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHR0eXBlID0gXCJidXR0b25cIixcblx0XHRkaXNhYmxlZCA9IGZhbHNlLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBQb3BvdmVyVHJpZ2dlclByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgdHJpZ2dlclN0YXRlID0gdXNlUG9wb3ZlclRyaWdnZXIoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHRcdGRpc2FibGVkOiBib3gud2l0aCgoKSA9PiBCb29sZWFuKGRpc2FibGVkKSksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIHRyaWdnZXJTdGF0ZS5wcm9wcywgeyB0eXBlIH0pKTtcbjwvc2NyaXB0PlxuXG48RmxvYXRpbmdMYXllckFuY2hvciB7aWR9PlxuXHR7I2lmIGNoaWxkfVxuXHRcdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuXHR7OmVsc2V9XG5cdFx0PGJ1dHRvbiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHRcdDwvYnV0dG9uPlxuXHR7L2lmfVxuPC9GbG9hdGluZ0xheWVyQW5jaG9yPlxuIiwiaW1wb3J0IHsgZ2V0TG9jYWxUaW1lWm9uZSwgaXNTYW1lRGF5LCBpc1NhbWVNb250aCwgaXNUb2RheSwgfSBmcm9tIFwiQGludGVybmF0aW9uYWxpemVkL2RhdGVcIjtcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyB1c2VSZWZCeUlkIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5pbXBvcnQgeyBnZXRBcmlhRGlzYWJsZWQsIGdldEFyaWFTZWxlY3RlZCwgZ2V0RGF0YURpc2FibGVkLCBnZXREYXRhU2VsZWN0ZWQsIGdldERhdGFVbmF2YWlsYWJsZSwgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvYXR0cnMuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvY3JlYXRlLWNvbnRleHQuanNcIjtcbmltcG9ydCB7IGdldEFubm91bmNlciB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9kYXRlLXRpbWUvYW5ub3VuY2VyLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvZGF0ZS10aW1lL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlTW9udGhzLCBnZXRDYWxlbmRhckVsZW1lbnRQcm9wcywgZ2V0Q2FsZW5kYXJIZWFkaW5nVmFsdWUsIGdldElzTmV4dEJ1dHRvbkRpc2FibGVkLCBnZXRJc1ByZXZCdXR0b25EaXNhYmxlZCwgZ2V0V2Vla2RheXMsIGhhbmRsZUNhbGVuZGFyS2V5ZG93biwgaGFuZGxlQ2FsZW5kYXJOZXh0UGFnZSwgaGFuZGxlQ2FsZW5kYXJQcmV2UGFnZSwgc2hpZnRDYWxlbmRhckZvY3VzLCB1c2VNb250aFZpZXdPcHRpb25zU3luYywgdXNlTW9udGhWaWV3UGxhY2Vob2xkZXJTeW5jLCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9kYXRlLXRpbWUvY2FsZW5kYXItaGVscGVycy5zdmVsdGUuanNcIjtcbmltcG9ydCB7IGFyZUFsbERheXNCZXR3ZWVuVmFsaWQsIGlzQWZ0ZXIsIGlzQmVmb3JlLCBpc0JldHdlZW5JbmNsdXNpdmUsIHRvRGF0ZSwgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvZGF0ZS10aW1lL3V0aWxzLmpzXCI7XG5leHBvcnQgY2xhc3MgUmFuZ2VDYWxlbmRhclJvb3RTdGF0ZSB7XG4gICAgaWQ7XG4gICAgcmVmO1xuICAgIHZhbHVlO1xuICAgIHBsYWNlaG9sZGVyO1xuICAgIHByZXZlbnREZXNlbGVjdDtcbiAgICBtaW5WYWx1ZTtcbiAgICBtYXhWYWx1ZTtcbiAgICBkaXNhYmxlZDtcbiAgICBwYWdlZE5hdmlnYXRpb247XG4gICAgd2Vla1N0YXJ0c09uO1xuICAgIHdlZWtkYXlGb3JtYXQ7XG4gICAgaXNEYXRlRGlzYWJsZWRQcm9wO1xuICAgIGlzRGF0ZVVuYXZhaWxhYmxlUHJvcDtcbiAgICBmaXhlZFdlZWtzO1xuICAgIG51bWJlck9mTW9udGhzO1xuICAgIGxvY2FsZTtcbiAgICBjYWxlbmRhckxhYmVsO1xuICAgIHJlYWRvbmx5O1xuICAgIGRpc2FibGVEYXlzT3V0c2lkZU1vbnRoO1xuICAgIG9uUmFuZ2VTZWxlY3Q7XG4gICAgc3RhcnRWYWx1ZTtcbiAgICBlbmRWYWx1ZTtcbiAgICBtb250aHMgPSAkc3RhdGUoW10pO1xuICAgIHZpc2libGVNb250aHMgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLm1vbnRocy5tYXAoKG1vbnRoKSA9PiBtb250aC52YWx1ZSkpO1xuICAgIGFubm91bmNlcjtcbiAgICBmb3JtYXR0ZXI7XG4gICAgYWNjZXNzaWJsZUhlYWRpbmdJZCA9IHVzZUlkKCk7XG4gICAgZm9jdXNlZFZhbHVlID0gJHN0YXRlKHVuZGVmaW5lZCk7XG4gICAgbGFzdFByZXNzZWREYXRlVmFsdWUgPSAkc3RhdGUodW5kZWZpbmVkKTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVzZWxlY3QgPSBwcm9wcy5wcmV2ZW50RGVzZWxlY3Q7XG4gICAgICAgIHRoaXMubWluVmFsdWUgPSBwcm9wcy5taW5WYWx1ZTtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IHByb3BzLm1heFZhbHVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMucGFnZWROYXZpZ2F0aW9uID0gcHJvcHMucGFnZWROYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLndlZWtTdGFydHNPbiA9IHByb3BzLndlZWtTdGFydHNPbjtcbiAgICAgICAgdGhpcy53ZWVrZGF5Rm9ybWF0ID0gcHJvcHMud2Vla2RheUZvcm1hdDtcbiAgICAgICAgdGhpcy5pc0RhdGVEaXNhYmxlZFByb3AgPSBwcm9wcy5pc0RhdGVEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5pc0RhdGVVbmF2YWlsYWJsZVByb3AgPSBwcm9wcy5pc0RhdGVVbmF2YWlsYWJsZTtcbiAgICAgICAgdGhpcy5maXhlZFdlZWtzID0gcHJvcHMuZml4ZWRXZWVrcztcbiAgICAgICAgdGhpcy5udW1iZXJPZk1vbnRocyA9IHByb3BzLm51bWJlck9mTW9udGhzO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICAgICAgdGhpcy5jYWxlbmRhckxhYmVsID0gcHJvcHMuY2FsZW5kYXJMYWJlbDtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHByb3BzLnJlYWRvbmx5O1xuICAgICAgICB0aGlzLmRpc2FibGVEYXlzT3V0c2lkZU1vbnRoID0gcHJvcHMuZGlzYWJsZURheXNPdXRzaWRlTW9udGg7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMub25SYW5nZVNlbGVjdCA9IHByb3BzLm9uUmFuZ2VTZWxlY3Q7XG4gICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IHByb3BzLnN0YXJ0VmFsdWU7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSBwcm9wcy5lbmRWYWx1ZTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZXIgPSBnZXRBbm5vdW5jZXIoKTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIodGhpcy5sb2NhbGUuY3VycmVudCk7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb250aHMgPSBjcmVhdGVNb250aHMoe1xuICAgICAgICAgICAgZGF0ZU9iajogdGhpcy5wbGFjZWhvbGRlci5jdXJyZW50LFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB0aGlzLndlZWtTdGFydHNPbi5jdXJyZW50LFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZS5jdXJyZW50LFxuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLmN1cnJlbnQsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRoczogdGhpcy5udW1iZXJPZk1vbnRocy5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXR0ZXIuZ2V0TG9jYWxlKCkgPT09IHRoaXMubG9jYWxlLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuc2V0TG9jYWxlKHRoaXMubG9jYWxlLmN1cnJlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXllZCBtb250aHMgYmFzZWQgb24gY2hhbmdlcyBpbiB0aGUgcGxhY2Vob2xkZXIgdmFsdWVzLFxuICAgICAgICAgKiB3aGljaCBkZXRlcm1pbmVzIHRoZSBtb250aCB0byBzaG93IGluIHRoZSBjYWxlbmRhci5cbiAgICAgICAgICovXG4gICAgICAgIHVzZU1vbnRoVmlld1BsYWNlaG9sZGVyU3luYyh7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogdGhpcy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgIGdldFZpc2libGVNb250aHM6ICgpID0+IHRoaXMudmlzaWJsZU1vbnRocyxcbiAgICAgICAgICAgIHdlZWtTdGFydHNPbjogdGhpcy53ZWVrU3RhcnRzT24sXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLFxuICAgICAgICAgICAgbnVtYmVyT2ZNb250aHM6IHRoaXMubnVtYmVyT2ZNb250aHMsXG4gICAgICAgICAgICBzZXRNb250aHM6IHRoaXMuc2V0TW9udGhzLFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXllZCBtb250aHMgYmFzZWQgb24gY2hhbmdlcyBpbiB0aGUgb3B0aW9ucyB2YWx1ZXMsXG4gICAgICAgICAqIHdoaWNoIGRldGVybWluZXMgdGhlIG1vbnRoIHRvIHNob3cgaW4gdGhlIGNhbGVuZGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgdXNlTW9udGhWaWV3T3B0aW9uc1N5bmMoe1xuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgIG51bWJlck9mTW9udGhzOiB0aGlzLm51bWJlck9mTW9udGhzLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBzZXRNb250aHM6IHRoaXMuc2V0TW9udGhzLFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB0aGlzLndlZWtTdGFydHNPbixcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGFjY2Vzc2libGUgaGVhZGluZydzIHRleHQgY29udGVudCB3aGVuIHRoZSBgZnVsbENhbGVuZGFyTGFiZWxgXG4gICAgICAgICAqIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmFjY2Vzc2libGVIZWFkaW5nSWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0aGlzLmZ1bGxDYWxlbmRhckxhYmVsO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN5bmNocm9uaXplIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyB3aXRoIHRoZSBgdmFsdWVgIGluIGNhc2VcbiAgICAgICAgICogaXQgaXMgdXBkYXRlZCBleHRlcm5hbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWUuY3VycmVudDtcbiAgICAgICAgICAgIHVudHJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydCAmJiB2YWx1ZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFZhbHVlLmN1cnJlbnQgPSB2YWx1ZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRWYWx1ZS5jdXJyZW50ID0gdmFsdWUuZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCA9IHZhbHVlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFZhbHVlLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3luY2hyb25pemUgdGhlIHBsYWNlaG9sZGVyIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgc3RhcnQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5jdXJyZW50O1xuICAgICAgICAgICAgdW50cmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHRoaXMudmFsdWUuY3VycmVudC5zdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRWYWx1ZSAmJiB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgIT09IHN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5jdXJyZW50ID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgZW5kVmFsdWUgPSB0aGlzLmVuZFZhbHVlLmN1cnJlbnQ7XG4gICAgICAgICAgICB1bnRyYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWUuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuc3RhcnQgPT09IHN0YXJ0VmFsdWUgJiYgdmFsdWUuZW5kID09PSBlbmRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGFydFZhbHVlICYmIGVuZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VwZGF0ZVZhbHVlKChwcmV2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zdGFydCA9PT0gc3RhcnRWYWx1ZSAmJiBwcmV2LmVuZCA9PT0gZW5kVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCZWZvcmUoZW5kVmFsdWUsIHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGVuZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3NldFN0YXJ0VmFsdWUoZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNzZXRFbmRWYWx1ZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZFZhbHVlLCBlbmQ6IHN0YXJ0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS5zdGFydCAmJiB2YWx1ZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaGlmdEZvY3VzID0gdGhpcy5zaGlmdEZvY3VzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2VsbENsaWNrID0gdGhpcy5oYW5kbGVDZWxsQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmtleWRvd24gPSB0aGlzLm9ua2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5leHRQYWdlID0gdGhpcy5uZXh0UGFnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByZXZQYWdlID0gdGhpcy5wcmV2UGFnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5leHRZZWFyID0gdGhpcy5uZXh0WWVhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByZXZZZWFyID0gdGhpcy5wcmV2WWVhci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFllYXIgPSB0aGlzLnNldFllYXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRNb250aCA9IHRoaXMuc2V0TW9udGguYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc0RhdGVEaXNhYmxlZCA9IHRoaXMuaXNEYXRlRGlzYWJsZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc0RhdGVVbmF2YWlsYWJsZSA9IHRoaXMuaXNEYXRlVW5hdmFpbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc091dHNpZGVWaXNpYmxlTW9udGhzID0gdGhpcy5pc091dHNpZGVWaXNpYmxlTW9udGhzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRoaXMuaXNTZWxlY3RlZC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAjdXBkYXRlVmFsdWUoY2IpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY2IodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlLnN0YXJ0ICYmIG5ld1ZhbHVlLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5vblJhbmdlU2VsZWN0Py5jdXJyZW50Py4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjc2V0U3RhcnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgICAjc2V0RW5kVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbmRWYWx1ZS5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIHNldE1vbnRocyA9IChtb250aHMpID0+IHtcbiAgICAgICAgdGhpcy5tb250aHMgPSBtb250aHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGRlcml2ZWQgc3RhdGUgaG9sZHMgYW4gYXJyYXkgb2YgbG9jYWxpemVkIGRheSBuYW1lcyBmb3IgdGhlIGN1cnJlbnRcbiAgICAgKiBsb2NhbGUgYW5kIGNhbGVuZGFyIHZpZXcuIEl0IGR5bmFtaWNhbGx5IHN5bmNzIHdpdGggdGhlICd3ZWVrU3RhcnRzT24nIG9wdGlvbixcbiAgICAgKiB1cGRhdGluZyBpdHMgY29udGVudCB3aGVuIHRoZSBvcHRpb24gY2hhbmdlcy4gVXNpbmcgdGhpcyBzdGF0ZSB0byByZW5kZXIgdGhlXG4gICAgICogY2FsZW5kYXIncyBkYXlzIG9mIHRoZSB3ZWVrIGlzIHN0cm9uZ2x5IHJlY29tbWVuZGVkLCBhcyBpdCBndWFyYW50ZWVzIHRoYXRcbiAgICAgKiB0aGUgZGF5cyBhcmUgY29ycmVjdGx5IGZvcm1hdHRlZCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlIGFuZCBjYWxlbmRhciB2aWV3LlxuICAgICAqL1xuICAgIHdlZWtkYXlzID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0V2Vla2RheXMoe1xuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdGhpcy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICB3ZWVrZGF5Rm9ybWF0OiB0aGlzLndlZWtkYXlGb3JtYXQuY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXNPdXRzaWRlVmlzaWJsZU1vbnRocyhkYXRlKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy52aXNpYmxlTW9udGhzLnNvbWUoKG1vbnRoKSA9PiBpc1NhbWVNb250aChkYXRlLCBtb250aCkpO1xuICAgIH1cbiAgICBpc0RhdGVEaXNhYmxlZChkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZURpc2FibGVkUHJvcC5jdXJyZW50KGRhdGUpIHx8IHRoaXMuZGlzYWJsZWQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBtaW5WYWx1ZSA9IHRoaXMubWluVmFsdWUuY3VycmVudDtcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSB0aGlzLm1heFZhbHVlLmN1cnJlbnQ7XG4gICAgICAgIGlmIChtaW5WYWx1ZSAmJiBpc0JlZm9yZShkYXRlLCBtaW5WYWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG1heFZhbHVlICYmIGlzQWZ0ZXIoZGF0ZSwgbWF4VmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNEYXRlVW5hdmFpbGFibGUoZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RhdGVVbmF2YWlsYWJsZVByb3AuY3VycmVudChkYXRlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzU3RhcnRJbnZhbGlkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNEYXRlVW5hdmFpbGFibGUodGhpcy5zdGFydFZhbHVlLmN1cnJlbnQpIHx8XG4gICAgICAgICAgICB0aGlzLmlzRGF0ZURpc2FibGVkKHRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50KSk7XG4gICAgfSk7XG4gICAgaXNFbmRJbnZhbGlkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5kVmFsdWUuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRGF0ZVVuYXZhaWxhYmxlKHRoaXMuZW5kVmFsdWUuY3VycmVudCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQodGhpcy5lbmRWYWx1ZS5jdXJyZW50KSk7XG4gICAgfSk7XG4gICAgaXNJbnZhbGlkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0SW52YWxpZCB8fCB0aGlzLmlzRW5kSW52YWxpZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5lbmRWYWx1ZS5jdXJyZW50ICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCAmJlxuICAgICAgICAgICAgaXNCZWZvcmUodGhpcy5lbmRWYWx1ZS5jdXJyZW50LCB0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIGlzTmV4dEJ1dHRvbkRpc2FibGVkID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0SXNOZXh0QnV0dG9uRGlzYWJsZWQoe1xuICAgICAgICAgICAgbWF4VmFsdWU6IHRoaXMubWF4VmFsdWUuY3VycmVudCxcbiAgICAgICAgICAgIG1vbnRoczogdGhpcy5tb250aHMsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZC5jdXJyZW50LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpc1ByZXZCdXR0b25EaXNhYmxlZCA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldElzUHJldkJ1dHRvbkRpc2FibGVkKHtcbiAgICAgICAgICAgIG1pblZhbHVlOiB0aGlzLm1pblZhbHVlLmN1cnJlbnQsXG4gICAgICAgICAgICBtb250aHM6IHRoaXMubW9udGhzLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQuY3VycmVudCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaGVhZGluZ1ZhbHVlID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0Q2FsZW5kYXJIZWFkaW5nVmFsdWUoe1xuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdGhpcy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZ1bGxDYWxlbmRhckxhYmVsID0gJGRlcml2ZWQuYnkoKCkgPT4gYCR7dGhpcy5jYWxlbmRhckxhYmVsLmN1cnJlbnR9ICR7dGhpcy5oZWFkaW5nVmFsdWV9YCk7XG4gICAgaXNTZWxlY3Rpb25TdGFydChkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydFZhbHVlLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF0ZSwgdGhpcy5zdGFydFZhbHVlLmN1cnJlbnQpO1xuICAgIH1cbiAgICBpc1NlbGVjdGlvbkVuZChkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmRWYWx1ZS5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRhdGUsIHRoaXMuZW5kVmFsdWUuY3VycmVudCk7XG4gICAgfVxuICAgIGlzU2VsZWN0ZWQoZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5zdGFydFZhbHVlLmN1cnJlbnQgJiYgaXNTYW1lRGF5KHRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50LCBkYXRlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5lbmRWYWx1ZS5jdXJyZW50ICYmIGlzU2FtZURheSh0aGlzLmVuZFZhbHVlLmN1cnJlbnQsIGRhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCAmJiB0aGlzLmVuZFZhbHVlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JldHdlZW5JbmNsdXNpdmUoZGF0ZSwgdGhpcy5zdGFydFZhbHVlLmN1cnJlbnQsIHRoaXMuZW5kVmFsdWUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoaWdobGlnaHRlZFJhbmdlID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGFydFZhbHVlLmN1cnJlbnQgJiYgdGhpcy5lbmRWYWx1ZS5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghdGhpcy5zdGFydFZhbHVlLmN1cnJlbnQgfHwgIXRoaXMuZm9jdXNlZFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGlzU3RhcnRCZWZvcmVGb2N1c2VkID0gaXNCZWZvcmUodGhpcy5zdGFydFZhbHVlLmN1cnJlbnQsIHRoaXMuZm9jdXNlZFZhbHVlKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpc1N0YXJ0QmVmb3JlRm9jdXNlZCA/IHRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50IDogdGhpcy5mb2N1c2VkVmFsdWU7XG4gICAgICAgIGNvbnN0IGVuZCA9IGlzU3RhcnRCZWZvcmVGb2N1c2VkID8gdGhpcy5mb2N1c2VkVmFsdWUgOiB0aGlzLnN0YXJ0VmFsdWUuY3VycmVudDtcbiAgICAgICAgaWYgKGlzU2FtZURheShzdGFydC5hZGQoeyBkYXlzOiAxIH0pLCBlbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGFyZUFsbERheXNCZXR3ZWVuVmFsaWQoc3RhcnQsIGVuZCwgdGhpcy5pc0RhdGVVbmF2YWlsYWJsZSwgdGhpcy5pc0RhdGVEaXNhYmxlZCk7XG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgc2hpZnRGb2N1cyhub2RlLCBhZGQpIHtcbiAgICAgICAgcmV0dXJuIHNoaWZ0Q2FsZW5kYXJGb2N1cyh7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgYWRkLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBjYWxlbmRhck5vZGU6IHRoaXMucmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBpc1ByZXZCdXR0b25EaXNhYmxlZDogdGhpcy5pc1ByZXZCdXR0b25EaXNhYmxlZCxcbiAgICAgICAgICAgIGlzTmV4dEJ1dHRvbkRpc2FibGVkOiB0aGlzLmlzTmV4dEJ1dHRvbkRpc2FibGVkLFxuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgICAgIG51bWJlck9mTW9udGhzOiB0aGlzLm51bWJlck9mTW9udGhzLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjYW5ub3VuY2VFbXB0eSgpIHtcbiAgICAgICAgdGhpcy5hbm5vdW5jZXIuYW5ub3VuY2UoXCJTZWxlY3RlZCBkYXRlIGlzIG5vdyBlbXB0eS5cIiwgXCJwb2xpdGVcIik7XG4gICAgfVxuICAgICNhbm5vdW5jZVNlbGVjdGVkRGF0ZShkYXRlKSB7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VyLmFubm91bmNlKGBTZWxlY3RlZCBEYXRlOiAke3RoaXMuZm9ybWF0dGVyLnNlbGVjdGVkRGF0ZShkYXRlLCBmYWxzZSl9YCwgXCJwb2xpdGVcIik7XG4gICAgfVxuICAgICNhbm5vdW5jZVNlbGVjdGVkUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmFubm91bmNlci5hbm5vdW5jZShgU2VsZWN0ZWQgRGF0ZXM6ICR7dGhpcy5mb3JtYXR0ZXIuc2VsZWN0ZWREYXRlKHN0YXJ0LCBmYWxzZSl9IHRvICR7dGhpcy5mb3JtYXR0ZXIuc2VsZWN0ZWREYXRlKGVuZCwgZmFsc2UpfWAsIFwicG9saXRlXCIpO1xuICAgIH1cbiAgICBoYW5kbGVDZWxsQ2xpY2soZSwgZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RhdGVEaXNhYmxlZChkYXRlKSB8fCB0aGlzLmlzRGF0ZVVuYXZhaWxhYmxlKGRhdGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcmV2TGFzdFByZXNzZWREYXRlID0gdGhpcy5sYXN0UHJlc3NlZERhdGVWYWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0UHJlc3NlZERhdGVWYWx1ZSA9IGRhdGU7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCAmJiB0aGlzLmhpZ2hsaWdodGVkUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc1NhbWVEYXkodGhpcy5zdGFydFZhbHVlLmN1cnJlbnQsIGRhdGUpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucHJldmVudERlc2VsZWN0LmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5lbmRWYWx1ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2V0U3RhcnRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGRhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy4jYW5ub3VuY2VFbXB0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmVuZFZhbHVlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZMYXN0UHJlc3NlZERhdGUgJiYgaXNTYW1lRGF5KHByZXZMYXN0UHJlc3NlZERhdGUsIGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NldFN0YXJ0VmFsdWUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Fubm91bmNlU2VsZWN0ZWREYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGFydFZhbHVlLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIHRoaXMuZW5kVmFsdWUuY3VycmVudCAmJlxuICAgICAgICAgICAgaXNTYW1lRGF5KHRoaXMuZW5kVmFsdWUuY3VycmVudCwgZGF0ZSkgJiZcbiAgICAgICAgICAgICF0aGlzLnByZXZlbnREZXNlbGVjdC5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLiNzZXRTdGFydFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLiNzZXRFbmRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5jdXJyZW50ID0gZGF0ZTtcbiAgICAgICAgICAgIHRoaXMuI2Fubm91bmNlRW1wdHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLiNhbm5vdW5jZVNlbGVjdGVkRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuI3NldFN0YXJ0VmFsdWUoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuZW5kVmFsdWUuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy4jYW5ub3VuY2VTZWxlY3RlZFJhbmdlKHRoaXMuc3RhcnRWYWx1ZS5jdXJyZW50LCBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuI3NldEVuZFZhbHVlKGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5kVmFsdWUuY3VycmVudCAmJiB0aGlzLnN0YXJ0VmFsdWUuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy4jc2V0RW5kVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRoaXMuI2Fubm91bmNlU2VsZWN0ZWREYXRlKGRhdGUpO1xuICAgICAgICAgICAgdGhpcy4jc2V0U3RhcnRWYWx1ZShkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbmtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGVuZGFyS2V5ZG93bih7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGhhbmRsZUNlbGxDbGljazogdGhpcy5oYW5kbGVDZWxsQ2xpY2ssXG4gICAgICAgICAgICBwbGFjZWhvbGRlclZhbHVlOiB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQsXG4gICAgICAgICAgICBzaGlmdEZvY3VzOiB0aGlzLnNoaWZ0Rm9jdXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIG5leHQgcGFnZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAgICovXG4gICAgbmV4dFBhZ2UoKSB7XG4gICAgICAgIGhhbmRsZUNhbGVuZGFyTmV4dFBhZ2Uoe1xuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLmN1cnJlbnQsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRoczogdGhpcy5udW1iZXJPZk1vbnRocy5jdXJyZW50LFxuICAgICAgICAgICAgcGFnZWROYXZpZ2F0aW9uOiB0aGlzLnBhZ2VkTmF2aWdhdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgc2V0TW9udGhzOiB0aGlzLnNldE1vbnRocyxcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyOiAoZGF0ZSkgPT4gKHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGRhdGUpLFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB0aGlzLndlZWtTdGFydHNPbi5jdXJyZW50LFxuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyB0byB0aGUgcHJldmlvdXMgcGFnZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAgICovXG4gICAgcHJldlBhZ2UoKSB7XG4gICAgICAgIGhhbmRsZUNhbGVuZGFyUHJldlBhZ2Uoe1xuICAgICAgICAgICAgZml4ZWRXZWVrczogdGhpcy5maXhlZFdlZWtzLmN1cnJlbnQsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLmN1cnJlbnQsXG4gICAgICAgICAgICBudW1iZXJPZk1vbnRoczogdGhpcy5udW1iZXJPZk1vbnRocy5jdXJyZW50LFxuICAgICAgICAgICAgcGFnZWROYXZpZ2F0aW9uOiB0aGlzLnBhZ2VkTmF2aWdhdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgc2V0TW9udGhzOiB0aGlzLnNldE1vbnRocyxcbiAgICAgICAgICAgIHNldFBsYWNlaG9sZGVyOiAoZGF0ZSkgPT4gKHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IGRhdGUpLFxuICAgICAgICAgICAgd2Vla1N0YXJ0c09uOiB0aGlzLndlZWtTdGFydHNPbi5jdXJyZW50LFxuICAgICAgICAgICAgbW9udGhzOiB0aGlzLm1vbnRocyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHRZZWFyKCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQuYWRkKHsgeWVhcnM6IDEgfSk7XG4gICAgfVxuICAgIHByZXZZZWFyKCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQuc3VidHJhY3QoeyB5ZWFyczogMSB9KTtcbiAgICB9XG4gICAgc2V0WWVhcih5ZWFyKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIuY3VycmVudCA9IHRoaXMucGxhY2Vob2xkZXIuY3VycmVudC5zZXQoeyB5ZWFyIH0pO1xuICAgIH1cbiAgICBzZXRNb250aChtb250aCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQgPSB0aGlzLnBsYWNlaG9sZGVyLmN1cnJlbnQuc2V0KHsgbW9udGggfSk7XG4gICAgfVxuICAgIGdldEJpdHNBdHRyKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGBkYXRhLXJhbmdlLWNhbGVuZGFyLSR7cGFydH1gO1xuICAgIH1cbiAgICBzbmlwcGV0UHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBtb250aHM6IHRoaXMubW9udGhzLFxuICAgICAgICB3ZWVrZGF5czogdGhpcy53ZWVrZGF5cyxcbiAgICB9KSk7XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICAuLi5nZXRDYWxlbmRhckVsZW1lbnRQcm9wcyh7XG4gICAgICAgICAgICBmdWxsQ2FsZW5kYXJMYWJlbDogdGhpcy5mdWxsQ2FsZW5kYXJMYWJlbCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLmN1cnJlbnQsXG4gICAgICAgICAgICBpc0ludmFsaWQ6IHRoaXMuaXNJbnZhbGlkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQuY3VycmVudCxcbiAgICAgICAgICAgIHJlYWRvbmx5OiB0aGlzLnJlYWRvbmx5LmN1cnJlbnQsXG4gICAgICAgIH0pLFxuICAgICAgICBbdGhpcy5nZXRCaXRzQXR0cihcInJvb3RcIildOiBcIlwiLFxuICAgICAgICAvL1xuICAgICAgICBvbmtleWRvd246IHRoaXMub25rZXlkb3duLFxuICAgIH0pKTtcbn1cbmV4cG9ydCBjbGFzcyBSYW5nZUNhbGVuZGFyQ2VsbFN0YXRlIHtcbiAgICByb290O1xuICAgIGlkO1xuICAgIHJlZjtcbiAgICBkYXRlO1xuICAgIG1vbnRoO1xuICAgIGNlbGxEYXRlID0gJGRlcml2ZWQuYnkoKCkgPT4gdG9EYXRlKHRoaXMuZGF0ZS5jdXJyZW50KSk7XG4gICAgaXNEaXNhYmxlZCA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMucm9vdC5pc0RhdGVEaXNhYmxlZCh0aGlzLmRhdGUuY3VycmVudCkpO1xuICAgIGlzVW5hdmFpbGFibGUgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLnJvb3QuaXNEYXRlVW5hdmFpbGFibGVQcm9wLmN1cnJlbnQodGhpcy5kYXRlLmN1cnJlbnQpKTtcbiAgICBpc0RhdGVUb2RheSA9ICRkZXJpdmVkLmJ5KCgpID0+IGlzVG9kYXkodGhpcy5kYXRlLmN1cnJlbnQsIGdldExvY2FsVGltZVpvbmUoKSkpO1xuICAgIGlzT3V0c2lkZU1vbnRoID0gJGRlcml2ZWQuYnkoKCkgPT4gIWlzU2FtZU1vbnRoKHRoaXMuZGF0ZS5jdXJyZW50LCB0aGlzLm1vbnRoLmN1cnJlbnQpKTtcbiAgICBpc091dHNpZGVWaXNpYmxlTW9udGhzID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmlzT3V0c2lkZVZpc2libGVNb250aHModGhpcy5kYXRlLmN1cnJlbnQpKTtcbiAgICBpc0ZvY3VzZWREYXRlID0gJGRlcml2ZWQuYnkoKCkgPT4gaXNTYW1lRGF5KHRoaXMuZGF0ZS5jdXJyZW50LCB0aGlzLnJvb3QucGxhY2Vob2xkZXIuY3VycmVudCkpO1xuICAgIGlzU2VsZWN0ZWREYXRlID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmlzU2VsZWN0ZWQodGhpcy5kYXRlLmN1cnJlbnQpKTtcbiAgICBpc1NlbGVjdGlvblN0YXJ0ID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmlzU2VsZWN0aW9uU3RhcnQodGhpcy5kYXRlLmN1cnJlbnQpKTtcbiAgICBpc1NlbGVjdGlvbkVuZCA9ICRkZXJpdmVkLmJ5KCgpID0+IHRoaXMucm9vdC5pc1NlbGVjdGlvbkVuZCh0aGlzLmRhdGUuY3VycmVudCkpO1xuICAgIGlzSGlnaGxpZ2h0ZWQgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLnJvb3QuaGlnaGxpZ2h0ZWRSYW5nZVxuICAgICAgICA/IGlzQmV0d2VlbkluY2x1c2l2ZSh0aGlzLmRhdGUuY3VycmVudCwgdGhpcy5yb290LmhpZ2hsaWdodGVkUmFuZ2Uuc3RhcnQsIHRoaXMucm9vdC5oaWdobGlnaHRlZFJhbmdlLmVuZClcbiAgICAgICAgOiBmYWxzZSk7XG4gICAgbGFiZWxUZXh0ID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5yb290LmZvcm1hdHRlci5jdXN0b20odGhpcy5jZWxsRGF0ZSwge1xuICAgICAgICB3ZWVrZGF5OiBcImxvbmdcIixcbiAgICAgICAgbW9udGg6IFwibG9uZ1wiLFxuICAgICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICB9KSk7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLnJlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgdGhpcy5kYXRlID0gcHJvcHMuZGF0ZTtcbiAgICAgICAgdGhpcy5tb250aCA9IHByb3BzLm1vbnRoO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNuaXBwZXRQcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQsXG4gICAgICAgIHVuYXZhaWxhYmxlOiB0aGlzLmlzVW5hdmFpbGFibGUsXG4gICAgICAgIHNlbGVjdGVkOiB0aGlzLmlzU2VsZWN0ZWREYXRlLFxuICAgIH0pKTtcbiAgICBhcmlhRGlzYWJsZWQgPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0Rpc2FibGVkIHx8XG4gICAgICAgICAgICAodGhpcy5pc091dHNpZGVNb250aCAmJiB0aGlzLnJvb3QuZGlzYWJsZURheXNPdXRzaWRlTW9udGguY3VycmVudCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNVbmF2YWlsYWJsZSk7XG4gICAgfSk7XG4gICAgc2hhcmVkRGF0YUF0dHJzID0gJGRlcml2ZWQuYnkoKCkgPT4gKHtcbiAgICAgICAgXCJkYXRhLXVuYXZhaWxhYmxlXCI6IGdldERhdGFVbmF2YWlsYWJsZSh0aGlzLmlzVW5hdmFpbGFibGUpLFxuICAgICAgICBcImRhdGEtdG9kYXlcIjogdGhpcy5pc0RhdGVUb2RheSA/IFwiXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiZGF0YS1vdXRzaWRlLW1vbnRoXCI6IHRoaXMuaXNPdXRzaWRlTW9udGggPyBcIlwiIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtb3V0c2lkZS12aXNpYmxlLW1vbnRoc1wiOiB0aGlzLmlzT3V0c2lkZVZpc2libGVNb250aHMgPyBcIlwiIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtZm9jdXNlZFwiOiB0aGlzLmlzRm9jdXNlZERhdGUgPyBcIlwiIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtc2VsZWN0aW9uLXN0YXJ0XCI6IHRoaXMuaXNTZWxlY3Rpb25TdGFydCA/IFwiXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiZGF0YS1zZWxlY3Rpb24tZW5kXCI6IHRoaXMuaXNTZWxlY3Rpb25FbmQgPyBcIlwiIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtaGlnaGxpZ2h0ZWRcIjogdGhpcy5pc0hpZ2hsaWdodGVkID8gXCJcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJkYXRhLXNlbGVjdGVkXCI6IGdldERhdGFTZWxlY3RlZCh0aGlzLmlzU2VsZWN0ZWREYXRlKSxcbiAgICAgICAgXCJkYXRhLXZhbHVlXCI6IHRoaXMuZGF0ZS5jdXJyZW50LnRvU3RyaW5nKCksXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBnZXREYXRhRGlzYWJsZWQodGhpcy5pc0Rpc2FibGVkIHx8XG4gICAgICAgICAgICAodGhpcy5pc091dHNpZGVNb250aCAmJiB0aGlzLnJvb3QuZGlzYWJsZURheXNPdXRzaWRlTW9udGguY3VycmVudCkpLFxuICAgIH0pKTtcbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLmlkLmN1cnJlbnQsXG4gICAgICAgIHJvbGU6IFwiZ3JpZGNlbGxcIixcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IGdldEFyaWFTZWxlY3RlZCh0aGlzLmlzU2VsZWN0ZWREYXRlKSxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGdldEFyaWFEaXNhYmxlZCh0aGlzLmFyaWFEaXNhYmxlZCksXG4gICAgICAgIC4uLnRoaXMuc2hhcmVkRGF0YUF0dHJzLFxuICAgICAgICBbdGhpcy5yb290LmdldEJpdHNBdHRyKFwiY2VsbFwiKV06IFwiXCIsXG4gICAgfSkpO1xufVxuY2xhc3MgUmFuZ2VDYWxlbmRhckRheVN0YXRlIHtcbiAgICBjZWxsO1xuICAgIGlkO1xuICAgIHJlZjtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY2VsbCkge1xuICAgICAgICB0aGlzLmNlbGwgPSBjZWxsO1xuICAgICAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICB1c2VSZWZCeUlkKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jbGljayA9IHRoaXMub25jbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9ubW91c2VlbnRlciA9IHRoaXMub25tb3VzZWVudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25mb2N1c2luID0gdGhpcy5vbmZvY3VzaW4uYmluZCh0aGlzKTtcbiAgICB9XG4gICAgI3RhYmluZGV4ID0gJGRlcml2ZWQuYnkoKCkgPT4gdGhpcy5jZWxsLmlzRm9jdXNlZERhdGVcbiAgICAgICAgPyAwXG4gICAgICAgIDogKHRoaXMuY2VsbC5pc091dHNpZGVNb250aCAmJiB0aGlzLmNlbGwucm9vdC5kaXNhYmxlRGF5c091dHNpZGVNb250aC5jdXJyZW50KSB8fFxuICAgICAgICAgICAgdGhpcy5jZWxsLmlzRGlzYWJsZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IC0xKTtcbiAgICBvbmNsaWNrKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbC5pc0Rpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNlbGwucm9vdC5oYW5kbGVDZWxsQ2xpY2soZSwgdGhpcy5jZWxsLmRhdGUuY3VycmVudCk7XG4gICAgfVxuICAgIG9ubW91c2VlbnRlcihfKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGwuaXNEaXNhYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jZWxsLnJvb3QuZm9jdXNlZFZhbHVlID0gdGhpcy5jZWxsLmRhdGUuY3VycmVudDtcbiAgICB9XG4gICAgb25mb2N1c2luKF8pIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbC5pc0Rpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNlbGwucm9vdC5mb2N1c2VkVmFsdWUgPSB0aGlzLmNlbGwuZGF0ZS5jdXJyZW50O1xuICAgIH1cbiAgICBzbmlwcGV0UHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBkaXNhYmxlZDogdGhpcy5jZWxsLmlzRGlzYWJsZWQsXG4gICAgICAgIHVuYXZhaWxhYmxlOiB0aGlzLmNlbGwuaXNVbmF2YWlsYWJsZSxcbiAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuY2VsbC5pc1NlbGVjdGVkRGF0ZSxcbiAgICAgICAgZGF5OiBgJHt0aGlzLmNlbGwuZGF0ZS5jdXJyZW50LmRheX1gLFxuICAgIH0pKTtcbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIGlkOiB0aGlzLmlkLmN1cnJlbnQsXG4gICAgICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLmNlbGwubGFiZWxUZXh0LFxuICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogZ2V0QXJpYURpc2FibGVkKHRoaXMuY2VsbC5hcmlhRGlzYWJsZWQpLFxuICAgICAgICAuLi50aGlzLmNlbGwuc2hhcmVkRGF0YUF0dHJzLFxuICAgICAgICB0YWJpbmRleDogdGhpcy4jdGFiaW5kZXgsXG4gICAgICAgIFt0aGlzLmNlbGwucm9vdC5nZXRCaXRzQXR0cihcImRheVwiKV06IFwiXCIsXG4gICAgICAgIC8vIFNoYXJlZCBsb2dpYyBmb3IgcmFuZ2UgY2FsZW5kYXIgYW5kIGNhbGVuZGFyXG4gICAgICAgIFwiZGF0YS1iaXRzLWRheVwiOiBcIlwiLFxuICAgICAgICAvL1xuICAgICAgICBvbmNsaWNrOiB0aGlzLm9uY2xpY2ssXG4gICAgICAgIG9ubW91c2VlbnRlcjogdGhpcy5vbm1vdXNlZW50ZXIsXG4gICAgICAgIG9uZm9jdXNpbjogdGhpcy5vbmZvY3VzaW4sXG4gICAgfSkpO1xufVxuY29uc3QgW3NldFJhbmdlQ2FsZW5kYXJSb290Q29udGV4dCwgZ2V0UmFuZ2VDYWxlbmRhclJvb3RDb250ZXh0XSA9IGNyZWF0ZUNvbnRleHQoW1wiQ2FsZW5kYXIuUm9vdFwiLCBcIlJhbmdlQ2FsZW5kYXIuUm9vdFwiXSwgXCJDYWxlbmRhci5Sb290XCIsIGZhbHNlKTtcbmNvbnN0IFtzZXRSYW5nZUNhbGVuZGFyQ2VsbENvbnRleHQsIGdldFJhbmdlQ2FsZW5kYXJDZWxsQ29udGV4dF0gPSBjcmVhdGVDb250ZXh0KFwiUmFuZ2VDYWxlbmRhci5DZWxsXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmdlQ2FsZW5kYXJSb290KHByb3BzKSB7XG4gICAgcmV0dXJuIHNldFJhbmdlQ2FsZW5kYXJSb290Q29udGV4dChuZXcgUmFuZ2VDYWxlbmRhclJvb3RTdGF0ZShwcm9wcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmdlQ2FsZW5kYXJDZWxsKHByb3BzKSB7XG4gICAgcmV0dXJuIHNldFJhbmdlQ2FsZW5kYXJDZWxsQ29udGV4dChuZXcgUmFuZ2VDYWxlbmRhckNlbGxTdGF0ZShwcm9wcywgZ2V0UmFuZ2VDYWxlbmRhclJvb3RDb250ZXh0KCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VSYW5nZUNhbGVuZGFyRGF5KHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUNhbGVuZGFyRGF5U3RhdGUocHJvcHMsIGdldFJhbmdlQ2FsZW5kYXJDZWxsQ29udGV4dCgpKTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHR5cGUgeyBSYW5nZUNhbGVuZGFyQ2VsbFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZVJhbmdlQ2FsZW5kYXJDZWxsIH0gZnJvbSBcIi4uL3JhbmdlLWNhbGVuZGFyLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0ZGF0ZSxcblx0XHRtb250aCxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogUmFuZ2VDYWxlbmRhckNlbGxQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IGNlbGxTdGF0ZSA9IHVzZVJhbmdlQ2FsZW5kYXJDZWxsKHtcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0XHRkYXRlOiBib3gud2l0aCgoKSA9PiBkYXRlKSxcblx0XHRtb250aDogYm94LndpdGgoKCkgPT4gbW9udGgpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBjZWxsU3RhdGUucHJvcHMpKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcywgLi4uY2VsbFN0YXRlLnNuaXBwZXRQcm9wcyB9KX1cbns6ZWxzZX1cblx0PHRkIHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LihjZWxsU3RhdGUuc25pcHBldFByb3BzKX1cblx0PC90ZD5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgUmFuZ2VDYWxlbmRhckRheVByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZVJhbmdlQ2FsZW5kYXJEYXkgfSBmcm9tIFwiLi4vcmFuZ2UtY2FsZW5kYXIuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3VzZS1pZC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0aWQgPSB1c2VJZCgpLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogUmFuZ2VDYWxlbmRhckRheVByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgZGF5U3RhdGUgPSB1c2VSYW5nZUNhbGVuZGFyRGF5KHtcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgZGF5U3RhdGUucHJvcHMpKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcywgLi4uZGF5U3RhdGUuc25pcHBldFByb3BzIH0pfVxuezplbHNlfVxuXHQ8ZGl2IHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0eyNpZiBjaGlsZHJlbn1cblx0XHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oZGF5U3RhdGUuc25pcHBldFByb3BzKX1cblx0XHR7OmVsc2V9XG5cdFx0XHR7ZGF5U3RhdGUuY2VsbC5kYXRlLmN1cnJlbnQuZGF5fVxuXHRcdHsvaWZ9XG5cdDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHsgdXNlRGlhbG9nUm9vdCB9IGZyb20gXCIuLi9kaWFsb2cuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgRGlhbG9nUm9vdFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IG5vb3AgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvbm9vcC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0b3BlbiA9ICRiaW5kYWJsZShmYWxzZSksXG5cdFx0b25PcGVuQ2hhbmdlID0gbm9vcCxcblx0XHRjb250cm9sbGVkT3BlbiA9IGZhbHNlLFxuXHRcdGNoaWxkcmVuLFxuXHR9OiBEaWFsb2dSb290UHJvcHMgPSAkcHJvcHMoKTtcblxuXHR1c2VEaWFsb2dSb290KHtcblx0XHR2YXJpYW50OiBib3gud2l0aCgoKSA9PiBcImRpYWxvZ1wiKSxcblx0XHRvcGVuOiBib3gud2l0aChcblx0XHRcdCgpID0+IG9wZW4sXG5cdFx0XHQodikgPT4ge1xuXHRcdFx0XHRpZiAoY29udHJvbGxlZE9wZW4pIHtcblx0XHRcdFx0XHRvbk9wZW5DaGFuZ2Uodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3BlbiA9IHY7XG5cdFx0XHRcdFx0b25PcGVuQ2hhbmdlKHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KSxcblx0fSk7XG48L3NjcmlwdD5cblxue0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgeyB1c2VEaWFsb2dDbG9zZSB9IGZyb20gXCIuLi9kaWFsb2cuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgRGlhbG9nQ2xvc2VQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0ZGlzYWJsZWQgPSBmYWxzZSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nQ2xvc2VQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IGNsb3NlU3RhdGUgPSB1c2VEaWFsb2dDbG9zZSh7XG5cdFx0dmFyaWFudDogYm94LndpdGgoKCkgPT4gXCJjbG9zZVwiKSxcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0XHRkaXNhYmxlZDogYm94LndpdGgoKCkgPT4gQm9vbGVhbihkaXNhYmxlZCkpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCBjbG9zZVN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMgfSl9XG57OmVsc2V9XG5cdDxidXR0b24gey4uLm1lcmdlZFByb3BzfT5cblx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdDwvYnV0dG9uPlxuey9pZn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHsgdXNlRGlhbG9nQ29udGVudCB9IGZyb20gXCIuLi9kaWFsb2cuc3ZlbHRlLmpzXCI7XG5cdGltcG9ydCB0eXBlIHsgRGlhbG9nQ29udGVudFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCBEaXNtaXNzaWJsZUxheWVyIGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZGlzbWlzc2libGUtbGF5ZXIvZGlzbWlzc2libGUtbGF5ZXIuc3ZlbHRlXCI7XG5cdGltcG9ydCBFc2NhcGVMYXllciBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2VzY2FwZS1sYXllci9lc2NhcGUtbGF5ZXIuc3ZlbHRlXCI7XG5cdGltcG9ydCBGb2N1c1Njb3BlIGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZm9jdXMtc2NvcGUvZm9jdXMtc2NvcGUuc3ZlbHRlXCI7XG5cdGltcG9ydCBQcmVzZW5jZUxheWVyIGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcHJlc2VuY2UtbGF5ZXIvcHJlc2VuY2UtbGF5ZXIuc3ZlbHRlXCI7XG5cdGltcG9ydCBUZXh0U2VsZWN0aW9uTGF5ZXIgZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXh0LXNlbGVjdGlvbi1sYXllci90ZXh0LXNlbGVjdGlvbi1sYXllci5zdmVsdGVcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cdGltcG9ydCB7IG5vb3AgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvbm9vcC5qc1wiO1xuXHRpbXBvcnQgU2Nyb2xsTG9jayBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Njcm9sbC1sb2NrL3Njcm9sbC1sb2NrLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBzaG91bGRUcmFwRm9jdXMgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvc2hvdWxkLXRyYXAtZm9jdXMuanNcIjtcblxuXHRsZXQge1xuXHRcdGlkID0gdXNlSWQoKSxcblx0XHRjaGlsZHJlbixcblx0XHRjaGlsZCxcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Zm9yY2VNb3VudCA9IGZhbHNlLFxuXHRcdG9uQ2xvc2VBdXRvRm9jdXMgPSBub29wLFxuXHRcdG9uRXNjYXBlS2V5ZG93biA9IG5vb3AsXG5cdFx0b25JbnRlcmFjdE91dHNpZGUgPSBub29wLFxuXHRcdHRyYXBGb2N1cyA9IHRydWUsXG5cdFx0cHJldmVudFNjcm9sbCA9IHRydWUsXG5cdFx0cmVzdG9yZVNjcm9sbERlbGF5ID0gbnVsbCxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nQ29udGVudFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3QgY29udGVudFN0YXRlID0gdXNlRGlhbG9nQ29udGVudCh7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIGNvbnRlbnRTdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbjxQcmVzZW5jZUxheWVyIHsuLi5tZXJnZWRQcm9wc30ge2ZvcmNlTW91bnR9IHByZXNlbnQ9e2NvbnRlbnRTdGF0ZS5yb290Lm9wZW4uY3VycmVudCB8fCBmb3JjZU1vdW50fT5cblx0eyNzbmlwcGV0IHByZXNlbmNlKHsgcHJlc2VudCB9KX1cblx0XHQ8Rm9jdXNTY29wZVxuXHRcdFx0bG9vcFxuXHRcdFx0dHJhcEZvY3VzPXtzaG91bGRUcmFwRm9jdXMoe1xuXHRcdFx0XHRmb3JjZU1vdW50LFxuXHRcdFx0XHRwcmVzZW50OiBwcmVzZW50LmN1cnJlbnQsXG5cdFx0XHRcdHRyYXBGb2N1cyxcblx0XHRcdFx0b3BlbjogY29udGVudFN0YXRlLnJvb3Qub3Blbi5jdXJyZW50LFxuXHRcdFx0fSl9XG5cdFx0XHR7Li4ubWVyZ2VkUHJvcHN9XG5cdFx0XHRvbkNsb3NlQXV0b0ZvY3VzPXsoZSkgPT4ge1xuXHRcdFx0XHRvbkNsb3NlQXV0b0ZvY3VzKGUpO1xuXHRcdFx0XHRpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cdFx0XHRcdGNvbnRlbnRTdGF0ZS5yb290LnRyaWdnZXJOb2RlPy5mb2N1cygpO1xuXHRcdFx0fX1cblx0XHQ+XG5cdFx0XHR7I3NuaXBwZXQgZm9jdXNTY29wZSh7IHByb3BzOiBmb2N1c1Njb3BlUHJvcHMgfSl9XG5cdFx0XHRcdDxFc2NhcGVMYXllclxuXHRcdFx0XHRcdHsuLi5tZXJnZWRQcm9wc31cblx0XHRcdFx0XHRlbmFibGVkPXtwcmVzZW50LmN1cnJlbnR9XG5cdFx0XHRcdFx0b25Fc2NhcGVLZXlkb3duPXsoZSkgPT4ge1xuXHRcdFx0XHRcdFx0b25Fc2NhcGVLZXlkb3duKGUpO1xuXHRcdFx0XHRcdFx0aWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0Y29udGVudFN0YXRlLnJvb3QuaGFuZGxlQ2xvc2UoKTtcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PERpc21pc3NpYmxlTGF5ZXJcblx0XHRcdFx0XHRcdHsuLi5tZXJnZWRQcm9wc31cblx0XHRcdFx0XHRcdGVuYWJsZWQ9e3ByZXNlbnQuY3VycmVudH1cblx0XHRcdFx0XHRcdG9uSW50ZXJhY3RPdXRzaWRlPXsoZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRvbkludGVyYWN0T3V0c2lkZShlKTtcblx0XHRcdFx0XHRcdFx0aWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRjb250ZW50U3RhdGUucm9vdC5oYW5kbGVDbG9zZSgpO1xuXHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8VGV4dFNlbGVjdGlvbkxheWVyIHsuLi5tZXJnZWRQcm9wc30gZW5hYmxlZD17cHJlc2VudC5jdXJyZW50fT5cblx0XHRcdFx0XHRcdFx0eyNpZiBjaGlsZH1cblx0XHRcdFx0XHRcdFx0XHR7I2lmIGNvbnRlbnRTdGF0ZS5yb290Lm9wZW4uY3VycmVudH1cblx0XHRcdFx0XHRcdFx0XHRcdDxTY3JvbGxMb2NrIHtwcmV2ZW50U2Nyb2xsfSB7cmVzdG9yZVNjcm9sbERlbGF5fSAvPlxuXHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0e0ByZW5kZXIgY2hpbGQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcHM6IG1lcmdlUHJvcHMobWVyZ2VkUHJvcHMsIGZvY3VzU2NvcGVQcm9wcyksXG5cdFx0XHRcdFx0XHRcdFx0XHQuLi5jb250ZW50U3RhdGUuc25pcHBldFByb3BzLFxuXHRcdFx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHRcdFx0PFNjcm9sbExvY2sge3ByZXZlbnRTY3JvbGx9IC8+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiB7Li4ubWVyZ2VQcm9wcyhtZXJnZWRQcm9wcywgZm9jdXNTY29wZVByb3BzKX0+XG5cdFx0XHRcdFx0XHRcdFx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHQ8L1RleHRTZWxlY3Rpb25MYXllcj5cblx0XHRcdFx0XHQ8L0Rpc21pc3NpYmxlTGF5ZXI+XG5cdFx0XHRcdDwvRXNjYXBlTGF5ZXI+XG5cdFx0XHR7L3NuaXBwZXR9XG5cdFx0PC9Gb2N1c1Njb3BlPlxuXHR7L3NuaXBwZXR9XG48L1ByZXNlbmNlTGF5ZXI+XG4iLCJpbXBvcnQgeyB1c2VSZWZCeUlkIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuY29uc3QgUk9PVF9BVFRSID0gXCJkYXRhLWxhYmVsLXJvb3RcIjtcbmNsYXNzIExhYmVsUm9vdFN0YXRlIHtcbiAgICAjaWQ7XG4gICAgI3JlZjtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHRoaXMub25tb3VzZWRvd24gPSB0aGlzLm9ubW91c2Vkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbm1vdXNlZG93bihlKSB7XG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIHByb3BzID0gJGRlcml2ZWQoe1xuICAgICAgICBbUk9PVF9BVFRSXTogXCJcIixcbiAgICAgICAgb25tb3VzZWRvd246IHRoaXMub25tb3VzZWRvd24sXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0TGFiZWxSb290U3RhdGUocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IExhYmVsUm9vdFN0YXRlKHByb3BzKTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHR5cGUgeyBMYWJlbFJvb3RQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyBzZXRMYWJlbFJvb3RTdGF0ZSB9IGZyb20gXCIuLi9sYWJlbC5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cblx0bGV0IHtcblx0XHRjaGlsZHJlbixcblx0XHRjaGlsZCxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGZvcjogZm9yUHJvcCxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogTGFiZWxSb290UHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCByb290U3RhdGUgPSBzZXRMYWJlbFJvb3RTdGF0ZSh7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCByb290U3RhdGUucHJvcHMsIHsgZm9yOiBmb3JQcm9wIH0pKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcyB9KX1cbns6ZWxzZX1cblx0PGxhYmVsIHsuLi5tZXJnZWRQcm9wc30gZm9yPXtmb3JQcm9wfT5cblx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdDwvbGFiZWw+XG57L2lmfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94IH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IFBvcG92ZXJSb290UHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlUG9wb3ZlclJvb3QgfSBmcm9tIFwiLi4vcG9wb3Zlci5zdmVsdGUuanNcIjtcblx0aW1wb3J0IEZsb2F0aW5nTGF5ZXIgZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9mbG9hdGluZy1sYXllci9jb21wb25lbnRzL2Zsb2F0aW5nLWxheWVyLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBub29wIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL25vb3AuanNcIjtcblxuXHRsZXQge1xuXHRcdG9wZW4gPSAkYmluZGFibGUoZmFsc2UpLFxuXHRcdG9uT3BlbkNoYW5nZSA9IG5vb3AsXG5cdFx0Y29udHJvbGxlZE9wZW4gPSBmYWxzZSxcblx0XHRjaGlsZHJlbixcblx0fTogUG9wb3ZlclJvb3RQcm9wcyA9ICRwcm9wcygpO1xuXG5cdHVzZVBvcG92ZXJSb290KHtcblx0XHRvcGVuOiBib3gud2l0aChcblx0XHRcdCgpID0+IG9wZW4sXG5cdFx0XHQodikgPT4ge1xuXHRcdFx0XHRpZiAoY29udHJvbGxlZE9wZW4pIHtcblx0XHRcdFx0XHRvbk9wZW5DaGFuZ2Uodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3BlbiA9IHY7XG5cdFx0XHRcdFx0b25PcGVuQ2hhbmdlKHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KSxcblx0fSk7XG48L3NjcmlwdD5cblxuPEZsb2F0aW5nTGF5ZXI+XG5cdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvRmxvYXRpbmdMYXllcj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGJveCwgbWVyZ2VQcm9wcyB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcblx0aW1wb3J0IHR5cGUgeyBEYXRlVmFsdWUgfSBmcm9tIFwiQGludGVybmF0aW9uYWxpemVkL2RhdGVcIjtcblx0aW1wb3J0IHR5cGUgeyBSYW5nZUNhbGVuZGFyUm9vdFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IHVzZVJhbmdlQ2FsZW5kYXJSb290IH0gZnJvbSBcIi4uL3JhbmdlLWNhbGVuZGFyLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyBub29wIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL25vb3AuanNcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cdGltcG9ydCB7IGdldERlZmF1bHREYXRlIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2RhdGUtdGltZS91dGlscy5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2hpbGQsXG5cdFx0aWQgPSB1c2VJZCgpLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHR2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuXHRcdG9uVmFsdWVDaGFuZ2UgPSBub29wLFxuXHRcdHBsYWNlaG9sZGVyID0gJGJpbmRhYmxlKCksXG5cdFx0b25QbGFjZWhvbGRlckNoYW5nZSA9IG5vb3AsXG5cdFx0d2Vla2RheUZvcm1hdCA9IFwibmFycm93XCIsXG5cdFx0d2Vla1N0YXJ0c09uID0gMCxcblx0XHRwYWdlZE5hdmlnYXRpb24gPSBmYWxzZSxcblx0XHRpc0RhdGVEaXNhYmxlZCA9ICgpID0+IGZhbHNlLFxuXHRcdGlzRGF0ZVVuYXZhaWxhYmxlID0gKCkgPT4gZmFsc2UsXG5cdFx0Zml4ZWRXZWVrcyA9IGZhbHNlLFxuXHRcdG51bWJlck9mTW9udGhzID0gMSxcblx0XHRsb2NhbGUgPSBcImVuXCIsXG5cdFx0Y2FsZW5kYXJMYWJlbCA9IFwiRXZlbnRcIixcblx0XHRkaXNhYmxlZCA9IGZhbHNlLFxuXHRcdHJlYWRvbmx5ID0gZmFsc2UsXG5cdFx0bWluVmFsdWUgPSB1bmRlZmluZWQsXG5cdFx0bWF4VmFsdWUgPSB1bmRlZmluZWQsXG5cdFx0cHJldmVudERlc2VsZWN0ID0gZmFsc2UsXG5cdFx0ZGlzYWJsZURheXNPdXRzaWRlTW9udGggPSB0cnVlLFxuXHRcdG9uU3RhcnRWYWx1ZUNoYW5nZSA9IG5vb3AsXG5cdFx0b25FbmRWYWx1ZUNoYW5nZSA9IG5vb3AsXG5cdFx0Y29udHJvbGxlZFBsYWNlaG9sZGVyID0gZmFsc2UsXG5cdFx0Y29udHJvbGxlZFZhbHVlID0gZmFsc2UsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJSb290UHJvcHMgPSAkcHJvcHMoKTtcblxuXHRsZXQgc3RhcnRWYWx1ZSA9ICRzdGF0ZTxEYXRlVmFsdWUgfCB1bmRlZmluZWQ+KHZhbHVlPy5zdGFydCk7XG5cdGxldCBlbmRWYWx1ZSA9ICRzdGF0ZTxEYXRlVmFsdWUgfCB1bmRlZmluZWQ+KHZhbHVlPy5lbmQpO1xuXG5cdGlmIChwbGFjZWhvbGRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgZGVmYXVsdFBsYWNlaG9sZGVyID0gZ2V0RGVmYXVsdERhdGUoe1xuXHRcdFx0ZGVmYXVsdFBsYWNlaG9sZGVyOiB1bmRlZmluZWQsXG5cdFx0XHRkZWZhdWx0VmFsdWU6IHZhbHVlPy5zdGFydCxcblx0XHR9KTtcblxuXHRcdGlmIChjb250cm9sbGVkUGxhY2Vob2xkZXIpIHtcblx0XHRcdG9uUGxhY2Vob2xkZXJDaGFuZ2UoZGVmYXVsdFBsYWNlaG9sZGVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGxhY2Vob2xkZXIgPSBkZWZhdWx0UGxhY2Vob2xkZXI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBkZWZhdWx0VmFsdWUgPSB7IHN0YXJ0OiB1bmRlZmluZWQsIGVuZDogdW5kZWZpbmVkIH07XG5cdFx0aWYgKGNvbnRyb2xsZWRWYWx1ZSkge1xuXHRcdFx0b25WYWx1ZUNoYW5nZShkZWZhdWx0VmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCByb290U3RhdGUgPSB1c2VSYW5nZUNhbGVuZGFyUm9vdCh7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdFx0dmFsdWU6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gdmFsdWUhLFxuXHRcdFx0KHYpID0+IHtcblx0XHRcdFx0aWYgKGNvbnRyb2xsZWRWYWx1ZSkge1xuXHRcdFx0XHRcdG9uVmFsdWVDaGFuZ2Uodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2O1xuXHRcdFx0XHRcdG9uVmFsdWVDaGFuZ2Uodik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpLFxuXHRcdHBsYWNlaG9sZGVyOiBib3gud2l0aChcblx0XHRcdCgpID0+IHBsYWNlaG9sZGVyISxcblx0XHRcdCh2KSA9PiB7XG5cdFx0XHRcdGlmIChjb250cm9sbGVkUGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0XHRvblBsYWNlaG9sZGVyQ2hhbmdlKHYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBsYWNlaG9sZGVyID0gdjtcblx0XHRcdFx0XHRvblBsYWNlaG9sZGVyQ2hhbmdlKHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KSxcblx0XHRkaXNhYmxlZDogYm94LndpdGgoKCkgPT4gZGlzYWJsZWQpLFxuXHRcdHJlYWRvbmx5OiBib3gud2l0aCgoKSA9PiByZWFkb25seSksXG5cdFx0cHJldmVudERlc2VsZWN0OiBib3gud2l0aCgoKSA9PiBwcmV2ZW50RGVzZWxlY3QpLFxuXHRcdG1pblZhbHVlOiBib3gud2l0aCgoKSA9PiBtaW5WYWx1ZSksXG5cdFx0bWF4VmFsdWU6IGJveC53aXRoKCgpID0+IG1heFZhbHVlKSxcblx0XHRpc0RhdGVVbmF2YWlsYWJsZTogYm94LndpdGgoKCkgPT4gaXNEYXRlVW5hdmFpbGFibGUpLFxuXHRcdGlzRGF0ZURpc2FibGVkOiBib3gud2l0aCgoKSA9PiBpc0RhdGVEaXNhYmxlZCksXG5cdFx0cGFnZWROYXZpZ2F0aW9uOiBib3gud2l0aCgoKSA9PiBwYWdlZE5hdmlnYXRpb24pLFxuXHRcdHdlZWtTdGFydHNPbjogYm94LndpdGgoKCkgPT4gd2Vla1N0YXJ0c09uKSxcblx0XHR3ZWVrZGF5Rm9ybWF0OiBib3gud2l0aCgoKSA9PiB3ZWVrZGF5Rm9ybWF0KSxcblx0XHRudW1iZXJPZk1vbnRoczogYm94LndpdGgoKCkgPT4gbnVtYmVyT2ZNb250aHMpLFxuXHRcdGxvY2FsZTogYm94LndpdGgoKCkgPT4gbG9jYWxlKSxcblx0XHRjYWxlbmRhckxhYmVsOiBib3gud2l0aCgoKSA9PiBjYWxlbmRhckxhYmVsKSxcblx0XHRmaXhlZFdlZWtzOiBib3gud2l0aCgoKSA9PiBmaXhlZFdlZWtzKSxcblx0XHRkaXNhYmxlRGF5c091dHNpZGVNb250aDogYm94LndpdGgoKCkgPT4gZGlzYWJsZURheXNPdXRzaWRlTW9udGgpLFxuXHRcdHN0YXJ0VmFsdWU6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gc3RhcnRWYWx1ZSxcblx0XHRcdCh2KSA9PiB7XG5cdFx0XHRcdHN0YXJ0VmFsdWUgPSB2O1xuXHRcdFx0XHRvblN0YXJ0VmFsdWVDaGFuZ2Uodik7XG5cdFx0XHR9XG5cdFx0KSxcblx0XHRlbmRWYWx1ZTogYm94LndpdGgoXG5cdFx0XHQoKSA9PiBlbmRWYWx1ZSxcblx0XHRcdCh2KSA9PiB7XG5cdFx0XHRcdGVuZFZhbHVlID0gdjtcblx0XHRcdFx0b25FbmRWYWx1ZUNoYW5nZSh2KTtcblx0XHRcdH1cblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCByb290U3RhdGUucHJvcHMpKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcywgLi4ucm9vdFN0YXRlLnNuaXBwZXRQcm9wcyB9KX1cbns6ZWxzZX1cblx0PGRpdiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4ocm9vdFN0YXRlLnNuaXBwZXRQcm9wcyl9XG5cdDwvZGl2Plxuey9pZn1cbiIsImltcG9ydCB7IHNyT25seVN0eWxlcywgc3R5bGVUb1N0cmluZywgdXNlUmVmQnlJZCB9IGZyb20gXCJzdmVsdGUtdG9vbGJlbHRcIjtcbmltcG9ydCB7IGdldEFyaWFDaGVja2VkLCBnZXRBcmlhSGlkZGVuLCBnZXRBcmlhUmVxdWlyZWQsIGdldERhdGFDaGVja2VkLCBnZXREYXRhRGlzYWJsZWQsIGdldERhdGFSZXF1aXJlZCwgZ2V0RGlzYWJsZWQsIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2F0dHJzLmpzXCI7XG5pbXBvcnQgeyBrYmQgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwva2JkLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2NyZWF0ZS1jb250ZXh0LmpzXCI7XG5jb25zdCBST09UX0FUVFIgPSBcImRhdGEtc3dpdGNoLXJvb3RcIjtcbmNvbnN0IFRIVU1CX0FUVFIgPSBcImRhdGEtc3dpdGNoLXRodW1iXCI7XG5jbGFzcyBTd2l0Y2hSb290U3RhdGUge1xuICAgICNpZDtcbiAgICAjcmVmO1xuICAgIGNoZWNrZWQ7XG4gICAgZGlzYWJsZWQ7XG4gICAgcmVxdWlyZWQ7XG4gICAgbmFtZTtcbiAgICB2YWx1ZTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSBwcm9wcy5yZXF1aXJlZDtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9ua2V5ZG93biA9IHRoaXMub25rZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25jbGljayA9IHRoaXMub25jbGljay5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAjdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQuY3VycmVudCA9ICF0aGlzLmNoZWNrZWQuY3VycmVudDtcbiAgICB9XG4gICAgb25rZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKCEoZS5rZXkgPT09IGtiZC5FTlRFUiB8fCBlLmtleSA9PT0ga2JkLlNQQUNFKSB8fCB0aGlzLmRpc2FibGVkLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICAgIG9uY2xpY2soXykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gICAgc2hhcmVkUHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZ2V0RGF0YURpc2FibGVkKHRoaXMuZGlzYWJsZWQuY3VycmVudCksXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBnZXREYXRhQ2hlY2tlZCh0aGlzLmNoZWNrZWQuY3VycmVudCksXG4gICAgICAgIFwiZGF0YS1yZXF1aXJlZFwiOiBnZXREYXRhUmVxdWlyZWQodGhpcy5yZXF1aXJlZC5jdXJyZW50KSxcbiAgICB9KSk7XG4gICAgcHJvcHMgPSAkZGVyaXZlZC5ieSgoKSA9PiAoe1xuICAgICAgICAuLi50aGlzLnNoYXJlZFByb3BzLFxuICAgICAgICBpZDogdGhpcy4jaWQuY3VycmVudCxcbiAgICAgICAgcm9sZTogXCJzd2l0Y2hcIixcbiAgICAgICAgZGlzYWJsZWQ6IGdldERpc2FibGVkKHRoaXMuZGlzYWJsZWQuY3VycmVudCksXG4gICAgICAgIFwiYXJpYS1jaGVja2VkXCI6IGdldEFyaWFDaGVja2VkKHRoaXMuY2hlY2tlZC5jdXJyZW50LCBmYWxzZSksXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBnZXRBcmlhUmVxdWlyZWQodGhpcy5yZXF1aXJlZC5jdXJyZW50KSxcbiAgICAgICAgW1JPT1RfQVRUUl06IFwiXCIsXG4gICAgICAgIC8vXG4gICAgICAgIG9uY2xpY2s6IHRoaXMub25jbGljayxcbiAgICAgICAgb25rZXlkb3duOiB0aGlzLm9ua2V5ZG93bixcbiAgICB9KSk7XG59XG5jbGFzcyBTd2l0Y2hJbnB1dFN0YXRlIHtcbiAgICAjcm9vdDtcbiAgICBzaG91bGRSZW5kZXIgPSAkZGVyaXZlZC5ieSgoKSA9PiB0aGlzLiNyb290Lm5hbWUuY3VycmVudCAhPT0gdW5kZWZpbmVkKTtcbiAgICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgICAgIHRoaXMuI3Jvb3QgPSByb290O1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgbmFtZTogdGhpcy4jcm9vdC5uYW1lLmN1cnJlbnQsXG4gICAgICAgIHZhbHVlOiB0aGlzLiNyb290LnZhbHVlLmN1cnJlbnQsXG4gICAgICAgIGNoZWNrZWQ6IHRoaXMuI3Jvb3QuY2hlY2tlZC5jdXJyZW50LFxuICAgICAgICBkaXNhYmxlZDogdGhpcy4jcm9vdC5kaXNhYmxlZC5jdXJyZW50LFxuICAgICAgICByZXF1aXJlZDogdGhpcy4jcm9vdC5yZXF1aXJlZC5jdXJyZW50LFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IGdldEFyaWFIaWRkZW4odHJ1ZSksXG4gICAgICAgIHN0eWxlOiBzdHlsZVRvU3RyaW5nKHNyT25seVN0eWxlcyksXG4gICAgfSkpO1xufVxuY2xhc3MgU3dpdGNoVGh1bWJTdGF0ZSB7XG4gICAgI2lkO1xuICAgICNyZWY7XG4gICAgcm9vdDtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgcm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLiNpZCA9IHByb3BzLmlkO1xuICAgICAgICB0aGlzLiNyZWYgPSBwcm9wcy5yZWY7XG4gICAgICAgIHVzZVJlZkJ5SWQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgcmVmOiB0aGlzLiNyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcyA9ICRkZXJpdmVkLmJ5KCgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMucm9vdC5zaGFyZWRQcm9wcyxcbiAgICAgICAgaWQ6IHRoaXMuI2lkLmN1cnJlbnQsXG4gICAgICAgIFtUSFVNQl9BVFRSXTogXCJcIixcbiAgICB9KSk7XG59XG4vL1xuLy8gQ09OVEVYVCBNRVRIT0RTXG4vL1xuY29uc3QgW3NldFN3aXRjaFJvb3RDb250ZXh0LCBnZXRTd2l0Y2hSb290Q29udGV4dF0gPSBjcmVhdGVDb250ZXh0KFwiU3dpdGNoLlJvb3RcIik7XG5leHBvcnQgZnVuY3Rpb24gdXNlU3dpdGNoUm9vdChwcm9wcykge1xuICAgIHJldHVybiBzZXRTd2l0Y2hSb290Q29udGV4dChuZXcgU3dpdGNoUm9vdFN0YXRlKHByb3BzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlU3dpdGNoSW5wdXQoKSB7XG4gICAgcmV0dXJuIG5ldyBTd2l0Y2hJbnB1dFN0YXRlKGdldFN3aXRjaFJvb3RDb250ZXh0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN3aXRjaFRodW1iKHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBTd2l0Y2hUaHVtYlN0YXRlKHByb3BzLCBnZXRTd2l0Y2hSb290Q29udGV4dCgpKTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IHVzZVN3aXRjaElucHV0IH0gZnJvbSBcIi4uL3N3aXRjaC5zdmVsdGUuanNcIjtcblxuXHRjb25zdCBpbnB1dFN0YXRlID0gdXNlU3dpdGNoSW5wdXQoKTtcbjwvc2NyaXB0PlxuXG57I2lmIGlucHV0U3RhdGUuc2hvdWxkUmVuZGVyfVxuXHQ8aW5wdXQgey4uLmlucHV0U3RhdGUucHJvcHN9IC8+XG57L2lmfVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IFN3aXRjaFJvb3RQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyB1c2VTd2l0Y2hSb290IH0gZnJvbSBcIi4uL3N3aXRjaC5zdmVsdGUuanNcIjtcblx0aW1wb3J0IFN3aXRjaElucHV0IGZyb20gXCIuL3N3aXRjaC1pbnB1dC5zdmVsdGVcIjtcblx0aW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvdXNlLWlkLmpzXCI7XG5cdGltcG9ydCB7IG5vb3AgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvbm9vcC5qc1wiO1xuXG5cdGxldCB7XG5cdFx0Y2hpbGQsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGlkID0gdXNlSWQoKSxcblx0XHRkaXNhYmxlZCA9IGZhbHNlLFxuXHRcdHJlcXVpcmVkID0gZmFsc2UsXG5cdFx0Y2hlY2tlZCA9ICRiaW5kYWJsZShmYWxzZSksXG5cdFx0dmFsdWUgPSBcIm9uXCIsXG5cdFx0bmFtZSA9IHVuZGVmaW5lZCxcblx0XHR0eXBlID0gXCJidXR0b25cIixcblx0XHRvbkNoZWNrZWRDaGFuZ2UgPSBub29wLFxuXHRcdGNvbnRyb2xsZWRDaGVja2VkID0gZmFsc2UsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFN3aXRjaFJvb3RQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGNvbnN0IHJvb3RTdGF0ZSA9IHVzZVN3aXRjaFJvb3Qoe1xuXHRcdGNoZWNrZWQ6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gY2hlY2tlZCxcblx0XHRcdCh2KSA9PiB7XG5cdFx0XHRcdGlmIChjb250cm9sbGVkQ2hlY2tlZCkge1xuXHRcdFx0XHRcdG9uQ2hlY2tlZENoYW5nZSh2KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGVja2VkID0gdjtcblx0XHRcdFx0XHRvbkNoZWNrZWRDaGFuZ2U/Lih2KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCksXG5cdFx0ZGlzYWJsZWQ6IGJveC53aXRoKCgpID0+IGRpc2FibGVkID8/IGZhbHNlKSxcblx0XHRyZXF1aXJlZDogYm94LndpdGgoKCkgPT4gcmVxdWlyZWQpLFxuXHRcdHZhbHVlOiBib3gud2l0aCgoKSA9PiB2YWx1ZSksXG5cdFx0bmFtZTogYm94LndpdGgoKCkgPT4gbmFtZSksXG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIHJvb3RTdGF0ZS5wcm9wcywgeyB0eXBlIH0pKTtcbjwvc2NyaXB0PlxuXG57I2lmIGNoaWxkfVxuXHR7QHJlbmRlciBjaGlsZCh7IHByb3BzOiBtZXJnZWRQcm9wcywgY2hlY2tlZDogcm9vdFN0YXRlLmNoZWNrZWQuY3VycmVudCB9KX1cbns6ZWxzZX1cblx0PGJ1dHRvbiB7Li4ubWVyZ2VkUHJvcHN9PlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oeyBjaGVja2VkOiByb290U3RhdGUuY2hlY2tlZC5jdXJyZW50IH0pfVxuXHQ8L2J1dHRvbj5cbnsvaWZ9XG5cbjxTd2l0Y2hJbnB1dCAvPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IFN3aXRjaFRodW1iUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblx0aW1wb3J0IHsgdXNlU3dpdGNoVGh1bWIgfSBmcm9tIFwiLi4vc3dpdGNoLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyB1c2VJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC91c2UtaWQuanNcIjtcblxuXHRsZXQge1xuXHRcdGNoaWxkLFxuXHRcdGNoaWxkcmVuLFxuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IHVzZUlkKCksXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFN3aXRjaFRodW1iUHJvcHMgPSAkcHJvcHMoKTtcblxuXHRjb25zdCB0aHVtYlN0YXRlID0gdXNlU3dpdGNoVGh1bWIoe1xuXHRcdGlkOiBib3gud2l0aCgoKSA9PiBpZCksXG5cdFx0cmVmOiBib3gud2l0aChcblx0XHRcdCgpID0+IHJlZixcblx0XHRcdCh2KSA9PiAocmVmID0gdilcblx0XHQpLFxuXHR9KTtcblxuXHRjb25zdCBtZXJnZWRQcm9wcyA9ICRkZXJpdmVkKG1lcmdlUHJvcHMocmVzdFByb3BzLCB0aHVtYlN0YXRlLnByb3BzKSk7XG48L3NjcmlwdD5cblxueyNpZiBjaGlsZH1cblx0e0ByZW5kZXIgY2hpbGQoeyBwcm9wczogbWVyZ2VkUHJvcHMsIGNoZWNrZWQ6IHRodW1iU3RhdGUucm9vdC5jaGVja2VkLmN1cnJlbnQgfSl9XG57OmVsc2V9XG5cdDxzcGFuIHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/Lih7IGNoZWNrZWQ6IHRodW1iU3RhdGUucm9vdC5jaGVja2VkLmN1cnJlbnQgfSl9XG5cdDwvc3Bhbj5cbnsvaWZ9XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBEaWFsb2cgYXMgRGlhbG9nUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nUHJpbWl0aXZlLlRpdGxlUHJvcHMgPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48RGlhbG9nUHJpbWl0aXZlLlRpdGxlXG5cdGJpbmQ6cmVmXG5cdGNsYXNzPXtjbigndGV4dC1sZyBmb250LXNlbWlib2xkIGxlYWRpbmctbm9uZSB0cmFja2luZy10aWdodCcsIGNsYXNzTmFtZSl9XG5cdHsuLi5yZXN0UHJvcHN9XG4vPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBXaXRoRWxlbWVudFJlZiB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgdHlwZSB7IEhUTUxBdHRyaWJ1dGVzIH0gZnJvbSAnc3ZlbHRlL2VsZW1lbnRzJztcblx0aW1wb3J0IHsgY24gfSBmcm9tICckbGliL3V0aWwvc2hhZGNuLXVpLmpzJztcblxuXHRsZXQge1xuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdGNoaWxkcmVuLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBXaXRoRWxlbWVudFJlZjxIVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD4+ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdlxuXHRiaW5kOnRoaXM9e3JlZn1cblx0Y2xhc3M9e2NuKCdmbGV4IGZsZXgtY29sLXJldmVyc2Ugc206ZmxleC1yb3cgc206anVzdGlmeS1lbmQgc206c3BhY2UteC0yJywgY2xhc3NOYW1lKX1cblx0ey4uLnJlc3RQcm9wc31cbj5cblx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7IEhUTUxBdHRyaWJ1dGVzIH0gZnJvbSAnc3ZlbHRlL2VsZW1lbnRzJztcblx0aW1wb3J0IHR5cGUgeyBXaXRoRWxlbWVudFJlZiB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFdpdGhFbGVtZW50UmVmPEhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50Pj4gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG5cdGJpbmQ6dGhpcz17cmVmfVxuXHRjbGFzcz17Y24oJ2ZsZXggZmxleC1jb2wgc3BhY2UteS0xLjUgdGV4dC1jZW50ZXIgc206dGV4dC1sZWZ0JywgY2xhc3NOYW1lKX1cblx0ey4uLnJlc3RQcm9wc31cbj5cblx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBEaWFsb2cgYXMgRGlhbG9nUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogRGlhbG9nUHJpbWl0aXZlLk92ZXJsYXlQcm9wcyA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxEaWFsb2dQcmltaXRpdmUuT3ZlcmxheVxuXHRiaW5kOnJlZlxuXHRjbGFzcz17Y24oXG5cdFx0J2ZpeGVkIGluc2V0LTAgei01MCBiZy1ibGFjay84MCAgZGF0YS1bc3RhdGU9b3Blbl06YW5pbWF0ZS1pbiBkYXRhLVtzdGF0ZT1jbG9zZWRdOmFuaW1hdGUtb3V0IGRhdGEtW3N0YXRlPWNsb3NlZF06ZmFkZS1vdXQtMCBkYXRhLVtzdGF0ZT1vcGVuXTpmYWRlLWluLTAnLFxuXHRcdGNsYXNzTmFtZVxuXHQpfVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC40NjkuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIHdpZHRoOiAyNCxcbiAgICBoZWlnaHQ6IDI0LFxuICAgIHZpZXdCb3g6ICcwIDAgMjQgMjQnLFxuICAgIGZpbGw6ICdub25lJyxcbiAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsXG59O1xuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdEF0dHJpYnV0ZXM7XG4iLCI8c2NyaXB0PmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzJztcbmV4cG9ydCBsZXQgbmFtZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgY29sb3IgPSAnY3VycmVudENvbG9yJztcbmV4cG9ydCBsZXQgc2l6ZSA9IDI0O1xuZXhwb3J0IGxldCBzdHJva2VXaWR0aCA9IDI7XG5leHBvcnQgbGV0IGFic29sdXRlU3Ryb2tlV2lkdGggPSBmYWxzZTtcbmV4cG9ydCBsZXQgaWNvbk5vZGUgPSBbXTtcbmNvbnN0IG1lcmdlQ2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiBjbGFzc2VzLmZpbHRlcigoY2xhc3NOYW1lLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICByZXR1cm4gQm9vbGVhbihjbGFzc05hbWUpICYmIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXg7XG59KVxuICAgIC5qb2luKCcgJyk7XG48L3NjcmlwdD5cblxuPHN2Z1xuICB7Li4uZGVmYXVsdEF0dHJpYnV0ZXN9XG4gIHsuLi4kJHJlc3RQcm9wc31cbiAgd2lkdGg9e3NpemV9XG4gIGhlaWdodD17c2l6ZX1cbiAgc3Ryb2tlPXtjb2xvcn1cbiAgc3Ryb2tlLXdpZHRoPXtcbiAgICBhYnNvbHV0ZVN0cm9rZVdpZHRoXG4gICAgICA/IE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCAvIE51bWJlcihzaXplKVxuICAgICAgOiBzdHJva2VXaWR0aFxuICB9XG4gIGNsYXNzPXtcbiAgICBtZXJnZUNsYXNzZXMoXG4gICAgICAnbHVjaWRlLWljb24nLFxuICAgICAgJ2x1Y2lkZScsXG4gICAgICBuYW1lID8gYGx1Y2lkZS0ke25hbWV9YDogJycsXG4gICAgICAkJHByb3BzLmNsYXNzXG4gICAgKVxuICB9XG4+XG4gIHsjZWFjaCBpY29uTm9kZSBhcyBbdGFnLCBhdHRyc119XG4gICAgPHN2ZWx0ZTplbGVtZW50IHRoaXM9e3RhZ30gey4uLmF0dHJzfS8+XG4gIHsvZWFjaH1cbiAgPHNsb3QgLz5cbjwvc3ZnPlxuIiwiPHNjcmlwdD4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1zdmVsdGUgdjAuNDY5LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9JY29uLnN2ZWx0ZSc7XG5jb25zdCBpY29uTm9kZSA9IFtbXCJwYXRoXCIsIHsgXCJkXCI6IFwiTTE4IDYgNiAxOFwiIH1dLCBbXCJwYXRoXCIsIHsgXCJkXCI6IFwibTYgNiAxMiAxMlwiIH1dXTtcbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBYXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVGdnTmlBMklERTRJaUF2UGdvZ0lEeHdZWFJvSUdROUltMDJJRFlnTVRJZ01USWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy94XG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtc3ZlbHRlIC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbmFsQ29tcG9uZW50fSBTdmVsdGUgY29tcG9uZW50XG4gKlxuICovXG48L3NjcmlwdD5cblxuPEljb24gbmFtZT1cInhcIiB7Li4uJCRwcm9wc30gaWNvbk5vZGU9e2ljb25Ob2RlfT5cbiAgPHNsb3QvPlxuPC9JY29uPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgRGlhbG9nIGFzIERpYWxvZ1ByaW1pdGl2ZSwgdHlwZSBXaXRob3V0Q2hpbGRyZW5PckNoaWxkIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCBYIGZyb20gJ2x1Y2lkZS1zdmVsdGUvaWNvbnMveCc7XG5cdGltcG9ydCB0eXBlIHsgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCAqIGFzIERpYWxvZyBmcm9tICcuL2luZGV4LmpzJztcblx0aW1wb3J0IHsgY24gfSBmcm9tICckbGliL3V0aWwvc2hhZGNuLXVpLmpzJztcblxuXHRsZXQge1xuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdHBvcnRhbFByb3BzLFxuXHRcdGNoaWxkcmVuLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBXaXRob3V0Q2hpbGRyZW5PckNoaWxkPERpYWxvZ1ByaW1pdGl2ZS5Db250ZW50UHJvcHM+ICYge1xuXHRcdHBvcnRhbFByb3BzPzogRGlhbG9nUHJpbWl0aXZlLlBvcnRhbFByb3BzO1xuXHRcdGNoaWxkcmVuOiBTbmlwcGV0O1xuXHR9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPERpYWxvZy5Qb3J0YWwgey4uLnBvcnRhbFByb3BzfT5cblx0PERpYWxvZy5PdmVybGF5IC8+XG5cdDxEaWFsb2dQcmltaXRpdmUuQ29udGVudFxuXHRcdGJpbmQ6cmVmXG5cdFx0Y2xhc3M9e2NuKFxuXHRcdFx0J2ZpeGVkIGxlZnQtWzUwJV0gdG9wLVs1MCVdIHotNTAgZ3JpZCB3LWZ1bGwgbWF4LXctbGcgdHJhbnNsYXRlLXgtWy01MCVdIHRyYW5zbGF0ZS15LVstNTAlXSBnYXAtNCBib3JkZXIgYmctYmFja2dyb3VuZCBwLTYgc2hhZG93LWxnIGR1cmF0aW9uLTIwMCBkYXRhLVtzdGF0ZT1vcGVuXTphbmltYXRlLWluIGRhdGEtW3N0YXRlPWNsb3NlZF06YW5pbWF0ZS1vdXQgZGF0YS1bc3RhdGU9Y2xvc2VkXTpmYWRlLW91dC0wIGRhdGEtW3N0YXRlPW9wZW5dOmZhZGUtaW4tMCBkYXRhLVtzdGF0ZT1jbG9zZWRdOnpvb20tb3V0LTk1IGRhdGEtW3N0YXRlPW9wZW5dOnpvb20taW4tOTUgZGF0YS1bc3RhdGU9Y2xvc2VkXTpzbGlkZS1vdXQtdG8tbGVmdC0xLzIgZGF0YS1bc3RhdGU9Y2xvc2VkXTpzbGlkZS1vdXQtdG8tdG9wLVs0OCVdIGRhdGEtW3N0YXRlPW9wZW5dOnNsaWRlLWluLWZyb20tbGVmdC0xLzIgZGF0YS1bc3RhdGU9b3Blbl06c2xpZGUtaW4tZnJvbS10b3AtWzQ4JV0gc206cm91bmRlZC1sZycsXG5cdFx0XHRjbGFzc05hbWVcblx0XHQpfVxuXHRcdHsuLi5yZXN0UHJvcHN9XG5cdD5cblx0XHR7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cdFx0PERpYWxvZ1ByaW1pdGl2ZS5DbG9zZVxuXHRcdFx0Y2xhc3M9XCJhYnNvbHV0ZSByaWdodC00IHRvcC00IHJvdW5kZWQtc20gb3BhY2l0eS03MCByaW5nLW9mZnNldC1iYWNrZ3JvdW5kIHRyYW5zaXRpb24tb3BhY2l0eSBob3ZlcjpvcGFjaXR5LTEwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctcmluZyBmb2N1czpyaW5nLW9mZnNldC0yIGRpc2FibGVkOnBvaW50ZXItZXZlbnRzLW5vbmVcIlxuXHRcdD5cblx0XHRcdDxYIGNsYXNzPVwic2l6ZS00XCIgLz5cblx0XHRcdDxzcGFuIGNsYXNzPVwic3Itb25seVwiPkNsb3NlPC9zcGFuPlxuXHRcdDwvRGlhbG9nUHJpbWl0aXZlLkNsb3NlPlxuXHQ8L0RpYWxvZ1ByaW1pdGl2ZS5Db250ZW50PlxuPC9EaWFsb2cuUG9ydGFsPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgRGlhbG9nIGFzIERpYWxvZ1ByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IERpYWxvZ1ByaW1pdGl2ZS5EZXNjcmlwdGlvblByb3BzID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPERpYWxvZ1ByaW1pdGl2ZS5EZXNjcmlwdGlvblxuXHRiaW5kOnJlZlxuXHRjbGFzcz17Y24oJ3RleHQtc20gdGV4dC1tdXRlZC1mb3JlZ3JvdW5kJywgY2xhc3NOYW1lKX1cblx0ey4uLnJlc3RQcm9wc31cbi8+XG4iLCJpbXBvcnQgeyBEaWFsb2cgYXMgRGlhbG9nUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5cbmltcG9ydCBUaXRsZSBmcm9tICcuL2RpYWxvZy10aXRsZS5zdmVsdGUnO1xuaW1wb3J0IEZvb3RlciBmcm9tICcuL2RpYWxvZy1mb290ZXIuc3ZlbHRlJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi9kaWFsb2ctaGVhZGVyLnN2ZWx0ZSc7XG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuL2RpYWxvZy1vdmVybGF5LnN2ZWx0ZSc7XG5pbXBvcnQgQ29udGVudCBmcm9tICcuL2RpYWxvZy1jb250ZW50LnN2ZWx0ZSc7XG5pbXBvcnQgRGVzY3JpcHRpb24gZnJvbSAnLi9kaWFsb2ctZGVzY3JpcHRpb24uc3ZlbHRlJztcblxuY29uc3QgUm9vdCA9IERpYWxvZ1ByaW1pdGl2ZS5Sb290O1xuY29uc3QgVHJpZ2dlciA9IERpYWxvZ1ByaW1pdGl2ZS5UcmlnZ2VyO1xuY29uc3QgQ2xvc2UgPSBEaWFsb2dQcmltaXRpdmUuQ2xvc2U7XG5jb25zdCBQb3J0YWwgPSBEaWFsb2dQcmltaXRpdmUuUG9ydGFsO1xuXG5leHBvcnQge1xuXHRSb290LFxuXHRUaXRsZSxcblx0UG9ydGFsLFxuXHRGb290ZXIsXG5cdEhlYWRlcixcblx0VHJpZ2dlcixcblx0T3ZlcmxheSxcblx0Q29udGVudCxcblx0RGVzY3JpcHRpb24sXG5cdENsb3NlLFxuXHQvL1xuXHRSb290IGFzIERpYWxvZyxcblx0VGl0bGUgYXMgRGlhbG9nVGl0bGUsXG5cdFBvcnRhbCBhcyBEaWFsb2dQb3J0YWwsXG5cdEZvb3RlciBhcyBEaWFsb2dGb290ZXIsXG5cdEhlYWRlciBhcyBEaWFsb2dIZWFkZXIsXG5cdFRyaWdnZXIgYXMgRGlhbG9nVHJpZ2dlcixcblx0T3ZlcmxheSBhcyBEaWFsb2dPdmVybGF5LFxuXHRDb250ZW50IGFzIERpYWxvZ0NvbnRlbnQsXG5cdERlc2NyaXB0aW9uIGFzIERpYWxvZ0Rlc2NyaXB0aW9uLFxuXHRDbG9zZSBhcyBEaWFsb2dDbG9zZVxufTtcbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEFjY29yZGlvbiBhcyBBY2NvcmRpb25QcmltaXRpdmUsIHR5cGUgV2l0aG91dENoaWxkIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHRjaGlsZHJlbixcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogV2l0aG91dENoaWxkPEFjY29yZGlvblByaW1pdGl2ZS5Db250ZW50UHJvcHM+ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPEFjY29yZGlvblByaW1pdGl2ZS5Db250ZW50XG5cdGJpbmQ6cmVmXG5cdGNsYXNzPXtjbihcblx0XHQnb3ZlcmZsb3ctaGlkZGVuIHRleHQtc20gdHJhbnNpdGlvbi1hbGwgZGF0YS1bc3RhdGU9Y2xvc2VkXTphbmltYXRlLWFjY29yZGlvbi11cCBkYXRhLVtzdGF0ZT1vcGVuXTphbmltYXRlLWFjY29yZGlvbi1kb3duJyxcblx0XHRjbGFzc05hbWVcblx0KX1cblx0ey4uLnJlc3RQcm9wc31cbj5cblx0PGRpdiBjbGFzcz1cInBiLTQgcHQtMFwiPlxuXHRcdHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblx0PC9kaXY+XG48L0FjY29yZGlvblByaW1pdGl2ZS5Db250ZW50PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgQWNjb3JkaW9uIGFzIEFjY29yZGlvblByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IEFjY29yZGlvblByaW1pdGl2ZS5JdGVtUHJvcHMgPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48QWNjb3JkaW9uUHJpbWl0aXZlLkl0ZW0gYmluZDpyZWYgY2xhc3M9e2NuKCdib3JkZXItYicsIGNsYXNzTmFtZSl9IHsuLi5yZXN0UHJvcHN9IC8+XG4iLCI8c2NyaXB0Pi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC40NjkuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJztcbmNvbnN0IGljb25Ob2RlID0gW1tcInBhdGhcIiwgeyBcImRcIjogXCJtNiA5IDYgNiA2LTZcIiB9XV07XG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQ2hldnJvbkRvd25cbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKdE5pQTVJRFlnTmlBMkxUWWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9jaGV2cm9uLWRvd25cbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1zdmVsdGUgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0Z1bmN0aW9uYWxDb21wb25lbnR9IFN2ZWx0ZSBjb21wb25lbnRcbiAqXG4gKi9cbjwvc2NyaXB0PlxuXG48SWNvbiBuYW1lPVwiY2hldnJvbi1kb3duXCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEFjY29yZGlvbiBhcyBBY2NvcmRpb25QcmltaXRpdmUsIHR5cGUgV2l0aG91dENoaWxkIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCBDaGV2cm9uRG93biBmcm9tICdsdWNpZGUtc3ZlbHRlL2ljb25zL2NoZXZyb24tZG93bic7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHRsZXZlbCA9IDMsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFdpdGhvdXRDaGlsZDxBY2NvcmRpb25QcmltaXRpdmUuVHJpZ2dlclByb3BzPiAmIHtcblx0XHRsZXZlbD86IEFjY29yZGlvblByaW1pdGl2ZS5IZWFkZXJQcm9wc1snbGV2ZWwnXTtcblx0fSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxBY2NvcmRpb25QcmltaXRpdmUuSGVhZGVyIHtsZXZlbH0gY2xhc3M9XCJmbGV4XCI+XG5cdDxBY2NvcmRpb25QcmltaXRpdmUuVHJpZ2dlclxuXHRcdGJpbmQ6cmVmXG5cdFx0Y2xhc3M9e2NuKFxuXHRcdFx0J2ZsZXggZmxleC0xIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcHktNCBmb250LW1lZGl1bSB0cmFuc2l0aW9uLWFsbCBob3Zlcjp1bmRlcmxpbmUgWyZbZGF0YS1zdGF0ZT1vcGVuXT5zdmddOnJvdGF0ZS0xODAnLFxuXHRcdFx0Y2xhc3NOYW1lXG5cdFx0KX1cblx0XHR7Li4ucmVzdFByb3BzfVxuXHQ+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHRcdDxDaGV2cm9uRG93biBjbGFzcz1cInNpemUtNCBzaHJpbmstMCB0cmFuc2l0aW9uLXRyYW5zZm9ybSBkdXJhdGlvbi0yMDBcIiAvPlxuXHQ8L0FjY29yZGlvblByaW1pdGl2ZS5UcmlnZ2VyPlxuPC9BY2NvcmRpb25QcmltaXRpdmUuSGVhZGVyPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgY24gfSBmcm9tICckbGliL3V0aWwvc2hhZGNuLXVpLmpzJztcblx0aW1wb3J0IHsgUG9wb3ZlciBhcyBQb3BvdmVyUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHRzaWRlT2Zmc2V0ID0gNCxcblx0XHRhbGlnbiA9ICdjZW50ZXInLFxuXHRcdHBvcnRhbFByb3BzLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBQb3BvdmVyUHJpbWl0aXZlLkNvbnRlbnRQcm9wcyAmIHtcblx0XHRwb3J0YWxQcm9wcz86IFBvcG92ZXJQcmltaXRpdmUuUG9ydGFsUHJvcHM7XG5cdH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48UG9wb3ZlclByaW1pdGl2ZS5Qb3J0YWwgey4uLnBvcnRhbFByb3BzfT5cblx0PFBvcG92ZXJQcmltaXRpdmUuQ29udGVudFxuXHRcdGJpbmQ6cmVmXG5cdFx0e3NpZGVPZmZzZXR9XG5cdFx0e2FsaWdufVxuXHRcdGNsYXNzPXtjbihcblx0XHRcdCd6LTUwIHctNzIgcm91bmRlZC1tZCBib3JkZXIgYmctcG9wb3ZlciBwLTQgdGV4dC1wb3BvdmVyLWZvcmVncm91bmQgc2hhZG93LW1kIG91dGxpbmUtbm9uZSBkYXRhLVtzdGF0ZT1vcGVuXTphbmltYXRlLWluIGRhdGEtW3N0YXRlPWNsb3NlZF06YW5pbWF0ZS1vdXQgZGF0YS1bc3RhdGU9Y2xvc2VkXTpmYWRlLW91dC0wIGRhdGEtW3N0YXRlPW9wZW5dOmZhZGUtaW4tMCBkYXRhLVtzdGF0ZT1jbG9zZWRdOnpvb20tb3V0LTk1IGRhdGEtW3N0YXRlPW9wZW5dOnpvb20taW4tOTUgZGF0YS1bc2lkZT1ib3R0b21dOnNsaWRlLWluLWZyb20tdG9wLTIgZGF0YS1bc2lkZT1sZWZ0XTpzbGlkZS1pbi1mcm9tLXJpZ2h0LTIgZGF0YS1bc2lkZT1yaWdodF06c2xpZGUtaW4tZnJvbS1sZWZ0LTIgZGF0YS1bc2lkZT10b3BdOnNsaWRlLWluLWZyb20tYm90dG9tLTInLFxuXHRcdFx0Y2xhc3NOYW1lXG5cdFx0KX1cblx0XHR7Li4ucmVzdFByb3BzfVxuXHQvPlxuPC9Qb3BvdmVyUHJpbWl0aXZlLlBvcnRhbD5cbiIsImltcG9ydCB7IFBvcG92ZXIgYXMgUG9wb3ZlclByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuaW1wb3J0IENvbnRlbnQgZnJvbSAnLi9wb3BvdmVyLWNvbnRlbnQuc3ZlbHRlJztcbmNvbnN0IFJvb3QgPSBQb3BvdmVyUHJpbWl0aXZlLlJvb3Q7XG5jb25zdCBUcmlnZ2VyID0gUG9wb3ZlclByaW1pdGl2ZS5UcmlnZ2VyO1xuY29uc3QgQ2xvc2UgPSBQb3BvdmVyUHJpbWl0aXZlLkNsb3NlO1xuXG5leHBvcnQge1xuXHRSb290LFxuXHRDb250ZW50LFxuXHRUcmlnZ2VyLFxuXHRDbG9zZSxcblx0Ly9cblx0Um9vdCBhcyBQb3BvdmVyLFxuXHRDb250ZW50IGFzIFBvcG92ZXJDb250ZW50LFxuXHRUcmlnZ2VyIGFzIFBvcG92ZXJUcmlnZ2VyLFxuXHRDbG9zZSBhcyBQb3BvdmVyQ2xvc2Vcbn07XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBTd2l0Y2ggYXMgU3dpdGNoUHJpbWl0aXZlLCB0eXBlIFdpdGhvdXRDaGlsZHJlbk9yQ2hpbGQgfSBmcm9tICdiaXRzLXVpJztcblx0aW1wb3J0IHsgY24gfSBmcm9tICckbGliL3V0aWwvc2hhZGNuLXVpLmpzJztcblxuXHRsZXQge1xuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdGNoZWNrZWQgPSAkYmluZGFibGUoZmFsc2UpLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBXaXRob3V0Q2hpbGRyZW5PckNoaWxkPFN3aXRjaFByaW1pdGl2ZS5Sb290UHJvcHM+ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFN3aXRjaFByaW1pdGl2ZS5Sb290XG5cdGJpbmQ6cmVmXG5cdGJpbmQ6Y2hlY2tlZFxuXHRjbGFzcz17Y24oXG5cdFx0J3BlZXIgaW5saW5lLWZsZXggaC02IHctMTEgc2hyaW5rLTAgY3Vyc29yLXBvaW50ZXIgaXRlbXMtY2VudGVyIHJvdW5kZWQtZnVsbCBib3JkZXItMiBib3JkZXItdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1jb2xvcnMgZm9jdXMtdmlzaWJsZTpvdXRsaW5lLW5vbmUgZm9jdXMtdmlzaWJsZTpyaW5nLTIgZm9jdXMtdmlzaWJsZTpyaW5nLXJpbmcgZm9jdXMtdmlzaWJsZTpyaW5nLW9mZnNldC0yIGZvY3VzLXZpc2libGU6cmluZy1vZmZzZXQtYmFja2dyb3VuZCBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6b3BhY2l0eS01MCBkYXRhLVtzdGF0ZT1jaGVja2VkXTpiZy1wcmltYXJ5IGRhdGEtW3N0YXRlPXVuY2hlY2tlZF06YmctaW5wdXQnLFxuXHRcdGNsYXNzTmFtZVxuXHQpfVxuXHR7Li4ucmVzdFByb3BzfVxuPlxuXHQ8U3dpdGNoUHJpbWl0aXZlLlRodW1iXG5cdFx0Y2xhc3M9e2NuKFxuXHRcdFx0J3BvaW50ZXItZXZlbnRzLW5vbmUgYmxvY2sgc2l6ZS01IHJvdW5kZWQtZnVsbCBiZy1iYWNrZ3JvdW5kIHNoYWRvdy1sZyByaW5nLTAgdHJhbnNpdGlvbi10cmFuc2Zvcm0gZGF0YS1bc3RhdGU9Y2hlY2tlZF06dHJhbnNsYXRlLXgtNSBkYXRhLVtzdGF0ZT11bmNoZWNrZWRdOnRyYW5zbGF0ZS14LTAnXG5cdFx0KX1cblx0Lz5cbjwvU3dpdGNoUHJpbWl0aXZlLlJvb3Q+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBMYWJlbCBhcyBMYWJlbFByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IExhYmVsUHJpbWl0aXZlLlJvb3RQcm9wcyA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxMYWJlbFByaW1pdGl2ZS5Sb290XG5cdGJpbmQ6cmVmXG5cdGNsYXNzPXtjbihcblx0XHQndGV4dC1zbSBmb250LW1lZGl1bSBsZWFkaW5nLW5vbmUgcGVlci1kaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgcGVlci1kaXNhYmxlZDpvcGFjaXR5LTcwJyxcblx0XHRjbGFzc05hbWVcblx0KX1cblx0ey4uLnJlc3RQcm9wc31cbi8+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBSYW5nZUNhbGVuZGFyIGFzIFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUsIHR5cGUgV2l0aG91dENoaWxkcmVuT3JDaGlsZCB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgKiBhcyBSYW5nZUNhbGVuZGFyIGZyb20gJy4vaW5kZXguanMnO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdHZhbHVlID0gJGJpbmRhYmxlKCksXG5cdFx0cGxhY2Vob2xkZXIgPSAkYmluZGFibGUoKSxcblx0XHR3ZWVrZGF5Rm9ybWF0ID0gJ3Nob3J0Jyxcblx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBXaXRob3V0Q2hpbGRyZW5PckNoaWxkPFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuUm9vdFByb3BzPiA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLlJvb3Rcblx0YmluZDpyZWZcblx0YmluZDp2YWx1ZVxuXHRiaW5kOnBsYWNlaG9sZGVyXG5cdHt3ZWVrZGF5Rm9ybWF0fVxuXHRjbGFzcz17Y24oJ3AtMycsIGNsYXNzTmFtZSl9XG5cdHsuLi5yZXN0UHJvcHN9XG4+XG5cdHsjc25pcHBldCBjaGlsZHJlbih7IG1vbnRocywgd2Vla2RheXMgfSl9XG5cdFx0PFJhbmdlQ2FsZW5kYXIuSGVhZGVyPlxuXHRcdFx0PFJhbmdlQ2FsZW5kYXIuUHJldkJ1dHRvbiAvPlxuXHRcdFx0PFJhbmdlQ2FsZW5kYXIuSGVhZGluZyAvPlxuXHRcdFx0PFJhbmdlQ2FsZW5kYXIuTmV4dEJ1dHRvbiAvPlxuXHRcdDwvUmFuZ2VDYWxlbmRhci5IZWFkZXI+XG5cdFx0PFJhbmdlQ2FsZW5kYXIuTW9udGhzPlxuXHRcdFx0eyNlYWNoIG1vbnRocyBhcyBtb250aH1cblx0XHRcdFx0PFJhbmdlQ2FsZW5kYXIuR3JpZD5cblx0XHRcdFx0XHQ8UmFuZ2VDYWxlbmRhci5HcmlkSGVhZD5cblx0XHRcdFx0XHRcdDxSYW5nZUNhbGVuZGFyLkdyaWRSb3cgY2xhc3M9XCJmbGV4XCI+XG5cdFx0XHRcdFx0XHRcdHsjZWFjaCB3ZWVrZGF5cyBhcyB3ZWVrZGF5fVxuXHRcdFx0XHRcdFx0XHRcdDxSYW5nZUNhbGVuZGFyLkhlYWRDZWxsPlxuXHRcdFx0XHRcdFx0XHRcdFx0e3dlZWtkYXkuc2xpY2UoMCwgMil9XG5cdFx0XHRcdFx0XHRcdFx0PC9SYW5nZUNhbGVuZGFyLkhlYWRDZWxsPlxuXHRcdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0XHQ8L1JhbmdlQ2FsZW5kYXIuR3JpZFJvdz5cblx0XHRcdFx0XHQ8L1JhbmdlQ2FsZW5kYXIuR3JpZEhlYWQ+XG5cdFx0XHRcdFx0PFJhbmdlQ2FsZW5kYXIuR3JpZEJvZHk+XG5cdFx0XHRcdFx0XHR7I2VhY2ggbW9udGgud2Vla3MgYXMgd2Vla0RhdGVzfVxuXHRcdFx0XHRcdFx0XHQ8UmFuZ2VDYWxlbmRhci5HcmlkUm93IGNsYXNzPVwibXQtMiB3LWZ1bGxcIj5cblx0XHRcdFx0XHRcdFx0XHR7I2VhY2ggd2Vla0RhdGVzIGFzIGRhdGV9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8UmFuZ2VDYWxlbmRhci5DZWxsIHtkYXRlfSBtb250aD17bW9udGgudmFsdWV9PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8UmFuZ2VDYWxlbmRhci5EYXkgLz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvUmFuZ2VDYWxlbmRhci5DZWxsPlxuXHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdFx0PC9SYW5nZUNhbGVuZGFyLkdyaWRSb3c+XG5cdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0PC9SYW5nZUNhbGVuZGFyLkdyaWRCb2R5PlxuXHRcdFx0XHQ8L1JhbmdlQ2FsZW5kYXIuR3JpZD5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L1JhbmdlQ2FsZW5kYXIuTW9udGhzPlxuXHR7L3NuaXBwZXR9XG48L1JhbmdlQ2FsZW5kYXJQcmltaXRpdmUuUm9vdD5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFJhbmdlQ2FsZW5kYXIgYXMgUmFuZ2VDYWxlbmRhclByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuQ2VsbFByb3BzID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuQ2VsbFxuXHRiaW5kOnJlZlxuXHRjbGFzcz17Y24oXG5cdFx0J3JlbGF0aXZlIHNpemUtOSBwLTAgdGV4dC1jZW50ZXIgdGV4dC1zbSBmb2N1cy13aXRoaW46cmVsYXRpdmUgZm9jdXMtd2l0aGluOnotMjAgWyY6aGFzKFtkYXRhLXNlbGVjdGVkXSldOmJnLWFjY2VudCBmaXJzdDpbJjpoYXMoW2RhdGEtc2VsZWN0ZWRdKV06cm91bmRlZC1sLW1kIGxhc3Q6WyY6aGFzKFtkYXRhLXNlbGVjdGVkXSldOnJvdW5kZWQtci1tZCBbJjpoYXMoW2RhdGEtc2VsZWN0ZWRdW2RhdGEtb3V0c2lkZS1tb250aF0pXTpiZy1hY2NlbnQvNTAgWyY6aGFzKFtkYXRhLXNlbGVjdGVkXVtkYXRhLXNlbGVjdGlvbi1lbmRdKV06cm91bmRlZC1yLW1kIFsmOmhhcyhbZGF0YS1zZWxlY3RlZF1bZGF0YS1zZWxlY3Rpb24tc3RhcnRdKV06cm91bmRlZC1sLW1kJyxcblx0XHRjbGFzc05hbWVcblx0KX1cblx0ey4uLnJlc3RQcm9wc31cbi8+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBSYW5nZUNhbGVuZGFyIGFzIFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUgfSBmcm9tICdiaXRzLXVpJztcblx0aW1wb3J0IHsgYnV0dG9uVmFyaWFudHMgfSBmcm9tICckbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2J1dHRvbi9pbmRleC5qcyc7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogUmFuZ2VDYWxlbmRhclByaW1pdGl2ZS5EYXlQcm9wcyA9ICRwcm9wcygpO1xuXG5cdGV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xuPC9zY3JpcHQ+XG5cbjxSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLkRheVxuXHRiaW5kOnJlZlxuXHRjbGFzcz17Y24oXG5cdFx0YnV0dG9uVmFyaWFudHMoeyB2YXJpYW50OiAnZ2hvc3QnIH0pLFxuXHRcdCdzaXplLTkgcC0wIGZvbnQtbm9ybWFsIGRhdGEtW3NlbGVjdGVkXTpvcGFjaXR5LTEwMCcsXG5cdFx0J1smW2RhdGEtdG9kYXldOm5vdChbZGF0YS1zZWxlY3RlZF0pXTpiZy1hY2NlbnQgWyZbZGF0YS10b2RheV06bm90KFtkYXRhLXNlbGVjdGVkXSldOnRleHQtYWNjZW50LWZvcmVncm91bmQnLFxuXHRcdC8vIFNlbGVjdGlvbiBTdGFydFxuXHRcdCdkYXRhLVtzZWxlY3Rpb24tc3RhcnRdOmJnLXByaW1hcnkgZGF0YS1bc2VsZWN0aW9uLXN0YXJ0XTp0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCBkYXRhLVtzZWxlY3Rpb24tc3RhcnRdOmhvdmVyOmJnLXByaW1hcnkgZGF0YS1bc2VsZWN0aW9uLXN0YXJ0XTpob3Zlcjp0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCBkYXRhLVtzZWxlY3Rpb24tc3RhcnRdOmZvY3VzOmJnLXByaW1hcnkgZGF0YS1bc2VsZWN0aW9uLXN0YXJ0XTpmb2N1czp0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCcsXG5cdFx0Ly8gU2VsZWN0aW9uIEVuZFxuXHRcdCdkYXRhLVtzZWxlY3Rpb24tZW5kXTpiZy1wcmltYXJ5IGRhdGEtW3NlbGVjdGlvbi1lbmRdOnRleHQtcHJpbWFyeS1mb3JlZ3JvdW5kIGRhdGEtW3NlbGVjdGlvbi1lbmRdOmhvdmVyOmJnLXByaW1hcnkgZGF0YS1bc2VsZWN0aW9uLWVuZF06aG92ZXI6dGV4dC1wcmltYXJ5LWZvcmVncm91bmQgZGF0YS1bc2VsZWN0aW9uLWVuZF06Zm9jdXM6YmctcHJpbWFyeSBkYXRhLVtzZWxlY3Rpb24tZW5kXTpmb2N1czp0ZXh0LXByaW1hcnktZm9yZWdyb3VuZCcsXG5cdFx0Ly8gT3V0c2lkZSBtb250aHNcblx0XHQnZGF0YS1bb3V0c2lkZS1tb250aF06cG9pbnRlci1ldmVudHMtbm9uZSBkYXRhLVtvdXRzaWRlLW1vbnRoXTp0ZXh0LW11dGVkLWZvcmVncm91bmQgZGF0YS1bb3V0c2lkZS1tb250aF06b3BhY2l0eS01MCBbJltkYXRhLW91dHNpZGUtbW9udGhdW2RhdGEtc2VsZWN0ZWRdXTpiZy1hY2NlbnQvNTAgWyZbZGF0YS1vdXRzaWRlLW1vbnRoXVtkYXRhLXNlbGVjdGVkXV06dGV4dC1tdXRlZC1mb3JlZ3JvdW5kIFsmW2RhdGEtb3V0c2lkZS1tb250aF1bZGF0YS1zZWxlY3RlZF1dOm9wYWNpdHktMzAnLFxuXHRcdC8vIERpc2FibGVkXG5cdFx0J2RhdGEtW2Rpc2FibGVkXTp0ZXh0LW11dGVkLWZvcmVncm91bmQgZGF0YS1bZGlzYWJsZWRdOm9wYWNpdHktNTAnLFxuXHRcdC8vIFVuYXZhaWxhYmxlXG5cdFx0J2RhdGEtW3VuYXZhaWxhYmxlXTp0ZXh0LWRlc3RydWN0aXZlLWZvcmVncm91bmQgZGF0YS1bdW5hdmFpbGFibGVdOmxpbmUtdGhyb3VnaCcsXG5cdFx0Y2xhc3NOYW1lXG5cdCl9XG5cdHsuLi5yZXN0UHJvcHN9XG4vPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgUmFuZ2VDYWxlbmRhciBhcyBSYW5nZUNhbGVuZGFyUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogUmFuZ2VDYWxlbmRhclByaW1pdGl2ZS5HcmlkUHJvcHMgPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48UmFuZ2VDYWxlbmRhclByaW1pdGl2ZS5HcmlkXG5cdGJpbmQ6cmVmXG5cdGNsYXNzPXtjbigndy1mdWxsIGJvcmRlci1jb2xsYXBzZSBzcGFjZS15LTEnLCBjbGFzc05hbWUpfVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFJhbmdlQ2FsZW5kYXIgYXMgUmFuZ2VDYWxlbmRhclByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuSGVhZGVyUHJvcHMgPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48UmFuZ2VDYWxlbmRhclByaW1pdGl2ZS5IZWFkZXJcblx0YmluZDpyZWZcblx0Y2xhc3M9e2NuKCdyZWxhdGl2ZSBmbGV4IHctZnVsbCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHB0LTEnLCBjbGFzc05hbWUpfVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgV2l0aEVsZW1lbnRSZWYgfSBmcm9tICdiaXRzLXVpJztcblx0aW1wb3J0IHR5cGUgeyBIVE1MQXR0cmlidXRlcyB9IGZyb20gJ3N2ZWx0ZS9lbGVtZW50cyc7XG5cdGltcG9ydCB7IGNuIH0gZnJvbSAnJGxpYi91dGlsL3NoYWRjbi11aS5qcyc7XG5cblx0bGV0IHtcblx0XHRyZWYgPSAkYmluZGFibGUobnVsbCksXG5cdFx0Y2xhc3M6IGNsYXNzTmFtZSxcblx0XHRjaGlsZHJlbixcblx0XHQuLi5yZXN0UHJvcHNcblx0fTogV2l0aEVsZW1lbnRSZWY8SFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+PiA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcblx0YmluZDp0aGlzPXtyZWZ9XG5cdGNsYXNzPXtjbignbXQtNCBmbGV4IGZsZXgtY29sIHNwYWNlLXktNCBzbTpmbGV4LXJvdyBzbTpzcGFjZS14LTQgc206c3BhY2UteS0wJywgY2xhc3NOYW1lKX1cblx0ey4uLnJlc3RQcm9wc31cbj5cblx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBSYW5nZUNhbGVuZGFyIGFzIFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUgfSBmcm9tICdiaXRzLXVpJztcblx0aW1wb3J0IHsgY24gfSBmcm9tICckbGliL3V0aWwvc2hhZGNuLXVpLmpzJztcblxuXHRsZXQge1xuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLkdyaWRSb3dQcm9wcyA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLkdyaWRSb3cgYmluZDpyZWYgY2xhc3M9e2NuKCdmbGV4JywgY2xhc3NOYW1lKX0gey4uLnJlc3RQcm9wc30gLz5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFJhbmdlQ2FsZW5kYXIgYXMgUmFuZ2VDYWxlbmRhclByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuSGVhZGluZ1Byb3BzID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuSGVhZGluZ1xuXHRiaW5kOnJlZlxuXHRjbGFzcz17Y24oJ3RleHQtc20gZm9udC1tZWRpdW0nLCBjbGFzc05hbWUpfVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFJhbmdlQ2FsZW5kYXIgYXMgUmFuZ2VDYWxlbmRhclByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuSGVhZENlbGxQcm9wcyA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLkhlYWRDZWxsXG5cdGJpbmQ6cmVmXG5cdGNsYXNzPXtjbigndy05IHJvdW5kZWQtbWQgdGV4dC1bMC44cmVtXSBmb250LW5vcm1hbCB0ZXh0LW11dGVkLWZvcmVncm91bmQnLCBjbGFzc05hbWUpfVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cbiIsIjxzY3JpcHQ+LyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtc3ZlbHRlIHYwLjQ2OS4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IEljb24gZnJvbSAnLi4vSWNvbi5zdmVsdGUnO1xuY29uc3QgaWNvbk5vZGUgPSBbW1wicGF0aFwiLCB7IFwiZFwiOiBcIm05IDE4IDYtNi02LTZcIiB9XV07XG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQ2hldnJvblJpZ2h0XG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnRPU0F4T0NBMkxUWXROaTAySWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvY2hldnJvbi1yaWdodFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXN2ZWx0ZSAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25hbENvbXBvbmVudH0gU3ZlbHRlIGNvbXBvbmVudFxuICpcbiAqL1xuPC9zY3JpcHQ+XG5cbjxJY29uIG5hbWU9XCJjaGV2cm9uLXJpZ2h0XCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFJhbmdlQ2FsZW5kYXIgYXMgUmFuZ2VDYWxlbmRhclByaW1pdGl2ZSB9IGZyb20gJ2JpdHMtdWknO1xuXHRpbXBvcnQgQ2hldnJvblJpZ2h0IGZyb20gJ2x1Y2lkZS1zdmVsdGUvaWNvbnMvY2hldnJvbi1yaWdodCc7XG5cdGltcG9ydCB7IGJ1dHRvblZhcmlhbnRzIH0gZnJvbSAnJGxpYi9jb21wb25lbnRzL3NoYWRjbi11aS9idXR0b24vaW5kZXguanMnO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuTmV4dEJ1dHRvblByb3BzID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IEZhbGxiYWNrKCl9XG5cdDxDaGV2cm9uUmlnaHQgY2xhc3M9XCJzaXplLTRcIiAvPlxuey9zbmlwcGV0fVxuXG48UmFuZ2VDYWxlbmRhclByaW1pdGl2ZS5OZXh0QnV0dG9uXG5cdGJpbmQ6cmVmXG5cdGNsYXNzPXtjbihcblx0XHRidXR0b25WYXJpYW50cyh7IHZhcmlhbnQ6ICdvdXRsaW5lJyB9KSxcblx0XHQnc2l6ZS03IGJnLXRyYW5zcGFyZW50IHAtMCBvcGFjaXR5LTUwIGhvdmVyOm9wYWNpdHktMTAwJyxcblx0XHRjbGFzc05hbWVcblx0KX1cblx0Y2hpbGRyZW49e2NoaWxkcmVuIHx8IEZhbGxiYWNrfVxuXHR7Li4ucmVzdFByb3BzfVxuLz5cbiIsIjxzY3JpcHQ+LyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtc3ZlbHRlIHYwLjQ2OS4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IEljb24gZnJvbSAnLi4vSWNvbi5zdmVsdGUnO1xuY29uc3QgaWNvbk5vZGUgPSBbW1wicGF0aFwiLCB7IFwiZFwiOiBcIm0xNSAxOC02LTYgNi02XCIgfV1dO1xuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIENoZXZyb25MZWZ0XG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnRNVFVnTVRndE5pMDJJRFl0TmlJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2NoZXZyb24tbGVmdFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXN2ZWx0ZSAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25hbENvbXBvbmVudH0gU3ZlbHRlIGNvbXBvbmVudFxuICpcbiAqL1xuPC9zY3JpcHQ+XG5cbjxJY29uIG5hbWU9XCJjaGV2cm9uLWxlZnRcIiB7Li4uJCRwcm9wc30gaWNvbk5vZGU9e2ljb25Ob2RlfT5cbiAgPHNsb3QvPlxuPC9JY29uPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgUmFuZ2VDYWxlbmRhciBhcyBSYW5nZUNhbGVuZGFyUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5cdGltcG9ydCBDaGV2cm9uTGVmdCBmcm9tICdsdWNpZGUtc3ZlbHRlL2ljb25zL2NoZXZyb24tbGVmdCc7XG5cdGltcG9ydCB7IGJ1dHRvblZhcmlhbnRzIH0gZnJvbSAnJGxpYi9jb21wb25lbnRzL3NoYWRjbi11aS9idXR0b24vaW5kZXguanMnO1xuXHRpbXBvcnQgeyBjbiB9IGZyb20gJyRsaWIvdXRpbC9zaGFkY24tdWkuanMnO1xuXG5cdGxldCB7XG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuUHJldkJ1dHRvblByb3BzID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IEZhbGxiYWNrKCl9XG5cdDxDaGV2cm9uTGVmdCBjbGFzcz1cInNpemUtNFwiIC8+XG57L3NuaXBwZXR9XG5cbjxSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLlByZXZCdXR0b25cblx0YmluZDpyZWZcblx0Y2xhc3M9e2NuKFxuXHRcdGJ1dHRvblZhcmlhbnRzKHsgdmFyaWFudDogJ291dGxpbmUnIH0pLFxuXHRcdCdzaXplLTcgYmctdHJhbnNwYXJlbnQgcC0wIG9wYWNpdHktNTAgaG92ZXI6b3BhY2l0eS0xMDAnLFxuXHRcdGNsYXNzTmFtZVxuXHQpfVxuXHRjaGlsZHJlbj17Y2hpbGRyZW4gfHwgRmFsbGJhY2t9XG5cdHsuLi5yZXN0UHJvcHN9XG4vPlxuIiwiaW1wb3J0IHsgUmFuZ2VDYWxlbmRhciBhcyBSYW5nZUNhbGVuZGFyUHJpbWl0aXZlIH0gZnJvbSAnYml0cy11aSc7XG5pbXBvcnQgUm9vdCBmcm9tICcuL3JhbmdlLWNhbGVuZGFyLnN2ZWx0ZSc7XG5pbXBvcnQgQ2VsbCBmcm9tICcuL3JhbmdlLWNhbGVuZGFyLWNlbGwuc3ZlbHRlJztcbmltcG9ydCBEYXkgZnJvbSAnLi9yYW5nZS1jYWxlbmRhci1kYXkuc3ZlbHRlJztcbmltcG9ydCBHcmlkIGZyb20gJy4vcmFuZ2UtY2FsZW5kYXItZ3JpZC5zdmVsdGUnO1xuaW1wb3J0IEhlYWRlciBmcm9tICcuL3JhbmdlLWNhbGVuZGFyLWhlYWRlci5zdmVsdGUnO1xuaW1wb3J0IE1vbnRocyBmcm9tICcuL3JhbmdlLWNhbGVuZGFyLW1vbnRocy5zdmVsdGUnO1xuaW1wb3J0IEdyaWRSb3cgZnJvbSAnLi9yYW5nZS1jYWxlbmRhci1ncmlkLXJvdy5zdmVsdGUnO1xuaW1wb3J0IEhlYWRpbmcgZnJvbSAnLi9yYW5nZS1jYWxlbmRhci1oZWFkaW5nLnN2ZWx0ZSc7XG5pbXBvcnQgSGVhZENlbGwgZnJvbSAnLi9yYW5nZS1jYWxlbmRhci1oZWFkLWNlbGwuc3ZlbHRlJztcbmltcG9ydCBOZXh0QnV0dG9uIGZyb20gJy4vcmFuZ2UtY2FsZW5kYXItbmV4dC1idXR0b24uc3ZlbHRlJztcbmltcG9ydCBQcmV2QnV0dG9uIGZyb20gJy4vcmFuZ2UtY2FsZW5kYXItcHJldi1idXR0b24uc3ZlbHRlJztcblxuY29uc3QgR3JpZEhlYWQgPSBSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLkdyaWRIZWFkO1xuY29uc3QgR3JpZEJvZHkgPSBSYW5nZUNhbGVuZGFyUHJpbWl0aXZlLkdyaWRCb2R5O1xuXG5leHBvcnQge1xuXHREYXksXG5cdENlbGwsXG5cdEdyaWQsXG5cdEhlYWRlcixcblx0TW9udGhzLFxuXHRHcmlkUm93LFxuXHRIZWFkaW5nLFxuXHRHcmlkQm9keSxcblx0R3JpZEhlYWQsXG5cdEhlYWRDZWxsLFxuXHROZXh0QnV0dG9uLFxuXHRQcmV2QnV0dG9uLFxuXHQvL1xuXHRSb290IGFzIFJhbmdlQ2FsZW5kYXJcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlIEBsdWNpZGUvc3ZlbHRlIHYwLjQ4My4wIC0gSVNDXG4gKlxuICogSVNDIExpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIyIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjIuXG4gKiBcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICogXG4gKi9cbmNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIHdpZHRoOiAyNCxcbiAgICBoZWlnaHQ6IDI0LFxuICAgIHZpZXdCb3g6ICcwIDAgMjQgMjQnLFxuICAgIGZpbGw6ICdub25lJyxcbiAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsXG59O1xuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdEF0dHJpYnV0ZXM7XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzJztcbmNvbnN0IHsgbmFtZSwgY29sb3IgPSAnY3VycmVudENvbG9yJywgc2l6ZSA9IDI0LCBzdHJva2VXaWR0aCA9IDIsIGFic29sdXRlU3Ryb2tlV2lkdGggPSBmYWxzZSwgaWNvbk5vZGUgPSBbXSwgY2hpbGRyZW4sIC4uLnByb3BzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48c3ZnXG4gIHsuLi5kZWZhdWx0QXR0cmlidXRlc31cbiAgey4uLnByb3BzfVxuICB3aWR0aD17c2l6ZX1cbiAgaGVpZ2h0PXtzaXplfVxuICBzdHJva2U9e2NvbG9yfVxuICBzdHJva2Utd2lkdGg9e2Fic29sdXRlU3Ryb2tlV2lkdGggPyAoTnVtYmVyKHN0cm9rZVdpZHRoKSAqIDI0KSAvIE51bWJlcihzaXplKSA6IHN0cm9rZVdpZHRofVxuICBjbGFzcz17WydsdWNpZGUtaWNvbiBsdWNpZGUnLCBuYW1lICYmIGBsdWNpZGUtJHtuYW1lfWAsIHByb3BzLmNsYXNzXX1cbj5cbiAgeyNlYWNoIGljb25Ob2RlIGFzIFt0YWcsIGF0dHJzXX1cbiAgICA8c3ZlbHRlOmVsZW1lbnRcbiAgICAgIHRoaXM9e3RhZ31cbiAgICAgIHsuLi5hdHRyc31cbiAgICAvPlxuICB7L2VhY2h9XG4gIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvc3ZnPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj4vKipcbiAqIEBsaWNlbnNlIEBsdWNpZGUvc3ZlbHRlIHYwLjQ4My4wIC0gSVNDXG4gKlxuICogSVNDIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIGZvciBwb3J0aW9ucyBvZiBMdWNpZGUgYXJlIGhlbGQgYnkgQ29sZSBCZW1pcyAyMDEzLTIwMjIgYXMgcGFydCBvZiBGZWF0aGVyIChNSVQpLiBBbGwgb3RoZXIgY29weXJpZ2h0IChjKSBmb3IgTHVjaWRlIGFyZSBoZWxkIGJ5IEx1Y2lkZSBDb250cmlidXRvcnMgMjAyMi5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IEljb24gZnJvbSAnLi4vSWNvbi5zdmVsdGUnO1xubGV0IHByb3BzID0gJHByb3BzKCk7XG5jb25zdCBpY29uTm9kZSA9IFtbXCJwYXRoXCIsIHsgXCJkXCI6IFwiTTggMnY0XCIgfV0sIFtcInBhdGhcIiwgeyBcImRcIjogXCJNMTYgMnY0XCIgfV0sIFtcInJlY3RcIiwgeyBcIndpZHRoXCI6IFwiMThcIiwgXCJoZWlnaHRcIjogXCIxOFwiLCBcInhcIjogXCIzXCIsIFwieVwiOiBcIjRcIiwgXCJyeFwiOiBcIjJcIiB9XSwgW1wicGF0aFwiLCB7IFwiZFwiOiBcIk0zIDEwaDE4XCIgfV1dO1xuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIENhbGVuZGFyXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5PQ0F5ZGpRaUlDOCtDaUFnUEhCaGRHZ2daRDBpVFRFMklESjJOQ0lnTHo0S0lDQThjbVZqZENCM2FXUjBhRDBpTVRnaUlHaGxhV2RvZEQwaU1UZ2lJSGc5SWpNaUlIazlJalFpSUhKNFBTSXlJaUF2UGdvZ0lEeHdZWFJvSUdROUlrMHpJREV3YURFNElpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2NhbGVuZGFyXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtc3ZlbHRlIC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbmFsQ29tcG9uZW50fSBTdmVsdGUgY29tcG9uZW50XG4gKlxuICovXG48L3NjcmlwdD5cblxuPEljb24gbmFtZT1cImNhbGVuZGFyXCIgey4uLnByb3BzfSBpY29uTm9kZT17aWNvbk5vZGV9PlxuICB7QHJlbmRlciBwcm9wcy5jaGlsZHJlbj8uKCl9XG48L0ljb24+XG4iLCJleHBvcnQgZGVmYXVsdCB7XG5cdGFwcE5hbWU6ICdLTUlUTCBETEMnLFxuXHR1dGNPZmZzZXQ6IDcsXG5cdG1lc3NhZ2VzOiB7XG5cdFx0c2NyYXBlRXJyb3I6ICdTY3JhcGluZyBlcnJvci4nXG5cdH0sXG5cdHNjcmFwZXI6IHtcblx0XHRjbGFzc1R5cGVzOiB7XG5cdFx0XHRsZWN0dXJlOiBbJ+C4lycsICdMJ10sXG5cdFx0XHRsYWI6IFsn4LibJywgJ1AnXVxuXHRcdH0sXG5cdFx0ZGF5czoge1xuXHRcdFx0J+C4reC4si4nOiAwLFxuXHRcdFx0J+C4iC4nOiAxLFxuXHRcdFx0J+C4rS4nOiAyLFxuXHRcdFx0J+C4ni4nOiAzLFxuXHRcdFx0J+C4nuC4pC4nOiA0LFxuXHRcdFx0J+C4qC4nOiA1LFxuXHRcdFx0J+C4qi4nOiA2LFxuXHRcdFx0U3VuOiAwLFxuXHRcdFx0TW9uOiAxLFxuXHRcdFx0VHVlOiAyLFxuXHRcdFx0V2VkOiAzLFxuXHRcdFx0VGh1OiA0LFxuXHRcdFx0RnJpOiA1LFxuXHRcdFx0U2F0OiA2XG5cdFx0fVxuXHR9LFxuXHRhcGlQYXRoczoge1xuXHRcdG5ld1JlZzogJ2h0dHBzOi8vazhzLnJlZy5rbWl0bC5hYy50aC9yZWcvYXBpLz9sZXZlbF9pZD0xJmZ1bmN0aW9uPSdcblx0fVxufTtcbiIsIihmdW5jdGlvbihhLGIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sYik7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cyliKCk7ZWxzZXtiKCksYS5GaWxlU2F2ZXI9e2V4cG9ydHM6e319LmV4cG9ydHN9fSkodGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSxiKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgYj9iPXthdXRvQm9tOiExfTpcIm9iamVjdFwiIT10eXBlb2YgYiYmKGNvbnNvbGUud2FybihcIkRlcHJlY2F0ZWQ6IEV4cGVjdGVkIHRoaXJkIGFyZ3VtZW50IHRvIGJlIGEgb2JqZWN0XCIpLGI9e2F1dG9Cb206IWJ9KSxiLmF1dG9Cb20mJi9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGEudHlwZSk/bmV3IEJsb2IoW1wiXFx1RkVGRlwiLGFdLHt0eXBlOmEudHlwZX0pOmF9ZnVuY3Rpb24gYyhhLGIsYyl7dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O2Qub3BlbihcIkdFVFwiLGEpLGQucmVzcG9uc2VUeXBlPVwiYmxvYlwiLGQub25sb2FkPWZ1bmN0aW9uKCl7ZyhkLnJlc3BvbnNlLGIsYyl9LGQub25lcnJvcj1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJjb3VsZCBub3QgZG93bmxvYWQgZmlsZVwiKX0sZC5zZW5kKCl9ZnVuY3Rpb24gZChhKXt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiSEVBRFwiLGEsITEpO3RyeXtiLnNlbmQoKX1jYXRjaChhKXt9cmV0dXJuIDIwMDw9Yi5zdGF0dXMmJjI5OT49Yi5zdGF0dXN9ZnVuY3Rpb24gZShhKXt0cnl7YS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfWNhdGNoKGMpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7Yi5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsd2luZG93LDAsMCwwLDgwLDIwLCExLCExLCExLCExLDAsbnVsbCksYS5kaXNwYXRjaEV2ZW50KGIpfX12YXIgZj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cud2luZG93PT09d2luZG93P3dpbmRvdzpcIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZi5zZWxmPT09c2VsZj9zZWxmOlwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbC5nbG9iYWw9PT1nbG9iYWw/Z2xvYmFsOnZvaWQgMCxhPWYubmF2aWdhdG9yJiYvTWFjaW50b3NoLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvQXBwbGVXZWJLaXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiEvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLGc9Zi5zYXZlQXN8fChcIm9iamVjdFwiIT10eXBlb2Ygd2luZG93fHx3aW5kb3chPT1mP2Z1bmN0aW9uKCl7fTpcImRvd25sb2FkXCJpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUmJiFhP2Z1bmN0aW9uKGIsZyxoKXt2YXIgaT1mLlVSTHx8Zi53ZWJraXRVUkwsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtnPWd8fGIubmFtZXx8XCJkb3dubG9hZFwiLGouZG93bmxvYWQ9ZyxqLnJlbD1cIm5vb3BlbmVyXCIsXCJzdHJpbmdcIj09dHlwZW9mIGI/KGouaHJlZj1iLGoub3JpZ2luPT09bG9jYXRpb24ub3JpZ2luP2Uoaik6ZChqLmhyZWYpP2MoYixnLGgpOmUoaixqLnRhcmdldD1cIl9ibGFua1wiKSk6KGouaHJlZj1pLmNyZWF0ZU9iamVjdFVSTChiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS5yZXZva2VPYmplY3RVUkwoai5ocmVmKX0sNEU0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShqKX0sMCkpfTpcIm1zU2F2ZU9yT3BlbkJsb2JcImluIG5hdmlnYXRvcj9mdW5jdGlvbihmLGcsaCl7aWYoZz1nfHxmLm5hbWV8fFwiZG93bmxvYWRcIixcInN0cmluZ1wiIT10eXBlb2YgZiluYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihiKGYsaCksZyk7ZWxzZSBpZihkKGYpKWMoZixnLGgpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7aS5ocmVmPWYsaS50YXJnZXQ9XCJfYmxhbmtcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShpKX0pfX06ZnVuY3Rpb24oYixkLGUsZyl7aWYoZz1nfHxvcGVuKFwiXCIsXCJfYmxhbmtcIiksZyYmKGcuZG9jdW1lbnQudGl0bGU9Zy5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD1cImRvd25sb2FkaW5nLi4uXCIpLFwic3RyaW5nXCI9PXR5cGVvZiBiKXJldHVybiBjKGIsZCxlKTt2YXIgaD1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiPT09Yi50eXBlLGk9L2NvbnN0cnVjdG9yL2kudGVzdChmLkhUTUxFbGVtZW50KXx8Zi5zYWZhcmksaj0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoKGp8fGgmJml8fGEpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgRmlsZVJlYWRlcil7dmFyIGs9bmV3IEZpbGVSZWFkZXI7ay5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXt2YXIgYT1rLnJlc3VsdDthPWo/YTphLnJlcGxhY2UoL15kYXRhOlteO10qOy8sXCJkYXRhOmF0dGFjaG1lbnQvZmlsZTtcIiksZz9nLmxvY2F0aW9uLmhyZWY9YTpsb2NhdGlvbj1hLGc9bnVsbH0say5yZWFkQXNEYXRhVVJMKGIpfWVsc2V7dmFyIGw9Zi5VUkx8fGYud2Via2l0VVJMLG09bC5jcmVhdGVPYmplY3RVUkwoYik7Zz9nLmxvY2F0aW9uPW06bG9jYXRpb24uaHJlZj1tLGc9bnVsbCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bC5yZXZva2VPYmplY3RVUkwobSl9LDRFNCl9fSk7Zi5zYXZlQXM9Zy5zYXZlQXM9ZyxcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiYobW9kdWxlLmV4cG9ydHM9Zyl9KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsZVNhdmVyLm1pbi5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCBuZXcgUHJveHkoe30sIHtcbiAgZ2V0KF8sIGtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlIFwiXCIgaGFzIGJlZW4gZXh0ZXJuYWxpemVkIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHkuIENhbm5vdCBhY2Nlc3MgXCIuJHtrZXl9XCIgaW4gY2xpZW50IGNvZGUuICBTZWUgaHR0cHM6Ly92aXRlLmRldi9ndWlkZS90cm91Ymxlc2hvb3RpbmcuaHRtbCNtb2R1bGUtZXh0ZXJuYWxpemVkLWZvci1icm93c2VyLWNvbXBhdGliaWxpdHkgZm9yIG1vcmUgZGV0YWlscy5gKVxuICB9XG59KSIsIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKXtcblxuICB2YXJcbiAgICBidWYsXG4gICAgYnVmSWR4ID0gMCxcbiAgICBoZXhCeXRlcyA9IFtdLFxuICAgIGlcbiAgO1xuXG4gIC8vIFByZS1jYWxjdWxhdGUgdG9TdHJpbmcoMTYpIGZvciBzcGVlZFxuICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBoZXhCeXRlc1tpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIH1cblxuICAvLyBCdWZmZXIgcmFuZG9tIG51bWJlcnMgZm9yIHNwZWVkXG4gIC8vIFJlZHVjZSBtZW1vcnkgdXNhZ2UgYnkgZGVjcmVhc2luZyB0aGlzIG51bWJlciAobWluIDE2KVxuICAvLyBvciBpbXByb3ZlIHNwZWVkIGJ5IGluY3JlYXNpbmcgdGhpcyBudW1iZXIgKHRyeSAxNjM4NClcbiAgdXVpZC5CVUZGRVJfU0laRSA9IDQwOTY7XG5cbiAgLy8gQmluYXJ5IHV1aWRzXG4gIHV1aWQuYmluID0gdXVpZEJpbjtcblxuICAvLyBDbGVhciBidWZmZXJcbiAgdXVpZC5jbGVhckJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGJ1ZiA9IG51bGw7XG4gICAgYnVmSWR4ID0gMDtcbiAgfTtcblxuICAvLyBUZXN0IGZvciB1dWlkXG4gIHV1aWQudGVzdCA9IGZ1bmN0aW9uKHV1aWQpIHtcbiAgICBpZiAodHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS00WzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JC9pLnRlc3QodXVpZCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBOb2RlICYgQnJvd3NlciBzdXBwb3J0XG4gIHZhciBjcnlwdDA7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNyeXB0MCA9IGNyeXB0bztcbiAgfSBlbHNlIGlmKCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICBjcnlwdDAgPSB3aW5kb3cubXNDcnlwdG87IC8vIElFMTFcbiAgfVxuXG4gIGlmICgodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjcnlwdDAgPSBjcnlwdDAgfHwgcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnV1aWQgPSB1dWlkO1xuICB9XG5cbiAgLy8gVXNlIGJlc3QgYXZhaWxhYmxlIFBSTkdcbiAgLy8gQWxzbyBleHBvc2UgdGhpcyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0LlxuICB1dWlkLnJhbmRvbUJ5dGVzID0gKGZ1bmN0aW9uKCl7XG4gICAgaWYgKGNyeXB0MCkge1xuICAgICAgaWYgKGNyeXB0MC5yYW5kb21CeXRlcykge1xuICAgICAgICByZXR1cm4gY3J5cHQwLnJhbmRvbUJ5dGVzO1xuICAgICAgfVxuICAgICAgaWYgKGNyeXB0MC5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICAgIGNyeXB0MC5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICBjcnlwdDAuZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgaSwgciA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICByLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8vIEJ1ZmZlciBzb21lIHJhbmRvbSBieXRlcyBmb3Igc3BlZWRcbiAgZnVuY3Rpb24gcmFuZG9tQnl0ZXNCdWZmZXJlZChuKSB7XG4gICAgaWYgKCFidWYgfHwgKChidWZJZHggKyBuKSA+IHV1aWQuQlVGRkVSX1NJWkUpKSB7XG4gICAgICBidWZJZHggPSAwO1xuICAgICAgYnVmID0gdXVpZC5yYW5kb21CeXRlcyh1dWlkLkJVRkZFUl9TSVpFKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5zbGljZShidWZJZHgsIGJ1ZklkeCArPSBuKTtcbiAgfVxuXG4gIC8vIHV1aWQuYmluXG4gIGZ1bmN0aW9uIHV1aWRCaW4oKSB7XG4gICAgdmFyIGIgPSByYW5kb21CeXRlc0J1ZmZlcmVkKDE2KTtcbiAgICBiWzZdID0gKGJbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgYls4XSA9IChiWzhdICYgMHgzZikgfCAweDgwO1xuICAgIHJldHVybiBiO1xuICB9XG5cbiAgLy8gU3RyaW5nIFVVSUR2NCAoUmFuZG9tKVxuICBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHZhciBiID0gdXVpZEJpbigpO1xuICAgIHJldHVybiBoZXhCeXRlc1tiWzBdXSArIGhleEJ5dGVzW2JbMV1dICtcbiAgICAgIGhleEJ5dGVzW2JbMl1dICsgaGV4Qnl0ZXNbYlszXV0gKyAnLScgK1xuICAgICAgaGV4Qnl0ZXNbYls0XV0gKyBoZXhCeXRlc1tiWzVdXSArICctJyArXG4gICAgICBoZXhCeXRlc1tiWzZdXSArIGhleEJ5dGVzW2JbN11dICsgJy0nICtcbiAgICAgIGhleEJ5dGVzW2JbOF1dICsgaGV4Qnl0ZXNbYls5XV0gKyAnLScgK1xuICAgICAgaGV4Qnl0ZXNbYlsxMF1dICsgaGV4Qnl0ZXNbYlsxMV1dICtcbiAgICAgIGhleEJ5dGVzW2JbMTJdXSArIGhleEJ5dGVzW2JbMTNdXSArXG4gICAgICBoZXhCeXRlc1tiWzE0XV0gKyBoZXhCeXRlc1tiWzE1XV1cbiAgICA7XG4gIH1cblxufSkoKTtcbiIsInZhciBiPSh1PT4odS5TRUNPTkRMWT1cIlNFQ09ORExZXCIsdS5NSU5VVEVMWT1cIk1JTlVURUxZXCIsdS5IT1VSTFk9XCJIT1VSTFlcIix1LkRBSUxZPVwiREFJTFlcIix1LldFRUtMWT1cIldFRUtMWVwiLHUuTU9OVEhMWT1cIk1PTlRITFlcIix1LllFQVJMWT1cIllFQVJMWVwiLHUpKShifHx7fSksQT0odT0+KHUuU1U9XCJTVVwiLHUuTU89XCJNT1wiLHUuVFU9XCJUVVwiLHUuV0U9XCJXRVwiLHUuVEg9XCJUSFwiLHUuRlI9XCJGUlwiLHUuU0E9XCJTQVwiLHUpKShBfHx7fSk7ZnVuY3Rpb24gbyhhLHQsZSxuKXtpZihhPy5zdGFydHNXaXRoKFwiL1wiKSYmKGE9YS5zdWJzdHIoMSkpLHR5cGVvZiB0PT1cInN0cmluZ1wifHx0IGluc3RhbmNlb2YgRGF0ZSl7bGV0IGk9bmV3IERhdGUodCkscz1pLmdldFVUQ0Z1bGxZZWFyKCkrU3RyaW5nKGkuZ2V0VVRDTW9udGgoKSsxKS5wYWRTdGFydCgyLFwiMFwiKStpLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsXCIwXCIpO3JldHVybiBhJiYocz1pLmdldEZ1bGxZZWFyKCkrU3RyaW5nKGkuZ2V0TW9udGgoKSsxKS5wYWRTdGFydCgyLFwiMFwiKStpLmdldERhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsXCIwXCIpKSxlP3M6YT8ocys9XCJUXCIraS5nZXRIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMixcIjBcIikraS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLFwiMFwiKStpLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsXCIwXCIpLHMpOihzKz1cIlRcIitpLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLFwiMFwiKStpLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsXCIwXCIpK2kuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMixcIjBcIikrKG4/XCJcIjpcIlpcIikscyl9ZWxzZSBpZihTKHQpKXtsZXQgaT1hP0YodCkmJiF0LnR6KCk/dC5jbG9uZSgpLnR6KGEpOnQ6bnx8ZSYmRih0KSYmdC50eigpP3Q6dC51dGMoKTtyZXR1cm4gaS5mb3JtYXQoXCJZWVlZTU1ERFwiKSsoZT9cIlwiOlwiVFwiK2kuZm9ybWF0KFwiSEhtbXNzXCIpKyhufHxhP1wiXCI6XCJaXCIpKX1lbHNlIGlmKFIodCkpe2xldCBpPWE/dC5zZXRab25lKGEpOm58fGUmJnQuem9uZS50eXBlIT09XCJzeXN0ZW1cIj90OnQuc2V0Wm9uZShcInV0Y1wiKTtyZXR1cm4gaS50b0Zvcm1hdChcInl5eXlMTGRkXCIpKyhlP1wiXCI6XCJUXCIraS50b0Zvcm1hdChcIkhIbW1zc1wiKSsobnx8YT9cIlwiOlwiWlwiKSl9ZWxzZXtsZXQgaT10O2lmKGEpaT10eXBlb2YgdC50ej09XCJmdW5jdGlvblwiP3QudHooYSk6dDtlbHNlIGlmKCFuKWlmKHR5cGVvZiB0LnV0Yz09XCJmdW5jdGlvblwiKWk9dC51dGMoKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb252ZXJ0IGRheWpzIG9iamVjdCB0byBVVEMgdmFsdWU6IFVUQyBwbHVnaW4gaXMgbm90IGF2YWlsYWJsZSFcIik7cmV0dXJuIGkuZm9ybWF0KFwiWVlZWU1NRERcIikrKGU/XCJcIjpcIlRcIitpLmZvcm1hdChcIkhIbW1zc1wiKSsobnx8YT9cIlwiOlwiWlwiKSl9fWZ1bmN0aW9uIEUoYSx0LGUsbil7bGV0IGk9XCJcIixzPW4/LmZsb2F0aW5nfHwhMTtyZXR1cm4gbj8udGltZXpvbmUmJihpPVwiO1RaSUQ9XCIrbi50aW1lem9uZSxzPSEwKSx0K2krXCI6XCIrbyhhLGUsITEscyl9ZnVuY3Rpb24gcihhLHQpe3JldHVybiBTdHJpbmcoYSkucmVwbGFjZSh0Py9bXFxcXFwiXS9nOi9bXFxcXDssXS9nLGZ1bmN0aW9uKGUpe3JldHVyblwiXFxcXFwiK2V9KS5yZXBsYWNlKC8oPzpcXHJcXG58XFxyfFxcbikvZyxcIlxcXFxuXCIpfWZ1bmN0aW9uIHYoYSl7cmV0dXJuIGEuc3BsaXQoYFxcclxuYCkubWFwKGZ1bmN0aW9uKHQpe2xldCBlPVwiXCIsbj0wO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtsZXQgcz10LmNoYXJBdChpKTtzPj1cIlxcdUQ4MDBcIiYmczw9XCJcXHVEQkZGXCImJihzKz10LmNoYXJBdCgrK2kpKTtsZXQgaz1uZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocykubGVuZ3RoO24rPWssbj43NCYmKGUrPWBcXHJcbiBgLG49ayksZSs9c31yZXR1cm4gZX0pLmpvaW4oYFxcclxuYCl9ZnVuY3Rpb24gbChhLHQsZSl7aWYoQXJyYXkuaXNBcnJheSh0KSlhLng9dC5tYXAobj0+e2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIG47aWYodHlwZW9mIG4ua2V5IT1cInN0cmluZ1wifHx0eXBlb2Ygbi52YWx1ZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIga2V5IG9yIHZhbHVlIGlzIG5vdCBhIHN0cmluZyFcIik7aWYobi5rZXkuc3Vic3RyKDAsMikhPT1cIlgtXCIpdGhyb3cgbmV3IEVycm9yKFwiS2V5IGhhcyB0byBzdGFydCB3aXRoIGBYLWAhXCIpO3JldHVybltuLmtleSxuLnZhbHVlXX0pO2Vsc2UgaWYodHlwZW9mIHQ9PVwib2JqZWN0XCIpYS54PU9iamVjdC5lbnRyaWVzKHQpLm1hcCgoW24saV0pPT57aWYodHlwZW9mIG4hPVwic3RyaW5nXCJ8fHR5cGVvZiBpIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIkVpdGhlciBrZXkgb3IgdmFsdWUgaXMgbm90IGEgc3RyaW5nIVwiKTtpZihuLnN1YnN0cigwLDIpIT09XCJYLVwiKXRocm93IG5ldyBFcnJvcihcIktleSBoYXMgdG8gc3RhcnQgd2l0aCBgWC1gIVwiKTtyZXR1cm5bbixpXX0pO2Vsc2UgaWYodHlwZW9mIHQ9PVwic3RyaW5nXCImJnR5cGVvZiBlPT1cInN0cmluZ1wiKXtpZih0LnN1YnN0cigwLDIpIT09XCJYLVwiKXRocm93IG5ldyBFcnJvcihcIktleSBoYXMgdG8gc3RhcnQgd2l0aCBgWC1gIVwiKTthLngucHVzaChbdCxlXSl9ZWxzZSByZXR1cm4gYS54Lm1hcChuPT4oe2tleTpuWzBdLHZhbHVlOm5bMV19KSl9ZnVuY3Rpb24gRChhKXtsZXQgdD1hLngubWFwKChbZSxuXSk9PmUudG9VcHBlckNhc2UoKStcIjpcIityKG4sITEpKS5qb2luKGBcXHJcbmApO3JldHVybiB0Lmxlbmd0aD90K2BcXHJcbmA6XCJcIn1mdW5jdGlvbiBwKGEsdCl7bGV0IGU9bnVsbDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil7bGV0IG49dC5tYXRjaCgvXiguKykgPzwoW14+XSspPiQvKTtuP2U9e25hbWU6blsxXS50cmltKCksZW1haWw6blsyXS50cmltKCl9OnQuaW5jbHVkZXMoXCJAXCIpJiYoZT17bmFtZTp0LnRyaW0oKSxlbWFpbDp0LnRyaW0oKX0pfWVsc2UgdHlwZW9mIHQ9PVwib2JqZWN0XCImJihlPXtuYW1lOnQubmFtZSxlbWFpbDp0LmVtYWlsLG1haWx0bzp0Lm1haWx0byxzZW50Qnk6dC5zZW50Qnl9KTtpZighZSYmdHlwZW9mIHQ9PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiYFwiK2ErXCJgIGlzbid0IGZvcm1hdGVkIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc2ViYm8yMDAyLmdpdGh1Yi5pby9pY2FsLWdlbmVyYXRvci9kZXZlbG9wL3JlZmVyZW5jZS9pbnRlcmZhY2VzL0lDYWxPcmdhbml6ZXIuaHRtbFwiKTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJgXCIrYStcImAgbmVlZHMgdG8gYmUgYSB2YWxpZCBmb3JtZWQgc3RyaW5nIG9yIGFuIG9iamVjdC4gU2VlIGh0dHBzOi8vc2ViYm8yMDAyLmdpdGh1Yi5pby9pY2FsLWdlbmVyYXRvci9kZXZlbG9wL3JlZmVyZW5jZS9pbnRlcmZhY2VzL0lDYWxPcmdhbml6ZXIuaHRtbFwiKTtpZighZS5uYW1lKXRocm93IG5ldyBFcnJvcihcImBcIithK1wiLm5hbWVgIGlzIGVtcHR5IVwiKTtyZXR1cm4gZX1mdW5jdGlvbiBkKGEsdCl7bGV0IGU9T2JqZWN0LnZhbHVlcyhhKSxuPVN0cmluZyh0KS50b1VwcGVyQ2FzZSgpO2lmKCFufHwhZS5pbmNsdWRlcyhuKSl0aHJvdyBuZXcgRXJyb3IoYElucHV0IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6ICR7ZS5qb2luKFwiLCBcIil9YCk7cmV0dXJuIG59ZnVuY3Rpb24gaChhLHQpe2lmKGEgaW5zdGFuY2VvZiBEYXRlJiZpc05hTihhLmdldFRpbWUoKSl8fHR5cGVvZiBhPT1cInN0cmluZ1wiJiZpc05hTihuZXcgRGF0ZShhKS5nZXRUaW1lKCkpKXRocm93IG5ldyBFcnJvcihgXFxgJHt0fVxcYCBoYXMgdG8gYmUgYSB2YWxpZCBkYXRlIWApO2lmKGEgaW5zdGFuY2VvZiBEYXRlfHx0eXBlb2YgYT09XCJzdHJpbmdcInx8UihhKSYmYS5pc1ZhbGlkPT09ITB8fChTKGEpfHxqKGEpKSYmYS5pc1ZhbGlkKCkpcmV0dXJuIGE7dGhyb3cgbmV3IEVycm9yKGBcXGAke3R9XFxgIGhhcyB0byBiZSBhIHZhbGlkIGRhdGUhYCl9ZnVuY3Rpb24gTihhKXtyZXR1cm4gdHlwZW9mIGE9PVwic3RyaW5nXCJ8fGEgaW5zdGFuY2VvZiBEYXRlP25ldyBEYXRlKGEpOlIoYSk/YS50b0pTRGF0ZSgpOmEudG9EYXRlKCl9ZnVuY3Rpb24gUyhhKXtyZXR1cm4gYSE9bnVsbCYmYS5faXNBTW9tZW50T2JqZWN0IT1udWxsfWZ1bmN0aW9uIEYoYSl7cmV0dXJuIFMoYSkmJlwidHpcImluIGEmJnR5cGVvZiBhLnR6PT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gaihhKXtyZXR1cm4gdHlwZW9mIGE9PVwib2JqZWN0XCImJmEhPT1udWxsJiYhKGEgaW5zdGFuY2VvZiBEYXRlKSYmIVMoYSkmJiFSKGEpfWZ1bmN0aW9uIFIoYSl7cmV0dXJuIHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhIT09bnVsbCYmXCJ0b0pTRGF0ZVwiaW4gYSYmdHlwZW9mIGEudG9KU0RhdGU9PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBKKGEpe3JldHVybiBhIT09bnVsbCYmdHlwZW9mIGE9PVwib2JqZWN0XCImJlwiYXNTZWNvbmRzXCJpbiBhJiZ0eXBlb2YgYS5hc1NlY29uZHM9PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiB4KGEpe3JldHVybiBhIT09bnVsbCYmdHlwZW9mIGE9PVwib2JqZWN0XCImJlwiYmV0d2VlblwiaW4gYSYmdHlwZW9mIGEuYmV0d2Vlbj09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYS50b1N0cmluZz09XCJmdW5jdGlvblwifWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGE/dHlwZW9mIGE9PVwic3RyaW5nXCI/YTphLnRvSlNPTigpOm51bGx9ZnVuY3Rpb24gQyhhKXtsZXQgdD1cIlwiO3JldHVybiBhPDAmJih0PVwiLVwiLGEqPS0xKSx0Kz1cIlBcIixhPj04NjQwMCYmKHQrPU1hdGguZmxvb3IoYS84NjQwMCkrXCJEXCIsYSU9ODY0MDApLCFhJiZ0Lmxlbmd0aD4xfHwodCs9XCJUXCIsYT49MzYwMCYmKHQrPU1hdGguZmxvb3IoYS8zNjAwKStcIkhcIixhJT0zNjAwKSxhPj02MCYmKHQrPU1hdGguZmxvb3IoYS82MCkrXCJNXCIsYSU9NjApLGE+MD90Kz1hK1wiU1wiOnQubGVuZ3RoPD0yJiYodCs9XCIwU1wiKSksdH1pbXBvcnQgRyBmcm9tXCJ1dWlkLXJhbmRvbVwiO3ZhciBPPShpPT4oaS5DSEFJUj1cIkNIQUlSXCIsaS5SRVE9XCJSRVEtUEFSVElDSVBBTlRcIixpLk9QVD1cIk9QVC1QQVJUSUNJUEFOVFwiLGkuTk9OPVwiTk9OLVBBUlRJQ0lQQU5UXCIsaSkpKE98fHt9KSxNPShzPT4ocy5BQ0NFUFRFRD1cIkFDQ0VQVEVEXCIscy5URU5UQVRJVkU9XCJURU5UQVRJVkVcIixzLkRFQ0xJTkVEPVwiREVDTElORURcIixzLkRFTEVHQVRFRD1cIkRFTEVHQVRFRFwiLHMuTkVFRFNBQ1RJT049XCJORUVEUy1BQ1RJT05cIixzKSkoTXx8e30pLHc9KHM9PihzLklORElWSURVQUw9XCJJTkRJVklEVUFMXCIscy5HUk9VUD1cIkdST1VQXCIscy5SRVNPVVJDRT1cIlJFU09VUkNFXCIscy5ST09NPVwiUk9PTVwiLHMuVU5LTk9XTj1cIlVOS05PV05cIixzKSkod3x8e30pLGY9Y2xhc3MgYXtkYXRhO3BhcmVudDtjb25zdHJ1Y3Rvcih0LGUpe2lmKHRoaXMuZGF0YT17bmFtZTpudWxsLGVtYWlsOlwiXCIsbWFpbHRvOm51bGwsc2VudEJ5Om51bGwsc3RhdHVzOm51bGwscm9sZTpcIlJFUS1QQVJUSUNJUEFOVFwiLHJzdnA6bnVsbCx0eXBlOm51bGwsZGVsZWdhdGVkVG86bnVsbCxkZWxlZ2F0ZWRGcm9tOm51bGwseDpbXX0sdGhpcy5wYXJlbnQ9ZSwhdGhpcy5wYXJlbnQpdGhyb3cgbmV3IEVycm9yKFwiYGV2ZW50YCBvcHRpb24gcmVxdWlyZWQhXCIpO2lmKCF0LmVtYWlsKXRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIGZvciBgZW1haWxgIGluIElDYWxBdHRlbmRlZSBnaXZlbiFcIik7dC5uYW1lIT09dm9pZCAwJiZ0aGlzLm5hbWUodC5uYW1lKSx0LmVtYWlsIT09dm9pZCAwJiZ0aGlzLmVtYWlsKHQuZW1haWwpLHQubWFpbHRvIT09dm9pZCAwJiZ0aGlzLm1haWx0byh0Lm1haWx0byksdC5zZW50QnkhPT12b2lkIDAmJnRoaXMuc2VudEJ5KHQuc2VudEJ5KSx0LnN0YXR1cyE9PXZvaWQgMCYmdGhpcy5zdGF0dXModC5zdGF0dXMpLHQucm9sZSE9PXZvaWQgMCYmdGhpcy5yb2xlKHQucm9sZSksdC5yc3ZwIT09dm9pZCAwJiZ0aGlzLnJzdnAodC5yc3ZwKSx0LnR5cGUhPT12b2lkIDAmJnRoaXMudHlwZSh0LnR5cGUpLHQuZGVsZWdhdGVkVG8hPT12b2lkIDAmJnRoaXMuZGVsZWdhdGVkVG8odC5kZWxlZ2F0ZWRUbyksdC5kZWxlZ2F0ZWRGcm9tIT09dm9pZCAwJiZ0aGlzLmRlbGVnYXRlZEZyb20odC5kZWxlZ2F0ZWRGcm9tKSx0LmRlbGVnYXRlc1RvJiZ0aGlzLmRlbGVnYXRlc1RvKHQuZGVsZWdhdGVzVG8pLHQuZGVsZWdhdGVzRnJvbSYmdGhpcy5kZWxlZ2F0ZXNGcm9tKHQuZGVsZWdhdGVzRnJvbSksdC54IT09dm9pZCAwJiZ0aGlzLngodC54KX1uYW1lKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5uYW1lOih0aGlzLmRhdGEubmFtZT10fHxudWxsLHRoaXMpfWVtYWlsKHQpe3JldHVybiB0Pyh0aGlzLmRhdGEuZW1haWw9dCx0aGlzKTp0aGlzLmRhdGEuZW1haWx9bWFpbHRvKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5tYWlsdG86KHRoaXMuZGF0YS5tYWlsdG89dHx8bnVsbCx0aGlzKX1zZW50QnkodCl7cmV0dXJuIHQ/KHRoaXMuZGF0YS5zZW50Qnk9dCx0aGlzKTp0aGlzLmRhdGEuc2VudEJ5fXJvbGUodCl7cmV0dXJuIHQ9PT12b2lkIDA/dGhpcy5kYXRhLnJvbGU6KHRoaXMuZGF0YS5yb2xlPWQoTyx0KSx0aGlzKX1yc3ZwKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5yc3ZwOnQ9PT1udWxsPyh0aGlzLmRhdGEucnN2cD1udWxsLHRoaXMpOih0aGlzLmRhdGEucnN2cD0hIXQsdGhpcyl9c3RhdHVzKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5zdGF0dXM6dD8odGhpcy5kYXRhLnN0YXR1cz1kKE0sdCksdGhpcyk6KHRoaXMuZGF0YS5zdGF0dXM9bnVsbCx0aGlzKX10eXBlKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS50eXBlOnQ/KHRoaXMuZGF0YS50eXBlPWQodyx0KSx0aGlzKToodGhpcy5kYXRhLnR5cGU9bnVsbCx0aGlzKX1kZWxlZ2F0ZWRUbyh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuZGVsZWdhdGVkVG86dD8odHlwZW9mIHQ9PVwic3RyaW5nXCI/dGhpcy5kYXRhLmRlbGVnYXRlZFRvPW5ldyBhKHtlbWFpbDp0LC4uLnAoXCJkZWxlZ2F0ZWRUb1wiLHQpfSx0aGlzLnBhcmVudCk6dCBpbnN0YW5jZW9mIGE/dGhpcy5kYXRhLmRlbGVnYXRlZFRvPXQ6dGhpcy5kYXRhLmRlbGVnYXRlZFRvPW5ldyBhKHQsdGhpcy5wYXJlbnQpLHRoaXMuZGF0YS5zdGF0dXM9XCJERUxFR0FURURcIix0aGlzKToodGhpcy5kYXRhLmRlbGVnYXRlZFRvPW51bGwsdGhpcy5kYXRhLnN0YXR1cz09PVwiREVMRUdBVEVEXCImJih0aGlzLmRhdGEuc3RhdHVzPW51bGwpLHRoaXMpfWRlbGVnYXRlZEZyb20odCl7cmV0dXJuIHQ9PT12b2lkIDA/dGhpcy5kYXRhLmRlbGVnYXRlZEZyb206KHQ/dHlwZW9mIHQ9PVwic3RyaW5nXCI/dGhpcy5kYXRhLmRlbGVnYXRlZEZyb209bmV3IGEoe2VtYWlsOnQsLi4ucChcImRlbGVnYXRlZEZyb21cIix0KX0sdGhpcy5wYXJlbnQpOnQgaW5zdGFuY2VvZiBhP3RoaXMuZGF0YS5kZWxlZ2F0ZWRGcm9tPXQ6dGhpcy5kYXRhLmRlbGVnYXRlZEZyb209bmV3IGEodCx0aGlzLnBhcmVudCk6dGhpcy5kYXRhLmRlbGVnYXRlZEZyb209bnVsbCx0aGlzKX1kZWxlZ2F0ZXNUbyh0KXtsZXQgZT10IGluc3RhbmNlb2YgYT90OnRoaXMucGFyZW50LmNyZWF0ZUF0dGVuZGVlKHQpO3JldHVybiB0aGlzLmRlbGVnYXRlZFRvKGUpLGUuZGVsZWdhdGVkRnJvbSh0aGlzKSxlfWRlbGVnYXRlc0Zyb20odCl7bGV0IGU9dCBpbnN0YW5jZW9mIGE/dDp0aGlzLnBhcmVudC5jcmVhdGVBdHRlbmRlZSh0KTtyZXR1cm4gdGhpcy5kZWxlZ2F0ZWRGcm9tKGUpLGUuZGVsZWdhdGVkVG8odGhpcyksZX14KHQsZSl7aWYodD09PXZvaWQgMClyZXR1cm4gbCh0aGlzLmRhdGEpO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiJiZ0eXBlb2YgZT09XCJzdHJpbmdcIilsKHRoaXMuZGF0YSx0LGUpO2Vsc2UgaWYodHlwZW9mIHQ9PVwib2JqZWN0XCIpbCh0aGlzLmRhdGEsdCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIga2V5IG9yIHZhbHVlIGlzIG5vdCBhIHN0cmluZyFcIik7cmV0dXJuIHRoaXN9dG9KU09OKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sdGhpcy5kYXRhLHtkZWxlZ2F0ZWRUbzp0aGlzLmRhdGEuZGVsZWdhdGVkVG8/LmVtYWlsKCl8fG51bGwsZGVsZWdhdGVkRnJvbTp0aGlzLmRhdGEuZGVsZWdhdGVkRnJvbT8uZW1haWwoKXx8bnVsbCx4OnRoaXMueCgpfSl9dG9TdHJpbmcoKXtsZXQgdD1cIkFUVEVOREVFXCI7aWYoIXRoaXMuZGF0YS5lbWFpbCl0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWx1ZSBmb3IgYGVtYWlsYCBpbiBJQ2FsQXR0ZW5kZWUgZ2l2ZW4hXCIpO3JldHVybiB0Kz1cIjtST0xFPVwiK3RoaXMuZGF0YS5yb2xlLHRoaXMuZGF0YS50eXBlJiYodCs9XCI7Q1VUWVBFPVwiK3RoaXMuZGF0YS50eXBlKSx0aGlzLmRhdGEuc3RhdHVzJiYodCs9XCI7UEFSVFNUQVQ9XCIrdGhpcy5kYXRhLnN0YXR1cyksdGhpcy5kYXRhLnJzdnAhPT1udWxsJiYodCs9XCI7UlNWUD1cIit0aGlzLmRhdGEucnN2cC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkpLHRoaXMuZGF0YS5zZW50QnkhPT1udWxsJiYodCs9JztTRU5ULUJZPVwibWFpbHRvOicrdGhpcy5kYXRhLnNlbnRCeSsnXCInKSx0aGlzLmRhdGEuZGVsZWdhdGVkVG8mJih0Kz0nO0RFTEVHQVRFRC1UTz1cIicrdGhpcy5kYXRhLmRlbGVnYXRlZFRvLmVtYWlsKCkrJ1wiJyksdGhpcy5kYXRhLmRlbGVnYXRlZEZyb20mJih0Kz0nO0RFTEVHQVRFRC1GUk9NPVwiJyt0aGlzLmRhdGEuZGVsZWdhdGVkRnJvbS5lbWFpbCgpKydcIicpLHRoaXMuZGF0YS5uYW1lJiYodCs9JztDTj1cIicrcih0aGlzLmRhdGEubmFtZSwhMCkrJ1wiJyksdGhpcy5kYXRhLmVtYWlsJiZ0aGlzLmRhdGEubWFpbHRvJiYodCs9XCI7RU1BSUw9XCIrcih0aGlzLmRhdGEuZW1haWwsITEpKSx0aGlzLmRhdGEueC5sZW5ndGgmJih0Kz1cIjtcIit0aGlzLmRhdGEueC5tYXAoKFtlLG5dKT0+ZS50b1VwcGVyQ2FzZSgpK1wiPVwiK3IobiwhMSkpLmpvaW4oXCI7XCIpKSx0Kz1cIjpNQUlMVE86XCIrcih0aGlzLmRhdGEubWFpbHRvfHx0aGlzLmRhdGEuZW1haWwsITEpK2BcXHJcbmAsdH19O3ZhciBWPShuPT4obi5kaXNwbGF5PVwiZGlzcGxheVwiLG4uYXVkaW89XCJhdWRpb1wiLG4uZW1haWw9XCJlbWFpbFwiLG4pKShWfHx7fSksWT17ZW5kOlwiRU5EXCIsc3RhcnQ6XCJTVEFSVFwifSxJPWNsYXNze2RhdGE7ZXZlbnQ7Y29uc3RydWN0b3IodCxlKXtpZih0aGlzLmRhdGE9e3R5cGU6XCJkaXNwbGF5XCIsdHJpZ2dlcjotNjAwLHJlbGF0ZXNUbzpudWxsLHJlcGVhdDpudWxsLGludGVydmFsOm51bGwsYXR0YWNoOm51bGwsZGVzY3JpcHRpb246bnVsbCxzdW1tYXJ5Om51bGwsYXR0ZW5kZWVzOltdLHg6W119LHRoaXMuZXZlbnQ9ZSwhZSl0aHJvdyBuZXcgRXJyb3IoXCJgZXZlbnRgIG9wdGlvbiByZXF1aXJlZCFcIik7dC50eXBlIT09dm9pZCAwJiZ0aGlzLnR5cGUodC50eXBlKSxcInRyaWdnZXJcImluIHQmJnQudHJpZ2dlciE9PXZvaWQgMCYmdGhpcy50cmlnZ2VyKHQudHJpZ2dlciksXCJ0cmlnZ2VyQmVmb3JlXCJpbiB0JiZ0LnRyaWdnZXJCZWZvcmUhPT12b2lkIDAmJnRoaXMudHJpZ2dlckJlZm9yZSh0LnRyaWdnZXJCZWZvcmUpLFwidHJpZ2dlckFmdGVyXCJpbiB0JiZ0LnRyaWdnZXJBZnRlciE9PXZvaWQgMCYmdGhpcy50cmlnZ2VyQWZ0ZXIodC50cmlnZ2VyQWZ0ZXIpLHQucmVwZWF0JiZ0aGlzLnJlcGVhdCh0LnJlcGVhdCksdC5hdHRhY2ghPT12b2lkIDAmJnRoaXMuYXR0YWNoKHQuYXR0YWNoKSx0LmRlc2NyaXB0aW9uIT09dm9pZCAwJiZ0aGlzLmRlc2NyaXB0aW9uKHQuZGVzY3JpcHRpb24pLHQuc3VtbWFyeSE9PXZvaWQgMCYmdGhpcy5zdW1tYXJ5KHQuc3VtbWFyeSksdC5hdHRlbmRlZXMhPT12b2lkIDAmJnRoaXMuYXR0ZW5kZWVzKHQuYXR0ZW5kZWVzKSx0LnghPT12b2lkIDAmJnRoaXMueCh0LngpfXR5cGUodCl7aWYodD09PXZvaWQgMClyZXR1cm4gdGhpcy5kYXRhLnR5cGU7aWYoIXR8fCFPYmplY3Qua2V5cyhWKS5pbmNsdWRlcyh0KSl0aHJvdyBuZXcgRXJyb3IoXCJgdHlwZWAgaXMgbm90IGNvcnJlY3QsIG11c3QgYmUgZWl0aGVyIGBkaXNwbGF5YCBvciBgYXVkaW9gIVwiKTtyZXR1cm4gdGhpcy5kYXRhLnR5cGU9dCx0aGlzfXRyaWdnZXIodCl7aWYodD09PXZvaWQgMCYmdHlwZW9mIHRoaXMuZGF0YS50cmlnZ2VyPT1cIm51bWJlclwiKXJldHVybi0xKnRoaXMuZGF0YS50cmlnZ2VyO2lmKHQ9PT12b2lkIDApcmV0dXJuIHRoaXMuZGF0YS50cmlnZ2VyO2lmKHR5cGVvZiB0PT1cIm51bWJlclwiJiZpc0Zpbml0ZSh0KSl0aGlzLmRhdGEudHJpZ2dlcj0tMSp0O2Vsc2V7aWYoIXR8fHR5cGVvZiB0PT1cIm51bWJlclwiKXRocm93IG5ldyBFcnJvcihcImB0cmlnZ2VyYCBpcyBub3QgY29ycmVjdCwgbXVzdCBiZSBhIGZpbml0ZSBudW1iZXIgb3IgYSBzdXBwb3J0ZWQgZGF0ZSFcIik7dGhpcy5kYXRhLnRyaWdnZXI9aCh0LFwidHJpZ2dlclwiKX1yZXR1cm4gdGhpc31yZWxhdGVzVG8odCl7aWYodD09PXZvaWQgMClyZXR1cm4gdGhpcy5kYXRhLnJlbGF0ZXNUbztpZighdClyZXR1cm4gdGhpcy5kYXRhLnJlbGF0ZXNUbz1udWxsLHRoaXM7aWYoIU9iamVjdC52YWx1ZXMoWSkuaW5jbHVkZXModCkpdGhyb3cgbmV3IEVycm9yKFwiYHJlbGF0ZXNUb2AgaXMgbm90IGNvcnJlY3QsIG11c3QgYmUgZWl0aGVyIGBTVEFSVGAgb3IgYEVORGAhXCIpO3JldHVybiB0aGlzLmRhdGEucmVsYXRlc1RvPXQsdGhpc310cmlnZ2VyQWZ0ZXIodCl7cmV0dXJuIHQ9PT12b2lkIDA/dGhpcy5kYXRhLnRyaWdnZXI6dGhpcy50cmlnZ2VyKHR5cGVvZiB0PT1cIm51bWJlclwiPy0xKnQ6dCl9dHJpZ2dlckJlZm9yZSh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLnRyaWdnZXIoKTp0aGlzLnRyaWdnZXIodCl9cmVwZWF0KHQpe2lmKHQ9PT12b2lkIDApcmV0dXJuIHRoaXMuZGF0YS5yZXBlYXQ7aWYoIXQpcmV0dXJuIHRoaXMuZGF0YS5yZXBlYXQ9bnVsbCx0aGlzO2lmKHR5cGVvZiB0IT1cIm9iamVjdFwiKXRocm93IG5ldyBFcnJvcihcImByZXBlYXRgIGlzIG5vdCBjb3JyZWN0LCBtdXN0IGJlIGFuIG9iamVjdCFcIik7aWYodHlwZW9mIHQudGltZXMhPVwibnVtYmVyXCJ8fCFpc0Zpbml0ZSh0LnRpbWVzKSl0aHJvdyBuZXcgRXJyb3IoXCJgcmVwZWF0LnRpbWVzYCBpcyBub3QgY29ycmVjdCwgbXVzdCBiZSBudW1lcmljIVwiKTtpZih0eXBlb2YgdC5pbnRlcnZhbCE9XCJudW1iZXJcInx8IWlzRmluaXRlKHQuaW50ZXJ2YWwpKXRocm93IG5ldyBFcnJvcihcImByZXBlYXQuaW50ZXJ2YWxgIGlzIG5vdCBjb3JyZWN0LCBtdXN0IGJlIG51bWVyaWMhXCIpO3JldHVybiB0aGlzLmRhdGEucmVwZWF0PXQsdGhpc31hdHRhY2godCl7aWYodD09PXZvaWQgMClyZXR1cm4gdGhpcy5kYXRhLmF0dGFjaDtpZighdClyZXR1cm4gdGhpcy5kYXRhLmF0dGFjaD1udWxsLHRoaXM7bGV0IGU9bnVsbDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIillPXt1cmk6dCxtaW1lOm51bGx9O2Vsc2UgaWYodHlwZW9mIHQ9PVwib2JqZWN0XCIpZT17dXJpOnQudXJpLG1pbWU6dC5taW1lfHxudWxsfTtlbHNlIHRocm93IG5ldyBFcnJvcihcImBhdHRhY2htZW50YCBuZWVkcyB0byBiZSBhIHZhbGlkIGZvcm1lZCBzdHJpbmcgb3IgYW4gb2JqZWN0LiBTZWUgaHR0cHM6Ly9zZWJibzIwMDIuZ2l0aHViLmlvL2ljYWwtZ2VuZXJhdG9yL2RldmVsb3AvcmVmZXJlbmNlL2NsYXNzZXMvSUNhbEFsYXJtLmh0bWwjYXR0YWNoXCIpO2lmKCFlLnVyaSl0aHJvdyBuZXcgRXJyb3IoXCJgYXR0YWNoLnVyaWAgaXMgZW1wdHkhXCIpO3JldHVybiB0aGlzLmRhdGEuYXR0YWNoPXt1cmk6ZS51cmksbWltZTplLm1pbWV9LHRoaXN9ZGVzY3JpcHRpb24odCl7cmV0dXJuIHQ9PT12b2lkIDA/dGhpcy5kYXRhLmRlc2NyaXB0aW9uOnQ/KHRoaXMuZGF0YS5kZXNjcmlwdGlvbj10LHRoaXMpOih0aGlzLmRhdGEuZGVzY3JpcHRpb249bnVsbCx0aGlzKX1zdW1tYXJ5KHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5zdW1tYXJ5OnQ/KHRoaXMuZGF0YS5zdW1tYXJ5PXQsdGhpcyk6KHRoaXMuZGF0YS5zdW1tYXJ5PW51bGwsdGhpcyl9Y3JlYXRlQXR0ZW5kZWUodCl7aWYodCBpbnN0YW5jZW9mIGYpcmV0dXJuIHRoaXMuZGF0YS5hdHRlbmRlZXMucHVzaCh0KSx0O3R5cGVvZiB0PT1cInN0cmluZ1wiJiYodD17ZW1haWw6dCwuLi5wKFwiZGF0YVwiLHQpfSk7bGV0IGU9bmV3IGYodCx0aGlzKTtyZXR1cm4gdGhpcy5kYXRhLmF0dGVuZGVlcy5wdXNoKGUpLGV9YXR0ZW5kZWVzKHQpe3JldHVybiB0Pyh0LmZvckVhY2goZT0+dGhpcy5jcmVhdGVBdHRlbmRlZShlKSksdGhpcyk6dGhpcy5kYXRhLmF0dGVuZGVlc314KHQsZSl7aWYodD09PXZvaWQgMClyZXR1cm4gbCh0aGlzLmRhdGEpO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiJiZ0eXBlb2YgZT09XCJzdHJpbmdcIilsKHRoaXMuZGF0YSx0LGUpO2Vsc2UgaWYodHlwZW9mIHQ9PVwib2JqZWN0XCIpbCh0aGlzLmRhdGEsdCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIga2V5IG9yIHZhbHVlIGlzIG5vdCBhIHN0cmluZyFcIik7cmV0dXJuIHRoaXN9dG9KU09OKCl7bGV0IHQ9dGhpcy50cmlnZ2VyKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sdGhpcy5kYXRhLHt0cmlnZ2VyOnR5cGVvZiB0PT1cIm51bWJlclwiP3Q6Zyh0KSx4OnRoaXMueCgpfSl9dG9TdHJpbmcoKXtsZXQgdD1gQkVHSU46VkFMQVJNXFxyXG5gO2lmKHQrPVwiQUNUSU9OOlwiK3RoaXMuZGF0YS50eXBlLnRvVXBwZXJDYXNlKCkrYFxcclxuYCx0eXBlb2YgdGhpcy5kYXRhLnRyaWdnZXI9PVwibnVtYmVyXCImJnRoaXMuZGF0YS5yZWxhdGVzVG89PT1udWxsP3RoaXMuZGF0YS50cmlnZ2VyPjA/dCs9XCJUUklHR0VSO1JFTEFURUQ9RU5EOlwiK0ModGhpcy5kYXRhLnRyaWdnZXIpK2BcXHJcbmA6dCs9XCJUUklHR0VSOlwiK0ModGhpcy5kYXRhLnRyaWdnZXIpK2BcXHJcbmA6dHlwZW9mIHRoaXMuZGF0YS50cmlnZ2VyPT1cIm51bWJlclwiP3QrPVwiVFJJR0dFUjtSRUxBVEVEPVwiK3RoaXMuZGF0YS5yZWxhdGVzVG8/LnRvVXBwZXJDYXNlKCkrXCI6XCIrQyh0aGlzLmRhdGEudHJpZ2dlcikrYFxcclxuYDp0Kz1cIlRSSUdHRVI7VkFMVUU9REFURS1USU1FOlwiK28odGhpcy5ldmVudC50aW1lem9uZSgpLHRoaXMuZGF0YS50cmlnZ2VyKStgXFxyXG5gLHRoaXMuZGF0YS5yZXBlYXQpe2lmKCF0aGlzLmRhdGEucmVwZWF0LnRpbWVzKXRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIGZvciBgcmVwZWF0LnRpbWVzYCBpbiBJQ2FsQWxhcm0gZ2l2ZW4sIGJ1dCByZXF1aXJlZCBmb3IgYGludGVydmFsYCFcIik7aWYoIXRoaXMuZGF0YS5yZXBlYXQuaW50ZXJ2YWwpdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgZm9yIGByZXBlYXQuaW50ZXJ2YWxgIGluIElDYWxBbGFybSBnaXZlbiwgYnV0IHJlcXVpcmVkIGZvciBgcmVwZWF0YCFcIik7dCs9XCJSRVBFQVQ6XCIrdGhpcy5kYXRhLnJlcGVhdC50aW1lcytgXFxyXG5gLHQrPVwiRFVSQVRJT046XCIrQyh0aGlzLmRhdGEucmVwZWF0LmludGVydmFsKStgXFxyXG5gfXJldHVybiB0aGlzLmRhdGEudHlwZT09PVwiYXVkaW9cIiYmdGhpcy5kYXRhLmF0dGFjaCYmdGhpcy5kYXRhLmF0dGFjaC5taW1lP3QrPVwiQVRUQUNIO0ZNVFRZUEU9XCIrcih0aGlzLmRhdGEuYXR0YWNoLm1pbWUsITEpK1wiOlwiK3IodGhpcy5kYXRhLmF0dGFjaC51cmksITEpK2BcXHJcbmA6dGhpcy5kYXRhLnR5cGU9PT1cImF1ZGlvXCImJnRoaXMuZGF0YS5hdHRhY2g/dCs9XCJBVFRBQ0g7VkFMVUU9VVJJOlwiK3IodGhpcy5kYXRhLmF0dGFjaC51cmksITEpK2BcXHJcbmA6dGhpcy5kYXRhLnR5cGU9PT1cImF1ZGlvXCImJih0Kz1gQVRUQUNIO1ZBTFVFPVVSSTpCYXNzb1xcclxuYCksdGhpcy5kYXRhLnR5cGUhPT1cImF1ZGlvXCImJnRoaXMuZGF0YS5kZXNjcmlwdGlvbj90Kz1cIkRFU0NSSVBUSU9OOlwiK3IodGhpcy5kYXRhLmRlc2NyaXB0aW9uLCExKStgXFxyXG5gOnRoaXMuZGF0YS50eXBlIT09XCJhdWRpb1wiJiYodCs9XCJERVNDUklQVElPTjpcIityKHRoaXMuZXZlbnQuc3VtbWFyeSgpLCExKStgXFxyXG5gKSx0aGlzLmRhdGEudHlwZT09PVwiZW1haWxcIiYmdGhpcy5kYXRhLnN1bW1hcnk/dCs9XCJTVU1NQVJZOlwiK3IodGhpcy5kYXRhLnN1bW1hcnksITEpK2BcXHJcbmA6dGhpcy5kYXRhLnR5cGU9PT1cImVtYWlsXCImJih0Kz1cIlNVTU1BUlk6XCIrcih0aGlzLmV2ZW50LnN1bW1hcnkoKSwhMSkrYFxcclxuYCksdGhpcy5kYXRhLnR5cGU9PT1cImVtYWlsXCImJnRoaXMuZGF0YS5hdHRlbmRlZXMuZm9yRWFjaChlPT57dCs9ZS50b1N0cmluZygpfSksdCs9RCh0aGlzLmRhdGEpLHQrPWBFTkQ6VkFMQVJNXFxyXG5gLHR9fTt2YXIgYz1jbGFzc3tkYXRhO2NvbnN0cnVjdG9yKHQpe2lmKHRoaXMuZGF0YT17bmFtZTpcIlwifSwhdC5uYW1lKXRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIGZvciBgbmFtZWAgaW4gSUNhbENhdGVnb3J5IGdpdmVuIVwiKTt0aGlzLm5hbWUodC5uYW1lKX1uYW1lKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5uYW1lOih0aGlzLmRhdGEubmFtZT10LHRoaXMpfXRvSlNPTigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LHRoaXMuZGF0YSl9dG9TdHJpbmcoKXtyZXR1cm4gcih0aGlzLmRhdGEubmFtZSwhMSl9fTt2YXIgTD0obj0+KG4uQ09ORklSTUVEPVwiQ09ORklSTUVEXCIsbi5URU5UQVRJVkU9XCJURU5UQVRJVkVcIixuLkNBTkNFTExFRD1cIkNBTkNFTExFRFwiLG4pKShMfHx7fSksej0oaT0+KGkuRlJFRT1cIkZSRUVcIixpLlRFTlRBVElWRT1cIlRFTlRBVElWRVwiLGkuQlVTWT1cIkJVU1lcIixpLk9PRj1cIk9PRlwiLGkpKSh6fHx7fSksVT0oZT0+KGUuVFJBTlNQQVJFTlQ9XCJUUkFOU1BBUkVOVFwiLGUuT1BBUVVFPVwiT1BBUVVFXCIsZSkpKFV8fHt9KSxCPShuPT4obi5QVUJMSUM9XCJQVUJMSUNcIixuLlBSSVZBVEU9XCJQUklWQVRFXCIsbi5DT05GSURFTlRJQUw9XCJDT05GSURFTlRJQUxcIixuKSkoQnx8e30pLHk9Y2xhc3N7ZGF0YTtjYWxlbmRhcjtjb25zdHJ1Y3Rvcih0LGUpe2lmKHRoaXMuZGF0YT17aWQ6RygpLHNlcXVlbmNlOjAsc3RhcnQ6bmV3IERhdGUsZW5kOm51bGwscmVjdXJyZW5jZUlkOm51bGwsdGltZXpvbmU6bnVsbCxzdGFtcDpuZXcgRGF0ZSxhbGxEYXk6ITEsZmxvYXRpbmc6ITEscmVwZWF0aW5nOm51bGwsc3VtbWFyeTpcIlwiLGxvY2F0aW9uOm51bGwsZGVzY3JpcHRpb246bnVsbCxvcmdhbml6ZXI6bnVsbCxhdHRlbmRlZXM6W10sYWxhcm1zOltdLGNhdGVnb3JpZXM6W10sc3RhdHVzOm51bGwsYnVzeXN0YXR1czpudWxsLHByaW9yaXR5Om51bGwsdXJsOm51bGwsYXR0YWNobWVudHM6W10sdHJhbnNwYXJlbmN5Om51bGwsY3JlYXRlZDpudWxsLGxhc3RNb2RpZmllZDpudWxsLGNsYXNzOm51bGwseDpbXX0sdGhpcy5jYWxlbmRhcj1lLCFlKXRocm93IG5ldyBFcnJvcihcImBjYWxlbmRhcmAgb3B0aW9uIHJlcXVpcmVkIVwiKTt0LmlkJiZ0aGlzLmlkKHQuaWQpLHQuc2VxdWVuY2UhPT12b2lkIDAmJnRoaXMuc2VxdWVuY2UodC5zZXF1ZW5jZSksdC5zdGFydCYmdGhpcy5zdGFydCh0LnN0YXJ0KSx0LmVuZCE9PXZvaWQgMCYmdGhpcy5lbmQodC5lbmQpLHQucmVjdXJyZW5jZUlkIT09dm9pZCAwJiZ0aGlzLnJlY3VycmVuY2VJZCh0LnJlY3VycmVuY2VJZCksdC50aW1lem9uZSE9PXZvaWQgMCYmdGhpcy50aW1lem9uZSh0LnRpbWV6b25lKSx0LnN0YW1wIT09dm9pZCAwJiZ0aGlzLnN0YW1wKHQuc3RhbXApLHQuYWxsRGF5IT09dm9pZCAwJiZ0aGlzLmFsbERheSh0LmFsbERheSksdC5mbG9hdGluZyE9PXZvaWQgMCYmdGhpcy5mbG9hdGluZyh0LmZsb2F0aW5nKSx0LnJlcGVhdGluZyE9PXZvaWQgMCYmdGhpcy5yZXBlYXRpbmcodC5yZXBlYXRpbmcpLHQuc3VtbWFyeSE9PXZvaWQgMCYmdGhpcy5zdW1tYXJ5KHQuc3VtbWFyeSksdC5sb2NhdGlvbiE9PXZvaWQgMCYmdGhpcy5sb2NhdGlvbih0LmxvY2F0aW9uKSx0LmRlc2NyaXB0aW9uIT09dm9pZCAwJiZ0aGlzLmRlc2NyaXB0aW9uKHQuZGVzY3JpcHRpb24pLHQub3JnYW5pemVyIT09dm9pZCAwJiZ0aGlzLm9yZ2FuaXplcih0Lm9yZ2FuaXplciksdC5hdHRlbmRlZXMhPT12b2lkIDAmJnRoaXMuYXR0ZW5kZWVzKHQuYXR0ZW5kZWVzKSx0LmFsYXJtcyE9PXZvaWQgMCYmdGhpcy5hbGFybXModC5hbGFybXMpLHQuY2F0ZWdvcmllcyE9PXZvaWQgMCYmdGhpcy5jYXRlZ29yaWVzKHQuY2F0ZWdvcmllcyksdC5zdGF0dXMhPT12b2lkIDAmJnRoaXMuc3RhdHVzKHQuc3RhdHVzKSx0LmJ1c3lzdGF0dXMhPT12b2lkIDAmJnRoaXMuYnVzeXN0YXR1cyh0LmJ1c3lzdGF0dXMpLHQucHJpb3JpdHkhPT12b2lkIDAmJnRoaXMucHJpb3JpdHkodC5wcmlvcml0eSksdC51cmwhPT12b2lkIDAmJnRoaXMudXJsKHQudXJsKSx0LmF0dGFjaG1lbnRzIT09dm9pZCAwJiZ0aGlzLmF0dGFjaG1lbnRzKHQuYXR0YWNobWVudHMpLHQudHJhbnNwYXJlbmN5IT09dm9pZCAwJiZ0aGlzLnRyYW5zcGFyZW5jeSh0LnRyYW5zcGFyZW5jeSksdC5jcmVhdGVkIT09dm9pZCAwJiZ0aGlzLmNyZWF0ZWQodC5jcmVhdGVkKSx0Lmxhc3RNb2RpZmllZCE9PXZvaWQgMCYmdGhpcy5sYXN0TW9kaWZpZWQodC5sYXN0TW9kaWZpZWQpLHQuY2xhc3MhPT12b2lkIDAmJnRoaXMuY2xhc3ModC5jbGFzcyksdC54IT09dm9pZCAwJiZ0aGlzLngodC54KX1pZCh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuaWQ6KHRoaXMuZGF0YS5pZD1TdHJpbmcodCksdGhpcyl9dWlkKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuaWQoKTp0aGlzLmlkKHQpfXNlcXVlbmNlKHQpe2lmKHQ9PT12b2lkIDApcmV0dXJuIHRoaXMuZGF0YS5zZXF1ZW5jZTtsZXQgZT1wYXJzZUludChTdHJpbmcodCksMTApO2lmKGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcihcImBzZXF1ZW5jZWAgbXVzdCBiZSBhIG51bWJlciFcIik7cmV0dXJuIHRoaXMuZGF0YS5zZXF1ZW5jZT10LHRoaXN9c3RhcnQodCl7cmV0dXJuIHQ9PT12b2lkIDA/KHRoaXMuc3dhcFN0YXJ0QW5kRW5kSWZSZXF1aXJlZCgpLHRoaXMuZGF0YS5zdGFydCk6KHRoaXMuZGF0YS5zdGFydD1oKHQsXCJzdGFydFwiKSx0aGlzKX1lbmQodCl7cmV0dXJuIHQ9PT12b2lkIDA/KHRoaXMuc3dhcFN0YXJ0QW5kRW5kSWZSZXF1aXJlZCgpLHRoaXMuZGF0YS5lbmQpOnQ9PT1udWxsPyh0aGlzLmRhdGEuZW5kPW51bGwsdGhpcyk6KHRoaXMuZGF0YS5lbmQ9aCh0LFwiZW5kXCIpLHRoaXMpfXN3YXBTdGFydEFuZEVuZElmUmVxdWlyZWQoKXtpZih0aGlzLmRhdGEuc3RhcnQmJnRoaXMuZGF0YS5lbmQmJk4odGhpcy5kYXRhLnN0YXJ0KS5nZXRUaW1lKCk+Tih0aGlzLmRhdGEuZW5kKS5nZXRUaW1lKCkpe2xldCB0PXRoaXMuZGF0YS5zdGFydDt0aGlzLmRhdGEuc3RhcnQ9dGhpcy5kYXRhLmVuZCx0aGlzLmRhdGEuZW5kPXR9fXJlY3VycmVuY2VJZCh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEucmVjdXJyZW5jZUlkOnQ9PT1udWxsPyh0aGlzLmRhdGEucmVjdXJyZW5jZUlkPW51bGwsdGhpcyk6KHRoaXMuZGF0YS5yZWN1cnJlbmNlSWQ9aCh0LFwicmVjdXJyZW5jZUlkXCIpLHRoaXMpfXRpbWV6b25lKHQpe3JldHVybiB0PT09dm9pZCAwJiZ0aGlzLmRhdGEudGltZXpvbmUhPT1udWxsP3RoaXMuZGF0YS50aW1lem9uZTp0PT09dm9pZCAwP3RoaXMuY2FsZW5kYXIudGltZXpvbmUoKToodGhpcy5kYXRhLnRpbWV6b25lPXQmJnQhPT1cIlVUQ1wiP3QudG9TdHJpbmcoKTpudWxsLHRoaXMuZGF0YS50aW1lem9uZSYmKHRoaXMuZGF0YS5mbG9hdGluZz0hMSksdGhpcyl9c3RhbXAodCl7cmV0dXJuIHQ9PT12b2lkIDA/dGhpcy5kYXRhLnN0YW1wOih0aGlzLmRhdGEuc3RhbXA9aCh0LFwic3RhbXBcIiksdGhpcyl9dGltZXN0YW1wKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuc3RhbXAoKTp0aGlzLnN0YW1wKHQpfWFsbERheSh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuYWxsRGF5Oih0aGlzLmRhdGEuYWxsRGF5PSEhdCx0aGlzKX1mbG9hdGluZyh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuZmxvYXRpbmc6KHRoaXMuZGF0YS5mbG9hdGluZz0hIXQsdGhpcy5kYXRhLmZsb2F0aW5nJiYodGhpcy5kYXRhLnRpbWV6b25lPW51bGwpLHRoaXMpfXJlcGVhdGluZyh0KXtpZih0PT09dm9pZCAwKXJldHVybiB0aGlzLmRhdGEucmVwZWF0aW5nO2lmKCF0KXJldHVybiB0aGlzLmRhdGEucmVwZWF0aW5nPW51bGwsdGhpcztpZih4KHQpfHx0eXBlb2YgdD09XCJzdHJpbmdcIilyZXR1cm4gdGhpcy5kYXRhLnJlcGVhdGluZz10LHRoaXM7aWYodGhpcy5kYXRhLnJlcGVhdGluZz17ZnJlcTpkKGIsdC5mcmVxKX0sdC5jb3VudCl7aWYoIWlzRmluaXRlKHQuY291bnQpKXRocm93IG5ldyBFcnJvcihcImByZXBlYXRpbmcuY291bnRgIG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyIVwiKTt0aGlzLmRhdGEucmVwZWF0aW5nLmNvdW50PXQuY291bnR9aWYodC5pbnRlcnZhbCl7aWYoIWlzRmluaXRlKHQuaW50ZXJ2YWwpKXRocm93IG5ldyBFcnJvcihcImByZXBlYXRpbmcuaW50ZXJ2YWxgIG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyIVwiKTt0aGlzLmRhdGEucmVwZWF0aW5nLmludGVydmFsPXQuaW50ZXJ2YWx9aWYodC51bnRpbCE9PXZvaWQgMCYmKHRoaXMuZGF0YS5yZXBlYXRpbmcudW50aWw9aCh0LnVudGlsLFwicmVwZWF0aW5nLnVudGlsXCIpKSx0LmJ5RGF5KXtsZXQgZT1BcnJheS5pc0FycmF5KHQuYnlEYXkpP3QuYnlEYXk6W3QuYnlEYXldO3RoaXMuZGF0YS5yZXBlYXRpbmcuYnlEYXk9ZS5tYXAobj0+ZChBLG4pKX1pZih0LmJ5TW9udGgpe2xldCBlPUFycmF5LmlzQXJyYXkodC5ieU1vbnRoKT90LmJ5TW9udGg6W3QuYnlNb250aF07dGhpcy5kYXRhLnJlcGVhdGluZy5ieU1vbnRoPWUubWFwKG49PntpZih0eXBlb2YgbiE9XCJudW1iZXJcInx8bjwxfHxuPjEyKXRocm93IG5ldyBFcnJvcihcImByZXBlYXRpbmcuYnlNb250aGAgY29udGFpbnMgaW52YWxpZCB2YWx1ZSBgXCIrbitcImAhXCIpO3JldHVybiBufSl9aWYodC5ieU1vbnRoRGF5KXtsZXQgZT1BcnJheS5pc0FycmF5KHQuYnlNb250aERheSk/dC5ieU1vbnRoRGF5Olt0LmJ5TW9udGhEYXldO3RoaXMuZGF0YS5yZXBlYXRpbmcuYnlNb250aERheT1lLm1hcChuPT57aWYodHlwZW9mIG4hPVwibnVtYmVyXCJ8fG48LTMxfHxuPjMxfHxuPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJgcmVwZWF0aW5nLmJ5TW9udGhEYXlgIGNvbnRhaW5zIGludmFsaWQgdmFsdWUgYFwiK24rXCJgIVwiKTtyZXR1cm4gbn0pfWlmKHQuYnlTZXRQb3Mpe2lmKCF0aGlzLmRhdGEucmVwZWF0aW5nLmJ5RGF5KXRocm93XCJgcmVwZWF0aW5nLmJ5U2V0UG9zYCBtdXN0IGJlIHVzZWQgYWxvbmcgd2l0aCBgcmVwZWF0aW5nLmJ5RGF5YCFcIjtsZXQgZT1BcnJheS5pc0FycmF5KHQuYnlTZXRQb3MpP3QuYnlTZXRQb3M6W3QuYnlTZXRQb3NdO3RoaXMuZGF0YS5yZXBlYXRpbmcuYnlTZXRQb3M9ZS5tYXAobj0+e2lmKHR5cGVvZiBuIT1cIm51bWJlclwifHxuPC0zNjZ8fG4+MzY2fHxuPT09MCl0aHJvd1wiYHJlcGVhdGluZy5ieVNldFBvc2AgY29udGFpbnMgaW52YWxpZCB2YWx1ZSBgXCIrbitcImAhXCI7cmV0dXJuIG59KX1pZih0LmV4Y2x1ZGUpe2xldCBlPUFycmF5LmlzQXJyYXkodC5leGNsdWRlKT90LmV4Y2x1ZGU6W3QuZXhjbHVkZV07dGhpcy5kYXRhLnJlcGVhdGluZy5leGNsdWRlPWUubWFwKChuLGkpPT5oKG4sYHJlcGVhdGluZy5leGNsdWRlWyR7aX1dYCkpfXJldHVybiB0LnN0YXJ0T2ZXZWVrJiYodGhpcy5kYXRhLnJlcGVhdGluZy5zdGFydE9mV2Vlaz1kKEEsdC5zdGFydE9mV2VlaykpLHRoaXN9c3VtbWFyeSh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuc3VtbWFyeToodGhpcy5kYXRhLnN1bW1hcnk9dD9TdHJpbmcodCk6XCJcIix0aGlzKX1sb2NhdGlvbih0KXtpZih0PT09dm9pZCAwKXJldHVybiB0aGlzLmRhdGEubG9jYXRpb247aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpcmV0dXJuIHRoaXMuZGF0YS5sb2NhdGlvbj17dGl0bGU6dH0sdGhpcztpZih0JiYoXCJ0aXRsZVwiaW4gdCYmIXQudGl0bGV8fHQ/LmdlbyYmKHR5cGVvZiB0Lmdlby5sYXQhPVwibnVtYmVyXCJ8fCFpc0Zpbml0ZSh0Lmdlby5sYXQpfHx0eXBlb2YgdC5nZW8ubG9uIT1cIm51bWJlclwifHwhaXNGaW5pdGUodC5nZW8ubG9uKSl8fCEoXCJ0aXRsZVwiaW4gdCkmJiF0Py5nZW8pKXRocm93IG5ldyBFcnJvcihcImBsb2NhdGlvbmAgaXNuJ3QgZm9ybWF0dGVkIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc2ViYm8yMDAyLmdpdGh1Yi5pby9pY2FsLWdlbmVyYXRvci9kZXZlbG9wL3JlZmVyZW5jZS9jbGFzc2VzL0lDYWxFdmVudC5odG1sI2xvY2F0aW9uXCIpO3JldHVybiB0aGlzLmRhdGEubG9jYXRpb249dHx8bnVsbCx0aGlzfWRlc2NyaXB0aW9uKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5kZXNjcmlwdGlvbjp0PT09bnVsbD8odGhpcy5kYXRhLmRlc2NyaXB0aW9uPW51bGwsdGhpcyk6KHR5cGVvZiB0PT1cInN0cmluZ1wiP3RoaXMuZGF0YS5kZXNjcmlwdGlvbj17cGxhaW46dH06dGhpcy5kYXRhLmRlc2NyaXB0aW9uPXQsdGhpcyl9b3JnYW5pemVyKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5vcmdhbml6ZXI6dD09PW51bGw/KHRoaXMuZGF0YS5vcmdhbml6ZXI9bnVsbCx0aGlzKToodGhpcy5kYXRhLm9yZ2FuaXplcj1wKFwib3JnYW5pemVyXCIsdCksdGhpcyl9Y3JlYXRlQXR0ZW5kZWUodCl7aWYodCBpbnN0YW5jZW9mIGYpcmV0dXJuIHRoaXMuZGF0YS5hdHRlbmRlZXMucHVzaCh0KSx0O3R5cGVvZiB0PT1cInN0cmluZ1wiJiYodD17ZW1haWw6dCwuLi5wKFwiZGF0YVwiLHQpfSk7bGV0IGU9bmV3IGYodCx0aGlzKTtyZXR1cm4gdGhpcy5kYXRhLmF0dGVuZGVlcy5wdXNoKGUpLGV9YXR0ZW5kZWVzKHQpe3JldHVybiB0Pyh0LmZvckVhY2goZT0+dGhpcy5jcmVhdGVBdHRlbmRlZShlKSksdGhpcyk6dGhpcy5kYXRhLmF0dGVuZGVlc31jcmVhdGVBbGFybSh0KXtsZXQgZT10IGluc3RhbmNlb2YgST90Om5ldyBJKHQsdGhpcyk7cmV0dXJuIHRoaXMuZGF0YS5hbGFybXMucHVzaChlKSxlfWFsYXJtcyh0KXtyZXR1cm4gdD8odC5mb3JFYWNoKGU9PnRoaXMuY3JlYXRlQWxhcm0oZSkpLHRoaXMpOnRoaXMuZGF0YS5hbGFybXN9Y3JlYXRlQ2F0ZWdvcnkodCl7bGV0IGU9dCBpbnN0YW5jZW9mIGM/dDpuZXcgYyh0KTtyZXR1cm4gdGhpcy5kYXRhLmNhdGVnb3JpZXMucHVzaChlKSxlfWNhdGVnb3JpZXModCl7cmV0dXJuIHQ/KHQuZm9yRWFjaChlPT50aGlzLmNyZWF0ZUNhdGVnb3J5KGUpKSx0aGlzKTp0aGlzLmRhdGEuY2F0ZWdvcmllc31zdGF0dXModCl7cmV0dXJuIHQ9PT12b2lkIDA/dGhpcy5kYXRhLnN0YXR1czp0PT09bnVsbD8odGhpcy5kYXRhLnN0YXR1cz1udWxsLHRoaXMpOih0aGlzLmRhdGEuc3RhdHVzPWQoTCx0KSx0aGlzKX1idXN5c3RhdHVzKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5idXN5c3RhdHVzOnQ9PT1udWxsPyh0aGlzLmRhdGEuYnVzeXN0YXR1cz1udWxsLHRoaXMpOih0aGlzLmRhdGEuYnVzeXN0YXR1cz1kKHosdCksdGhpcyl9cHJpb3JpdHkodCl7aWYodD09PXZvaWQgMClyZXR1cm4gdGhpcy5kYXRhLnByaW9yaXR5O2lmKHQ9PT1udWxsKXJldHVybiB0aGlzLmRhdGEucHJpb3JpdHk9bnVsbCx0aGlzO2lmKHQ8MHx8dD45KXRocm93IG5ldyBFcnJvcihcImBwcmlvcml0eWAgaXMgaW52YWxpZCwgbXVzc3QgYmUgMCBcXHUyMjY0IHByaW9yaXR5IFxcdTIyNjQgOS5cIik7cmV0dXJuIHRoaXMuZGF0YS5wcmlvcml0eT1NYXRoLnJvdW5kKHQpLHRoaXN9dXJsKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS51cmw6KHRoaXMuZGF0YS51cmw9dD9TdHJpbmcodCk6bnVsbCx0aGlzKX1jcmVhdGVBdHRhY2htZW50KHQpe3JldHVybiB0aGlzLmRhdGEuYXR0YWNobWVudHMucHVzaCh0KSx0aGlzfWF0dGFjaG1lbnRzKHQpe3JldHVybiB0Pyh0LmZvckVhY2goZT0+dGhpcy5jcmVhdGVBdHRhY2htZW50KGUpKSx0aGlzKTp0aGlzLmRhdGEuYXR0YWNobWVudHN9dHJhbnNwYXJlbmN5KHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS50cmFuc3BhcmVuY3k6dD8odGhpcy5kYXRhLnRyYW5zcGFyZW5jeT1kKFUsdCksdGhpcyk6KHRoaXMuZGF0YS50cmFuc3BhcmVuY3k9bnVsbCx0aGlzKX1jcmVhdGVkKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5jcmVhdGVkOnQ9PT1udWxsPyh0aGlzLmRhdGEuY3JlYXRlZD1udWxsLHRoaXMpOih0aGlzLmRhdGEuY3JlYXRlZD1oKHQsXCJjcmVhdGVkXCIpLHRoaXMpfWxhc3RNb2RpZmllZCh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEubGFzdE1vZGlmaWVkOnQ9PT1udWxsPyh0aGlzLmRhdGEubGFzdE1vZGlmaWVkPW51bGwsdGhpcyk6KHRoaXMuZGF0YS5sYXN0TW9kaWZpZWQ9aCh0LFwibGFzdE1vZGlmaWVkXCIpLHRoaXMpfWNsYXNzKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS5jbGFzczp0PT09bnVsbD8odGhpcy5kYXRhLmNsYXNzPW51bGwsdGhpcyk6KHRoaXMuZGF0YS5jbGFzcz1kKEIsdCksdGhpcyl9eCh0LGUpe3JldHVybiB0PT09dm9pZCAwP2wodGhpcy5kYXRhKToodHlwZW9mIHQ9PVwic3RyaW5nXCImJnR5cGVvZiBlPT1cInN0cmluZ1wiJiZsKHRoaXMuZGF0YSx0LGUpLHR5cGVvZiB0PT1cIm9iamVjdFwiJiZsKHRoaXMuZGF0YSx0KSx0aGlzKX10b0pTT04oKXtsZXQgdD1udWxsO3JldHVybiB4KHRoaXMuZGF0YS5yZXBlYXRpbmcpfHx0eXBlb2YgdGhpcy5kYXRhLnJlcGVhdGluZz09XCJzdHJpbmdcIj90PXRoaXMuZGF0YS5yZXBlYXRpbmcudG9TdHJpbmcoKTp0aGlzLmRhdGEucmVwZWF0aW5nJiYodD1PYmplY3QuYXNzaWduKHt9LHRoaXMuZGF0YS5yZXBlYXRpbmcse3VudGlsOmcodGhpcy5kYXRhLnJlcGVhdGluZy51bnRpbCl8fHZvaWQgMCxleGNsdWRlOnRoaXMuZGF0YS5yZXBlYXRpbmcuZXhjbHVkZT8ubWFwKGU9PmcoZSkpfSkpLHRoaXMuc3dhcFN0YXJ0QW5kRW5kSWZSZXF1aXJlZCgpLE9iamVjdC5hc3NpZ24oe30sdGhpcy5kYXRhLHtzdGFydDpnKHRoaXMuZGF0YS5zdGFydCl8fG51bGwsZW5kOmcodGhpcy5kYXRhLmVuZCl8fG51bGwscmVjdXJyZW5jZUlkOmcodGhpcy5kYXRhLnJlY3VycmVuY2VJZCl8fG51bGwsc3RhbXA6Zyh0aGlzLmRhdGEuc3RhbXApfHxudWxsLGNyZWF0ZWQ6Zyh0aGlzLmRhdGEuY3JlYXRlZCl8fG51bGwsbGFzdE1vZGlmaWVkOmcodGhpcy5kYXRhLmxhc3RNb2RpZmllZCl8fG51bGwscmVwZWF0aW5nOnQseDp0aGlzLngoKX0pfXRvU3RyaW5nKCl7bGV0IHQ9XCJcIjtpZih0Kz1gQkVHSU46VkVWRU5UXFxyXG5gLHQrPVwiVUlEOlwiK3RoaXMuZGF0YS5pZCtgXFxyXG5gLHQrPVwiU0VRVUVOQ0U6XCIrdGhpcy5kYXRhLnNlcXVlbmNlK2BcXHJcbmAsdGhpcy5zd2FwU3RhcnRBbmRFbmRJZlJlcXVpcmVkKCksdCs9XCJEVFNUQU1QOlwiK28odGhpcy5jYWxlbmRhci50aW1lem9uZSgpLHRoaXMuZGF0YS5zdGFtcCkrYFxcclxuYCx0aGlzLmRhdGEuYWxsRGF5Pyh0Kz1cIkRUU1RBUlQ7VkFMVUU9REFURTpcIitvKHRoaXMudGltZXpvbmUoKSx0aGlzLmRhdGEuc3RhcnQsITApK2BcXHJcbmAsdGhpcy5kYXRhLmVuZCYmKHQrPVwiRFRFTkQ7VkFMVUU9REFURTpcIitvKHRoaXMudGltZXpvbmUoKSx0aGlzLmRhdGEuZW5kLCEwKStgXFxyXG5gKSx0Kz1gWC1NSUNST1NPRlQtQ0RPLUFMTERBWUVWRU5UOlRSVUVcXHJcbmAsdCs9YFgtTUlDUk9TT0ZULU1TTkNBTEVOREFSLUFMTERBWUVWRU5UOlRSVUVcXHJcbmApOih0Kz1FKHRoaXMudGltZXpvbmUoKSxcIkRUU1RBUlRcIix0aGlzLmRhdGEuc3RhcnQsdGhpcy5kYXRhKStgXFxyXG5gLHRoaXMuZGF0YS5lbmQmJih0Kz1FKHRoaXMudGltZXpvbmUoKSxcIkRURU5EXCIsdGhpcy5kYXRhLmVuZCx0aGlzLmRhdGEpK2BcXHJcbmApKSx4KHRoaXMuZGF0YS5yZXBlYXRpbmcpfHx0eXBlb2YgdGhpcy5kYXRhLnJlcGVhdGluZz09XCJzdHJpbmdcIil7bGV0IGU9dGhpcy5kYXRhLnJlcGVhdGluZy50b1N0cmluZygpLnJlcGxhY2UoL1xcclxcbi9nLGBcbmApLnNwbGl0KGBcbmApLmZpbHRlcihuPT5uJiYhbi5zdGFydHNXaXRoKFwiRFRTVEFSVDpcIikpLmpvaW4oYFxcclxuYCk7IWUuaW5jbHVkZXMoYFxcclxuYCkmJiFlLnN0YXJ0c1dpdGgoXCJSUlVMRTpcIikmJihlPVwiUlJVTEU6XCIrZSksdCs9ZS50cmltKCkrYFxcclxuYH1lbHNlIHRoaXMuZGF0YS5yZXBlYXRpbmcmJih0Kz1cIlJSVUxFOkZSRVE9XCIrdGhpcy5kYXRhLnJlcGVhdGluZy5mcmVxLHRoaXMuZGF0YS5yZXBlYXRpbmcuY291bnQmJih0Kz1cIjtDT1VOVD1cIit0aGlzLmRhdGEucmVwZWF0aW5nLmNvdW50KSx0aGlzLmRhdGEucmVwZWF0aW5nLmludGVydmFsJiYodCs9XCI7SU5URVJWQUw9XCIrdGhpcy5kYXRhLnJlcGVhdGluZy5pbnRlcnZhbCksdGhpcy5kYXRhLnJlcGVhdGluZy51bnRpbCYmKHQrPVwiO1VOVElMPVwiK28odGhpcy5jYWxlbmRhci50aW1lem9uZSgpLHRoaXMuZGF0YS5yZXBlYXRpbmcudW50aWwsITEsdGhpcy5mbG9hdGluZygpKSksdGhpcy5kYXRhLnJlcGVhdGluZy5ieURheSYmKHQrPVwiO0JZREFZPVwiK3RoaXMuZGF0YS5yZXBlYXRpbmcuYnlEYXkuam9pbihcIixcIikpLHRoaXMuZGF0YS5yZXBlYXRpbmcuYnlNb250aCYmKHQrPVwiO0JZTU9OVEg9XCIrdGhpcy5kYXRhLnJlcGVhdGluZy5ieU1vbnRoLmpvaW4oXCIsXCIpKSx0aGlzLmRhdGEucmVwZWF0aW5nLmJ5TW9udGhEYXkmJih0Kz1cIjtCWU1PTlRIREFZPVwiK3RoaXMuZGF0YS5yZXBlYXRpbmcuYnlNb250aERheS5qb2luKFwiLFwiKSksdGhpcy5kYXRhLnJlcGVhdGluZy5ieVNldFBvcyYmKHQrPVwiO0JZU0VUUE9TPVwiK3RoaXMuZGF0YS5yZXBlYXRpbmcuYnlTZXRQb3Muam9pbihcIixcIikpLHRoaXMuZGF0YS5yZXBlYXRpbmcuc3RhcnRPZldlZWsmJih0Kz1cIjtXS1NUPVwiK3RoaXMuZGF0YS5yZXBlYXRpbmcuc3RhcnRPZldlZWspLHQrPWBcXHJcbmAsdGhpcy5kYXRhLnJlcGVhdGluZy5leGNsdWRlJiYodGhpcy5kYXRhLmFsbERheT90Kz1cIkVYREFURTtWQUxVRT1EQVRFOlwiK3RoaXMuZGF0YS5yZXBlYXRpbmcuZXhjbHVkZS5tYXAoZT0+byh0aGlzLmNhbGVuZGFyLnRpbWV6b25lKCksZSwhMCkpLmpvaW4oXCIsXCIpK2BcXHJcbmA6KHQrPVwiRVhEQVRFXCIsdGhpcy50aW1lem9uZSgpP3QrPVwiO1RaSUQ9XCIrdGhpcy50aW1lem9uZSgpK1wiOlwiK3RoaXMuZGF0YS5yZXBlYXRpbmcuZXhjbHVkZS5tYXAoZT0+byh0aGlzLnRpbWV6b25lKCksZSwhMSwhMCkpLmpvaW4oXCIsXCIpK2BcXHJcbmA6dCs9XCI6XCIrdGhpcy5kYXRhLnJlcGVhdGluZy5leGNsdWRlLm1hcChlPT5vKHRoaXMudGltZXpvbmUoKSxlLCExLHRoaXMuZmxvYXRpbmcoKSkpLmpvaW4oXCIsXCIpK2BcXHJcbmApKSk7cmV0dXJuIHRoaXMuZGF0YS5yZWN1cnJlbmNlSWQmJih0Kz1FKHRoaXMudGltZXpvbmUoKSxcIlJFQ1VSUkVOQ0UtSURcIix0aGlzLmRhdGEucmVjdXJyZW5jZUlkLHRoaXMuZGF0YSkrYFxcclxuYCksdCs9XCJTVU1NQVJZOlwiK3IodGhpcy5kYXRhLnN1bW1hcnksITEpK2BcXHJcbmAsdGhpcy5kYXRhLnRyYW5zcGFyZW5jeSYmKHQrPVwiVFJBTlNQOlwiK3IodGhpcy5kYXRhLnRyYW5zcGFyZW5jeSwhMSkrYFxcclxuYCksdGhpcy5kYXRhLmxvY2F0aW9uJiZcInRpdGxlXCJpbiB0aGlzLmRhdGEubG9jYXRpb24mJnRoaXMuZGF0YS5sb2NhdGlvbi50aXRsZSYmKHQrPVwiTE9DQVRJT046XCIrcih0aGlzLmRhdGEubG9jYXRpb24udGl0bGUrKHRoaXMuZGF0YS5sb2NhdGlvbi5hZGRyZXNzP2BcbmArdGhpcy5kYXRhLmxvY2F0aW9uLmFkZHJlc3M6XCJcIiksITEpK2BcXHJcbmAsdGhpcy5kYXRhLmxvY2F0aW9uLnJhZGl1cyYmdGhpcy5kYXRhLmxvY2F0aW9uLmdlbyYmKHQrPVwiWC1BUFBMRS1TVFJVQ1RVUkVELUxPQ0FUSU9OO1ZBTFVFPVVSSTtcIisodGhpcy5kYXRhLmxvY2F0aW9uLmFkZHJlc3M/XCJYLUFERFJFU1M9XCIrcih0aGlzLmRhdGEubG9jYXRpb24uYWRkcmVzcywhMSkrXCI7XCI6XCJcIikrXCJYLUFQUExFLVJBRElVUz1cIityKHRoaXMuZGF0YS5sb2NhdGlvbi5yYWRpdXMsITEpK1wiO1gtVElUTEU9XCIrcih0aGlzLmRhdGEubG9jYXRpb24udGl0bGUsITEpK1wiOmdlbzpcIityKHRoaXMuZGF0YS5sb2NhdGlvbi5nZW8/LmxhdCwhMSkrXCIsXCIrcih0aGlzLmRhdGEubG9jYXRpb24uZ2VvPy5sb24sITEpK2BcXHJcbmApKSx0aGlzLmRhdGEubG9jYXRpb24/Lmdlbz8ubGF0JiZ0aGlzLmRhdGEubG9jYXRpb24uZ2VvLmxvbiYmKHQrPVwiR0VPOlwiK3IodGhpcy5kYXRhLmxvY2F0aW9uLmdlby5sYXQsITEpK1wiO1wiK3IodGhpcy5kYXRhLmxvY2F0aW9uLmdlby5sb24sITEpK2BcXHJcbmApLHRoaXMuZGF0YS5kZXNjcmlwdGlvbiYmKHQrPVwiREVTQ1JJUFRJT046XCIrcih0aGlzLmRhdGEuZGVzY3JpcHRpb24ucGxhaW4sITEpK2BcXHJcbmAsdGhpcy5kYXRhLmRlc2NyaXB0aW9uLmh0bWwmJih0Kz1cIlgtQUxULURFU0M7Rk1UVFlQRT10ZXh0L2h0bWw6XCIrcih0aGlzLmRhdGEuZGVzY3JpcHRpb24uaHRtbCwhMSkrYFxcclxuYCkpLHRoaXMuZGF0YS5vcmdhbml6ZXImJih0Kz0nT1JHQU5JWkVSO0NOPVwiJytyKHRoaXMuZGF0YS5vcmdhbml6ZXIubmFtZSwhMCkrJ1wiJyx0aGlzLmRhdGEub3JnYW5pemVyLnNlbnRCeSYmKHQrPSc7U0VOVC1CWT1cIm1haWx0bzonK3IodGhpcy5kYXRhLm9yZ2FuaXplci5zZW50QnksITApKydcIicpLHRoaXMuZGF0YS5vcmdhbml6ZXIuZW1haWwmJnRoaXMuZGF0YS5vcmdhbml6ZXIubWFpbHRvJiYodCs9XCI7RU1BSUw9XCIrcih0aGlzLmRhdGEub3JnYW5pemVyLmVtYWlsLCExKSksdCs9XCI6XCIsdGhpcy5kYXRhLm9yZ2FuaXplci5lbWFpbCYmKHQrPVwibWFpbHRvOlwiK3IodGhpcy5kYXRhLm9yZ2FuaXplci5tYWlsdG98fHRoaXMuZGF0YS5vcmdhbml6ZXIuZW1haWwsITEpKSx0Kz1gXFxyXG5gKSx0aGlzLmRhdGEuYXR0ZW5kZWVzLmZvckVhY2goZnVuY3Rpb24oZSl7dCs9ZS50b1N0cmluZygpfSksdGhpcy5kYXRhLmFsYXJtcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QrPWUudG9TdHJpbmcoKX0pLHRoaXMuZGF0YS5jYXRlZ29yaWVzLmxlbmd0aD4wJiYodCs9XCJDQVRFR09SSUVTOlwiK3RoaXMuZGF0YS5jYXRlZ29yaWVzLm1hcChlPT5lLnRvU3RyaW5nKCkpLmpvaW4oKStgXFxyXG5gKSx0aGlzLmRhdGEudXJsJiYodCs9XCJVUkw7VkFMVUU9VVJJOlwiK3IodGhpcy5kYXRhLnVybCwhMSkrYFxcclxuYCksdGhpcy5kYXRhLmF0dGFjaG1lbnRzLmxlbmd0aD4wJiZ0aGlzLmRhdGEuYXR0YWNobWVudHMuZm9yRWFjaChlPT57dCs9XCJBVFRBQ0g6XCIrcihlLCExKStgXFxyXG5gfSksdGhpcy5kYXRhLnN0YXR1cyYmKHQrPVwiU1RBVFVTOlwiK3RoaXMuZGF0YS5zdGF0dXMudG9VcHBlckNhc2UoKStgXFxyXG5gKSx0aGlzLmRhdGEuYnVzeXN0YXR1cyYmKHQrPVwiWC1NSUNST1NPRlQtQ0RPLUJVU1lTVEFUVVM6XCIrdGhpcy5kYXRhLmJ1c3lzdGF0dXMudG9VcHBlckNhc2UoKStgXFxyXG5gKSx0aGlzLmRhdGEucHJpb3JpdHkhPT1udWxsJiYodCs9XCJQUklPUklUWTpcIit0aGlzLmRhdGEucHJpb3JpdHkrYFxcclxuYCksdCs9RCh0aGlzLmRhdGEpLHRoaXMuZGF0YS5jcmVhdGVkJiYodCs9XCJDUkVBVEVEOlwiK28odGhpcy5jYWxlbmRhci50aW1lem9uZSgpLHRoaXMuZGF0YS5jcmVhdGVkKStgXFxyXG5gKSx0aGlzLmRhdGEubGFzdE1vZGlmaWVkJiYodCs9XCJMQVNULU1PRElGSUVEOlwiK28odGhpcy5jYWxlbmRhci50aW1lem9uZSgpLHRoaXMuZGF0YS5sYXN0TW9kaWZpZWQpK2BcXHJcbmApLHRoaXMuZGF0YS5jbGFzcyYmKHQrPVwiQ0xBU1M6XCIrdGhpcy5kYXRhLmNsYXNzLnRvVXBwZXJDYXNlKCkrYFxcclxuYCksdCs9YEVORDpWRVZFTlRcXHJcbmAsdH19O3ZhciBQPShtPT4obS5QVUJMSVNIPVwiUFVCTElTSFwiLG0uUkVRVUVTVD1cIlJFUVVFU1RcIixtLlJFUExZPVwiUkVQTFlcIixtLkFERD1cIkFERFwiLG0uQ0FOQ0VMPVwiQ0FOQ0VMXCIsbS5SRUZSRVNIPVwiUkVGUkVTSFwiLG0uQ09VTlRFUj1cIkNPVU5URVJcIixtLkRFQ0xJTkVDT1VOVEVSPVwiREVDTElORUNPVU5URVJcIixtKSkoUHx8e30pLFQ9Y2xhc3N7ZGF0YTtjb25zdHJ1Y3Rvcih0PXt9KXt0aGlzLmRhdGE9e3Byb2RJZDpcIi8vc2ViYm8ubmV0Ly9pY2FsLWdlbmVyYXRvci8vRU5cIixtZXRob2Q6bnVsbCxuYW1lOm51bGwsZGVzY3JpcHRpb246bnVsbCx0aW1lem9uZTpudWxsLHNvdXJjZTpudWxsLHVybDpudWxsLHNjYWxlOm51bGwsdHRsOm51bGwsZXZlbnRzOltdLHg6W119LHQucHJvZElkIT09dm9pZCAwJiZ0aGlzLnByb2RJZCh0LnByb2RJZCksdC5tZXRob2QhPT12b2lkIDAmJnRoaXMubWV0aG9kKHQubWV0aG9kKSx0Lm5hbWUhPT12b2lkIDAmJnRoaXMubmFtZSh0Lm5hbWUpLHQuZGVzY3JpcHRpb24hPT12b2lkIDAmJnRoaXMuZGVzY3JpcHRpb24odC5kZXNjcmlwdGlvbiksdC50aW1lem9uZSE9PXZvaWQgMCYmdGhpcy50aW1lem9uZSh0LnRpbWV6b25lKSx0LnNvdXJjZSE9PXZvaWQgMCYmdGhpcy5zb3VyY2UodC5zb3VyY2UpLHQudXJsIT09dm9pZCAwJiZ0aGlzLnVybCh0LnVybCksdC5zY2FsZSE9PXZvaWQgMCYmdGhpcy5zY2FsZSh0LnNjYWxlKSx0LnR0bCE9PXZvaWQgMCYmdGhpcy50dGwodC50dGwpLHQuZXZlbnRzIT09dm9pZCAwJiZ0aGlzLmV2ZW50cyh0LmV2ZW50cyksdC54IT09dm9pZCAwJiZ0aGlzLngodC54KX1wcm9kSWQodCl7aWYoIXQpcmV0dXJuIHRoaXMuZGF0YS5wcm9kSWQ7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpcmV0dXJuIHRoaXMuZGF0YS5wcm9kSWQ9dCx0aGlzO2lmKHR5cGVvZiB0IT1cIm9iamVjdFwiKXRocm93IG5ldyBFcnJvcihcImBwcm9kaWRgIG5lZWRzIHRvIGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdCFcIik7aWYoIXQuY29tcGFueSl0aHJvdyBuZXcgRXJyb3IoXCJgcHJvZGlkLmNvbXBhbnlgIGlzIGEgbWFuZGF0b3J5IGl0ZW0hXCIpO2lmKCF0LnByb2R1Y3QpdGhyb3cgbmV3IEVycm9yKFwiYHByb2RpZC5wcm9kdWN0YCBpcyBhIG1hbmRhdG9yeSBpdGVtIVwiKTtsZXQgZT0odC5sYW5ndWFnZXx8XCJFTlwiKS50b1VwcGVyQ2FzZSgpO3JldHVybiB0aGlzLmRhdGEucHJvZElkPVwiLy9cIit0LmNvbXBhbnkrXCIvL1wiK3QucHJvZHVjdCtcIi8vXCIrZSx0aGlzfW1ldGhvZCh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEubWV0aG9kOnQ/KHRoaXMuZGF0YS5tZXRob2Q9ZChQLHQpLHRoaXMpOih0aGlzLmRhdGEubWV0aG9kPW51bGwsdGhpcyl9bmFtZSh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEubmFtZToodGhpcy5kYXRhLm5hbWU9dD9TdHJpbmcodCk6bnVsbCx0aGlzKX1kZXNjcmlwdGlvbih0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuZGVzY3JpcHRpb246KHRoaXMuZGF0YS5kZXNjcmlwdGlvbj10P1N0cmluZyh0KTpudWxsLHRoaXMpfXRpbWV6b25lKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS50aW1lem9uZT8ubmFtZXx8bnVsbDoodD09PVwiVVRDXCI/dGhpcy5kYXRhLnRpbWV6b25lPW51bGw6dHlwZW9mIHQ9PVwic3RyaW5nXCI/dGhpcy5kYXRhLnRpbWV6b25lPXtuYW1lOnR9OnQ9PT1udWxsP3RoaXMuZGF0YS50aW1lem9uZT1udWxsOnRoaXMuZGF0YS50aW1lem9uZT10LHRoaXMpfXNvdXJjZSh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuc291cmNlOih0aGlzLmRhdGEuc291cmNlPXR8fG51bGwsdGhpcyl9dXJsKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS51cmw6KHRoaXMuZGF0YS51cmw9dHx8bnVsbCx0aGlzKX1zY2FsZSh0KXtyZXR1cm4gdD09PXZvaWQgMD90aGlzLmRhdGEuc2NhbGU6KHQ9PT1udWxsP3RoaXMuZGF0YS5zY2FsZT1udWxsOnRoaXMuZGF0YS5zY2FsZT10LnRvVXBwZXJDYXNlKCksdGhpcyl9dHRsKHQpe3JldHVybiB0PT09dm9pZCAwP3RoaXMuZGF0YS50dGw6KEoodCk/dGhpcy5kYXRhLnR0bD10LmFzU2Vjb25kcygpOnQmJnQ+MD90aGlzLmRhdGEudHRsPXQ6dGhpcy5kYXRhLnR0bD1udWxsLHRoaXMpfWNyZWF0ZUV2ZW50KHQpe2xldCBlPXQgaW5zdGFuY2VvZiB5P3Q6bmV3IHkodCx0aGlzKTtyZXR1cm4gdGhpcy5kYXRhLmV2ZW50cy5wdXNoKGUpLGV9ZXZlbnRzKHQpe3JldHVybiB0Pyh0LmZvckVhY2goZT0+dGhpcy5jcmVhdGVFdmVudChlKSksdGhpcyk6dGhpcy5kYXRhLmV2ZW50c31jbGVhcigpe3JldHVybiB0aGlzLmRhdGEuZXZlbnRzPVtdLHRoaXN9eCh0LGUpe2lmKHQ9PT12b2lkIDApcmV0dXJuIGwodGhpcy5kYXRhKTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIiYmdHlwZW9mIGU9PVwic3RyaW5nXCIpbCh0aGlzLmRhdGEsdCxlKTtlbHNlIGlmKHR5cGVvZiB0PT1cIm9iamVjdFwiKWwodGhpcy5kYXRhLHQpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGtleSBvciB2YWx1ZSBpcyBub3QgYSBzdHJpbmchXCIpO3JldHVybiB0aGlzfXRvSlNPTigpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LHRoaXMuZGF0YSx7dGltZXpvbmU6dGhpcy50aW1lem9uZSgpLGV2ZW50czp0aGlzLmRhdGEuZXZlbnRzLm1hcCh0PT50LnRvSlNPTigpKSx4OnRoaXMueCgpfSl9bGVuZ3RoKCl7cmV0dXJuIHRoaXMuZGF0YS5ldmVudHMubGVuZ3RofXRvU3RyaW5nKCl7bGV0IHQ9XCJcIjtyZXR1cm4gdD1gQkVHSU46VkNBTEVOREFSXFxyXG5WRVJTSU9OOjIuMFxcclxuYCx0Kz1cIlBST0RJRDotXCIrdGhpcy5kYXRhLnByb2RJZCtgXFxyXG5gLHRoaXMuZGF0YS51cmwmJih0Kz1cIlVSTDpcIit0aGlzLmRhdGEudXJsK2BcXHJcbmApLHRoaXMuZGF0YS5zb3VyY2UmJih0Kz1cIlNPVVJDRTtWQUxVRT1VUkk6XCIrdGhpcy5kYXRhLnNvdXJjZStgXFxyXG5gKSx0aGlzLmRhdGEuc2NhbGUmJih0Kz1cIkNBTFNDQUxFOlwiK3RoaXMuZGF0YS5zY2FsZStgXFxyXG5gKSx0aGlzLmRhdGEubWV0aG9kJiYodCs9XCJNRVRIT0Q6XCIrdGhpcy5kYXRhLm1ldGhvZCtgXFxyXG5gKSx0aGlzLmRhdGEubmFtZSYmKHQrPVwiTkFNRTpcIit0aGlzLmRhdGEubmFtZStgXFxyXG5gLHQrPVwiWC1XUi1DQUxOQU1FOlwiK3RoaXMuZGF0YS5uYW1lK2BcXHJcbmApLHRoaXMuZGF0YS5kZXNjcmlwdGlvbiYmKHQrPVwiWC1XUi1DQUxERVNDOlwiK3RoaXMuZGF0YS5kZXNjcmlwdGlvbitgXFxyXG5gKSx0aGlzLmRhdGEudGltZXpvbmU/LmdlbmVyYXRvciYmWy4uLm5ldyBTZXQoW3RoaXMudGltZXpvbmUoKSwuLi50aGlzLmRhdGEuZXZlbnRzLm1hcChuPT5uLnRpbWV6b25lKCkpXSldLmZpbHRlcihuPT5uIT09bnVsbCYmIW4uc3RhcnRzV2l0aChcIi9cIikpLmZvckVhY2gobj0+e2lmKCF0aGlzLmRhdGEudGltZXpvbmU/LmdlbmVyYXRvcilyZXR1cm47bGV0IGk9dGhpcy5kYXRhLnRpbWV6b25lLmdlbmVyYXRvcihuKTtpJiYodCs9aS5yZXBsYWNlKC9cXHJcXG4vZyxgXG5gKS5yZXBsYWNlKC9cXG4vZyxgXFxyXG5gKS50cmltKCkrYFxcclxuYCl9KSx0aGlzLmRhdGEudGltZXpvbmU/Lm5hbWUmJih0Kz1cIlRJTUVaT05FLUlEOlwiK3RoaXMuZGF0YS50aW1lem9uZS5uYW1lK2BcXHJcbmAsdCs9XCJYLVdSLVRJTUVaT05FOlwiK3RoaXMuZGF0YS50aW1lem9uZS5uYW1lK2BcXHJcbmApLHRoaXMuZGF0YS50dGwmJih0Kz1cIlJFRlJFU0gtSU5URVJWQUw7VkFMVUU9RFVSQVRJT046XCIrQyh0aGlzLmRhdGEudHRsKStgXFxyXG5gLHQrPVwiWC1QVUJMSVNIRUQtVFRMOlwiK0ModGhpcy5kYXRhLnR0bCkrYFxcclxuYCksdGhpcy5kYXRhLmV2ZW50cy5mb3JFYWNoKGU9PnQrPWUudG9TdHJpbmcoKSksdCs9RCh0aGlzLmRhdGEpLHQrPVwiRU5EOlZDQUxFTkRBUlwiLHYodCl9fTtmdW5jdGlvbiBIKGEpe3JldHVybiBuZXcgVChhKX12YXIgSXQ9SDtleHBvcnR7SSBhcyBJQ2FsQWxhcm0sWSBhcyBJQ2FsQWxhcm1SZWxhdGVzVG8sViBhcyBJQ2FsQWxhcm1UeXBlLGYgYXMgSUNhbEF0dGVuZGVlLE8gYXMgSUNhbEF0dGVuZGVlUm9sZSxNIGFzIElDYWxBdHRlbmRlZVN0YXR1cyx3IGFzIElDYWxBdHRlbmRlZVR5cGUsVCBhcyBJQ2FsQ2FsZW5kYXIsUCBhcyBJQ2FsQ2FsZW5kYXJNZXRob2QsYyBhcyBJQ2FsQ2F0ZWdvcnkseSBhcyBJQ2FsRXZlbnQseiBhcyBJQ2FsRXZlbnRCdXN5U3RhdHVzLEIgYXMgSUNhbEV2ZW50Q2xhc3MsYiBhcyBJQ2FsRXZlbnRSZXBlYXRpbmdGcmVxLEwgYXMgSUNhbEV2ZW50U3RhdHVzLFUgYXMgSUNhbEV2ZW50VHJhbnNwYXJlbmN5LEEgYXMgSUNhbFdlZWtkYXksSXQgYXMgZGVmYXVsdCxyIGFzIGVzY2FwZSx2IGFzIGZvbGRMaW5lcyxvIGFzIGZvcm1hdERhdGUsRSBhcyBmb3JtYXREYXRlVFp9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IGNvbnN0YW50cyBmcm9tICckbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgdHlwZSB7IFNjaGVkdWxlSXRlbSB9IGZyb20gJyRsaWIvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TG9jYWxUaW1lWm9uZSwgVGltZSwgdG9DYWxlbmRhckRhdGVUaW1lIH0gZnJvbSAnQGludGVybmF0aW9uYWxpemVkL2RhdGUnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnYml0cy11aSc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdmaWxlLXNhdmVyJztcbmltcG9ydCBpY2FsLCB7IElDYWxFdmVudFJlcGVhdGluZ0ZyZXEsIHR5cGUgSUNhbEV2ZW50RGF0YSB9IGZyb20gJ2ljYWwtZ2VuZXJhdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERheUluZGV4T2ZXZWVrKGRhdGU6IERhdGUsIGRheUluZGV4OiBudW1iZXIpOiBEYXRlIHtcblx0Y29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblx0Y29uc3Qgb2Zmc2V0ID0gZGF5SW5kZXggLSBkYXk7XG5cdGNvbnN0IGFkamVzdGVkRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgb2Zmc2V0ICogKDEwMDAgKiAzNjAwICogMjQpKTtcblx0cmV0dXJuIGFkamVzdGVkRGF0ZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSWNhbFN0dWR5KHNjaGVkdWxlSXRlbXM6IFNjaGVkdWxlSXRlbVtdLCByZXBlYXRpbmdSYW5nZTogRGF0ZVJhbmdlKSB7XG5cdGlmICghcmVwZWF0aW5nUmFuZ2Uuc3RhcnQgfHwgIXJlcGVhdGluZ1JhbmdlLmVuZClcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVwZWF0aW5nUmFuZ2UnKTtcblxuXHRmdW5jdGlvbiBjb252ZXJ0RXZlbnQoc2NoZWR1bGVJdGVtOiBTY2hlZHVsZUl0ZW0pOiBJQ2FsRXZlbnREYXRhIHtcblx0XHRjb25zdCBldmVudDogSUNhbEV2ZW50RGF0YSA9IHtcblx0XHRcdHN1bW1hcnk6IGAke3NjaGVkdWxlSXRlbS5zdWJqZWN0TmFtZX0gKCR7c2NoZWR1bGVJdGVtLnR5cGV9KWAsXG5cdFx0XHRsb2NhdGlvbjogYCR7c2NoZWR1bGVJdGVtLmJ1aWxkaW5nfToke3NjaGVkdWxlSXRlbS5yb29tfWAsXG5cdFx0XHRzdGFydDogZ2V0RGF5SW5kZXhPZldlZWsoXG5cdFx0XHRcdHRvQ2FsZW5kYXJEYXRlVGltZShcblx0XHRcdFx0XHRyZXBlYXRpbmdSYW5nZS5zdGFydCEsXG5cdFx0XHRcdFx0bmV3IFRpbWUoTnVtYmVyKHNjaGVkdWxlSXRlbS5zdGFydC5zbGljZSgwLCAyKSksIE51bWJlcihzY2hlZHVsZUl0ZW0uc3RhcnQuc2xpY2UoLTIpKSlcblx0XHRcdFx0KS50b0RhdGUoZ2V0TG9jYWxUaW1lWm9uZSgpKSxcblx0XHRcdFx0c2NoZWR1bGVJdGVtLmRheVxuXHRcdFx0KSxcblx0XHRcdGVuZDogZ2V0RGF5SW5kZXhPZldlZWsoXG5cdFx0XHRcdHRvQ2FsZW5kYXJEYXRlVGltZShcblx0XHRcdFx0XHRyZXBlYXRpbmdSYW5nZS5zdGFydCEsXG5cdFx0XHRcdFx0bmV3IFRpbWUoTnVtYmVyKHNjaGVkdWxlSXRlbS5zdGFydC5zbGljZSgwLCAyKSksIE51bWJlcihzY2hlZHVsZUl0ZW0uc3RhcnQuc2xpY2UoLTIpKSlcblx0XHRcdFx0KS50b0RhdGUoZ2V0TG9jYWxUaW1lWm9uZSgpKSxcblx0XHRcdFx0c2NoZWR1bGVJdGVtLmRheVxuXHRcdFx0KSxcblx0XHRcdHJlcGVhdGluZzoge1xuXHRcdFx0XHRmcmVxOiBJQ2FsRXZlbnRSZXBlYXRpbmdGcmVxLldFRUtMWSxcblx0XHRcdFx0dW50aWw6IHJlcGVhdGluZ1JhbmdlLmVuZCEudG9EYXRlKGdldExvY2FsVGltZVpvbmUoKSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBldmVudDtcblx0fVxuXHRjb25zdCBjYWxlbmRhck5hbWUgPSBgU3R1ZHkgKCR7Y29uc3RhbnRzLmFwcE5hbWV9QCR7bmV3IERhdGUoKS50b1N0cmluZygpfSlgO1xuXHRjb25zdCBjYWxlbmRhciA9IGljYWwoeyBuYW1lOiBjYWxlbmRhck5hbWUsIHByb2RJZDogY29uc3RhbnRzLmFwcE5hbWUgfSk7XG5cdHNjaGVkdWxlSXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdGNvbnN0IGV2ZW50ID0gY29udmVydEV2ZW50KGl0ZW0pO1xuXHRcdGNhbGVuZGFyLmNyZWF0ZUV2ZW50KGV2ZW50KTtcblx0fSk7XG5cblx0Y29uc3QgY2FsZW5kYXJCbG9iID0gbmV3IEJsb2IoW2NhbGVuZGFyLnRvU3RyaW5nKCldLCB7IHR5cGU6ICd0ZXh0L2NhbGVuZGFyO2NoYXJzZXQ9dXRmLTgnIH0pO1xuXHRzYXZlQXMoY2FsZW5kYXJCbG9iLCBgJHtjYWxlbmRhck5hbWV9LmljYWxgKTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7XG4gICAgQ2FsZW5kYXJEYXRlLFxuICAgIERhdGVGb3JtYXR0ZXIsXG4gICAgdHlwZSBEYXRlVmFsdWUsXG4gICAgZ2V0TG9jYWxUaW1lWm9uZVxuICB9IGZyb20gXCJAaW50ZXJuYXRpb25hbGl6ZWQvZGF0ZVwiO1xuICBpbXBvcnQgeyBCdXR0b24sIGJ1dHRvblZhcmlhbnRzIH0gZnJvbSAnJGxpYi9jb21wb25lbnRzL3NoYWRjbi11aS9idXR0b24nO1xuXHRpbXBvcnQgKiBhcyBEaWFsb2cgZnJvbSAnJGxpYi9jb21wb25lbnRzL3NoYWRjbi11aS9kaWFsb2cnO1xuICBpbXBvcnQgKiBhcyBBY2NvcmRpb24gZnJvbSAnJGxpYi9jb21wb25lbnRzL3NoYWRjbi11aS9hY2NvcmRpb24nO1xuXHRpbXBvcnQgKiBhcyBQb3BvdmVyIGZyb20gJyRsaWIvY29tcG9uZW50cy9zaGFkY24tdWkvcG9wb3Zlcic7XG5cdGltcG9ydCB7IFN3aXRjaCB9IGZyb20gJyRsaWIvY29tcG9uZW50cy9zaGFkY24tdWkvc3dpdGNoJztcblx0aW1wb3J0IHsgTGFiZWwgfSBmcm9tICckbGliL2NvbXBvbmVudHMvc2hhZGNuLXVpL2xhYmVsJztcbiAgaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICckbGliL2NvbXBvbmVudHMvY2FsZW5kYXIvc2V0dGluZ3MnO1xuICBpbXBvcnQgeyBSYW5nZUNhbGVuZGFyIH0gZnJvbSBcIiRsaWIvY29tcG9uZW50cy9zaGFkY24tdWkvcmFuZ2UtY2FsZW5kYXJcIjtcbiAgaW1wb3J0IHR5cGUgeyBEYXRlUmFuZ2UgfSBmcm9tICdiaXRzLXVpJztcbiAgaW1wb3J0IHsgY24gfSBmcm9tICckbGliL3V0aWwvc2hhZGNuLXVpJztcblx0aW1wb3J0IHsgQ2FsZW5kYXJJY29uIH0gZnJvbSBcIkBsdWNpZGUvc3ZlbHRlXCI7XG5cdGltcG9ydCB7IGdlbmVyYXRlSWNhbFN0dWR5IH0gZnJvbSBcIiRsaWIvdXRpbC9pY2FsL2dlbmVyYXRvclwiO1xuXHRpbXBvcnQgeyBTY2hlZHVsZUl0ZW0gfSBmcm9tIFwiJGxpYi90eXBlc1wiO1xuXG4gIGxldCB7IHNjaGVkdWxlOiBzY2hlZHVsZSB9OiB7IHNjaGVkdWxlOiBTY2hlZHVsZUl0ZW1bXX0gPSAkcHJvcHMoKTtcblxuICBjb25zdCBkZiA9IG5ldyBEYXRlRm9ybWF0dGVyKFwiZW4tVVNcIiwge1xuICAgIGRhdGVTdHlsZTogXCJtZWRpdW1cIlxuICB9KTtcblxuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIGxldCB2YWx1ZTogRGF0ZVJhbmdlID0gJHN0YXRlKHtcbiAgICBzdGFydDogbmV3IENhbGVuZGFyRGF0ZSh0b2RheS5nZXRGdWxsWWVhcigpLCB0b2RheS5nZXRNb250aCgpICsgMSwgdG9kYXkuZ2V0RGF0ZSgpKSxcbiAgICBlbmQ6IG5ldyBDYWxlbmRhckRhdGUodG9kYXkuZ2V0RnVsbFllYXIoKSwgdG9kYXkuZ2V0TW9udGgoKSArIDEsIHRvZGF5LmdldERhdGUoKSlcbiAgfSk7XG5cbiAgbGV0IHN0YXJ0VmFsdWU6IERhdGVWYWx1ZSB8IHVuZGVmaW5lZCA9ICRzdGF0ZSh1bmRlZmluZWQpO1xuXG48L3NjcmlwdD5cblxuPERpYWxvZy5Sb290PlxuXHQ8RGlhbG9nLlRyaWdnZXIgY2xhc3M9e2J1dHRvblZhcmlhbnRzKHsgdmFyaWFudDogJ291dGxpbmUnIH0pfT5HZW5lcmF0ZSBDYWxlbmRhcjwvRGlhbG9nLlRyaWdnZXI+XG5cdDxEaWFsb2cuQ29udGVudCBjbGFzcz1cInNtOm1heC13LVs0MjVweF1cIj5cblx0XHQ8RGlhbG9nLkhlYWRlcj5cblx0XHRcdDxEaWFsb2cuVGl0bGU+R2VuZXJhdGUgQ2FsZW5kYXI8L0RpYWxvZy5UaXRsZT5cblx0XHRcdDwhLS0gPERpYWxvZy5EZXNjcmlwdGlvbj5cblx0XHRcdFx0TWFrZSBjaGFuZ2VzIHRvIHlvdXIgcHJvZmlsZSBoZXJlLiBDbGljayBzYXZlIHdoZW4geW91J3JlIGRvbmUuXG5cdFx0XHQ8L0RpYWxvZy5EZXNjcmlwdGlvbj4gLS0+XG5cdFx0PC9EaWFsb2cuSGVhZGVyPlxuXG4gICAgPGgzPlNldCByZXBlYXRpbmcgcmFuZ2U8L2gzPlxuICAgIDxkaXYgY2xhc3M9XCJncmlkIGdhcC0yXCI+XG4gICAgICA8UG9wb3Zlci5Sb290PlxuICAgICAgICA8UG9wb3Zlci5UcmlnZ2VyXG4gICAgICAgICAgY2xhc3M9e2NuKFxuICAgICAgICAgICAgYnV0dG9uVmFyaWFudHMoeyB2YXJpYW50OiBcIm91dGxpbmVcIiB9KSxcbiAgICAgICAgICAgICF2YWx1ZSAmJiBcInRleHQtbXV0ZWQtZm9yZWdyb3VuZFwiXG4gICAgICAgICAgKX1cbiAgICAgICAgPlxuICAgICAgICAgIDxDYWxlbmRhckljb24gY2xhc3M9XCJtci0yIHNpemUtNFwiIC8+XG4gICAgICAgICAgeyNpZiB2YWx1ZSAmJiB2YWx1ZS5zdGFydH1cbiAgICAgICAgICAgIHsjaWYgdmFsdWUuZW5kfVxuICAgICAgICAgICAgICB7ZGYuZm9ybWF0KHZhbHVlLnN0YXJ0LnRvRGF0ZShnZXRMb2NhbFRpbWVab25lKCkpKX0gLSB7ZGYuZm9ybWF0KFxuICAgICAgICAgICAgICAgIHZhbHVlLmVuZC50b0RhdGUoZ2V0TG9jYWxUaW1lWm9uZSgpKVxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICB7ZGYuZm9ybWF0KHZhbHVlLnN0YXJ0LnRvRGF0ZShnZXRMb2NhbFRpbWVab25lKCkpKX1cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgezplbHNlIGlmIHN0YXJ0VmFsdWV9XG4gICAgICAgICAgICB7ZGYuZm9ybWF0KHN0YXJ0VmFsdWUudG9EYXRlKGdldExvY2FsVGltZVpvbmUoKSkpfVxuICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIFBpY2sgYSBkYXRlXG4gICAgICAgICAgey9pZn1cbiAgICAgICAgPC9Qb3BvdmVyLlRyaWdnZXI+XG4gICAgICAgIDxQb3BvdmVyLkNvbnRlbnQgY2xhc3M9XCJ3LWF1dG8gcC0wXCIgYWxpZ249XCJzdGFydFwiPlxuICAgICAgICAgIDxSYW5nZUNhbGVuZGFyXG4gICAgICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgICAgICBvblN0YXJ0VmFsdWVDaGFuZ2U9eyh2KSA9PiB7XG4gICAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSB2O1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG51bWJlck9mTW9udGhzPXsyfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvUG9wb3Zlci5Db250ZW50PlxuICAgICAgPC9Qb3BvdmVyLlJvb3Q+XG4gICAgPC9kaXY+XG5cblx0XHQ8IS0tIDxBY2NvcmRpb24uUm9vdCB0eXBlPVwic2luZ2xlXCI+XG4gICAgICA8QWNjb3JkaW9uLkl0ZW0gdmFsdWU9XCJvcHRpb25zLWFjY29yZGlvblwiPlxuICAgICAgICA8QWNjb3JkaW9uLlRyaWdnZXI+T3B0aW9uczwvQWNjb3JkaW9uLlRyaWdnZXI+XG4gICAgICAgIDxBY2NvcmRpb24uQ29udGVudD5cbiAgICAgICAgICB7I2VhY2ggc2V0dGluZ3MgYXMgeyBpZCwgbGFiZWwsIHZhbHVlIH19XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XG4gICAgICAgICAgICAgIDxTd2l0Y2ggYmluZDpjaGVja2VkPXt2YWx1ZX0gaWQ9e2lkfSAvPlxuICAgICAgICAgICAgICA8TGFiZWwgZm9yPXtpZH0+e2xhYmVsfTwvTGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvQWNjb3JkaW9uLkNvbnRlbnQ+XG4gICAgICA8L0FjY29yZGlvbi5JdGVtPlxuICAgIDwvQWNjb3JkaW9uLlJvb3Q+IC0tPlxuICAgIDxEaWFsb2cuRm9vdGVyPlxuICAgICAgPEJ1dHRvbiBvbmNsaWNrPXsoKSA9PiBnZW5lcmF0ZUljYWxTdHVkeShzY2hlZHVsZSwgdmFsdWUpfT5HZW5lcmF0ZTwvQnV0dG9uPlxuICAgIDwvRGlhbG9nLkZvb3Rlcj5cblx0PC9EaWFsb2cuQ29udGVudD5cbjwvRGlhbG9nLlJvb3Q+XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmwsIGJhc2VVcmwpIHtcbiAgICAvLyB1cmwgaXMgYWJzb2x1dGUgYWxyZWFkeVxuICAgIGlmICh1cmwubWF0Y2goL15bYS16XSs6XFwvXFwvL2kpKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIC8vIHVybCBpcyBhYnNvbHV0ZSBhbHJlYWR5LCB3aXRob3V0IHByb3RvY29sXG4gICAgaWYgKHVybC5tYXRjaCgvXlxcL1xcLy8pKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIC8vIGRhdGFVUkksIG1haWx0bzosIHRlbDosIGV0Yy5cbiAgICBpZiAodXJsLm1hdGNoKC9eW2Etel0rOi9pKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBjb25zdCBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgICBjb25zdCBiYXNlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICBjb25zdCBhID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChiYXNlKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICBiYXNlLmhyZWYgPSBiYXNlVXJsO1xuICAgIH1cbiAgICBhLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGEuaHJlZjtcbn1cbmV4cG9ydCBjb25zdCB1dWlkID0gKCgpID0+IHtcbiAgICAvLyBnZW5lcmF0ZSB1dWlkIGZvciBjbGFzc05hbWUgb2YgcHNldWRvIGVsZW1lbnRzLlxuICAgIC8vIFdlIHNob3VsZCBub3QgdXNlIEdVSURzLCBvdGhlcndpc2UgcHNldWRvIGVsZW1lbnRzIHNvbWV0aW1lcyBjYW5ub3QgYmUgY2FwdHVyZWQuXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIC8vIHJlZjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjI0ODcyMi8yNTE5MzczXG4gICAgY29uc3QgcmFuZG9tID0gKCkgPT4gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBgMDAwMCR7KChNYXRoLnJhbmRvbSgpICogMzYgKiogNCkgPDwgMCkudG9TdHJpbmcoMzYpfWAuc2xpY2UoLTQpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgcmV0dXJuIGB1JHtyYW5kb20oKX0ke2NvdW50ZXJ9YDtcbiAgICB9O1xufSkoKTtcbmV4cG9ydCBmdW5jdGlvbiBkZWxheShtcykge1xuICAgIHJldHVybiAoYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKGFyZ3MpLCBtcyk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5TGlrZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goYXJyYXlMaWtlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHB4KG5vZGUsIHN0eWxlUHJvcGVydHkpIHtcbiAgICBjb25zdCB3aW4gPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGNvbnN0IHZhbCA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XG4gICAgcmV0dXJuIHZhbCA/IHBhcnNlRmxvYXQodmFsLnJlcGxhY2UoJ3B4JywgJycpKSA6IDA7XG59XG5mdW5jdGlvbiBnZXROb2RlV2lkdGgobm9kZSkge1xuICAgIGNvbnN0IGxlZnRCb3JkZXIgPSBweChub2RlLCAnYm9yZGVyLWxlZnQtd2lkdGgnKTtcbiAgICBjb25zdCByaWdodEJvcmRlciA9IHB4KG5vZGUsICdib3JkZXItcmlnaHQtd2lkdGgnKTtcbiAgICByZXR1cm4gbm9kZS5jbGllbnRXaWR0aCArIGxlZnRCb3JkZXIgKyByaWdodEJvcmRlcjtcbn1cbmZ1bmN0aW9uIGdldE5vZGVIZWlnaHQobm9kZSkge1xuICAgIGNvbnN0IHRvcEJvcmRlciA9IHB4KG5vZGUsICdib3JkZXItdG9wLXdpZHRoJyk7XG4gICAgY29uc3QgYm90dG9tQm9yZGVyID0gcHgobm9kZSwgJ2JvcmRlci1ib3R0b20td2lkdGgnKTtcbiAgICByZXR1cm4gbm9kZS5jbGllbnRIZWlnaHQgKyB0b3BCb3JkZXIgKyBib3R0b21Cb3JkZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VTaXplKHRhcmdldE5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBnZXROb2RlV2lkdGgodGFyZ2V0Tm9kZSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgZ2V0Tm9kZUhlaWdodCh0YXJnZXROb2RlKTtcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGl4ZWxSYXRpbygpIHtcbiAgICBsZXQgcmF0aW87XG4gICAgbGV0IEZJTkFMX1BST0NFU1M7XG4gICAgdHJ5IHtcbiAgICAgICAgRklOQUxfUFJPQ0VTUyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHBhc3NcbiAgICB9XG4gICAgY29uc3QgdmFsID0gRklOQUxfUFJPQ0VTUyAmJiBGSU5BTF9QUk9DRVNTLmVudlxuICAgICAgICA/IEZJTkFMX1BST0NFU1MuZW52LmRldmljZVBpeGVsUmF0aW9cbiAgICAgICAgOiBudWxsO1xuICAgIGlmICh2YWwpIHtcbiAgICAgICAgcmF0aW8gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihyYXRpbykpIHtcbiAgICAgICAgICAgIHJhdGlvID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cbi8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2NhbnZhcyNtYXhpbXVtX2NhbnZhc19zaXplXG5jb25zdCBjYW52YXNEaW1lbnNpb25MaW1pdCA9IDE2Mzg0O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQ2FudmFzRGltZW5zaW9ucyhjYW52YXMpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoID4gY2FudmFzRGltZW5zaW9uTGltaXQgfHxcbiAgICAgICAgY2FudmFzLmhlaWdodCA+IGNhbnZhc0RpbWVuc2lvbkxpbWl0KSB7XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggPiBjYW52YXNEaW1lbnNpb25MaW1pdCAmJlxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA+IGNhbnZhc0RpbWVuc2lvbkxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoID4gY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgKj0gY2FudmFzRGltZW5zaW9uTGltaXQgLyBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzRGltZW5zaW9uTGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggKj0gY2FudmFzRGltZW5zaW9uTGltaXQgLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNEaW1lbnNpb25MaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW52YXMud2lkdGggPiBjYW52YXNEaW1lbnNpb25MaW1pdCkge1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCAqPSBjYW52YXNEaW1lbnNpb25MaW1pdCAvIGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc0RpbWVuc2lvbkxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoICo9IGNhbnZhc0RpbWVuc2lvbkxpbWl0IC8gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNEaW1lbnNpb25MaW1pdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXNUb0Jsb2IoY2FudmFzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IocmVzb2x2ZSwgb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogJ2ltYWdlL3BuZycsIG9wdGlvbnMucXVhbGl0eSA/IG9wdGlvbnMucXVhbGl0eSA6IDEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKGNhbnZhc1xuICAgICAgICAgICAgLnRvRGF0YVVSTChvcHRpb25zLnR5cGUgPyBvcHRpb25zLnR5cGUgOiB1bmRlZmluZWQsIG9wdGlvbnMucXVhbGl0eSA/IG9wdGlvbnMucXVhbGl0eSA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpWzFdKTtcbiAgICAgICAgY29uc3QgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmluYXJ5QXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBiaW5hcnlBcnJheVtpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUobmV3IEJsb2IoW2JpbmFyeUFycmF5XSwge1xuICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogJ2ltYWdlL3BuZycsXG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbWFnZSh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLmRlY29kZSA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICBpbWcuZGVjb2RpbmcgPSAnYXN5bmMnO1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN2Z1RvRGF0YVVSTChzdmcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4oKCkgPT4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpKVxuICAgICAgICAudGhlbihlbmNvZGVVUklDb21wb25lbnQpXG4gICAgICAgIC50aGVuKChodG1sKSA9PiBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHtodG1sfWApO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5vZGVUb0RhdGFVUkwobm9kZSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsICdzdmcnKTtcbiAgICBjb25zdCBmb3JlaWduT2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAnZm9yZWlnbk9iamVjdCcpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYCR7d2lkdGh9YCk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYCR7aGVpZ2h0fWApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAnMCcpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZSgnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICd0cnVlJyk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGZvcmVpZ25PYmplY3QpO1xuICAgIGZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHN2Z1RvRGF0YVVSTChzdmcpO1xufVxuZXhwb3J0IGNvbnN0IGlzSW5zdGFuY2VPZkVsZW1lbnQgPSAobm9kZSwgaW5zdGFuY2UpID0+IHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGluc3RhbmNlKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBub2RlUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5vZGUpO1xuICAgIGlmIChub2RlUHJvdG90eXBlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIChub2RlUHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgPT09IGluc3RhbmNlLm5hbWUgfHxcbiAgICAgICAgaXNJbnN0YW5jZU9mRWxlbWVudChub2RlUHJvdG90eXBlLCBpbnN0YW5jZSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiaW1wb3J0IHsgdXVpZCwgdG9BcnJheSB9IGZyb20gJy4vdXRpbCc7XG5mdW5jdGlvbiBmb3JtYXRDU1NUZXh0KHN0eWxlKSB7XG4gICAgY29uc3QgY29udGVudCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2NvbnRlbnQnKTtcbiAgICByZXR1cm4gYCR7c3R5bGUuY3NzVGV4dH0gY29udGVudDogJyR7Y29udGVudC5yZXBsYWNlKC8nfFwiL2csICcnKX0nO2A7XG59XG5mdW5jdGlvbiBmb3JtYXRDU1NQcm9wZXJ0aWVzKHN0eWxlKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoc3R5bGUpXG4gICAgICAgIC5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICBjb25zdCBwcmlvcml0eSA9IHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkobmFtZSk7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfTogJHt2YWx1ZX0ke3ByaW9yaXR5ID8gJyAhaW1wb3J0YW50JyA6ICcnfTtgO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBnZXRQc2V1ZG9FbGVtZW50U3R5bGUoY2xhc3NOYW1lLCBwc2V1ZG8sIHN0eWxlKSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBgLiR7Y2xhc3NOYW1lfToke3BzZXVkb31gO1xuICAgIGNvbnN0IGNzc1RleHQgPSBzdHlsZS5jc3NUZXh0XG4gICAgICAgID8gZm9ybWF0Q1NTVGV4dChzdHlsZSlcbiAgICAgICAgOiBmb3JtYXRDU1NQcm9wZXJ0aWVzKHN0eWxlKTtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYCR7c2VsZWN0b3J9eyR7Y3NzVGV4dH19YCk7XG59XG5mdW5jdGlvbiBjbG9uZVBzZXVkb0VsZW1lbnQobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSwgcHNldWRvKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVOb2RlLCBwc2V1ZG8pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdjb250ZW50Jyk7XG4gICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHV1aWQoKTtcbiAgICB0cnkge1xuICAgICAgICBjbG9uZWROb2RlLmNsYXNzTmFtZSA9IGAke2Nsb25lZE5vZGUuY2xhc3NOYW1lfSAke2NsYXNzTmFtZX1gO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZ2V0UHNldWRvRWxlbWVudFN0eWxlKGNsYXNzTmFtZSwgcHNldWRvLCBzdHlsZSkpO1xuICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVBzZXVkb0VsZW1lbnRzKG5hdGl2ZU5vZGUsIGNsb25lZE5vZGUpIHtcbiAgICBjbG9uZVBzZXVkb0VsZW1lbnQobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSwgJzpiZWZvcmUnKTtcbiAgICBjbG9uZVBzZXVkb0VsZW1lbnQobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSwgJzphZnRlcicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmUtcHNldWRvcy5qcy5tYXAiLCJjb25zdCBXT0ZGID0gJ2FwcGxpY2F0aW9uL2ZvbnQtd29mZic7XG5jb25zdCBKUEVHID0gJ2ltYWdlL2pwZWcnO1xuY29uc3QgbWltZXMgPSB7XG4gICAgd29mZjogV09GRixcbiAgICB3b2ZmMjogV09GRixcbiAgICB0dGY6ICdhcHBsaWNhdGlvbi9mb250LXRydWV0eXBlJyxcbiAgICBlb3Q6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgcG5nOiAnaW1hZ2UvcG5nJyxcbiAgICBqcGc6IEpQRUcsXG4gICAganBlZzogSlBFRyxcbiAgICBnaWY6ICdpbWFnZS9naWYnLFxuICAgIHRpZmY6ICdpbWFnZS90aWZmJyxcbiAgICBzdmc6ICdpbWFnZS9zdmcreG1sJyxcbiAgICB3ZWJwOiAnaW1hZ2Uvd2VicCcsXG59O1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHVybCkge1xuICAgIGNvbnN0IG1hdGNoID0gL1xcLihbXi4vXSo/KSQvZy5leGVjKHVybCk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW1lVHlwZSh1cmwpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBnZXRFeHRlbnNpb24odXJsKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBtaW1lc1tleHRlbnNpb25dIHx8ICcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWltZXMuanMubWFwIiwiZnVuY3Rpb24gZ2V0Q29udGVudEZyb21EYXRhVXJsKGRhdGFVUkwpIHtcbiAgICByZXR1cm4gZGF0YVVSTC5zcGxpdCgvLC8pWzFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnNlYXJjaCgvXihkYXRhOikvKSAhPT0gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZURhdGFVcmwoY29udGVudCwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4gYGRhdGE6JHttaW1lVHlwZX07YmFzZTY0LCR7Y29udGVudH1gO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQXNEYXRhVVJMKHVybCwgaW5pdCwgcHJvY2Vzcykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIFwiJHtyZXMudXJsfVwiIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9jZXNzKHsgcmVzLCByZXN1bHQ6IHJlYWRlci5yZXN1bHQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfSk7XG59XG5jb25zdCBjYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVLZXkodXJsLCBjb250ZW50VHlwZSwgaW5jbHVkZVF1ZXJ5UGFyYW1zKSB7XG4gICAgbGV0IGtleSA9IHVybC5yZXBsYWNlKC9cXD8uKi8sICcnKTtcbiAgICBpZiAoaW5jbHVkZVF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGtleSA9IHVybDtcbiAgICB9XG4gICAgLy8gZm9udCByZXNvdXJjZVxuICAgIGlmICgvdHRmfG90Znxlb3R8d29mZjI/L2kudGVzdChrZXkpKSB7XG4gICAgICAgIGtleSA9IGtleS5yZXBsYWNlKC8uKlxcLy8sICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnRUeXBlID8gYFske2NvbnRlbnRUeXBlfV0ke2tleX1gIDoga2V5O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc291cmNlVG9EYXRhVVJMKHJlc291cmNlVXJsLCBjb250ZW50VHlwZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVzb3VyY2VVcmwsIGNvbnRlbnRUeXBlLCBvcHRpb25zLmluY2x1ZGVRdWVyeVBhcmFtcyk7XG4gICAgaWYgKGNhY2hlW2NhY2hlS2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIC8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L1VzaW5nX1hNTEh0dHBSZXF1ZXN0I0J5cGFzc2luZ190aGVfY2FjaGVcbiAgICBpZiAob3B0aW9ucy5jYWNoZUJ1c3QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc291cmNlVXJsICs9ICgvXFw/Ly50ZXN0KHJlc291cmNlVXJsKSA/ICcmJyA6ICc/JykgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgbGV0IGRhdGFVUkw7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZldGNoQXNEYXRhVVJMKHJlc291cmNlVXJsLCBvcHRpb25zLmZldGNoUmVxdWVzdEluaXQsICh7IHJlcywgcmVzdWx0IH0pID0+IHtcbiAgICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgfHwgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29udGVudEZyb21EYXRhVXJsKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhVVJMID0gbWFrZURhdGFVcmwoY29udGVudCwgY29udGVudFR5cGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGF0YVVSTCA9IG9wdGlvbnMuaW1hZ2VQbGFjZWhvbGRlciB8fCAnJztcbiAgICAgICAgbGV0IG1zZyA9IGBGYWlsZWQgdG8gZmV0Y2ggcmVzb3VyY2U6ICR7cmVzb3VyY2VVcmx9YDtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlW2NhY2hlS2V5XSA9IGRhdGFVUkw7XG4gICAgcmV0dXJuIGRhdGFVUkw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhdXJsLmpzLm1hcCIsImltcG9ydCB7IGNsb25lUHNldWRvRWxlbWVudHMgfSBmcm9tICcuL2Nsb25lLXBzZXVkb3MnO1xuaW1wb3J0IHsgY3JlYXRlSW1hZ2UsIHRvQXJyYXksIGlzSW5zdGFuY2VPZkVsZW1lbnQgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZ2V0TWltZVR5cGUgfSBmcm9tICcuL21pbWVzJztcbmltcG9ydCB7IHJlc291cmNlVG9EYXRhVVJMIH0gZnJvbSAnLi9kYXRhdXJsJztcbmFzeW5jIGZ1bmN0aW9uIGNsb25lQ2FudmFzRWxlbWVudChjYW52YXMpIHtcbiAgICBjb25zdCBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIGlmIChkYXRhVVJMID09PSAnZGF0YTosJykge1xuICAgICAgICByZXR1cm4gY2FudmFzLmNsb25lTm9kZShmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVJbWFnZShkYXRhVVJMKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNsb25lVmlkZW9FbGVtZW50KHZpZGVvLCBvcHRpb25zKSB7XG4gICAgaWYgKHZpZGVvLmN1cnJlbnRTcmMpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB2aWRlby5jbGllbnRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHZpZGVvLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlKGRhdGFVUkwpO1xuICAgIH1cbiAgICBjb25zdCBwb3N0ZXIgPSB2aWRlby5wb3N0ZXI7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBnZXRNaW1lVHlwZShwb3N0ZXIpO1xuICAgIGNvbnN0IGRhdGFVUkwgPSBhd2FpdCByZXNvdXJjZVRvRGF0YVVSTChwb3N0ZXIsIGNvbnRlbnRUeXBlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlSW1hZ2UoZGF0YVVSTCk7XG59XG5hc3luYyBmdW5jdGlvbiBjbG9uZUlGcmFtZUVsZW1lbnQoaWZyYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICgoX2EgPSBpZnJhbWUgPT09IG51bGwgfHwgaWZyYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZnJhbWUuY29udGVudERvY3VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBjbG9uZU5vZGUoaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LCB7fSwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICAvLyBGYWlsZWQgdG8gY2xvbmUgaWZyYW1lXG4gICAgfVxuICAgIHJldHVybiBpZnJhbWUuY2xvbmVOb2RlKGZhbHNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNsb25lU2luZ2xlTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzSW5zdGFuY2VPZkVsZW1lbnQobm9kZSwgSFRNTENhbnZhc0VsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZUNhbnZhc0VsZW1lbnQobm9kZSk7XG4gICAgfVxuICAgIGlmIChpc0luc3RhbmNlT2ZFbGVtZW50KG5vZGUsIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZVZpZGVvRWxlbWVudChub2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGlzSW5zdGFuY2VPZkVsZW1lbnQobm9kZSwgSFRNTElGcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZUlGcmFtZUVsZW1lbnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG59XG5jb25zdCBpc1Nsb3RFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSAhPSBudWxsICYmIG5vZGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0xPVCc7XG5hc3luYyBmdW5jdGlvbiBjbG9uZUNoaWxkcmVuKG5hdGl2ZU5vZGUsIGNsb25lZE5vZGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgIGlmIChpc1Nsb3RFbGVtZW50KG5hdGl2ZU5vZGUpICYmIG5hdGl2ZU5vZGUuYXNzaWduZWROb2Rlcykge1xuICAgICAgICBjaGlsZHJlbiA9IHRvQXJyYXkobmF0aXZlTm9kZS5hc3NpZ25lZE5vZGVzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0luc3RhbmNlT2ZFbGVtZW50KG5hdGl2ZU5vZGUsIEhUTUxJRnJhbWVFbGVtZW50KSAmJlxuICAgICAgICAoKF9hID0gbmF0aXZlTm9kZS5jb250ZW50RG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib2R5KSkge1xuICAgICAgICBjaGlsZHJlbiA9IHRvQXJyYXkobmF0aXZlTm9kZS5jb250ZW50RG9jdW1lbnQuYm9keS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gdG9BcnJheSgoKF9iID0gbmF0aXZlTm9kZS5zaGFkb3dSb290KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuYXRpdmVOb2RlKS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBpc0luc3RhbmNlT2ZFbGVtZW50KG5hdGl2ZU5vZGUsIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZWROb2RlO1xuICAgIH1cbiAgICBhd2FpdCBjaGlsZHJlbi5yZWR1Y2UoKGRlZmVycmVkLCBjaGlsZCkgPT4gZGVmZXJyZWRcbiAgICAgICAgLnRoZW4oKCkgPT4gY2xvbmVOb2RlKGNoaWxkLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oKGNsb25lZENoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjbG9uZWRDaGlsZCkge1xuICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChjbG9uZWRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9KSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgIHJldHVybiBjbG9uZWROb2RlO1xufVxuZnVuY3Rpb24gY2xvbmVDU1NTdHlsZShuYXRpdmVOb2RlLCBjbG9uZWROb2RlKSB7XG4gICAgY29uc3QgdGFyZ2V0U3R5bGUgPSBjbG9uZWROb2RlLnN0eWxlO1xuICAgIGlmICghdGFyZ2V0U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5hdGl2ZU5vZGUpO1xuICAgIGlmIChzb3VyY2VTdHlsZS5jc3NUZXh0KSB7XG4gICAgICAgIHRhcmdldFN0eWxlLmNzc1RleHQgPSBzb3VyY2VTdHlsZS5jc3NUZXh0O1xuICAgICAgICB0YXJnZXRTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzb3VyY2VTdHlsZS50cmFuc2Zvcm1PcmlnaW47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b0FycmF5KHNvdXJjZVN0eWxlKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzb3VyY2VTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdmb250LXNpemUnICYmIHZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkdWNlZEZvbnQgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDIpKSkgLSAwLjE7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgJHtyZWR1Y2VkRm9udH1weGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbnN0YW5jZU9mRWxlbWVudChuYXRpdmVOb2RlLCBIVE1MSUZyYW1lRWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnZGlzcGxheScgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2QnICYmIGNsb25lZE5vZGUuZ2V0QXR0cmlidXRlKCdkJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBwYXRoKCR7Y2xvbmVkTm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBzb3VyY2VTdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KG5hbWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvbmVJbnB1dFZhbHVlKG5hdGl2ZU5vZGUsIGNsb25lZE5vZGUpIHtcbiAgICBpZiAoaXNJbnN0YW5jZU9mRWxlbWVudChuYXRpdmVOb2RlLCBIVE1MVGV4dEFyZWFFbGVtZW50KSkge1xuICAgICAgICBjbG9uZWROb2RlLmlubmVySFRNTCA9IG5hdGl2ZU5vZGUudmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0luc3RhbmNlT2ZFbGVtZW50KG5hdGl2ZU5vZGUsIEhUTUxJbnB1dEVsZW1lbnQpKSB7XG4gICAgICAgIGNsb25lZE5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIG5hdGl2ZU5vZGUudmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lU2VsZWN0VmFsdWUobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIGlmIChpc0luc3RhbmNlT2ZFbGVtZW50KG5hdGl2ZU5vZGUsIEhUTUxTZWxlY3RFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjbG9uZWRTZWxlY3QgPSBjbG9uZWROb2RlO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbiA9IEFycmF5LmZyb20oY2xvbmVkU2VsZWN0LmNoaWxkcmVuKS5maW5kKChjaGlsZCkgPT4gbmF0aXZlTm9kZS52YWx1ZSA9PT0gY2hpbGQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJycpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGUobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIGlmIChpc0luc3RhbmNlT2ZFbGVtZW50KGNsb25lZE5vZGUsIEVsZW1lbnQpKSB7XG4gICAgICAgIGNsb25lQ1NTU3R5bGUobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSk7XG4gICAgICAgIGNsb25lUHNldWRvRWxlbWVudHMobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSk7XG4gICAgICAgIGNsb25lSW5wdXRWYWx1ZShuYXRpdmVOb2RlLCBjbG9uZWROb2RlKTtcbiAgICAgICAgY2xvbmVTZWxlY3RWYWx1ZShuYXRpdmVOb2RlLCBjbG9uZWROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZE5vZGU7XG59XG5hc3luYyBmdW5jdGlvbiBlbnN1cmVTVkdTeW1ib2xzKGNsb25lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdXNlcyA9IGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwgPyBjbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCd1c2UnKSA6IFtdO1xuICAgIGlmICh1c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIGNvbnN0IHByb2Nlc3NlZERlZnMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdXNlID0gdXNlc1tpXTtcbiAgICAgICAgY29uc3QgaWQgPSB1c2UuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJyk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3QgPSBjbG9uZS5xdWVyeVNlbGVjdG9yKGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGlkKTtcbiAgICAgICAgICAgIGlmICghZXhpc3QgJiYgZGVmaW5pdGlvbiAmJiAhcHJvY2Vzc2VkRGVmc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZERlZnNbaWRdID0gKGF3YWl0IGNsb25lTm9kZShkZWZpbml0aW9uLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBPYmplY3QudmFsdWVzKHByb2Nlc3NlZERlZnMpO1xuICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gICAgICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ3N2ZycpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd4bWxucycsIG5zKTtcbiAgICAgICAgc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3ZnLnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgICBzdmcuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgICBzdmcuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgc3ZnLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNvbnN0IGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdkZWZzJyk7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb25lTm9kZShub2RlLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICBpZiAoIWlzUm9vdCAmJiBvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobm9kZSlcbiAgICAgICAgLnRoZW4oKGNsb25lZE5vZGUpID0+IGNsb25lU2luZ2xlTm9kZShjbG9uZWROb2RlLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oKGNsb25lZE5vZGUpID0+IGNsb25lQ2hpbGRyZW4obm9kZSwgY2xvbmVkTm9kZSwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChjbG9uZWROb2RlKSA9PiBkZWNvcmF0ZShub2RlLCBjbG9uZWROb2RlKSlcbiAgICAgICAgLnRoZW4oKGNsb25lZE5vZGUpID0+IGVuc3VyZVNWR1N5bWJvbHMoY2xvbmVkTm9kZSwgb3B0aW9ucykpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmUtbm9kZS5qcy5tYXAiLCJpbXBvcnQgeyByZXNvbHZlVXJsIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdldE1pbWVUeXBlIH0gZnJvbSAnLi9taW1lcyc7XG5pbXBvcnQgeyBpc0RhdGFVcmwsIG1ha2VEYXRhVXJsLCByZXNvdXJjZVRvRGF0YVVSTCB9IGZyb20gJy4vZGF0YXVybCc7XG5jb25zdCBVUkxfUkVHRVggPSAvdXJsXFwoKFsnXCJdPykoW14nXCJdKz8pXFwxXFwpL2c7XG5jb25zdCBVUkxfV0lUSF9GT1JNQVRfUkVHRVggPSAvdXJsXFwoW14pXStcXClcXHMqZm9ybWF0XFwoKFtcIiddPykoW15cIiddKylcXDFcXCkvZztcbmNvbnN0IEZPTlRfU1JDX1JFR0VYID0gL3NyYzpcXHMqKD86dXJsXFwoW14pXStcXClcXHMqZm9ybWF0XFwoW14pXStcXClbLDtdXFxzKikrL2c7XG5mdW5jdGlvbiB0b1JlZ2V4KHVybCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgIGNvbnN0IGVzY2FwZWQgPSB1cmwucmVwbGFjZSgvKFsuKis/XiR7fSgpfFxcW1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYCh1cmxcXFxcKFsnXCJdPykoJHtlc2NhcGVkfSkoWydcIl0/XFxcXCkpYCwgJ2cnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVSTHMoY3NzVGV4dCkge1xuICAgIGNvbnN0IHVybHMgPSBbXTtcbiAgICBjc3NUZXh0LnJlcGxhY2UoVVJMX1JFR0VYLCAocmF3LCBxdW90YXRpb24sIHVybCkgPT4ge1xuICAgICAgICB1cmxzLnB1c2godXJsKTtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9KTtcbiAgICByZXR1cm4gdXJscy5maWx0ZXIoKHVybCkgPT4gIWlzRGF0YVVybCh1cmwpKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbWJlZChjc3NUZXh0LCByZXNvdXJjZVVSTCwgYmFzZVVSTCwgb3B0aW9ucywgZ2V0Q29udGVudEZyb21VcmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNvbHZlZFVSTCA9IGJhc2VVUkwgPyByZXNvbHZlVXJsKHJlc291cmNlVVJMLCBiYXNlVVJMKSA6IHJlc291cmNlVVJMO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGdldE1pbWVUeXBlKHJlc291cmNlVVJMKTtcbiAgICAgICAgbGV0IGRhdGFVUkw7XG4gICAgICAgIGlmIChnZXRDb250ZW50RnJvbVVybCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGdldENvbnRlbnRGcm9tVXJsKHJlc29sdmVkVVJMKTtcbiAgICAgICAgICAgIGRhdGFVUkwgPSBtYWtlRGF0YVVybChjb250ZW50LCBjb250ZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhVVJMID0gYXdhaXQgcmVzb3VyY2VUb0RhdGFVUkwocmVzb2x2ZWRVUkwsIGNvbnRlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHRvUmVnZXgocmVzb3VyY2VVUkwpLCBgJDEke2RhdGFVUkx9JDNgKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIHBhc3NcbiAgICB9XG4gICAgcmV0dXJuIGNzc1RleHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJQcmVmZXJyZWRGb250Rm9ybWF0KHN0ciwgeyBwcmVmZXJyZWRGb250Rm9ybWF0IH0pIHtcbiAgICByZXR1cm4gIXByZWZlcnJlZEZvbnRGb3JtYXRcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBzdHIucmVwbGFjZShGT05UX1NSQ19SRUdFWCwgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzcmMsICwgZm9ybWF0XSA9IFVSTF9XSVRIX0ZPUk1BVF9SRUdFWC5leGVjKG1hdGNoKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IHByZWZlcnJlZEZvbnRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBzcmM6ICR7c3JjfTtgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkRW1iZWQodXJsKSB7XG4gICAgcmV0dXJuIHVybC5zZWFyY2goVVJMX1JFR0VYKSAhPT0gLTE7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW1iZWRSZXNvdXJjZXMoY3NzVGV4dCwgYmFzZVVybCwgb3B0aW9ucykge1xuICAgIGlmICghc2hvdWxkRW1iZWQoY3NzVGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQ7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkQ1NTVGV4dCA9IGZpbHRlclByZWZlcnJlZEZvbnRGb3JtYXQoY3NzVGV4dCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdXJscyA9IHBhcnNlVVJMcyhmaWx0ZXJlZENTU1RleHQpO1xuICAgIHJldHVybiB1cmxzLnJlZHVjZSgoZGVmZXJyZWQsIHVybCkgPT4gZGVmZXJyZWQudGhlbigoY3NzKSA9PiBlbWJlZChjc3MsIHVybCwgYmFzZVVybCwgb3B0aW9ucykpLCBQcm9taXNlLnJlc29sdmUoZmlsdGVyZWRDU1NUZXh0KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZC1yZXNvdXJjZXMuanMubWFwIiwiaW1wb3J0IHsgZW1iZWRSZXNvdXJjZXMgfSBmcm9tICcuL2VtYmVkLXJlc291cmNlcyc7XG5pbXBvcnQgeyB0b0FycmF5LCBpc0luc3RhbmNlT2ZFbGVtZW50IH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGlzRGF0YVVybCwgcmVzb3VyY2VUb0RhdGFVUkwgfSBmcm9tICcuL2RhdGF1cmwnO1xuaW1wb3J0IHsgZ2V0TWltZVR5cGUgfSBmcm9tICcuL21pbWVzJztcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkUHJvcChwcm9wTmFtZSwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcm9wVmFsdWUgPSAoX2EgPSBub2RlLnN0eWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICBjb25zdCBjc3NTdHJpbmcgPSBhd2FpdCBlbWJlZFJlc291cmNlcyhwcm9wVmFsdWUsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KHByb3BOYW1lLCBjc3NTdHJpbmcsIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwcm9wTmFtZSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1iZWRCYWNrZ3JvdW5kKGNsb25lZE5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShhd2FpdCBlbWJlZFByb3AoJ2JhY2tncm91bmQnLCBjbG9uZWROb2RlLCBvcHRpb25zKSkpIHtcbiAgICAgICAgYXdhaXQgZW1iZWRQcm9wKCdiYWNrZ3JvdW5kLWltYWdlJywgY2xvbmVkTm9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICghKGF3YWl0IGVtYmVkUHJvcCgnbWFzaycsIGNsb25lZE5vZGUsIG9wdGlvbnMpKSkge1xuICAgICAgICBhd2FpdCBlbWJlZFByb3AoJ21hc2staW1hZ2UnLCBjbG9uZWROb2RlLCBvcHRpb25zKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBlbWJlZEltYWdlTm9kZShjbG9uZWROb2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXNJbWFnZUVsZW1lbnQgPSBpc0luc3RhbmNlT2ZFbGVtZW50KGNsb25lZE5vZGUsIEhUTUxJbWFnZUVsZW1lbnQpO1xuICAgIGlmICghKGlzSW1hZ2VFbGVtZW50ICYmICFpc0RhdGFVcmwoY2xvbmVkTm9kZS5zcmMpKSAmJlxuICAgICAgICAhKGlzSW5zdGFuY2VPZkVsZW1lbnQoY2xvbmVkTm9kZSwgU1ZHSW1hZ2VFbGVtZW50KSAmJlxuICAgICAgICAgICAgIWlzRGF0YVVybChjbG9uZWROb2RlLmhyZWYuYmFzZVZhbCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gaXNJbWFnZUVsZW1lbnQgPyBjbG9uZWROb2RlLnNyYyA6IGNsb25lZE5vZGUuaHJlZi5iYXNlVmFsO1xuICAgIGNvbnN0IGRhdGFVUkwgPSBhd2FpdCByZXNvdXJjZVRvRGF0YVVSTCh1cmwsIGdldE1pbWVUeXBlKHVybCksIG9wdGlvbnMpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2xvbmVkTm9kZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBjbG9uZWROb2RlLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGNvbnN0IGltYWdlID0gY2xvbmVkTm9kZTtcbiAgICAgICAgaWYgKGltYWdlLmRlY29kZSkge1xuICAgICAgICAgICAgaW1hZ2UuZGVjb2RlID0gcmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2UubG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICAgICAgICBpbWFnZS5sb2FkaW5nID0gJ2VhZ2VyJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNsb25lZE5vZGUuc3Jjc2V0ID0gJyc7XG4gICAgICAgICAgICBjbG9uZWROb2RlLnNyYyA9IGRhdGFVUkw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9uZWROb2RlLmhyZWYuYmFzZVZhbCA9IGRhdGFVUkw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtYmVkQ2hpbGRyZW4oY2xvbmVkTm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdG9BcnJheShjbG9uZWROb2RlLmNoaWxkTm9kZXMpO1xuICAgIGNvbnN0IGRlZmVycmVkcyA9IGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGVtYmVkSW1hZ2VzKGNoaWxkLCBvcHRpb25zKSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVmZXJyZWRzKS50aGVuKCgpID0+IGNsb25lZE5vZGUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVtYmVkSW1hZ2VzKGNsb25lZE5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNJbnN0YW5jZU9mRWxlbWVudChjbG9uZWROb2RlLCBFbGVtZW50KSkge1xuICAgICAgICBhd2FpdCBlbWJlZEJhY2tncm91bmQoY2xvbmVkTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IGVtYmVkSW1hZ2VOb2RlKGNsb25lZE5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBhd2FpdCBlbWJlZENoaWxkcmVuKGNsb25lZE5vZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkLWltYWdlcy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZShub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gbm9kZTtcbiAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7b3B0aW9ucy53aWR0aH1weGA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhlaWdodCkge1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtvcHRpb25zLmhlaWdodH1weGA7XG4gICAgfVxuICAgIGNvbnN0IG1hbnVhbCA9IG9wdGlvbnMuc3R5bGU7XG4gICAgaWYgKG1hbnVhbCAhPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1hbnVhbCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBzdHlsZVtrZXldID0gbWFudWFsW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5LXN0eWxlLmpzLm1hcCIsImltcG9ydCB7IHRvQXJyYXkgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZmV0Y2hBc0RhdGFVUkwgfSBmcm9tICcuL2RhdGF1cmwnO1xuaW1wb3J0IHsgc2hvdWxkRW1iZWQsIGVtYmVkUmVzb3VyY2VzIH0gZnJvbSAnLi9lbWJlZC1yZXNvdXJjZXMnO1xuY29uc3QgY3NzRmV0Y2hDYWNoZSA9IHt9O1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDU1ModXJsKSB7XG4gICAgbGV0IGNhY2hlID0gY3NzRmV0Y2hDYWNoZVt1cmxdO1xuICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBjb25zdCBjc3NUZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICBjYWNoZSA9IHsgdXJsLCBjc3NUZXh0IH07XG4gICAgY3NzRmV0Y2hDYWNoZVt1cmxdID0gY2FjaGU7XG4gICAgcmV0dXJuIGNhY2hlO1xufVxuYXN5bmMgZnVuY3Rpb24gZW1iZWRGb250cyhkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IGNzc1RleHQgPSBkYXRhLmNzc1RleHQ7XG4gICAgY29uc3QgcmVnZXhVcmwgPSAvdXJsXFwoW1wiJ10/KFteXCInKV0rKVtcIiddP1xcKS9nO1xuICAgIGNvbnN0IGZvbnRMb2NzID0gY3NzVGV4dC5tYXRjaCgvdXJsXFwoW14pXStcXCkvZykgfHwgW107XG4gICAgY29uc3QgbG9hZEZvbnRzID0gZm9udExvY3MubWFwKGFzeW5jIChsb2MpID0+IHtcbiAgICAgICAgbGV0IHVybCA9IGxvYy5yZXBsYWNlKHJlZ2V4VXJsLCAnJDEnKTtcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwsIGRhdGEudXJsKS5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaEFzRGF0YVVSTCh1cmwsIG9wdGlvbnMuZmV0Y2hSZXF1ZXN0SW5pdCwgKHsgcmVzdWx0IH0pID0+IHtcbiAgICAgICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UobG9jLCBgdXJsKCR7cmVzdWx0fSlgKTtcbiAgICAgICAgICAgIHJldHVybiBbbG9jLCByZXN1bHRdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZEZvbnRzKS50aGVuKCgpID0+IGNzc1RleHQpO1xufVxuZnVuY3Rpb24gcGFyc2VDU1Moc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgY29tbWVudHNSZWdleCA9IC8oXFwvXFwqW1xcc1xcU10qP1xcKlxcLykvZ2k7XG4gICAgLy8gc3RyaXAgb3V0IGNvbW1lbnRzXG4gICAgbGV0IGNzc1RleHQgPSBzb3VyY2UucmVwbGFjZShjb21tZW50c1JlZ2V4LCAnJyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZWdleC1saXRlcmFsc1xuICAgIGNvbnN0IGtleWZyYW1lc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnKChALio/a2V5ZnJhbWVzIFtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj99XFxcXHMqPyl9KScsICdnaScpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0ga2V5ZnJhbWVzUmVnZXguZXhlYyhjc3NUZXh0KTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG1hdGNoZXNbMF0pO1xuICAgIH1cbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKGtleWZyYW1lc1JlZ2V4LCAnJyk7XG4gICAgY29uc3QgaW1wb3J0UmVnZXggPSAvQGltcG9ydFtcXHNcXFNdKj91cmxcXChbXildKlxcKVtcXHNcXFNdKj87L2dpO1xuICAgIC8vIHRvIG1hdGNoIGNzcyAmIG1lZGlhIHF1ZXJpZXMgdG9nZXRoZXJcbiAgICBjb25zdCBjb21iaW5lZENTU1JlZ2V4ID0gJygoXFxcXHMqPyg/OlxcXFwvXFxcXCpbXFxcXHNcXFxcU10qP1xcXFwqXFxcXC8pP1xcXFxzKj9AbWVkaWFbXFxcXHNcXFxcU10nICtcbiAgICAgICAgJyo/KXsoW1xcXFxzXFxcXFNdKj8pfVxcXFxzKj99KXwoKFtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj8pfSknO1xuICAgIC8vIHVuaWZpZWQgcmVnZXhcbiAgICBjb25zdCB1bmlmaWVkUmVnZXggPSBuZXcgUmVnRXhwKGNvbWJpbmVkQ1NTUmVnZXgsICdnaScpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IGltcG9ydFJlZ2V4LmV4ZWMoY3NzVGV4dCk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBtYXRjaGVzID0gdW5pZmllZFJlZ2V4LmV4ZWMoY3NzVGV4dCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0UmVnZXgubGFzdEluZGV4ID0gdW5pZmllZFJlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaWZpZWRSZWdleC5sYXN0SW5kZXggPSBpbXBvcnRSZWdleC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gobWF0Y2hlc1swXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRDU1NSdWxlcyhzdHlsZVNoZWV0cywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IGRlZmVycmVkcyA9IFtdO1xuICAgIC8vIEZpcnN0IGxvb3AgaW5saW5lcyBpbXBvcnRzXG4gICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoc2hlZXQpID0+IHtcbiAgICAgICAgaWYgKCdjc3NSdWxlcycgaW4gc2hlZXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG9BcnJheShzaGVldC5jc3NSdWxlcyB8fCBbXSkuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gQ1NTUnVsZS5JTVBPUlRfUlVMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltcG9ydEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gaXRlbS5ocmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBmZXRjaENTUyh1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKG1ldGFkYXRhKSA9PiBlbWJlZEZvbnRzKG1ldGFkYXRhLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoY3NzVGV4dCkgPT4gcGFyc2VDU1MoY3NzVGV4dCkuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUocnVsZSwgcnVsZS5zdGFydHNXaXRoKCdAaW1wb3J0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGltcG9ydEluZGV4ICs9IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbnNlcnRpbmcgcnVsZSBmcm9tIHJlbW90ZSBjc3MnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcmVtb3RlIGNzcycsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmxpbmUgPSBzdHlsZVNoZWV0cy5maW5kKChhKSA9PiBhLmhyZWYgPT0gbnVsbCkgfHwgZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHNoZWV0LmhyZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZHMucHVzaChmZXRjaENTUyhzaGVldC5ocmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKG1ldGFkYXRhKSA9PiBlbWJlZEZvbnRzKG1ldGFkYXRhLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjc3NUZXh0KSA9PiBwYXJzZUNTUyhjc3NUZXh0KS5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmUuaW5zZXJ0UnVsZShydWxlLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHJlbW90ZSBzdHlsZXNoZWV0JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmxpbmluZyByZW1vdGUgY3NzIGZpbGUnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChkZWZlcnJlZHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBTZWNvbmQgbG9vcCBwYXJzZXMgcnVsZXNcbiAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoc2hlZXQpID0+IHtcbiAgICAgICAgICAgIGlmICgnY3NzUnVsZXMnIGluIHNoZWV0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdG9BcnJheShzaGVldC5jc3NSdWxlcyB8fCBbXSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSByZWFkaW5nIENTUyBydWxlcyBmcm9tICR7c2hlZXQuaHJlZn1gLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0V2ViRm9udFJ1bGVzKGNzc1J1bGVzKSB7XG4gICAgcmV0dXJuIGNzc1J1bGVzXG4gICAgICAgIC5maWx0ZXIoKHJ1bGUpID0+IHJ1bGUudHlwZSA9PT0gQ1NTUnVsZS5GT05UX0ZBQ0VfUlVMRSlcbiAgICAgICAgLmZpbHRlcigocnVsZSkgPT4gc2hvdWxkRW1iZWQocnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdzcmMnKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VXZWJGb250UnVsZXMobm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChub2RlLm93bmVyRG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGVsZW1lbnQgaXMgbm90IHdpdGhpbiBhIERvY3VtZW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gdG9BcnJheShub2RlLm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHMpO1xuICAgIGNvbnN0IGNzc1J1bGVzID0gYXdhaXQgZ2V0Q1NTUnVsZXMoc3R5bGVTaGVldHMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBnZXRXZWJGb250UnVsZXMoY3NzUnVsZXMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFdlYkZvbnRDU1Mobm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJ1bGVzID0gYXdhaXQgcGFyc2VXZWJGb250UnVsZXMobm9kZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgY3NzVGV4dHMgPSBhd2FpdCBQcm9taXNlLmFsbChydWxlcy5tYXAoKHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHJ1bGUucGFyZW50U3R5bGVTaGVldCA/IHJ1bGUucGFyZW50U3R5bGVTaGVldC5ocmVmIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGVtYmVkUmVzb3VyY2VzKHJ1bGUuY3NzVGV4dCwgYmFzZVVybCwgb3B0aW9ucyk7XG4gICAgfSkpO1xuICAgIHJldHVybiBjc3NUZXh0cy5qb2luKCdcXG4nKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbWJlZFdlYkZvbnRzKGNsb25lZE5vZGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjc3NUZXh0ID0gb3B0aW9ucy5mb250RW1iZWRDU1MgIT0gbnVsbFxuICAgICAgICA/IG9wdGlvbnMuZm9udEVtYmVkQ1NTXG4gICAgICAgIDogb3B0aW9ucy5za2lwRm9udHNcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBhd2FpdCBnZXRXZWJGb250Q1NTKGNsb25lZE5vZGUsIG9wdGlvbnMpO1xuICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGNvbnN0IHN5dGxlQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQpO1xuICAgICAgICBzdHlsZU5vZGUuYXBwZW5kQ2hpbGQoc3l0bGVDb250ZW50KTtcbiAgICAgICAgaWYgKGNsb25lZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY2xvbmVkTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVOb2RlLCBjbG9uZWROb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1iZWQtd2ViZm9udHMuanMubWFwIiwiaW1wb3J0IHsgY2xvbmVOb2RlIH0gZnJvbSAnLi9jbG9uZS1ub2RlJztcbmltcG9ydCB7IGVtYmVkSW1hZ2VzIH0gZnJvbSAnLi9lbWJlZC1pbWFnZXMnO1xuaW1wb3J0IHsgYXBwbHlTdHlsZSB9IGZyb20gJy4vYXBwbHktc3R5bGUnO1xuaW1wb3J0IHsgZW1iZWRXZWJGb250cywgZ2V0V2ViRm9udENTUyB9IGZyb20gJy4vZW1iZWQtd2ViZm9udHMnO1xuaW1wb3J0IHsgZ2V0SW1hZ2VTaXplLCBnZXRQaXhlbFJhdGlvLCBjcmVhdGVJbWFnZSwgY2FudmFzVG9CbG9iLCBub2RlVG9EYXRhVVJMLCBjaGVja0NhbnZhc0RpbWVuc2lvbnMsIH0gZnJvbSAnLi91dGlsJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b1N2Zyhub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldEltYWdlU2l6ZShub2RlLCBvcHRpb25zKTtcbiAgICBjb25zdCBjbG9uZWROb2RlID0gKGF3YWl0IGNsb25lTm9kZShub2RlLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgYXdhaXQgZW1iZWRXZWJGb250cyhjbG9uZWROb2RlLCBvcHRpb25zKTtcbiAgICBhd2FpdCBlbWJlZEltYWdlcyhjbG9uZWROb2RlLCBvcHRpb25zKTtcbiAgICBhcHBseVN0eWxlKGNsb25lZE5vZGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGF1cmkgPSBhd2FpdCBub2RlVG9EYXRhVVJMKGNsb25lZE5vZGUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBkYXRhdXJpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvQ2FudmFzKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0SW1hZ2VTaXplKG5vZGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN2ZyA9IGF3YWl0IHRvU3ZnKG5vZGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGltZyA9IGF3YWl0IGNyZWF0ZUltYWdlKHN2Zyk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IHJhdGlvID0gb3B0aW9ucy5waXhlbFJhdGlvIHx8IGdldFBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IG9wdGlvbnMuY2FudmFzV2lkdGggfHwgd2lkdGg7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gb3B0aW9ucy5jYW52YXNIZWlnaHQgfHwgaGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoICogcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHJhdGlvO1xuICAgIGlmICghb3B0aW9ucy5za2lwQXV0b1NjYWxlKSB7XG4gICAgICAgIGNoZWNrQ2FudmFzRGltZW5zaW9ucyhjYW52YXMpO1xuICAgIH1cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXNXaWR0aH1gO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjYW52YXNIZWlnaHR9YDtcbiAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b1BpeGVsRGF0YShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldEltYWdlU2l6ZShub2RlLCBvcHRpb25zKTtcbiAgICBjb25zdCBjYW52YXMgPSBhd2FpdCB0b0NhbnZhcyhub2RlLCBvcHRpb25zKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvUG5nKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHRvQ2FudmFzKG5vZGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9KcGVnKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHRvQ2FudmFzKG5vZGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgb3B0aW9ucy5xdWFsaXR5IHx8IDEpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvQmxvYihub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjYW52YXMgPSBhd2FpdCB0b0NhbnZhcyhub2RlLCBvcHRpb25zKTtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgY2FudmFzVG9CbG9iKGNhbnZhcyk7XG4gICAgcmV0dXJuIGJsb2I7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Rm9udEVtYmVkQ1NTKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBnZXRXZWJGb250Q1NTKG5vZGUsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IEljYWxHZW5lcmF0ZSBmcm9tICckbGliL2NvbXBvbmVudHMvY2FsZW5kYXIvZ2VuZXJhdGUuc3ZlbHRlJztcbiAgaW1wb3J0IHR5cGUgeyBTY2hlZHVsZUl0ZW0gfSBmcm9tICckbGliL3R5cGVzJztcblx0aW1wb3J0IHsgZ2VuZXJhdGVJY2FsU3R1ZHkgfSBmcm9tICckbGliL3V0aWwvaWNhbC9nZW5lcmF0b3InO1xuXG5cdGV4cG9ydCBsZXQgc2NoZWR1bGU6IFNjaGVkdWxlSXRlbVtdID0gW107XG5cdGV4cG9ydCBsZXQgb2xkVGFibGU6IEhUTUxEaXZFbGVtZW50O1xuXHRleHBvcnQgbGV0IGZhY3VsdHkgPSAnJztcblx0ZXhwb3J0IGxldCBkZXBhcnRtZW50ID0gJyc7XG5cdGV4cG9ydCBsZXQgbWFqb3IgPSAnJztcblx0ZXhwb3J0IGxldCBzZW1lc3RlciA9ICcnO1xuXHRleHBvcnQgbGV0IHllYXIgPSAnJztcblx0ZXhwb3J0IGxldCBzdHVkZW50SWQgPSAnJztcblx0ZXhwb3J0IGxldCBzdHVkZW50TmFtZSA9ICcnO1xuXHRpbXBvcnQgeyB0b1BuZyB9IGZyb20gJ2h0bWwtdG8taW1hZ2UnO1xuXG5cdGNvbnN0IGVuZ2xpc2hEYXlzID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcblx0bGV0IG5ld1RhYmxlQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcblx0bGV0IG1vZGUgPSAnbmV3JztcblxuXHRjb25zdCBkb3dubG9hZCA9IGFzeW5jICgpID0+IHtcblx0XHRjb25zdCBkYXRhVXJsID0gYXdhaXQgdG9QbmcobmV3VGFibGVDb250YWluZXIpO1xuXHRcdGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0bGluay5kb3dubG9hZCA9ICdpbWFnZS5wbmcnO1xuXHRcdGxpbmsuaHJlZiA9IGRhdGFVcmw7XG5cdFx0bGluay5jbGljaygpO1xuXHR9O1xuXG5cdGNvbnN0IGNvbG9yID0gW1xuXHRcdCcjZWY0NDQ0Jyxcblx0XHQnI2Y5NzMxNicsXG5cdFx0JyNmNTllMGInLFxuXHRcdCcjZWFiMzA4Jyxcblx0XHQnIzg0Y2MxNicsXG5cdFx0JyMyMmM1NWUnLFxuXHRcdCcjMTBiOTgxJyxcblx0XHQnIzE0YjhhNicsXG5cdFx0JyMwNmI2ZDQnLFxuXHRcdCcjMGVhNWU5Jyxcblx0XHQnIzNiODJmNicsXG5cdFx0JyM2MzY2ZjEnLFxuXHRcdCcjOGI1Y2Y2Jyxcblx0XHQnI2E4NTVmNycsXG5cdFx0JyNkOTQ2ZWYnLFxuXHRcdCcjZWM0ODk5Jyxcblx0XHQnI2Y0M2Y1ZSdcblx0XTtcblxuXHRjb25zdCBtYWtlVGhlbWUgPSAoKSA9PiB7XG5cdFx0bGV0IHRoZW1lOiB7XG5cdFx0XHRzdWJqZWN0SWQ6IHN0cmluZztcblx0XHRcdHN1YmplY3ROYW1lOiBzdHJpbmc7XG5cdFx0XHRjb2xvcjogc3RyaW5nO1xuXHRcdH1bXSA9IFtdO1xuXHRcdGxldCB1c2VkQ29sb3I6IHN0cmluZ1tdID0gW107XG5cdFx0c2NoZWR1bGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0bGV0IHRoZW1lQ29sb3IgPSBjb2xvcltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvci5sZW5ndGgpXTtcblx0XHRcdHdoaWxlICh1c2VkQ29sb3IuaW5jbHVkZXModGhlbWVDb2xvcikpIHtcblx0XHRcdFx0dGhlbWVDb2xvciA9IGNvbG9yW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9yLmxlbmd0aCldO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgaXNBbHJlYWR5ID0gdGhlbWUuZmluZCgodCkgPT4gaXRlbS5zdWJqZWN0SWQgPT09IHQuc3ViamVjdElkKTtcblx0XHRcdGlmIChpc0FscmVhZHkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhlbWUucHVzaCh7XG5cdFx0XHRcdHN1YmplY3RJZDogaXRlbS5zdWJqZWN0SWQsXG5cdFx0XHRcdHN1YmplY3ROYW1lOiBpdGVtLnN1YmplY3ROYW1lLFxuXHRcdFx0XHRjb2xvcjogdGhlbWVDb2xvclxuXHRcdFx0fSk7XG5cdFx0XHR1c2VkQ29sb3IucHVzaCh0aGVtZUNvbG9yKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhlbWU7XG5cdH07XG5cdGxldCB0aGVtZSA9IG1ha2VUaGVtZSgpO1xuXG5cdGNvbnN0IGdldFRoZW1lID0gKHN1YmplY3RJZDogc3RyaW5nKSA9PiB7XG5cdFx0Y29uc3QgZmlsdGVyZWQgPSB0aGVtZS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uc3ViamVjdElkID09PSBzdWJqZWN0SWQpO1xuXHRcdGlmIChmaWx0ZXJlZC5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm4gZmlsdGVyZWRbMF0uY29sb3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgY3JlYXRlVGltZVNsb3QgPSAoZGF5SW5kZXg6IG51bWJlcikgPT4ge1xuXHRcdGludGVyZmFjZSBUaW1lU2xvdCB7XG5cdFx0XHRzdWJqZWN0TmFtZTogc3RyaW5nO1xuXHRcdFx0c3ViamVjdEluZGV4OiBudW1iZXI7XG5cdFx0XHRjb2xzcGFuOiBudW1iZXI7XG5cdFx0XHRjb2xvcjogc3RyaW5nO1xuXHRcdFx0aW5mbzogU2NoZWR1bGVJdGVtO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbHRlcmVkID0gc2NoZWR1bGUuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmRheSA9PT0gZGF5SW5kZXgpO1xuXHRcdGNvbnN0IHRpbWVTbG90czogQXJyYXk8VGltZVNsb3QgfCB1bmRlZmluZWQ+ID0gW107XG5cdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDEyICogNDsgaW5kZXgrKykge1xuXHRcdFx0dGltZVNsb3RzLnB1c2godW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0ZmlsdGVyZWQuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IHN0YXJ0ID0gaXRlbS5zdGFydC5zcGxpdCgnOicpO1xuXHRcdFx0Y29uc3QgZW5kID0gaXRlbS5lbmQuc3BsaXQoJzonKTtcblx0XHRcdGNvbnN0IHN0YXJ0SG91ciA9IHBhcnNlSW50KHN0YXJ0WzBdKTtcblx0XHRcdGNvbnN0IHN0YXJ0TWludXRlID0gcGFyc2VJbnQoc3RhcnRbMV0pO1xuXHRcdFx0Y29uc3QgZW5kSG91ciA9IHBhcnNlSW50KGVuZFswXSk7XG5cdFx0XHRjb25zdCBlbmRNaW51dGUgPSBwYXJzZUludChlbmRbMV0pO1xuXHRcdFx0Y29uc3Qgc3RhcnRTbG90ID0gKHN0YXJ0SG91ciAtIDgpICogNCArIE1hdGguZmxvb3Ioc3RhcnRNaW51dGUgLyAxNSk7XG5cdFx0XHRjb25zdCBlbmRTbG90ID0gKGVuZEhvdXIgLSA4KSAqIDQgKyBNYXRoLmZsb29yKGVuZE1pbnV0ZSAvIDE1KTtcblx0XHRcdGZvciAobGV0IGkgPSBzdGFydFNsb3Q7IGkgPCBlbmRTbG90OyBpKyspIHtcblx0XHRcdFx0dGltZVNsb3RzW2ldID0ge1xuXHRcdFx0XHRcdHN1YmplY3ROYW1lOiBpdGVtLnN1YmplY3ROYW1lLFxuXHRcdFx0XHRcdHN1YmplY3RJbmRleDogaW5kZXgsXG5cdFx0XHRcdFx0Y29sc3BhbjogZW5kU2xvdCAtIHN0YXJ0U2xvdCxcblx0XHRcdFx0XHRjb2xvcjogY29sb3JbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3IubGVuZ3RoKV0sXG5cdFx0XHRcdFx0aW5mbzogaXRlbVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGNvbnN0IGZpbmFsOiBBcnJheTxUaW1lU2xvdCB8IHVuZGVmaW5lZD4gPSBbXTtcblx0XHR0aW1lU2xvdHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0aWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmaW5hbC5wdXNoKHVuZGVmaW5lZCk7XG5cdFx0XHR9IGVsc2UgaWYgKGZpbmFsW2ZpbmFsLmxlbmd0aCAtIDFdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGZpbmFsW2ZpbmFsLmxlbmd0aCAtIDFdPy5zdWJqZWN0SW5kZXggIT09IGl0ZW0uc3ViamVjdEluZGV4KSB7XG5cdFx0XHRcdFx0ZmluYWwucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmluYWwucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH07XG5cdGxldCBjdXN0b21pemVNZW51ID0gZmFsc2U7XG5cdGxldCBoZWFkZXJDb2xvciA9ICcjZjk3MzE2Jztcbjwvc2NyaXB0PlxuXG57I2lmIG1vZGUgPT0gJ25ldyd9XG5cdDxkaXYgYmluZDp0aGlzPXtuZXdUYWJsZUNvbnRhaW5lcn0gY2xhc3M9XCJmbGV4IHctZnVsbCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlciBwLTUgc2hhZG93XCI+XG5cdFx0PGRpdiBjbGFzcz1cInctZnVsbCByb3VuZGVkLXQtbGcgcC00IHRleHQtd2hpdGVcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IHtoZWFkZXJDb2xvcn07XCI+XG5cdFx0XHQ8cCBjbGFzcz1cInRleHQtY2VudGVyXCI+e2ZhY3VsdHl9PC9wPlxuXHRcdFx0PHAgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPntkZXBhcnRtZW50fSB7bWFqb3J9PC9wPlxuXHRcdFx0PHAgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPntzZW1lc3Rlcn0ge3llYXJ9PC9wPlxuXHRcdFx0PHAgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPntzdHVkZW50SWR9IHtzdHVkZW50TmFtZX08L3A+XG5cdFx0PC9kaXY+XG5cdFx0PHRhYmxlIGNsYXNzPVwiaC1zY3JlZW4gdy1mdWxsIHJvdW5kZWQtYi1sZyBiZy13aGl0ZSBzaGFkb3dcIj5cblx0XHRcdDx0aGVhZD5cblx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdDx0aCBjbGFzcz1cInAtMSBmb250LWxpZ2h0XCI+PC90aD5cblx0XHRcdFx0XHQ8dGggY2xhc3M9XCJwLTEgZm9udC1saWdodFwiIGNvbHNwYW49XCI0XCI+MDg6MDAgLSAwOTowMDwvdGg+XG5cdFx0XHRcdFx0PHRoIGNsYXNzPVwicC0xIGZvbnQtbGlnaHRcIiBjb2xzcGFuPVwiNFwiPjA5OjAwIC0gMTA6MDA8L3RoPlxuXHRcdFx0XHRcdDx0aCBjbGFzcz1cInAtMSBmb250LWxpZ2h0XCIgY29sc3Bhbj1cIjRcIj4xMDowMCAtIDExOjAwPC90aD5cblx0XHRcdFx0XHQ8dGggY2xhc3M9XCJwLTEgZm9udC1saWdodFwiIGNvbHNwYW49XCI0XCI+MTE6MDAgLSAxMjowMDwvdGg+XG5cdFx0XHRcdFx0PHRoIGNsYXNzPVwicC0xIGZvbnQtbGlnaHRcIiBjb2xzcGFuPVwiNFwiPjEyOjAwIC0gMTM6MDA8L3RoPlxuXHRcdFx0XHRcdDx0aCBjbGFzcz1cInAtMSBmb250LWxpZ2h0XCIgY29sc3Bhbj1cIjRcIj4xMzowMCAtIDE0OjAwPC90aD5cblx0XHRcdFx0XHQ8dGggY2xhc3M9XCJwLTEgZm9udC1saWdodFwiIGNvbHNwYW49XCI0XCI+MTQ6MDAgLSAxNTowMDwvdGg+XG5cdFx0XHRcdFx0PHRoIGNsYXNzPVwicC0xIGZvbnQtbGlnaHRcIiBjb2xzcGFuPVwiNFwiPjE1OjAwIC0gMTY6MDA8L3RoPlxuXHRcdFx0XHRcdDx0aCBjbGFzcz1cInAtMSBmb250LWxpZ2h0XCIgY29sc3Bhbj1cIjRcIj4xNjowMCAtIDE3OjAwPC90aD5cblx0XHRcdFx0XHQ8dGggY2xhc3M9XCJwLTEgZm9udC1saWdodFwiIGNvbHNwYW49XCI0XCI+MTc6MDAgLSAxODowMDwvdGg+XG5cdFx0XHRcdFx0PHRoIGNsYXNzPVwicC0xIGZvbnQtbGlnaHRcIiBjb2xzcGFuPVwiNFwiPjE4OjAwIC0gMTk6MDA8L3RoPlxuXHRcdFx0XHRcdDx0aCBjbGFzcz1cInAtMSBmb250LWxpZ2h0XCIgY29sc3Bhbj1cIjRcIj4xOTowMCAtIDIwOjAwPC90aD5cblx0XHRcdFx0PC90cj5cblx0XHRcdDwvdGhlYWQ+XG5cdFx0XHQ8dGJvZHk+XG5cdFx0XHRcdHsjZWFjaCBlbmdsaXNoRGF5cyBhcyBkYXlMYWJlbCwgaW5kZXh9XG5cdFx0XHRcdFx0PHRyIGNsYXNzPVwiaC1bMTQuMjg1NzElXSBob3ZlcjpiZy1zbGF0ZS0xMDBcIj5cblx0XHRcdFx0XHRcdDx0ZCBjbGFzcz1cInAtMVwiPntkYXlMYWJlbH08L3RkPlxuXHRcdFx0XHRcdFx0eyNlYWNoIGNyZWF0ZVRpbWVTbG90KGluZGV4KSBhcyB0aW1lU2xvdH1cblx0XHRcdFx0XHRcdFx0eyNpZiB0aW1lU2xvdCA9PT0gdW5kZWZpbmVkfVxuXHRcdFx0XHRcdFx0XHRcdDx0ZCBjbGFzcz1cInctWzIuMDgzMzMlXSBweS0xXCI+PC90ZD5cblx0XHRcdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0XHRcdDx0ZCBjbGFzcz17YHctWzIuMDgzMzMlXSBweC0wIHB5LTEgdGV4dC13aGl0ZWB9IGNvbHNwYW49e3RpbWVTbG90LmNvbHNwYW59PlxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzcz17YHJlbGF0aXZlIGgtZnVsbCB3LWZ1bGwgcm91bmRlZCBwLTFgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17YGJhY2tncm91bmQtY29sb3I6ICR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbWUgPyBgJHtnZXRUaGVtZSh0aW1lU2xvdC5pbmZvLnN1YmplY3RJZCl9YCA6ICcjNjQ3NDhiJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9YH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PHAgY2xhc3M9XCJhYnNvbHV0ZSB0b3AtMSB0ZXh0LXhzXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e3RpbWVTbG90LmluZm8uYnVpbGRpbmcgPyB0aW1lU2xvdC5pbmZvLmJ1aWxkaW5nIDogJyd9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e3RpbWVTbG90LmluZm8ucm9vbSA/IHRpbWVTbG90LmluZm8ucm9vbSA6ICcnfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3A+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxwIGNsYXNzPVwiZmxleCBoLWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHB4LTFcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7dGltZVNsb3Quc3ViamVjdE5hbWV9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PHAgY2xhc3M9XCJhYnNvbHV0ZSBib3R0b20tMSB0ZXh0LXhzXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U2VjdGlvbiB7dGltZVNsb3QuaW5mby5zZWN9ICh7dGltZVNsb3QuaW5mby50eXBlfSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8cCBjbGFzcz1cImFic29sdXRlIGJvdHRvbS0xIHJpZ2h0LTEgdGV4dC14c1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHt0aW1lU2xvdC5pbmZvLnN0YXJ0fSAtIHt0aW1lU2xvdC5pbmZvLmVuZH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PC90ZD5cblx0XHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHQ8L3Rib2R5PlxuXHRcdDwvdGFibGU+XG5cdDwvZGl2PlxuezplbHNlfVxuXHQ8ZGl2IGJpbmQ6dGhpcz17b2xkVGFibGV9PjwvZGl2Plxuey9pZn1cblxuPGRpdiBjbGFzcz1cImZpeGVkIGJvdHRvbS0zIHJpZ2h0LTMgZmxleCBnYXAtMlwiPlxuXHR7I2lmIG1vZGUgPT0gJ25ldyd9XG5cdFx0PGRpdiBjbGFzcz1cInJlbGF0aXZlXCI+XG5cdFx0XHR7I2lmIGN1c3RvbWl6ZU1lbnV9XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzcz1cImFic29sdXRlIGJvdHRvbS1bMTEwJV0gcmlnaHQtMCBmbGV4IGgtNTYgdy05NiBmbGV4LWNvbCBnYXAtMiBvdmVyZmxvdy15LWF1dG8gcm91bmRlZC1sZyBib3JkZXIgYmctd2hpdGUgcC00IHNoYWRvd1wiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNvbCBnYXAtMlwiPlxuXHRcdFx0XHRcdFx0PHAgY2xhc3M9XCJ0ZXh0LXNtXCI+VGhlbWU8L3A+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cInJlbGF0aXZlIGZsZXggZmxleC1jb2wgZ2FwLTJcIj5cblx0XHRcdFx0XHRcdFx0XHQ8cCBjbGFzcz1cInRleHQtc21cIj5IZWFkZXI8L3A+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImZsZXggZ2FwLTJcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJjb2xvclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmluZDp2YWx1ZT17aGVhZGVyQ29sb3J9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJhYnNvbHV0ZSBoLTUgdy01IG9wYWNpdHktMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzcz17YGgtNSB3LTUgcm91bmRlZC1mdWxsYH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17YGJhY2tncm91bmQtY29sb3I6ICR7aGVhZGVyQ29sb3J9YH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PjwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8cCBjbGFzcz1cInRleHQtc21cIj5CYWNrZ3JvdW5kIENvbG9yPC9wPlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0eyNlYWNoIHRoZW1lIGFzIGl0ZW19XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJyZWxhdGl2ZSBmbGV4IGZsZXgtY29sIGdhcC0yXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8cCBjbGFzcz1cInRleHQtc21cIj57aXRlbS5zdWJqZWN0TmFtZX08L3A+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZmxleCBnYXAtMlwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZT1cImNvbG9yXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJpbmQ6dmFsdWU9e2l0ZW0uY29sb3J9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImFic29sdXRlIGgtNSB3LTUgb3BhY2l0eS0wXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzPXtgaC01IHctNSByb3VuZGVkLWZ1bGxgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9e2BiYWNrZ3JvdW5kLWNvbG9yOiAke1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVtZSA/IGAke2dldFRoZW1lKGl0ZW0uc3ViamVjdElkKX1gIDogJyM2NDc0OGInXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9YH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ+PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8cCBjbGFzcz1cInRleHQtc21cIj5CYWNrZ3JvdW5kIENvbG9yPC9wPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHRoZW1lID0gbWFrZVRoZW1lKCk7XG5cdFx0XHRcdFx0XHRcdFx0aGVhZGVyQ29sb3IgPSAnI2Y5NzMxNic7XG5cdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiIGZsZXggY3Vyc29yLXBvaW50ZXIgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbGcgYmctb3JhbmdlLTUwMCBwLTIgdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWFsbCBob3ZlcjpiZy1vcmFuZ2UtNjAwIGFjdGl2ZTpiZy1vcmFuZ2UtNDAwXCJcblx0XHRcdFx0XHRcdFx0PlJlc2V0IFRoZW1lPC9idXR0b25cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdGN1c3RvbWl6ZU1lbnUgPSAhY3VzdG9taXplTWVudTtcblx0XHRcdFx0fX1cblx0XHRcdFx0Y2xhc3M9XCIgZmxleCBjdXJzb3ItcG9pbnRlciBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1mdWxsIGJnLW9yYW5nZS01MDAgcC0yIHRleHQtd2hpdGUgdHJhbnNpdGlvbi1hbGwgaG92ZXI6Ymctb3JhbmdlLTYwMCBhY3RpdmU6Ymctb3JhbmdlLTQwMFwiXG5cdFx0XHRcdGFyaWEtbGFiZWw9XCJjdXN0b21pemVcIlxuXHRcdFx0PlxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0eG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG5cdFx0XHRcdFx0ZmlsbD1cIm5vbmVcIlxuXHRcdFx0XHRcdHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuXHRcdFx0XHRcdHN0cm9rZS13aWR0aD1cIjEuNVwiXG5cdFx0XHRcdFx0c3Ryb2tlPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0XHRjbGFzcz1cImgtNiB3LTZcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PHBhdGhcblx0XHRcdFx0XHRcdHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxuXHRcdFx0XHRcdFx0c3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIlxuXHRcdFx0XHRcdFx0ZD1cIk0xNi44NjIgNC40ODdsMS42ODctMS42ODhhMS44NzUgMS44NzUgMCAxMTIuNjUyIDIuNjUyTDYuODMyIDE5LjgyYTQuNSA0LjUgMCAwMS0xLjg5NyAxLjEzbC0yLjY4NS44LjgtMi42ODVhNC41IDQuNSAwIDAxMS4xMy0xLjg5N0wxNi44NjMgNC40ODd6bTAgMEwxOS41IDcuMTI1XCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuXHR7I2lmIG1vZGUgPT0gJ25ldyd9XG5cdFx0PGJ1dHRvblxuXHRcdFx0b246Y2xpY2s9e2Rvd25sb2FkfVxuXHRcdFx0Y2xhc3M9XCIgZmxleCBjdXJzb3ItcG9pbnRlciBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1mdWxsIGJnLW9yYW5nZS01MDAgcC0yIHRleHQtd2hpdGUgdHJhbnNpdGlvbi1hbGwgaG92ZXI6Ymctb3JhbmdlLTYwMCBhY3RpdmU6Ymctb3JhbmdlLTQwMFwiXG5cdFx0XHRhcmlhLWxhYmVsPVwiZG93bmxvYWRcIlxuXHRcdD5cblx0XHRcdDxzdmdcblx0XHRcdFx0eG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG5cdFx0XHRcdGZpbGw9XCJub25lXCJcblx0XHRcdFx0dmlld0JveD1cIjAgMCAyNCAyNFwiXG5cdFx0XHRcdHN0cm9rZS13aWR0aD1cIjEuNVwiXG5cdFx0XHRcdHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG5cdFx0XHRcdGNsYXNzPVwiaC02IHctNlwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxwYXRoXG5cdFx0XHRcdFx0c3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG5cdFx0XHRcdFx0c3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIlxuXHRcdFx0XHRcdGQ9XCJNMyAxNi41djIuMjVBMi4yNSAyLjI1IDAgMDA1LjI1IDIxaDEzLjVBMi4yNSAyLjI1IDAgMDAyMSAxOC43NVYxNi41TTE2LjUgMTJMMTIgMTYuNW0wIDBMNy41IDEybTQuNSA0LjVWM1wiXG5cdFx0XHRcdC8+XG5cdFx0XHQ8L3N2Zz5cblx0XHQ8L2J1dHRvbj5cblx0ey9pZn1cblx0PGJ1dHRvblxuXHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRtb2RlID0gbW9kZSA9PSAnbmV3JyA/ICdvbGQnIDogJ25ldyc7XG5cdFx0fX1cblx0XHRjbGFzcz1cIiBmbGV4IGN1cnNvci1wb2ludGVyIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWZ1bGwgYmctb3JhbmdlLTUwMCBwLTIgdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWFsbCBob3ZlcjpiZy1vcmFuZ2UtNjAwIGFjdGl2ZTpiZy1vcmFuZ2UtNDAwXCJcblx0PlxuXHRcdHttb2RlID09ICduZXcnID8gJ09sZCBEZXNpZ24nIDogJ05ldyBEZXNpZ24nfVxuXHQ8L2J1dHRvbj5cblx0PCEtLSA8YnV0dG9uXG5cdFx0Y2xhc3M9XCJmbGV4IGN1cnNvci1wb2ludGVyIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWZ1bGwgYmctb3JhbmdlLTUwMCBwLTIgdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWFsbCBob3ZlcjpiZy1vcmFuZ2UtNjAwIGFjdGl2ZTpiZy1vcmFuZ2UtNDAwXCJcblx0XHRvbjpjbGljaz17YXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgZ2VuZXJhdGVJY2FsU3R1ZHkoc2NoZWR1bGUpO1xuXHRcdH19XG5cdFx0PkdlbmVyYXRlIGlDYWxcblx0PC9idXR0b24+IC0tPlxuICA8SWNhbEdlbmVyYXRlIHNjaGVkdWxlPXtzY2hlZHVsZX0vPlxuPC9kaXY+XG4iLCJpbXBvcnQgdHlwZSB7IENsYXNzSW5mbywgU2NoZWR1bGVJdGVtLCBTdWJqZWN0IH0gZnJvbSAnJGxpYi90eXBlcyc7XG5pbXBvcnQgY29uc3RhbnRzIGZyb20gJyRsaWIvY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldGluZm8ocmF3VGFibGU6IEhUTUxUYWJsZUVsZW1lbnQpIHtcblx0Y29uc3QgdGFibGUgPSByYXdUYWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0Ym9keScpWzFdO1xuXHRjb25zdCBmYWN1bHR5TmFtZSA9IHRhYmxlLmNoaWxkTm9kZXNbNl0/LnRleHRDb250ZW50Py50cmltKCkgfHwgY29uc3RhbnRzLm1lc3NhZ2VzLnNjcmFwZUVycm9yO1xuXHRjb25zdCBkZXBhcnRtZW50U3ViamVjdCA9XG5cdFx0dGFibGUuY2hpbGROb2Rlc1sxMF0/LnRleHRDb250ZW50Py50cmltKCkuc3BsaXQoJ8KgwqDCoCcpIHx8IGNvbnN0YW50cy5tZXNzYWdlcy5zY3JhcGVFcnJvcjtcblx0Y29uc3QgZGVwYXJ0bWVudFRlcm0gPVxuXHRcdHRhYmxlLmNoaWxkTm9kZXNbMTRdPy50ZXh0Q29udGVudD8udHJpbSgpLnNwbGl0KCfCoMKgwqAnKSB8fCBjb25zdGFudHMubWVzc2FnZXMuc2NyYXBlRXJyb3I7XG5cdGNvbnN0IHN0dWRlbnROYW1lID1cblx0XHR0YWJsZS5jaGlsZE5vZGVzWzE4XT8udGV4dENvbnRlbnQ/LnRyaW0oKS5zcGxpdCgnwqDCoMKgJykgfHwgY29uc3RhbnRzLm1lc3NhZ2VzLnNjcmFwZUVycm9yO1xuXHRyZXR1cm4ge1xuXHRcdGZhY3VsdHlOYW1lLFxuXHRcdGRlcGFydG1lbnQ6IGRlcGFydG1lbnRTdWJqZWN0WzBdLnRyaW0oKSxcblx0XHRtYWpvcjogZGVwYXJ0bWVudFN1YmplY3RbMV0udHJpbSgpLFxuXHRcdHNlbWVzdGVyOiBkZXBhcnRtZW50VGVybVswXS50cmltKCksXG5cdFx0eWVhcjogZGVwYXJ0bWVudFRlcm1bMV0udHJpbSgpLFxuXHRcdHN0dWRlbnRJZDogc3R1ZGVudE5hbWVbMF0udHJpbSgpLFxuXHRcdHN0dWRlbnROYW1lOiBzdHVkZW50TmFtZVsxXS50cmltKClcblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcmFwZVRhYmxlKHJhd1RhYmxlOiBIVE1MVGFibGVFbGVtZW50KSB7XG5cdGNvbnN0IHN0dWR5VGFibGVSb3dzID0gcmF3VGFibGUucXVlcnlTZWxlY3RvckFsbCgndHInKTtcblxuXHRjb25zdCBzdHVkeVRhYmxlUm93c0FycmF5ID0gQXJyYXkuZnJvbShzdHVkeVRhYmxlUm93cylcblx0XHQuZmlsdGVyKChpdGVtKSA9PiB7XG5cdFx0XHRyZXR1cm4gaXRlbS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAzNztcblx0XHR9KVxuXHRcdC5zcGxpY2UoMSk7XG5cblx0Y29uc3Qgc2NyYXBlZERhdGE6IFN1YmplY3RbXSA9IFtdO1xuXG5cdHN0dWR5VGFibGVSb3dzQXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdGNvbnN0IHN1YmplY3RJZDogc3RyaW5nID0gaXRlbS5jaGlsZE5vZGVzWzVdLnRleHRDb250ZW50IHx8IGNvbnN0YW50cy5tZXNzYWdlcy5zY3JhcGVFcnJvcjtcblx0XHRjb25zdCBzdWJqZWN0TmFtZTogc3RyaW5nID0gaXRlbS5jaGlsZE5vZGVzWzldLnRleHRDb250ZW50IHx8IGNvbnN0YW50cy5tZXNzYWdlcy5zY3JhcGVFcnJvcjtcblx0XHRjb25zdCBzdWJqZWN0Q3JlZGl0czogc3RyaW5nID1cblx0XHRcdGl0ZW0uY2hpbGROb2Rlc1sxM10udGV4dENvbnRlbnQgfHwgY29uc3RhbnRzLm1lc3NhZ2VzLnNjcmFwZUVycm9yO1xuXG5cdFx0Y29uc3Qgcm9vbUluZm8gPSBpdGVtLmNoaWxkTm9kZXNbMjldO1xuXHRcdGNvbnN0IHJvb206IHN0cmluZ1tdID0gW107XG5cdFx0cm9vbUluZm8uY2hpbGROb2Rlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRpZiAoaXRlbS50ZXh0Q29udGVudCkge1xuXHRcdFx0XHRyb29tLnB1c2goaXRlbS50ZXh0Q29udGVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Y29uc3QgbGVjdHVyZVJvb20gPSByb29tWzBdO1xuXHRcdGNvbnN0IGxhYlJvb20gPSByb29tWzFdO1xuXG5cdFx0Y29uc3QgYnVpbGRpbmdJbmZvID0gaXRlbS5jaGlsZE5vZGVzWzMzXTtcblx0XHRjb25zdCBidWlsZGluZzogc3RyaW5nW10gPSBbXTtcblx0XHRidWlsZGluZ0luZm8uY2hpbGROb2Rlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRpZiAoaXRlbS50ZXh0Q29udGVudCkge1xuXHRcdFx0XHRidWlsZGluZy5wdXNoKGl0ZW0udGV4dENvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGNvbnN0IGxlY3R1cmVCdWlsZGluZyA9IGJ1aWxkaW5nWzBdO1xuXHRcdGNvbnN0IGxhYkJ1aWxkaW5nID0gYnVpbGRpbmdbMV07XG5cblx0XHRjb25zdCBzdWJqZWN0TGVjdHVyZTogQ2xhc3NJbmZvID0ge1xuXHRcdFx0YnVpbGRpbmc6IGxlY3R1cmVCdWlsZGluZyxcblx0XHRcdHJvb206IGxlY3R1cmVSb29tLFxuXHRcdFx0c2VjOiBpdGVtLmNoaWxkTm9kZXNbMTddLnRleHRDb250ZW50IHx8IGNvbnN0YW50cy5tZXNzYWdlcy5zY3JhcGVFcnJvcixcblx0XHRcdHBlcmlvZHM6IFtdXG5cdFx0fTtcblx0XHRjb25zdCBzdWJqZWN0TGFiOiBDbGFzc0luZm8gPSB7XG5cdFx0XHRidWlsZGluZzogbGFiQnVpbGRpbmcsXG5cdFx0XHRyb29tOiBsYWJSb29tLFxuXHRcdFx0c2VjOiBpdGVtLmNoaWxkTm9kZXNbMjFdLnRleHRDb250ZW50IHx8IGNvbnN0YW50cy5tZXNzYWdlcy5zY3JhcGVFcnJvcixcblx0XHRcdHBlcmlvZHM6IFtdXG5cdFx0fTtcblx0XHRjb25zdCBzdWJqZWN0RGVzY3JpcHRpb246IHN0cmluZyA9XG5cdFx0XHRpdGVtLmNoaWxkTm9kZXNbMzVdLnRleHRDb250ZW50IHx8IGNvbnN0YW50cy5tZXNzYWdlcy5zY3JhcGVFcnJvcjtcblx0XHRjb25zdCBzdWJqZWN0UGVyaW9kID0gaXRlbS5jaGlsZE5vZGVzWzI1XTtcblx0XHRzdWJqZWN0UGVyaW9kLmNoaWxkTm9kZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0aWYgKCFpdGVtLnRleHRDb250ZW50KSByZXR1cm47XG5cdFx0XHRjb25zb2xlLmxvZyhpdGVtLnRleHRDb250ZW50KTtcblx0XHRcdGNvbnN0IHNwbGl0RGF0YSA9IGl0ZW0udGV4dENvbnRlbnQuc3BsaXQoJyAnKTtcblx0XHRcdGNvbnN0IHRpbWUgPSBzcGxpdERhdGFbMV0uc3BsaXQoJy0nKTtcblx0XHRcdGNvbnN0IHBlcmlvZCA9IHtcblx0XHRcdFx0ZGF5OiBzcGxpdERhdGFbMF0sXG5cdFx0XHRcdHN0YXJ0OiB0aW1lWzBdLFxuXHRcdFx0XHRlbmQ6IHRpbWVbMV1cblx0XHRcdH07XG5cblx0XHRcdGNvbnNvbGUubG9nKHN1YmplY3RMYWIucGVyaW9kcy5zb21lKChzYXZlZFBlcmlvZCkgPT4gc2F2ZWRQZXJpb2Quc3RhcnQgPT09IHBlcmlvZC5zdGFydCkpO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNvbnN0YW50cy5zY3JhcGVyLmNsYXNzVHlwZXMubGVjdHVyZS5zb21lKCh0eXBlU3RyaW5nKSA9PlxuXHRcdFx0XHRcdGl0ZW0udGV4dENvbnRlbnQ/LmluY2x1ZGVzKHR5cGVTdHJpbmcpXG5cdFx0XHRcdCkgJiZcblx0XHRcdFx0IXN1YmplY3RMZWN0dXJlLnBlcmlvZHMuc29tZSgoc2F2ZWRQZXJpb2QpID0+IHNhdmVkUGVyaW9kLnN0YXJ0ID09PSBwZXJpb2Quc3RhcnQpXG5cdFx0XHQpIHtcblx0XHRcdFx0c3ViamVjdExlY3R1cmUucGVyaW9kcy5wdXNoKHBlcmlvZCk7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRjb25zdGFudHMuc2NyYXBlci5jbGFzc1R5cGVzLmxhYi5zb21lKCh0eXBlU3RyaW5nKSA9PlxuXHRcdFx0XHRcdGl0ZW0udGV4dENvbnRlbnQ/LmluY2x1ZGVzKHR5cGVTdHJpbmcpXG5cdFx0XHRcdCkgJiZcblx0XHRcdFx0IXN1YmplY3RMYWIucGVyaW9kcy5zb21lKChzYXZlZFBlcmlvZCkgPT4gc2F2ZWRQZXJpb2Quc3RhcnQgPT09IHBlcmlvZC5zdGFydClcblx0XHRcdCkge1xuXHRcdFx0XHRzdWJqZWN0TGFiLnBlcmlvZHMucHVzaChwZXJpb2QpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgZGF0YTogU3ViamVjdCA9IHtcblx0XHRcdHN1YmplY3RJZCxcblx0XHRcdHN1YmplY3ROYW1lLFxuXHRcdFx0c3ViamVjdERlc2NyaXB0aW9uLFxuXHRcdFx0c3ViamVjdENyZWRpdHMsXG5cdFx0XHRzdWJqZWN0TGVjdHVyZSxcblx0XHRcdHN1YmplY3RMYWJcblx0XHR9O1xuXHRcdHNjcmFwZWREYXRhLnB1c2goZGF0YSk7XG5cdH0pO1xuXHRjb25zb2xlLmxvZyhzY3JhcGVkRGF0YSk7XG5cdHJldHVybiBzY3JhcGVkRGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5TdHVkeVRhYmxlKHN1YmplY3RzOiBTdWJqZWN0W10pIHtcblx0ZnVuY3Rpb24gZ2V0RGF5RnJvbVN0cmluZyhkYXlTdHJpbmc6IGtleW9mIHR5cGVvZiBjb25zdGFudHMuc2NyYXBlci5kYXlzKSB7XG5cdFx0cmV0dXJuIGNvbnN0YW50cy5zY3JhcGVyLmRheXNbZGF5U3RyaW5nXTtcblx0fVxuXG5cdGNvbnN0IGZsYXR0ZW5EYXRhOiBTY2hlZHVsZUl0ZW1bXSA9IFtdO1xuXHRzdWJqZWN0cy5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0Y29uc29sZS5sb2coaXRlbSk7XG5cdFx0Y29uc3Qge1xuXHRcdFx0c3ViamVjdElkLFxuXHRcdFx0c3ViamVjdE5hbWUsXG5cdFx0XHRzdWJqZWN0Q3JlZGl0cyxcblx0XHRcdHN1YmplY3RMZWN0dXJlLFxuXHRcdFx0c3ViamVjdExhYixcblx0XHRcdHN1YmplY3REZXNjcmlwdGlvblxuXHRcdH0gPSBpdGVtO1xuXHRcdGNvbnN0IHtcblx0XHRcdHNlYzogbGVjdHVyZVNlYyxcblx0XHRcdHBlcmlvZHM6IGxlY3R1cmVQZXJpb2QsXG5cdFx0XHRyb29tOiBsZWN0dXJlUm9vbSxcblx0XHRcdGJ1aWxkaW5nOiBsZWN0dXJlQnVpbGRpbmdcblx0XHR9ID0gc3ViamVjdExlY3R1cmU7XG5cdFx0Y29uc3QgeyBzZWM6IGxhYlNlYywgcGVyaW9kczogbGFiUGVyaW9kLCByb29tOiBsYWJSb29tLCBidWlsZGluZzogbGFiQnVpbGRpbmcgfSA9IHN1YmplY3RMYWI7XG5cdFx0aWYgKGxlY3R1cmVTZWMpIHtcblx0XHRcdGxlY3R1cmVQZXJpb2QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IGRheSwgc3RhcnQsIGVuZCB9ID0gaXRlbTtcblx0XHRcdFx0Y29uc3QgZGF0YTogU2NoZWR1bGVJdGVtID0ge1xuXHRcdFx0XHRcdHN1YmplY3RJZCxcblx0XHRcdFx0XHRzdWJqZWN0TmFtZSxcblx0XHRcdFx0XHRzdWJqZWN0Q3JlZGl0cyxcblx0XHRcdFx0XHRzdWJqZWN0RGVzY3JpcHRpb24sXG5cdFx0XHRcdFx0c2VjOiBsZWN0dXJlU2VjLFxuXHRcdFx0XHRcdHJvb206IGxlY3R1cmVSb29tLFxuXHRcdFx0XHRcdGJ1aWxkaW5nOiBsZWN0dXJlQnVpbGRpbmcsXG5cdFx0XHRcdFx0dHlwZTogJ2xlY3R1cmUnLFxuXHRcdFx0XHRcdGRheTogZ2V0RGF5RnJvbVN0cmluZyhkYXkgYXMga2V5b2YgdHlwZW9mIGNvbnN0YW50cy5zY3JhcGVyLmRheXMpLFxuXHRcdFx0XHRcdHN0YXJ0LFxuXHRcdFx0XHRcdGVuZFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRmbGF0dGVuRGF0YS5wdXNoKGRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmIChsYWJTZWMpIHtcblx0XHRcdGxhYlBlcmlvZC5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgZGF5LCBzdGFydCwgZW5kIH0gPSBpdGVtO1xuXHRcdFx0XHRjb25zdCBkYXRhOiBTY2hlZHVsZUl0ZW0gPSB7XG5cdFx0XHRcdFx0c3ViamVjdElkLFxuXHRcdFx0XHRcdHN1YmplY3ROYW1lLFxuXHRcdFx0XHRcdHN1YmplY3RDcmVkaXRzLFxuXHRcdFx0XHRcdHN1YmplY3REZXNjcmlwdGlvbixcblx0XHRcdFx0XHRkYXk6IGdldERheUZyb21TdHJpbmcoZGF5IGFzIGtleW9mIHR5cGVvZiBjb25zdGFudHMuc2NyYXBlci5kYXlzKSxcblx0XHRcdFx0XHRzdGFydCxcblx0XHRcdFx0XHRlbmQsXG5cdFx0XHRcdFx0dHlwZTogJ2xhYicsXG5cdFx0XHRcdFx0c2VjOiBsYWJTZWMsXG5cdFx0XHRcdFx0cm9vbTogbGFiUm9vbSxcblx0XHRcdFx0XHRidWlsZGluZzogbGFiQnVpbGRpbmdcblx0XHRcdFx0fTtcblx0XHRcdFx0ZmxhdHRlbkRhdGEucHVzaChkYXRhKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmbGF0dGVuRGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeURheShzY2hlZHVsZUl0ZW1zOiBTY2hlZHVsZUl0ZW1bXSkge1xuXHRyZXR1cm4gc2NoZWR1bGVJdGVtcy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0Y29uc3QgZGF5QSA9IGEuZGF5O1xuXHRcdGNvbnN0IGRheUIgPSBiLmRheTtcblx0XHRpZiAoZGF5QSA8IGRheUIpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9IGVsc2UgaWYgKGRheUEgPiBkYXlCKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGEuc3RhcnQubG9jYWxlQ29tcGFyZShiLnN0YXJ0KSA9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKGEuc3RhcnQubG9jYWxlQ29tcGFyZShiLnN0YXJ0KSA9PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHR9KTtcbn1cbiIsImltcG9ydCBzdHVkeVRhYmxlIGZyb20gJyRsaWIvY29tcG9uZW50cy9zdHVkeS10YWJsZS5zdmVsdGUnO1xuaW1wb3J0IHsgc2NyYXBlVGFibGUsIGZsYXR0ZW5TdHVkeVRhYmxlLCBzb3J0QnlEYXksIGdldGluZm8gfSBmcm9tICckbGliL3V0aWwvc2NyYXBlci9zdHVkeS10YWJsZSc7XG5cbmltcG9ydCAnJGxpYi9zdHlsZXMvc3R5bGVzLmNzcyc7XG5pbXBvcnQgeyBtb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTdHVkeVRhYmxlKCkge1xuICBjb25zdCByYXdTdHVkeVRhYmxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGFibGUnKTtcbiAgaWYgKCFyYXdTdHVkeVRhYmxlKSB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZWxlY3QgdGhlIHJhdyBzdHVkeSB0YWJsZScpO1xuICBjb25zdCBpbmZvID0gZ2V0aW5mbyhyYXdTdHVkeVRhYmxlKTtcbiAgY29uc3Qgc2NyYXBlZERhdGEgPSBzb3J0QnlEYXkoZmxhdHRlblN0dWR5VGFibGUoc2NyYXBlVGFibGUocmF3U3R1ZHlUYWJsZSkpKTtcbiAgY29uc3Qgb2xkVGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgb2xkVGFibGUuaW5uZXJIVE1MID0gZG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XG5cbiAgLy8gQWRkIGZvbnQg4LmA4Lie4Lij4Liy4Liw4LmA4Lij4Li14Lii4LiB4LiI4Liy4LiBIENTUyDguYHguKXguYnguKfguKHguLHguJnguIjguLDguYTguKHguYggbG9hZCDguYPguKvguYlcbiAgY29uc3QgZm9udFByb21wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGZvbnRQcm9tcHQuaW5uZXJIVE1MID0gYFxuICBAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Qcm9tcHQ6d2dodEAzMDA7NDAwOzUwMDs2MDA7NzAwJmRpc3BsYXk9c3dhcCcpO1xuICBgO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGZvbnRQcm9tcHQpO1xuXG4gIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gJyc7XG5cbiAgY29uc29sZS5sb2coc2NyYXBlZERhdGEpO1xuXG4gIG1vdW50KHN0dWR5VGFibGUsIHtcbiAgICB0YXJnZXQ6IGRvY3VtZW50LmJvZHksXG4gICAgcHJvcHM6IHtcbiAgICAgIHNjaGVkdWxlOiBzY3JhcGVkRGF0YSxcbiAgICAgIG9sZFRhYmxlOiBvbGRUYWJsZSxcbiAgICAgIGZhY3VsdHk6IGluZm8uZmFjdWx0eU5hbWUsXG4gICAgICBkZXBhcnRtZW50OiBpbmZvLmRlcGFydG1lbnQsXG4gICAgICBtYWpvcjogaW5mby5tYWpvcixcbiAgICAgIHNlbWVzdGVyOiBpbmZvLnNlbWVzdGVyLFxuICAgICAgeWVhcjogaW5mby55ZWFyLFxuICAgICAgc3R1ZGVudElkOiBpbmZvLnN0dWRlbnRJZCxcbiAgICAgIHN0dWRlbnROYW1lOiBpbmZvLnN0dWRlbnROYW1lXG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7IHJlbmRlclN0dWR5VGFibGUgfSBmcm9tICckbGliL3V0aWwvcmVuZGVyZXIvc3R1ZHktdGFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb250ZW50U2NyaXB0KHtcblx0bWF0Y2hlczogWycqOi8vKi5yZWcua21pdGwuYWMudGgvdV9zdHVkZW50L3JlcG9ydF9zdHVkeXRhYmxlX3Nob3cucGhwJ10sXG5cdG1haW4oKSB7XG5cdFx0cmVuZGVyU3R1ZHlUYWJsZSgpO1xuXHR9XG59KTtcbiIsImV4cG9ydCBjb25zdCBicm93c2VyID0gKFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGdsb2JhbFRoaXMuYnJvd3Nlcj8ucnVudGltZT8uaWQgPT0gbnVsbCA/IGdsb2JhbFRoaXMuY2hyb21lIDogKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBnbG9iYWxUaGlzLmJyb3dzZXJcbiAgKVxuKTtcbiIsImZ1bmN0aW9uIHByaW50KG1ldGhvZCwgLi4uYXJncykge1xuICBpZiAoaW1wb3J0Lm1ldGEuZW52Lk1PREUgPT09IFwicHJvZHVjdGlvblwiKSByZXR1cm47XG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzLnNoaWZ0KCk7XG4gICAgbWV0aG9kKGBbd3h0XSAke21lc3NhZ2V9YCwgLi4uYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kKFwiW3d4dF1cIiwgLi4uYXJncyk7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBsb2dnZXIgPSB7XG4gIGRlYnVnOiAoLi4uYXJncykgPT4gcHJpbnQoY29uc29sZS5kZWJ1ZywgLi4uYXJncyksXG4gIGxvZzogKC4uLmFyZ3MpID0+IHByaW50KGNvbnNvbGUubG9nLCAuLi5hcmdzKSxcbiAgd2FybjogKC4uLmFyZ3MpID0+IHByaW50KGNvbnNvbGUud2FybiwgLi4uYXJncyksXG4gIGVycm9yOiAoLi4uYXJncykgPT4gcHJpbnQoY29uc29sZS5lcnJvciwgLi4uYXJncylcbn07XG4iLCJpbXBvcnQgeyBicm93c2VyIH0gZnJvbSBcInd4dC9icm93c2VyXCI7XG5leHBvcnQgY2xhc3MgV3h0TG9jYXRpb25DaGFuZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IobmV3VXJsLCBvbGRVcmwpIHtcbiAgICBzdXBlcihXeHRMb2NhdGlvbkNoYW5nZUV2ZW50LkVWRU5UX05BTUUsIHt9KTtcbiAgICB0aGlzLm5ld1VybCA9IG5ld1VybDtcbiAgICB0aGlzLm9sZFVybCA9IG9sZFVybDtcbiAgfVxuICBzdGF0aWMgRVZFTlRfTkFNRSA9IGdldFVuaXF1ZUV2ZW50TmFtZShcInd4dDpsb2NhdGlvbmNoYW5nZVwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlxdWVFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIHJldHVybiBgJHticm93c2VyPy5ydW50aW1lPy5pZH06JHtpbXBvcnQubWV0YS5lbnYuRU5UUllQT0lOVH06JHtldmVudE5hbWV9YDtcbn1cbiIsImltcG9ydCB7IFd4dExvY2F0aW9uQ2hhbmdlRXZlbnQgfSBmcm9tIFwiLi9jdXN0b20tZXZlbnRzLm1qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uV2F0Y2hlcihjdHgpIHtcbiAgbGV0IGludGVydmFsO1xuICBsZXQgb2xkVXJsO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGUgbG9jYXRpb24gd2F0Y2hlciBpcyBhY3RpdmVseSBsb29raW5nIGZvciBVUkwgY2hhbmdlcy4gSWYgaXQncyBhbHJlYWR5IHdhdGNoaW5nLFxuICAgICAqIHRoaXMgaXMgYSBub29wLlxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgIGlmIChpbnRlcnZhbCAhPSBudWxsKSByZXR1cm47XG4gICAgICBvbGRVcmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xuICAgICAgaW50ZXJ2YWwgPSBjdHguc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBsZXQgbmV3VXJsID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKG5ld1VybC5ocmVmICE9PSBvbGRVcmwuaHJlZikge1xuICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBXeHRMb2NhdGlvbkNoYW5nZUV2ZW50KG5ld1VybCwgb2xkVXJsKSk7XG4gICAgICAgICAgb2xkVXJsID0gbmV3VXJsO1xuICAgICAgICB9XG4gICAgICB9LCAxZTMpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IGJyb3dzZXIgfSBmcm9tIFwid3h0L2Jyb3dzZXJcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi8uLi9zYW5kYm94L3V0aWxzL2xvZ2dlci5tanNcIjtcbmltcG9ydCB7IGdldFVuaXF1ZUV2ZW50TmFtZSB9IGZyb20gXCIuL2N1c3RvbS1ldmVudHMubWpzXCI7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbldhdGNoZXIgfSBmcm9tIFwiLi9sb2NhdGlvbi13YXRjaGVyLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENvbnRlbnRTY3JpcHRDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGVudFNjcmlwdE5hbWUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbnRlbnRTY3JpcHROYW1lID0gY29udGVudFNjcmlwdE5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAodGhpcy5pc1RvcEZyYW1lKSB7XG4gICAgICB0aGlzLmxpc3RlbkZvck5ld2VyU2NyaXB0cyh7IGlnbm9yZUZpcnN0RXZlbnQ6IHRydWUgfSk7XG4gICAgICB0aGlzLnN0b3BPbGRTY3JpcHRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdGVuRm9yTmV3ZXJTY3JpcHRzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBTQ1JJUFRfU1RBUlRFRF9NRVNTQUdFX1RZUEUgPSBnZXRVbmlxdWVFdmVudE5hbWUoXG4gICAgXCJ3eHQ6Y29udGVudC1zY3JpcHQtc3RhcnRlZFwiXG4gICk7XG4gIGlzVG9wRnJhbWUgPSB3aW5kb3cuc2VsZiA9PT0gd2luZG93LnRvcDtcbiAgYWJvcnRDb250cm9sbGVyO1xuICBsb2NhdGlvbldhdGNoZXIgPSBjcmVhdGVMb2NhdGlvbldhdGNoZXIodGhpcyk7XG4gIHJlY2VpdmVkTWVzc2FnZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGdldCBzaWduYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuICBhYm9ydChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbiAgfVxuICBnZXQgaXNJbnZhbGlkKCkge1xuICAgIGlmIChicm93c2VyLnJ1bnRpbWUuaWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5ub3RpZnlJbnZhbGlkYXRlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduYWwuYWJvcnRlZDtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNJbnZhbGlkO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjb250ZW50IHNjcmlwdCdzIGNvbnRleHQgaXMgaW52YWxpZGF0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYnJvd3Nlci5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihjYik7XG4gICAqIGNvbnN0IHJlbW92ZUludmFsaWRhdGVkTGlzdGVuZXIgPSBjdHgub25JbnZhbGlkYXRlZCgoKSA9PiB7XG4gICAqICAgYnJvd3Nlci5ydW50aW1lLm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihjYik7XG4gICAqIH0pXG4gICAqIC8vIC4uLlxuICAgKiByZW1vdmVJbnZhbGlkYXRlZExpc3RlbmVyKCk7XG4gICAqL1xuICBvbkludmFsaWRhdGVkKGNiKSB7XG4gICAgdGhpcy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNiKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IG5ldmVyIHJlc29sdmVzLiBVc2VmdWwgaWYgeW91IGhhdmUgYW4gYXN5bmMgZnVuY3Rpb24gdGhhdCBzaG91bGRuJ3QgcnVuXG4gICAqIGFmdGVyIHRoZSBjb250ZXh0IGlzIGV4cGlyZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGdldFZhbHVlRnJvbVN0b3JhZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAqICAgaWYgKGN0eC5pc0ludmFsaWQpIHJldHVybiBjdHguYmxvY2soKTtcbiAgICpcbiAgICogICAvLyAuLi5cbiAgICogfVxuICAgKi9cbiAgYmxvY2soKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV3JhcHBlciBhcm91bmQgYHdpbmRvdy5zZXRJbnRlcnZhbGAgdGhhdCBhdXRvbWF0aWNhbGx5IGNsZWFycyB0aGUgaW50ZXJ2YWwgd2hlbiBpbnZhbGlkYXRlZC5cbiAgICovXG4gIHNldEludGVydmFsKGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICBjb25zdCBpZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWQpIGhhbmRsZXIoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZWQoKCkgPT4gY2xlYXJJbnRlcnZhbChpZCkpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICAvKipcbiAgICogV3JhcHBlciBhcm91bmQgYHdpbmRvdy5zZXRUaW1lb3V0YCB0aGF0IGF1dG9tYXRpY2FsbHkgY2xlYXJzIHRoZSBpbnRlcnZhbCB3aGVuIGludmFsaWRhdGVkLlxuICAgKi9cbiAgc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWQpIGhhbmRsZXIoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZWQoKCkgPT4gY2xlYXJUaW1lb3V0KGlkKSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcGVyIGFyb3VuZCBgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGhhdCBhdXRvbWF0aWNhbGx5IGNhbmNlbHMgdGhlIHJlcXVlc3Qgd2hlblxuICAgKiBpbnZhbGlkYXRlZC5cbiAgICovXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZWQoKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIGB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFja2AgdGhhdCBhdXRvbWF0aWNhbGx5IGNhbmNlbHMgdGhlIHJlcXVlc3Qgd2hlblxuICAgKiBpbnZhbGlkYXRlZC5cbiAgICovXG4gIHJlcXVlc3RJZGxlQ2FsbGJhY2soY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICghdGhpcy5zaWduYWwuYWJvcnRlZCkgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbkludmFsaWRhdGVkKCgpID0+IGNhbmNlbElkbGVDYWxsYmFjayhpZCkpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlID09PSBcInd4dDpsb2NhdGlvbmNoYW5nZVwiKSB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSB0aGlzLmxvY2F0aW9uV2F0Y2hlci5ydW4oKTtcbiAgICB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXI/LihcbiAgICAgIHR5cGUuc3RhcnRzV2l0aChcInd4dDpcIikgPyBnZXRVbmlxdWVFdmVudE5hbWUodHlwZSkgOiB0eXBlLFxuICAgICAgaGFuZGxlcixcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBBYm9ydCB0aGUgYWJvcnQgY29udHJvbGxlciBhbmQgZXhlY3V0ZSBhbGwgYG9uSW52YWxpZGF0ZWRgIGxpc3RlbmVycy5cbiAgICovXG4gIG5vdGlmeUludmFsaWRhdGVkKCkge1xuICAgIHRoaXMuYWJvcnQoXCJDb250ZW50IHNjcmlwdCBjb250ZXh0IGludmFsaWRhdGVkXCIpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBDb250ZW50IHNjcmlwdCBcIiR7dGhpcy5jb250ZW50U2NyaXB0TmFtZX1cIiBjb250ZXh0IGludmFsaWRhdGVkYFxuICAgICk7XG4gIH1cbiAgc3RvcE9sZFNjcmlwdHMoKSB7XG4gICAgd2luZG93LnBvc3RNZXNzYWdlKFxuICAgICAge1xuICAgICAgICB0eXBlOiBDb250ZW50U2NyaXB0Q29udGV4dC5TQ1JJUFRfU1RBUlRFRF9NRVNTQUdFX1RZUEUsXG4gICAgICAgIGNvbnRlbnRTY3JpcHROYW1lOiB0aGlzLmNvbnRlbnRTY3JpcHROYW1lLFxuICAgICAgICBtZXNzYWdlSWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpXG4gICAgICB9LFxuICAgICAgXCIqXCJcbiAgICApO1xuICB9XG4gIHZlcmlmeVNjcmlwdFN0YXJ0ZWRFdmVudChldmVudCkge1xuICAgIGNvbnN0IGlzU2NyaXB0U3RhcnRlZEV2ZW50ID0gZXZlbnQuZGF0YT8udHlwZSA9PT0gQ29udGVudFNjcmlwdENvbnRleHQuU0NSSVBUX1NUQVJURURfTUVTU0FHRV9UWVBFO1xuICAgIGNvbnN0IGlzU2FtZUNvbnRlbnRTY3JpcHQgPSBldmVudC5kYXRhPy5jb250ZW50U2NyaXB0TmFtZSA9PT0gdGhpcy5jb250ZW50U2NyaXB0TmFtZTtcbiAgICBjb25zdCBpc05vdER1cGxpY2F0ZSA9ICF0aGlzLnJlY2VpdmVkTWVzc2FnZUlkcy5oYXMoZXZlbnQuZGF0YT8ubWVzc2FnZUlkKTtcbiAgICByZXR1cm4gaXNTY3JpcHRTdGFydGVkRXZlbnQgJiYgaXNTYW1lQ29udGVudFNjcmlwdCAmJiBpc05vdER1cGxpY2F0ZTtcbiAgfVxuICBsaXN0ZW5Gb3JOZXdlclNjcmlwdHMob3B0aW9ucykge1xuICAgIGxldCBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICBjb25zdCBjYiA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMudmVyaWZ5U2NyaXB0U3RhcnRlZEV2ZW50KGV2ZW50KSkge1xuICAgICAgICB0aGlzLnJlY2VpdmVkTWVzc2FnZUlkcy5hZGQoZXZlbnQuZGF0YS5tZXNzYWdlSWQpO1xuICAgICAgICBjb25zdCB3YXNGaXJzdCA9IGlzRmlyc3Q7XG4gICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdhc0ZpcnN0ICYmIG9wdGlvbnM/Lmlnbm9yZUZpcnN0RXZlbnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5ub3RpZnlJbnZhbGlkYXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgY2IpO1xuICAgIHRoaXMub25JbnZhbGlkYXRlZCgoKSA9PiByZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjYikpO1xuICB9XG59XG4iLCJjb25zdCBudWxsS2V5ID0gU3ltYm9sKCdudWxsJyk7IC8vIGBvYmplY3RIYXNoZXNgIGtleSBmb3IgbnVsbFxuXG5sZXQga2V5Q291bnRlciA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hbnlLZXlzTWFwIGV4dGVuZHMgTWFwIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX29iamVjdEhhc2hlcyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0dGhpcy5fc3ltYm9sSGFzaGVzID0gbmV3IE1hcCgpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL2lzc3Vlcy8xMTk0XG5cdFx0dGhpcy5fcHVibGljS2V5cyA9IG5ldyBNYXAoKTtcblxuXHRcdGNvbnN0IFtwYWlyc10gPSBhcmd1bWVudHM7IC8vIE1hcCBjb21wYXRcblx0XHRpZiAocGFpcnMgPT09IG51bGwgfHwgcGFpcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcGFpcnNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcih0eXBlb2YgcGFpcnMgKyAnIGlzIG5vdCBpdGVyYWJsZSAoY2Fubm90IHJlYWQgcHJvcGVydHkgU3ltYm9sKFN5bWJvbC5pdGVyYXRvcikpJyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBba2V5cywgdmFsdWVdIG9mIHBhaXJzKSB7XG5cdFx0XHR0aGlzLnNldChrZXlzLCB2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0X2dldFB1YmxpY0tleXMoa2V5cywgY3JlYXRlID0gZmFsc2UpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBrZXlzIHBhcmFtZXRlciBtdXN0IGJlIGFuIGFycmF5Jyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcHJpdmF0ZUtleSA9IHRoaXMuX2dldFByaXZhdGVLZXkoa2V5cywgY3JlYXRlKTtcblxuXHRcdGxldCBwdWJsaWNLZXk7XG5cdFx0aWYgKHByaXZhdGVLZXkgJiYgdGhpcy5fcHVibGljS2V5cy5oYXMocHJpdmF0ZUtleSkpIHtcblx0XHRcdHB1YmxpY0tleSA9IHRoaXMuX3B1YmxpY0tleXMuZ2V0KHByaXZhdGVLZXkpO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlKSB7XG5cdFx0XHRwdWJsaWNLZXkgPSBbLi4ua2V5c107IC8vIFJlZ2VuZXJhdGUga2V5cyBhcnJheSB0byBhdm9pZCBleHRlcm5hbCBpbnRlcmFjdGlvblxuXHRcdFx0dGhpcy5fcHVibGljS2V5cy5zZXQocHJpdmF0ZUtleSwgcHVibGljS2V5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3ByaXZhdGVLZXksIHB1YmxpY0tleX07XG5cdH1cblxuXHRfZ2V0UHJpdmF0ZUtleShrZXlzLCBjcmVhdGUgPSBmYWxzZSkge1xuXHRcdGNvbnN0IHByaXZhdGVLZXlzID0gW107XG5cdFx0Zm9yIChsZXQga2V5IG9mIGtleXMpIHtcblx0XHRcdGlmIChrZXkgPT09IG51bGwpIHtcblx0XHRcdFx0a2V5ID0gbnVsbEtleTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaGFzaGVzID0gdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJyA/ICdfb2JqZWN0SGFzaGVzJyA6ICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJyA/ICdfc3ltYm9sSGFzaGVzJyA6IGZhbHNlKTtcblxuXHRcdFx0aWYgKCFoYXNoZXMpIHtcblx0XHRcdFx0cHJpdmF0ZUtleXMucHVzaChrZXkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzW2hhc2hlc10uaGFzKGtleSkpIHtcblx0XHRcdFx0cHJpdmF0ZUtleXMucHVzaCh0aGlzW2hhc2hlc10uZ2V0KGtleSkpO1xuXHRcdFx0fSBlbHNlIGlmIChjcmVhdGUpIHtcblx0XHRcdFx0Y29uc3QgcHJpdmF0ZUtleSA9IGBAQG1rbS1yZWYtJHtrZXlDb3VudGVyKyt9QEBgO1xuXHRcdFx0XHR0aGlzW2hhc2hlc10uc2V0KGtleSwgcHJpdmF0ZUtleSk7XG5cdFx0XHRcdHByaXZhdGVLZXlzLnB1c2gocHJpdmF0ZUtleSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHByaXZhdGVLZXlzKTtcblx0fVxuXG5cdHNldChrZXlzLCB2YWx1ZSkge1xuXHRcdGNvbnN0IHtwdWJsaWNLZXl9ID0gdGhpcy5fZ2V0UHVibGljS2V5cyhrZXlzLCB0cnVlKTtcblx0XHRyZXR1cm4gc3VwZXIuc2V0KHB1YmxpY0tleSwgdmFsdWUpO1xuXHR9XG5cblx0Z2V0KGtleXMpIHtcblx0XHRjb25zdCB7cHVibGljS2V5fSA9IHRoaXMuX2dldFB1YmxpY0tleXMoa2V5cyk7XG5cdFx0cmV0dXJuIHN1cGVyLmdldChwdWJsaWNLZXkpO1xuXHR9XG5cblx0aGFzKGtleXMpIHtcblx0XHRjb25zdCB7cHVibGljS2V5fSA9IHRoaXMuX2dldFB1YmxpY0tleXMoa2V5cyk7XG5cdFx0cmV0dXJuIHN1cGVyLmhhcyhwdWJsaWNLZXkpO1xuXHR9XG5cblx0ZGVsZXRlKGtleXMpIHtcblx0XHRjb25zdCB7cHVibGljS2V5LCBwcml2YXRlS2V5fSA9IHRoaXMuX2dldFB1YmxpY0tleXMoa2V5cyk7XG5cdFx0cmV0dXJuIEJvb2xlYW4ocHVibGljS2V5ICYmIHN1cGVyLmRlbGV0ZShwdWJsaWNLZXkpICYmIHRoaXMuX3B1YmxpY0tleXMuZGVsZXRlKHByaXZhdGVLZXkpKTtcblx0fVxuXG5cdGNsZWFyKCkge1xuXHRcdHN1cGVyLmNsZWFyKCk7XG5cdFx0dGhpcy5fc3ltYm9sSGFzaGVzLmNsZWFyKCk7XG5cdFx0dGhpcy5fcHVibGljS2V5cy5jbGVhcigpO1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiAnTWFueUtleXNNYXAnO1xuXHR9XG5cblx0Z2V0IHNpemUoKSB7XG5cdFx0cmV0dXJuIHN1cGVyLnNpemU7XG5cdH1cbn1cbiIsImltcG9ydCBNYW55S2V5c01hcCBmcm9tICdtYW55LWtleXMtbWFwJztcbmltcG9ydCB7IGRlZnUgfSBmcm9tICdkZWZ1JztcbmltcG9ydCB7IGlzRXhpc3QgfSBmcm9tICcuL2RldGVjdG9ycy5tanMnO1xuXG5jb25zdCBnZXREZWZhdWx0T3B0aW9ucyA9ICgpID0+ICh7XG4gIHRhcmdldDogZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgdW5pZnlQcm9jZXNzOiB0cnVlLFxuICBkZXRlY3RvcjogaXNFeGlzdCxcbiAgb2JzZXJ2ZUNvbmZpZ3M6IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gIH0sXG4gIHNpZ25hbDogdm9pZCAwLFxuICBjdXN0b21NYXRjaGVyOiB2b2lkIDBcbn0pO1xuY29uc3QgbWVyZ2VPcHRpb25zID0gKHVzZXJTaWRlT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGRlZnUodXNlclNpZGVPcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG59O1xuXG5jb25zdCB1bmlmeUNhY2hlID0gbmV3IE1hbnlLZXlzTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVXYWl0RWxlbWVudChpbnN0YW5jZU9wdGlvbnMpIHtcbiAgY29uc3QgeyBkZWZhdWx0T3B0aW9ucyB9ID0gaW5zdGFuY2VPcHRpb25zO1xuICByZXR1cm4gKHNlbGVjdG9yLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgdW5pZnlQcm9jZXNzLFxuICAgICAgb2JzZXJ2ZUNvbmZpZ3MsXG4gICAgICBkZXRlY3RvcixcbiAgICAgIHNpZ25hbCxcbiAgICAgIGN1c3RvbU1hdGNoZXJcbiAgICB9ID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICBjb25zdCB1bmlmeVByb21pc2VLZXkgPSBbXG4gICAgICBzZWxlY3RvcixcbiAgICAgIHRhcmdldCxcbiAgICAgIHVuaWZ5UHJvY2VzcyxcbiAgICAgIG9ic2VydmVDb25maWdzLFxuICAgICAgZGV0ZWN0b3IsXG4gICAgICBzaWduYWwsXG4gICAgICBjdXN0b21NYXRjaGVyXG4gICAgXTtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdW5pZnlDYWNoZS5nZXQodW5pZnlQcm9taXNlS2V5KTtcbiAgICBpZiAodW5pZnlQcm9jZXNzICYmIGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBkZXRlY3RQcm9taXNlID0gbmV3IFByb21pc2UoXG4gICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vQXN5bmNQcm9taXNlRXhlY3V0b3I6IGF2b2lkIG5lc3RpbmcgcHJvbWlzZVxuICAgICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgICAgIGFzeW5jIChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgXyBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkZXRlY3RSZXN1bHQyID0gYXdhaXQgZGV0ZWN0RWxlbWVudCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRldGVjdG9yLFxuICAgICAgICAgICAgICAgIGN1c3RvbU1hdGNoZXJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChkZXRlY3RSZXN1bHQyLmlzRGV0ZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkZXRlY3RSZXN1bHQyLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBcImFib3J0XCIsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRldGVjdFJlc3VsdCA9IGF3YWl0IGRldGVjdEVsZW1lbnQoe1xuICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBkZXRlY3RvcixcbiAgICAgICAgICBjdXN0b21NYXRjaGVyXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGV0ZWN0UmVzdWx0LmlzRGV0ZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkZXRlY3RSZXN1bHQucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwgb2JzZXJ2ZUNvbmZpZ3MpO1xuICAgICAgfVxuICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICB1bmlmeUNhY2hlLmRlbGV0ZSh1bmlmeVByb21pc2VLZXkpO1xuICAgIH0pO1xuICAgIHVuaWZ5Q2FjaGUuc2V0KHVuaWZ5UHJvbWlzZUtleSwgZGV0ZWN0UHJvbWlzZSk7XG4gICAgcmV0dXJuIGRldGVjdFByb21pc2U7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkZXRlY3RFbGVtZW50KHtcbiAgdGFyZ2V0LFxuICBzZWxlY3RvcixcbiAgZGV0ZWN0b3IsXG4gIGN1c3RvbU1hdGNoZXJcbn0pIHtcbiAgY29uc3QgZWxlbWVudCA9IGN1c3RvbU1hdGNoZXIgPyBjdXN0b21NYXRjaGVyKHNlbGVjdG9yKSA6IHRhcmdldC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgcmV0dXJuIGF3YWl0IGRldGVjdG9yKGVsZW1lbnQpO1xufVxuY29uc3Qgd2FpdEVsZW1lbnQgPSBjcmVhdGVXYWl0RWxlbWVudCh7XG4gIGRlZmF1bHRPcHRpb25zOiBnZXREZWZhdWx0T3B0aW9ucygpXG59KTtcblxuZXhwb3J0IHsgY3JlYXRlV2FpdEVsZW1lbnQsIGdldERlZmF1bHRPcHRpb25zLCB3YWl0RWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbImRlZmluaXRpb24iLCJub29wIiwiaSIsImVxdWFscyIsImEiLCJiIiwiY29tcG9uZW50IiwidiIsInN0YWNrIiwiX2EiLCJzb3VyY2UiLCJlLnN0YXRlX3Vuc2FmZV9tdXRhdGlvbiIsImVmZmVjdCIsImNoaWxkIiwiX2IiLCJnbG9iYWwiLCJ3Lm93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmciLCJ3Lm93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uIiwiXyIsInByb3AiLCJlLnN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkIiwiZ2V0IiwidmFsdWUiLCJrZXkiLCJlLnN0YXRlX3Byb3RvdHlwZV9maXhlZCIsImQiLCJhcnJheV9wcm90b3R5cGUiLCJpbmRleCIsIncuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2giLCJkZXJpdmVkIiwiZS5kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZiIsImUuZWZmZWN0X29ycGhhbiIsImUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCIsImUuZWZmZWN0X2luX3RlYXJkb3duIiwicHVzaCIsInRlYXJkb3duIiwibmV4dCIsInNpYmxpbmciLCJpc19taWNyb190YXNrX3F1ZXVlZCIsImNvbXBvbmVudF9jb250ZXh0IiwicmVzdWx0IiwiZS5lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkIiwiZS5zdGF0ZV91bnNhZmVfbG9jYWxfcmVhZCIsImdldENvbnRleHQiLCJzZXRDb250ZXh0IiwiZS5ydW5lX291dHNpZGVfc3ZlbHRlIiwiZWxlbWVudCIsImxvY2F0aW9uIiwiZXZlbnQiLCJyb290IiwidGV4dCIsImV2ZW50cyIsInVubW91bnQiLCJ3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCIsImUuY29tcG9uZW50X2FwaV9pbnZhbGlkX25ldyIsImUuY29tcG9uZW50X2FwaV9jaGFuZ2VkIiwiZm4iLCJzdGF0ZSIsImoiLCJzbmlwcGV0IiwiZS5pbnZhbGlkX3NuaXBwZXQiLCJnZXRfY29tcG9uZW50IiwiciIsImYiLCJvIiwiY2xzeCIsIl9jbHN4IiwicHJldiIsInNldCIsImUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlIiwidXBkYXRlIiwicHJvcHMiLCJsIiwiZS5wcm9wc19yZXN0X3JlYWRvbmx5IiwicCIsImUucHJvcHNfaW52YWxpZF92YWx1ZSIsImUuYmluZF9pbnZhbGlkX2V4cG9ydCIsImUuYmluZF9ub3RfYmluZGFibGUiLCJlLnN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZSIsImRhdGUiLCJvZmZzZXQiLCJtaW4iLCJtYXgiLCJyb3VuZCIsInJlcyIsIm1zIiwiJGFrc3kxJF8iLCJ4IiwieSIsImMiLCJnIiwiY2xhc3NHcm91cCIsImNhY2hlIiwiTiIsImUiLCJSIiwiTSIsIk8iLCJVIiwiQyIsInoiLCJnJDEiLCJ3IiwiUyIsIlQiLCJWIiwiUCIsImgiLCJ1IiwiRCIsIkwiLCJFIiwiQSIsIkgiLCJJIiwiSiIsInR2Iiwic2l6ZSIsIiQucmVzdF9wcm9wcyIsIiQuYmluZF90aGlzIiwiaXNGdW5jdGlvbiIsIiQucHJveHkiLCJjb21tZW50IiwidGhpcyIsIlN0eWxlVG9PYmplY3QiLCJyZXF1aXJlJCQwIiwiJC51c2VyX2VmZmVjdCIsIiQuc3RhdGUiLCIkLmdldCIsIiQuc2V0IiwiJC5zdHJpY3RfZXF1YWxzIiwiJC51c2VyX3ByZV9lZmZlY3QiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50Iiwic2V0U3ZlbHRlQ29udGV4dCIsImdldFN2ZWx0ZUNvbnRleHQiLCIkLmRlcml2ZWQiLCJfaWQiLCJfaXNEaXNhYmxlZCIsIl9yZWYiLCJrYmQuU1BBQ0UiLCJrYmQuRU5URVIiLCIkLnNuaXBwZXQiLCIkLm5vb3AiLCJfZGlzYWJsZWQiLCJfcm9vdCIsIl9sZXZlbCIsIl9zbmlwcGV0UHJvcHMiLCJQb3J0YWxDb25zdW1lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJpc1ZhbGlkRXZlbnQiLCJrYmQuRVNDQVBFIiwiX2JlaGF2aW9yVHlwZSIsIl9lbmFibGVkIiwia2JkLlRBQiIsImFkZEV2ZW50TGlzdGVuZXJzX2ZuIiwiX3NpemUiLCIkLmVmZmVjdF9yb290Iiwib3BlbiIsIkNhbGVuZGFyRGF0ZVRpbWUiLCJDYWxlbmRhckRhdGUiLCJab25lZERhdGVUaW1lIiwicGFyc2Vab25lZERhdGVUaW1lIiwicGFyc2VEYXRlVGltZSIsInBhcnNlRGF0ZSIsInRvQ2FsZW5kYXIiLCJnZXRMb2NhbFRpbWVab25lIiwiZ2V0RGF5T2ZXZWVrIiwiRGF0ZUZvcm1hdHRlciIsInBhcnQiLCJzdGFydE9mTW9udGgiLCJlbmRPZk1vbnRoIiwia2JkLkFSUk9XX0RPV04iLCJrYmQuQVJST1dfVVAiLCJrYmQuQVJST1dfTEVGVCIsImtiZC5BUlJPV19SSUdIVCIsImlzU2FtZU1vbnRoIiwiJC50ZW1wbGF0ZV9lZmZlY3QiLCIkLnNldF90ZXh0IiwiY29tcHV0ZVBvc2l0aW9uIiwicGxhdGZvcm0iLCJyZXNldCIsImFycm93IiwiZmxpcCIsInNpZGVzIiwic2lkZSIsInBsYWNlbWVudCIsIm92ZXJmbG93IiwiaGlkZSIsInNoaWZ0IiwibGltaXRTaGlmdCIsImdldENvbXB1dGVkU3R5bGUiLCIkLnByb3AiLCJpc1NhbWVEYXkiLCJpc1RvZGF5IiwiUk9PVF9BVFRSIiwiJC5zZXRfYXR0cmlidXRlcyIsImRlZmF1bHRBdHRyaWJ1dGVzIiwiJC5pbmRleCIsIiQkYW5jaG9yIiwiJC5OQU1FU1BBQ0VfU1ZHIiwiUm9vdCIsIkRpYWxvZ1ByaW1pdGl2ZS5Sb290IiwiVHJpZ2dlciIsIkRpYWxvZ1ByaW1pdGl2ZS5UcmlnZ2VyIiwiRGlhbG9nUHJpbWl0aXZlLlBvcnRhbCIsIlBvcG92ZXJQcmltaXRpdmUuUm9vdCIsIlBvcG92ZXJQcmltaXRpdmUuVHJpZ2dlciIsIiQuZWFjaCIsIkZhbGxiYWNrIiwiUmFuZ2VDYWxlbmRhclByaW1pdGl2ZS5HcmlkSGVhZCIsIlJhbmdlQ2FsZW5kYXJQcmltaXRpdmUuR3JpZEJvZHkiLCJ1dWlkIiwicmVxdWlyZSIsInRvQ2FsZW5kYXJEYXRlVGltZSIsIlRpbWUiLCJJQ2FsRXZlbnRSZXBlYXRpbmdGcmVxIiwiaWNhbCIsInNhdmVBcyIsImluaXQiLCJwcm9jZXNzIiwiZGF0YVVSTCIsIiQubXV0YWJsZV9zdGF0ZSIsImxpbmsiLCJ0aGVtZSIsIiQuc2V0X2F0dHJpYnV0ZSIsIiQuZXF1YWxzIiwiJC5kZXJpdmVkX3NhZmVfZXF1YWwiLCIkLmJpbmRfdmFsdWUiLCJpdGVtIiwic3R1ZHlUYWJsZSIsInByaW50IiwibG9nZ2VyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sV0FBUyxvQkFBb0JBLGFBQVk7QUFDOUMsV0FBT0E7QUFBQSxFQUNUO0FDT08sUUFBTSxpQkFBaUI7QUNQOUIsTUFBSSxPQUFPLFdBQVc7QUFFckIsS0FBQyxPQUFPLGFBQVAsT0FBTyxXQUFhLEVBQUUsR0FBRyxvQkFBSSxJQUFHLE1BQU0sRUFBRSxJQUFJLGNBQWM7QUNKckQsTUFBSSxtQkFBbUI7QUFHdkIsV0FBUywwQkFBMEI7QUFDekMsdUJBQW1CO0FBQUEsRUFDcEI7QUNIQSwwQkFBeUI7QUNGbEIsUUFBTSxxQkFBcUI7QUFDM0IsUUFBTSxzQkFBc0IsS0FBSztBQUVqQyxRQUFNLHFCQUFxQixLQUFLO0FBQ2hDLFFBQU0sbUJBQW1CLEtBQUs7QUFDOUIsUUFBTSxzQkFBc0IsS0FBSztBQUVqQyxRQUFNLHFCQUFxQjtBQUMzQixRQUFNLGlCQUFpQixLQUFLO0FBQzVCLFFBQU0sbUJBQW1CLEtBQUs7QUFDOUIsUUFBTSxvQkFBb0IsS0FBSztBQUMvQixRQUFNLHdCQUF3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LGNBQWE7QUFDVCxXQUFLLGFBQWE7QUFBQSxJQUMxQjtBQUFBLEVBQ0E7QUNySEEsUUFBTSw0Q0FBNEM7QUFBQSxJQUM5QyxPQUFPO0FBQUEsSUFDUCxJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsRUFDUjtBQzdGQSxXQUFTLDBDQUEwQzFFLElBQUdDLElBQUc7QUFDckQsSUFBQUEsS0FBUSwwQ0FBMkNBLElBQUdELEdBQUUsUUFBUTtBQUNoRSxXQUFPQSxHQUFFLFFBQVFDLEdBQUUsT0FBT0QsR0FBRSxTQUFTQyxHQUFFLFFBQVFELEdBQUUsVUFBVUMsR0FBRSxTQUFTRCxHQUFFLFFBQVFDLEdBQUU7QUFBQSxFQUN0RjtBQUNBLFdBQVMsMENBQTBDRCxJQUFHQyxJQUFHO0FBQ3JELElBQUFBLEtBQVEsMENBQTJDQSxJQUFHRCxHQUFFLFFBQVE7QUFFaEUsSUFBQUEsS0FBSSwwQ0FBMENBLEVBQUM7QUFDL0MsSUFBQUMsS0FBSSwwQ0FBMENBLEVB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RCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxPQUFPO0FBQUEsUUFDcEIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxPQUFPO0FBQUEsUUFDcEIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxPQUFPO0FBQUEsUUFDcEIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxPQUFPO0FBQUEsUUFDcEIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxPQUFPO0FBQUEsUUFDcEIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxHQUFHLENBQUM7QUFBQSxVQUNGLEdBQUcsQ0FBQyxNQUFNO0FBQUEsUUFDbEIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxNQUFNO0FBQUEsUUFDbkIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxNQUFNO0FBQUEsUUFDbkIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxNQUFNO0FBQUEsUUFDbkIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxNQUFNO0FBQUEsUUFDbkIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENBQUM7QUFBQSxVQUNILElBQUksQ0FBQyxNQUFNO0FBQUEsUUFDbkIsQ0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLRCxJQUFJLENB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QUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSxDQUFDLFlBQVk7QUFBQSxRQUNsQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsY0FBYyxDQUFDLFlBQVk7QUFBQSxRQUNuQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELFlBQVksQ0FBQztBQUFBLFVBQ1gsUUFBUSxDQUFDLFdBQVc7QUFBQSxRQUM1QixDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGNBQWMsQ0FBQztBQUFBLFVBQ2IsWUFBWSxDQUFDLFdBQVc7QUFBQSxRQUNoQyxDQUFPO0FBQUE7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QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELFlBQVksQ0FBQztBQUFBLFVBQ1gsWUFBWSx3QkFBdUI7QUFBQSxRQUMzQyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVBQ1osYUFBYSx3QkFBdUI7QUFBQSxRQUM1QyxDQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtELGFBQWEsQ0FBQztBQUFBLFVB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QVMsR0FBRSxHQUFHLElBQUcsSUFBRSxJQUFFRSxNQUFHLEtBQUcsTUFBSUYsR0FBRSxTQUFVLEVBQUMsU0FBVSxFQUFDLFNBQVMsR0FBRSxHQUFHLElBQUVBLEdBQUUsV0FBVSxFQUFHLFNBQVEsRUFBRyxTQUFTLEdBQUUsR0FBRyxJQUFFQSxHQUFFLGFBQWEsV0FBVyxTQUFTLEdBQUUsR0FBRyxHQUFFLE1BQUksS0FBRyxNQUFJQSxHQUFFLFlBQWEsRUFBQyxTQUFVLEVBQUMsU0FBUyxHQUFFLEdBQUcsSUFBRUEsR0FBRSxjQUFhLEVBQUcsU0FBUSxFQUFHLFNBQVMsR0FBRSxHQUFHLElBQUVBLEdBQUUsY0FBYSxFQUFHLFdBQVcsU0FBUyxHQUFFLEdBQUcsS0FBRyxJQUFFLEtBQUcsTUFBSztBQUFBLElBQUUsV0FBUyxFQUFFLENBQUMsR0FBRTtBQUFDLFVBQUlBLEtBQUVFLEtBQUUsRUFBRSxDQUFDLEtBQUcsQ0FBQyxFQUFFLEdBQUksSUFBQyxFQUFFLE1BQU8sRUFBQyxHQUFHQSxFQUFDLElBQUUsSUFBRSxLQUFHLEtBQUcsRUFBRSxDQUFDLEtBQUcsRUFBRSxHQUFFLElBQUcsSUFBRSxFQUFFO0FBQU0sYUFBT0YsR0FBRSxPQUFPLFVBQVUsS0FBRyxJQUFFLEtBQUcsTUFBSUEsR0FBRSxPQUFPLFFBQVEsS0FBRyxLQUFHRSxLQUFFLEtBQUc7QUFBQSxJQUFLLFdBQVMsRUFBRSxDQUFDLEdBQUU7QUFBQyxVQUFJRixLQUFFRSxLQUFFLEVBQUUsUUFBUUEsRUFBQyxJQUFFLEtBQUcsS0FBRyxFQUFFLEtBQUssU0FBTyxXQUFTLElBQUUsRUFBRSxRQUFRLEtBQUs7QUFBRSxhQUFPRixHQUFFLFNBQVMsVUFBVSxLQUFHLElBQUUsS0FBRyxNQUFJQSxHQUFFLFNBQVMsUUFBUSxLQUFHLEtBQUdFLEtBQUUsS0FBRztBQUFBLElBQUssT0FBSztBQUFDLFVBQUlGLEtBQUU7QUFBRSxVQUFHRSxHQUFFLENBQUFGLEtBQUUsT0FBTyxFQUFFLE1BQUksYUFBVyxFQUFFLEdBQUdFLEVBQUMsSUFBRTtBQUFB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SUFBSztBQUFBLElBQUMsTUFBTSxHQUFFO0FBQUMsYUFBTyxLQUFHLEtBQUssS0FBSyxRQUFNLEdBQUUsUUFBTSxLQUFLLEtBQUs7QUFBQSxJQUFLO0FBQUEsSUFBQyxPQUFPLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEtBQUssVUFBUSxLQUFLLEtBQUssU0FBTyxLQUFHLE1BQUs7QUFBQSxJQUFLO0FBQUEsSUFBQyxPQUFPLEdBQUU7QUFBQyxhQUFPLEtBQUcsS0FBSyxLQUFLLFNBQU8sR0FBRSxRQUFNLEtBQUssS0FBSztBQUFBLElBQU07QUFBQSxJQUFDLEtBQUssR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssS0FBSyxRQUFNLEtBQUssS0FBSyxPQUFLLEVBQUUsR0FBRSxDQUFDLEdBQUU7QUFBQSxJQUFLO0FBQUEsSUFBQyxLQUFLLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEtBQUssT0FBSyxNQUFJLFFBQU0sS0FBSyxLQUFLLE9BQUssTUFBSyxTQUFPLEtBQUssS0FBSyxPQUFLLENBQUMsQ0FBQyxHQUFFO0FBQUEsSUFBSztBQUFBLElBQUMsT0FBTyxHQUFFO0FBQUMsYUFBTyxNQUFJLFNBQU8sS0FBSyxLQUFLLFNBQU8sS0FBRyxLQUFLLEtBQUssU0FBTyxFQUFFLEdBQUUsQ0FBQyxHQUFFLFNBQU8sS0FBSyxLQUFLLFNBQU8sTUFBSztBQUFBLElBQUs7QUFBQSxJQUFDLEtBQUssR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssS0FBSyxPQUFLLEtBQUcsS0FBSyxLQUFLLE9BQUssRUFBRSxHQUFFLENBQUMsR0FBRSxTQUFPLEtBQUssS0FBSyxPQUFLLE1BQUs7QUFBQSxJQUFLO0FBQUEsSUFBQyxZQUFZLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEtBQUssY0FBWSxLQUFHLE9BQU8sS0FBRyxXQUFTLEtBQUssS0FBSyxjQUFZLElBQUlBLEdBQUUsRUFBQyxPQUFNLEdBQUUsR0FBRyxFQUFFLGVBQWMsQ0FBQyxFQUFDLEdBQUUsS0FBSyxNQUFN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RUFBRSxFQUFFLENBQUM7QUFBQSxJQUFDO0FBQUEsSUFBQyxLQUFLLEdBQUU7QUFBQyxVQUFHLE1BQUksT0FBTyxRQUFPLEtBQUssS0FBSztBQUFLLFVBQUcsQ0FBQyxLQUFHLENBQUMsT0FBTyxLQUFLLENBQUMsRUFBRSxTQUFTLENBQUMsRUFBRSxPQUFNLElBQUksTUFBTSw2REFBNkQ7QUFBRSxhQUFPLEtBQUssS0FBSyxPQUFLLEdBQUU7QUFBQSxJQUFJO0FBQUEsSUFBQyxRQUFRLEdBQUU7QUFBQyxVQUFHLE1BQUksVUFBUSxPQUFPLEtBQUssS0FBSyxXQUFTLFNBQVMsUUFBTSxLQUFHLEtBQUssS0FBSztBQUFRLFVBQUcsTUFBSSxPQUFPLFFBQU8sS0FBSyxLQUFLO0FBQVEsVUFBRyxPQUFPLEtBQUcsWUFBVSxTQUFTLENBQUMsRUFBRSxNQUFLLEtBQUssVUFBUSxLQUFHO0FBQUEsV0FBTTtBQUFDLFlBQUcsQ0FBQyxLQUFHLE9BQU8sS0FBRyxTQUFTLE9BQU0sSUFBSSxNQUFNLHdFQUF3RTtBQUFFLGFBQUssS0FBSyxVQUFRLEVBQUUsR0FBRSxTQUFTO0FBQUEsTUFBQztBQUFDLGFBQU87QUFBQSxJQUFJO0FBQUEsSUFBQyxVQUFVLEdBQUU7QUFBQyxVQUFHLE1BQUksT0FBTyxRQUFPLEtBQUssS0FBSztBQUFVLFVBQUcsQ0FBQyxFQUFFLFFBQU8sS0FBSyxLQUFLLFlBQVUsTUFBSztBQUFLLFVBQUcsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxFQUFFLFNBQVMsQ0FBQyxFQUFFLE9BQU0sSUFBSSxNQUFNLDhEQUE4RDtBQUFFLGFBQU8sS0FBSyxLQUFLLFlBQVUsR0FBRTtBQUFBLElBQUk7QUFBQSxJQUFDLGFBQWEsR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssS0FBSyxVQUFRLEtBQUssUUFBUSxPQUFPLEtBQUcsV0FBUyxLQUFHLElBQUUsQ0FBQztBQUFBLElBQUM7QUFBQSxJQUFDLGNBQWMsR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssUUFBTyxJQUFHLEtBQUssUUFBUSxDQUFD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RUFBRSxLQUFLLEdBQUUsRUFBRSxXQUFTLFVBQVEsS0FBSyxPQUFPLEVBQUUsTUFBTSxHQUFFLEVBQUUsYUFBVyxVQUFRLEtBQUssU0FBUyxFQUFFLFFBQVEsR0FBRSxFQUFFLGNBQVksVUFBUSxLQUFLLFVBQVUsRUFBRSxTQUFTLEdBQUUsRUFBRSxZQUFVLFVBQVEsS0FBSyxRQUFRLEVBQUUsT0FBTyxHQUFFLEVBQUUsYUFBVyxVQUFRLEtBQUssU0FBUyxFQUFFLFFBQVEsR0FBRSxFQUFFLGdCQUFjLFVBQVEsS0FBSyxZQUFZLEVBQUUsV0FBVyxHQUFFLEVBQUUsY0FBWSxVQUFRLEtBQUssVUFBVSxFQUFFLFNBQVMsR0FBRSxFQUFFLGNBQVksVUFBUSxLQUFLLFVBQVUsRUFBRSxTQUFTLEdBQUUsRUFBRSxXQUFTLFVBQVEsS0FBSyxPQUFPLEVBQUUsTUFBTSxHQUFFLEVBQUUsZUFBYSxVQUFRLEtBQUssV0FBVyxFQUFFLFVBQVUsR0FBRSxFQUFFLFdBQVMsVUFBUSxLQUFLLE9BQU8sRUFBRSxNQUFNLEdBQUUsRUFBRSxlQUFhLFVBQVEsS0FBSyxXQUFXLEVBQUUsVUFBVSxHQUFFLEVBQUUsYUFBVyxVQUFRLEtBQUssU0FBUyxFQUFFLFFBQVEsR0FBRSxFQUFFLFFBQU0sVUFBUSxLQUFLLElBQUksRUFBRSxHQUFHLEdBQUUsRUFBRSxnQkFBYyxVQUFRLEtBQUssWUFBWSxFQUFFLFdBQVcsR0FBRSxFQUFFLGlCQUFlLFVBQVEsS0FBSyxhQUFhLEVBQUUsWUFBWSxHQUFFLEVBQUUsWUFBVSxVQUFRLEtBQUssUUFBUSxFQUFFLE9BQU8sR0FBRSxFQUFFLGlCQUFlLFVBQVEsS0FBSyxhQUFhLEVBQUUsWUFBWSxHQUFFLEVBQUUsVUFBUSxVQUFRLEtBQUssTUFBTSxFQUFFLEtBQUssR0FBRSxFQUFFLE1BQUksVUFBUSxLQUFLLEVBQUUsRUFBRSxDQUFDO0FBQUEsSUFBQztBQUFBLElBQUMsR0FBRyxHQUFFO0FBQUMsYUFBTyxNQUFJLFNBQU8sS0FBSyxLQUFLLE1BQUksS0FBSyxLQUFLLEtBQUcsT0FBTyxDQUFDLEdBQUU7QUFBQSxJQUFLO0FBQUEsSUFBQyxJQUFJLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEdBQUUsSUFBRyxLQUFLLEdBQUcsQ0FBQztBQUFBLElBQUM7QUFBQSxJQUFDLFNBQVMsR0FBRTtBQUFDLFVBQUcsTUFBSSxPQUFPLFFBQU8sS0FBSyxLQUFLO0FBQVMsVUFBSSxJQUFFLFNBQVMsT0FBTyxDQUFDLEdBQUUsRUFBRTtBQUFFLFVBQUcsTUFBTSxDQUFDLEVBQUUsT0FBTSxJQUFJLE1BQU0sOEJBQThCO0FBQUUsYUFBTyxLQUFLLEtBQUssV0FBUyxHQUFFO0FBQUEsSUFBSTtBQUFBLElBQUMsTUFBTSxHQUFFO0FBQUMsYUFBTyxNQUFJLFVBQVEsS0FBSywwQkFBeUIsR0FBRyxLQUFLLEtBQUssVUFBUSxLQUFLLEtBQUssUUFBTSxFQUFFLEdBQUUsT0FBTyxHQUFFO0FBQUEsSUFBSztBQUFBLElBQUMsSUFBSSxHQUFFO0FBQUMsYUFBTyxNQUFJLFVBQVEsS0FBSywwQkFBMkIsR0FBQyxLQUFLLEtBQUssT0FBSyxNQUFJLFFBQU0sS0FBSyxLQUFLLE1BQUksTUFBSyxTQUFPLEtBQUssS0FBSyxNQUFJLEVBQUUsR0FBRSxLQUFLLEdBQUU7QUFBQSxJQUFLO0FBQUEsSUFBQyw0QkFBMkI7QUFBQyxVQUFHLEtBQUssS0FBSyxTQUFPLEtBQUssS0FBSyxPQUFLLEVBQUUsS0FBSyxLQUFLLEtBQUssRUFBRSxRQUFPLElBQUcsRUFBRSxLQUFLLEtBQUssR0FBRyxFQUFFLFFBQU8sR0FBRztBQUFDLFlBQUksSUFBRSxLQUFLLEtBQUs7QUFBTSxhQUFLLEtBQUssUUFBTSxLQUFLLEtBQUssS0FBSSxLQUFLLEtBQUssTUFBSTtBQUFBLE1BQUM7QUFBQSxJQUFDO0FBQUEsSUFBQyxhQUFhLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEtBQUssZUFBYSxNQUFJLFFBQU0sS0FBSyxLQUFLLGVBQWEsTUFBSyxTQUFPLEtBQUssS0FBSyxlQUFhLEVBQUUsR0FBRSxjQUFjLEdBQUU7QUFBQSxJQUFLO0FBQUEsSUFBQyxTQUFTLEdBQUU7QUFBQyxhQUFPLE1BQUksVUFBUSxLQUFLLEtBQUssYUFBVyxPQUFLLEtBQUssS0FBSyxXQUFTLE1BQUksU0FBTyxLQUFLLFNBQVMsU0FBUSxLQUFJLEtBQUssS0FBSyxXQUFTLEtBQUcsTUFBSSxRQUFNLEVBQUUsU0FBVSxJQUFDLE1BQUssS0FBSyxLQUFLLGFBQVcsS0FBSyxLQUFLLFdBQVMsUUFBSTtBQUFBLElBQUs7QUFBQSxJQUFDLE1BQU0sR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssS0FBSyxTQUFPLEtBQUssS0FBSyxRQUFNLEVBQUUsR0FBRSxPQUFPLEdBQUU7QUFBQSxJQUFLO0FBQUEsSUFBQyxVQUFVLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLE1BQUssSUFBRyxLQUFLLE1BQU0sQ0FBQztBQUFBLElBQUM7QUFBQSxJQUFDLE9BQU8sR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssS0FBSyxVQUFRLEtBQUssS0FBSyxTQUFPLENBQUMsQ0FBQyxHQUFFO0FBQUEsSUFBSztBQUFBLElBQUMsU0FBUyxHQUFFO0FBQUMsYUFBTyxNQUFJLFNBQU8sS0FBSyxLQUFLLFlBQVUsS0FBSyxLQUFLLFdBQVMsQ0FBQyxDQUFDLEdBQUUsS0FBSyxLQUFLLGFBQVcsS0FBSyxLQUFLLFdBQVMsT0FBTTtBQUFBLElBQUs7QUFBQSxJQUFDLFVBQVUsR0FBRTtBQUFDLFVBQUcsTUFBSSxPQUFPLFFBQU8sS0FBSyxLQUFLO0FBQVUsVUFBRyxDQUFDLEVBQUUsUUFBTyxLQUFLLEtBQUssWUFBVSxNQUFLO0FBQUssVUFBRyxFQUFFLENBQUMsS0FBRyxPQUFPLEtBQUcsU0FBUyxRQUFPLEtBQUssS0FBSyxZQUFVLEdBQUU7QUFBSyxVQUFHLEtBQUssS0FBSyxZQUFVLEVBQUMsTUFBSyxFQUFFLEdBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRSxFQUFFLE9BQU07QUFBQyxZQUFHLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxPQUFNLElBQUksTUFB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QUFDLHVCQUFHLE1BQUssT0FBTSxJQUFJLE1BQU0sd0lBQXdJO0FBQUUsYUFBTyxLQUFLLEtBQUssV0FBUyxLQUFHLE1BQUs7QUFBQSxJQUFJO0FBQUEsSUFBQyxZQUFZLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEtBQUssY0FBWSxNQUFJLFFBQU0sS0FBSyxLQUFLLGNBQVksTUFBSyxTQUFPLE9BQU8sS0FBRyxXQUFTLEtBQUssS0FBSyxjQUFZLEVBQUMsT0FBTSxFQUFDLElBQUUsS0FBSyxLQUFLLGNBQVksR0FBRTtBQUFBLElBQUs7QUFBQSxJQUFDLFVBQVUsR0FBRTtBQUFDLGFBQU8sTUFBSSxTQUFPLEtBQUssS0FBSyxZQUFVLE1BQUksUUFBTSxLQUFLLEtBQUssWUFBVSxNQUFLLFNBQU8sS0FBSyxLQUFLLFlBQVUsRUFBRSxhQUFZLENBQUMsR0FBRTtBQUFBLElBQUs7QUFBQSxJQUFDLGVBQWUsR0FBRTtBQUFDLFVBQUcsYUFBYSxFQUFFLFFBQU8sS0FBSyxLQUFLLFVBQVUsS0FBSyxDQUFDLEdBQUU7QUFBRSxhQUFPLEtBQUcsYUFBVyxJQUFFLEVBQUMsT0FBTSxHQUFFLEdBQUcsRUFBRSxRQUFPLENBQUMsRUFBQztBQUFHLFVBQUksSUFBRSxJQUFJLEVBQUUsR0FBRSxJQUFJO0FBQUUsYUFBTyxLQUFLLEtBQUssVUFBVSxLQUFLLENBQUMsR0FBRTtBQUFBLElBQUM7QUFBQSxJQUFDLFVBQVUsR0FBRTtBQUFDLGFBQU8sS0FBRyxFQUFFLFFBQVEsT0FBRyxLQUFLLGVBQWUsQ0FBQyxDQUFDLEdBQUUsUUFBTSxLQUFLLEtBQUs7QUFBQSxJQUFTO0FBQUEsSUFBQyxZQUFZLEdBQUU7QUFBQyxVQUFJLElBQUUsYUFBYSxJQUFFLElBQUUsSUFBSSxFQUFFLEdBQUUsSUFBSTtBQUFFLGFBQU8sS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLEdBQUU7QUFBQSxJQUFDO0FBQUEsSUFBQyxPQUFPLEdBQUU7QUFBQyxhQUFPLEtBQUcsRUFBRSxRQUFRLE9BQUcsS0FBSyxZQUFZLENBQUMsQ0FB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QVMsRUFBQyxNQUFLLEVBQUMsSUFBRSxNQUFJLE9BQUssS0FBSyxLQUFLLFdBQVMsT0FBSyxLQUFLLEtBQUssV0FBUyxHQUFFO0FBQUEsSUFBSztBQUFBLElBQUMsT0FBTyxHQUFFO0FBQUMsYUFBTyxNQUFJLFNBQU8sS0FBSyxLQUFLLFVBQVEsS0FBSyxLQUFLLFNBQU8sS0FBRyxNQUFLO0FBQUEsSUFBSztBQUFBLElBQUMsSUFBSSxHQUFFO0FBQUMsYUFBTyxNQUFJLFNBQU8sS0FBSyxLQUFLLE9BQUssS0FBSyxLQUFLLE1BQUksS0FBRyxNQUFLO0FBQUEsSUFBSztBQUFBLElBQUMsTUFBTSxHQUFFO0FBQUMsYUFBTyxNQUFJLFNBQU8sS0FBSyxLQUFLLFNBQU8sTUFBSSxPQUFLLEtBQUssS0FBSyxRQUFNLE9BQUssS0FBSyxLQUFLLFFBQU0sRUFBRSxZQUFhLEdBQUM7QUFBQSxJQUFLO0FBQUEsSUFBQyxJQUFJLEdBQUU7QUFBQyxhQUFPLE1BQUksU0FBTyxLQUFLLEtBQUssT0FBSyxFQUFFLENBQUMsSUFBRSxLQUFLLEtBQUssTUFBSSxFQUFFLFVBQVMsSUFBRyxLQUFHLElBQUUsSUFBRSxLQUFLLEtBQUssTUFBSSxJQUFFLEtBQUssS0FBSyxNQUFJLE1BQUs7QUFBQSxJQUFLO0FBQUEsSUFBQyxZQUFZLEdBQUU7QUFBQyxVQUFJLElBQUUsYUFBYSxJQUFFLElBQUUsSUFBSSxFQUFFLEdBQUUsSUFBSTtBQUFFLGFBQU8sS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLEdBQUU7QUFBQSxJQUFDO0FBQUEsSUFBQyxPQUFPLEdBQUU7QUFBQyxhQUFPLEtBQUcsRUFBRSxRQUFRLE9BQUcsS0FBSyxZQUFZLENBQUMsQ0FBQyxHQUFFLFFBQU0sS0FBSyxLQUFLO0FBQUEsSUFBTTtBQUFBLElBQUMsUUFBTztBQUFDLGFBQU8sS0FBSyxLQUFLLFNBQU8sQ0FBRSxHQUFDO0FBQUEsSUFBSTtBQUFBLElBQUMsRUFBRSxHQUFFLEdBQUU7QUFBQyxVQUFHLE1BQUksT0FBTyxRQUFPLEVBQUUsS0FBSyxJQUFJO0FB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QUFBLElBQ25DO0FBQUEsSUFFQyxJQUFJLE1BQU0sT0FBTztBQUNoQixZQUFNLEVBQUMsVUFBUyxJQUFJLEtBQUssZUFBZSxNQUFNLElBQUk7QUFDbEQsYUFBTyxNQUFNLElBQUksV0FBVyxLQUFLO0FBQUEsSUFDbkM7QUFBQSxJQUVDLElBQUksTUFBTTtBQUNULFlBQU0sRUFBQyxVQUFTLElBQUksS0FBSyxlQUFlLElBQUk7QUFDNUMsYUFBTyxNQUFNLElBQUksU0FBUztBQUFBLElBQzVCO0FBQUEsSUFFQyxJQUFJLE1BQU07QUFDVCxZQUFNLEVBQUMsVUFBUyxJQUFJLEtBQUssZUFBZSxJQUFJO0FBQzVDLGFBQU8sTUFBTSxJQUFJLFNBQVM7QUFBQSxJQUM1QjtBQUFBLElBRUMsT0FBTyxNQUFNO0FBQ1osWUFBTSxFQUFDLFdBQVcsV0FBVSxJQUFJLEtBQUssZUFBZSxJQUFJO0FBQ3hELGFBQU8sUUFBUSxhQUFhLE1BQU0sT0FBTyxTQUFTLEtBQUssS0FBSyxZQUFZLE9BQU8sVUFBVSxDQUFDO0FBQUEsSUFDNUY7QUFBQSxJQUVDLFFBQVE7QUFDUCxZQUFNLE1BQU87QUFDYixXQUFLLGNBQWMsTUFBTztBQUMxQixXQUFLLFlBQVksTUFBTztBQUFBLElBQzFCO0FBQUEsSUFFQyxLQUFLLE9BQU8sV0FBVyxJQUFJO0FBQzFCLGFBQU87QUFBQSxJQUNUO0FBQUEsSUFFQyxJQUFJLE9BQU87QUFDVixhQUFPLE1BQU07QUFBQSxJQUNmO0FBQUEsRUFDQTtBQ2xGbUIsTUFBSSxZQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMjMsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksMTYwLDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3MywxNzQsMTc1LDE4MCwxODEsMTgyLDE4OCwyMDMsMjA1LDIwOCwyMDksMjEwLDIxMiwyMTQsMjE1LDIxOCwyMTksMjIwLDIyMSwyMjIsMjIzLDIyNCwyMjUsMjI2LDIyNywyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzhdfQ==
